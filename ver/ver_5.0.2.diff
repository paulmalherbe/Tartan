=== modified file '.bzrignore'
--- .bzrignore	2014-07-21 11:34:04 +0000
+++ .bzrignore	2014-10-09 05:47:41 +0000
@@ -5,6 +5,7 @@
 changes.txt
 csv/all_data_types.py
 csv/test.py
+doc/Bowls.pdf
 doc/Manual.html
 doc/Manual.pdf
 doc/tarlic.pdf
@@ -17,6 +18,7 @@
 scp/pop.py
 scp/states
 sdy/
+std/pymagic.py
 std/Tktable.py
 std/adodbapi.py
 std/fcrypt.py

=== modified file 'bkm/bk1010.py'
--- bkm/bk1010.py	2014-10-01 14:07:50 +0000
+++ bkm/bk1010.py	2014-11-26 07:40:39 +0000
@@ -13,19 +13,18 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-import copy, datetime, time
-from TartanClasses import ASD, CCD, DrawForm, GetCtl, NotesCreate
-from TartanClasses import SelectChoice, ScrollGrid, TartanDialog, Sql, TabPrt
-from tartanFunctions import askQuestion, callModule, dateDiff, doPrinter
-from tartanFunctions import getModName, getVatRate, projectDate, showError
-from tartanWork import bktrtp, mthnam
+import datetime, time
+from TartanClasses import CCD, GetCtl, ScrollGrid, Sql, ToolTip
+from tartanFunctions import callModule, dateDiff, projectDate
 
 class bk1010:
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
-            self.mainProcess()
-            self.opts["mf"].startLoop()
+            self.quit = False
+            while not self.quit:
+                self.opts["mf"].window.withdraw()
+                self.doCalendar()
 
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
@@ -36,7 +35,7 @@
         if not bkmctl:
             return
         self.glint = bkmctl["cbk_glint"]
-        self.bktpl = bkmctl["cbk_tplnam"]
+        self.bktpl = bkmctl["cbk_bkgtpl"]
         if self.glint == "Y":
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -51,8 +50,8 @@
             self.bkmctl = ctlctl["bkm_ctl"]
         tabs = [
             "ctlmst", "chglog", "ctlnot", "ctlvmf", "ctlvtf", "bkmmst",
-            "bkmcon", "bkmunt", "bkmunm", "bkmtrn", "bkmrtm", "bkmrtt",
-            "bkmlet", "tpldet"]
+            "bkmcon", "bkmunm", "bkmtrn", "bkmrtm", "bkmrtt", "bkmlet",
+            "tpldet"]
         if self.glint == "Y":
             tabs.append("gentrn")
         self.sql = Sql(self.opts["mf"].dbm, tables=tabs, prog=__name__)
@@ -61,804 +60,25 @@
         self.curdt = self.sysdtw / 100
         self.batno = "B%s" % self.curdt
         self.number = 0
+        self.tt = None
         return True
 
-    def mainProcess(self):
-        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Lodging and Function Bookings")
-        bkm = {
-            "stype": "R",
-            "tables": ["bkmmst", "bkmcon"],
-            "cols": [
-                ("bkm_number", "", 0, "Number"),
-                ("bkm_btype", "", 0, "B"),
-                ("bkm_state", "", 0, "S"),
-                ("bkc_title", "", 0, "Title"),
-                ("bkc_sname", "", 20, "Surname", "Y"),
-                ("bkc_names", "", 20, "Names", "F"),
-                ("bkm_arrive", "d1", 10, "Arrive-Dt", "F"),
-                ("bkm_depart", "", 0, "Depart-Dt"),
-                ("bkm_units", "", 20, "Units")],
-            "where": [
-                ("bkm_cono", "=", self.opts["conum"]),
-                #("bkm_arrive", ">=", self.sysdtw),
-                ("bkc_cono=bkm_cono",),
-                ("bkc_ccode=bkm_ccode",)],
-            "order": "bkm_arrive"}
-        unt = {
-            "stype": "M",
-            "func": self.showUnits}
-        bkc = {
-            "stype": "R",
-            "tables": ("bkmcon",),
-            "cols": (
-                ("bkc_ccode", "", 0, "Code"),
-                ("bkc_title", "", 0, "Title"),
-                ("bkc_sname", "", 0, "Surname", "Y"),
-                ("bkc_names", "", 0, "Names", "Y")),
-            "where": [
-                ("bkc_cono", "=", self.opts["conum"])],
-            "order": "bkc_sname"}
-        r1s = (
-            ("Accommodation","A"),
-            ("Other","O"))
-        r2s = (
-            ("Enquiry","Q"),
-            ("Confirmed","C"),
-            ("Settled","S"),
-            ("Cancelled","X"))
-        tag = (
-            ("Booking",self.chgPage,("T",1,1),None),
-            ("Contact",self.chgPage,(("T",1,2),("T",1,0)),("T",1,1)))
-        fld = (
-            (("T",1,0,0),"IUI",7,"Booking Number","",
-                0,"Y",self.doNumber,bkm,None,None),
-            (("T",1,1,0),("IRB",r1s),0,"Type","",
-                "A","N",self.doType,None,None,None),
-            (("T",1,2,0),"ITX",30,"Group Name","",
-                "","N",self.doGroup,None,None,None),
-            (("T",1,3,0),"IUI",3,"Number of Persons","",
-                0,"N",self.doGuests,None,None,("notzero",)),
-            (("T",1,4,0),"ID1",10,"Arrival (YYYYMMDD)","",
-                0,"N",self.doDate,None,None,("efld",)),
-            (("T",1,5,0),"ID1",10,"Departure (YYYYMMDD)","",
-                0,"N",self.doDate,None,None,("efld",)),
-            (("T",1,6,0),"ITX",50,"Allocated Units","",
-                "","N",self.doUnits,unt,None,("notblank",)),
-            (("T",1,7,0),"OSD",11.2,"Value"),
-            (("T",1,8,0),"ISD",11.2,"Deposit Amount","",
-                0,"N",self.doDeposit,None,None,None),
-            (("T",1,9,0),"ID1",10,"Deposit Date","",
-                0,"N",self.doDepdate,None,None,None),
-            (("T",1,10,0),"OSD",11.2,"Balance Outstanding"),
-            (("T",1,11,0),"ITX",50,"Special Requests","",
-                "","N",self.doRequests,None,None,None),
-            (("T",1,12,0),"Id1",10,"Wedding Date (YYYYMMDD)","",
-                0,"N",self.doDate,None,None,("efld",)),
-            (("T",1,13,0),"ItM",5,"Wedding Time (HH:MM)","",
-                0,"N",None,None,None,("efld",)),
-            (("T",1,14,0),"ITX",30,"Bride's Name","",
-                "","N",None,None,None,("notblank",)),
-            (("T",1,15,0),"ITX",30,"Groom's Name","",
-                "","N",None,None,None,("notblank",)),
-            (("T",1,16,0),"ITX",30,"Marriage Officer","",
-                "","N",None,None,None,("notblank",)),
-            (("T",1,17,0),("ORB",r2s),0,"Booking Status"),
-            (("T",2,0,0),"IUA",7,"Contact Code","",
-                "","N",self.doContact,bkc,None,None),
-            (("T",2,1,0),"ITX",6,"Title","",
-                "","N",self.doTitle,None,None,("notblank",)),
-            (("T",2,2,0),"ITX",30,"Surname","",
-                "","N",self.doSurname,None,None,("notblank",)),
-            (("T",2,3,0),"ITX",30,"Names","",
-                "","N",self.doNames,None,None,("notblank",)),
-            (("T",2,4,0),"ITX",30,"Address Line 1","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,5,0),"ITX",30,"Address Line 2","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,6,0),"ITX",30,"Address Line 3","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,7,0),"IUI",4,"Postal Code","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,8,0),"ITX",20,"Telephone Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,9,0),"ITX",20,"Fax Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,10,0),"ITX",20,"Mobile Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,11,0),"ITX",30,"E-Mail Address","",
-                "","N",self.doEmail,None,None,("email",)),
-            (("T",2,12,0),"IUI",10,"VAT Number","",
-                "","N",None,None,None,None))
-        on = (("T",1,0),("T",1,2))
-        off = ("T",1,1)
-        but = (
-            ("Calen_dar",None,self.doCalendar,0,off,on),
-            ("Transact",None,self.doTrans,0,on,off),
-            ("Movements",None,self.doMoves,0,on,off),
-            ("Notes",None,self.doNotes,0,on,off),
-            ("Print",None,self.doPrint,1,None,None),
-            ("Accept",None,self.doAccept,0,on,off),
-            ("Quit",None,self.doQuit,1,None,off),
-            ("Exit",None,self.doExit,0,("T",1,1),None))
-        tnd = (None, (self.doEnd,"n"), (self.doEnd,"n"))
-        txt = (None, self.doExit, self.doExit)
-        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            tags=tag, eflds=fld, butt=but, tend=tnd, txit=txt,
-            clicks=self.doClick)
-
-    def doClick(self, *opts):
-        if not self.number:
-            return
-        if self.arrive < self.sysdtw or self.depart < self.sysdtw:
-            return
-        if self.df.pag == 1 and self.invoiced:
-            return
-        wedopts = ((1,12), (1,13), (1,14), (1,15), (1,16))
-        if not self.df.t_work[1][0][11] and opts[0] in wedopts:
-            return
-        if self.click:
-            self.df.loadEntry("T", self.click[0], self.click[1],
-                data=self.df.t_work[self.click[0]][0][self.click[1]])
-        self.click = opts[0]
-        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
-
-    def doNumber(self, frt, pag, r, c, p, i, w):
-        self.click = []
-        self.quit = False
-        self.invoiced = False
-        if not w:
-            ok = askQuestion(self.opts["mf"].window, "New Booking",
-                "Is This a New Booking?", default="yes")
-            if ok == "no":
-                return "Invalid Booking Number"
-            else:
-                self.number = 0
-                self.state = "Q"
-                self.newmst = True
-                self.df.loadEntry(frt, pag, p+17, data=self.state)
-                return
-        self.oldmst = self.sql.getRec(tables="bkmmst", where=[("bkm_cono",
-            "=", self.opts["conum"]), ("bkm_number", "=", w)], limit=1)
-        if not self.oldmst:
-            return "Invalid Booking Number"
-        self.number = w
-        self.newmst = False
-        self.newcon = False
-        self.state = self.oldmst[self.sql.bkmmst_col.index("bkm_state")]
-        self.btype = self.oldmst[self.sql.bkmmst_col.index("bkm_btype")]
-        self.group = self.oldmst[self.sql.bkmmst_col.index("bkm_group")]
-        self.guests = self.oldmst[self.sql.bkmmst_col.index("bkm_guests")]
-        self.arrive = self.oldmst[self.sql.bkmmst_col.index("bkm_arrive")]
-        self.depart = self.oldmst[self.sql.bkmmst_col.index("bkm_depart")]
-        self.units = self.oldmst[self.sql.bkmmst_col.index("bkm_units")]
-        self.value = self.oldmst[self.sql.bkmmst_col.index("bkm_value")]
-        self.deposit = self.oldmst[self.sql.bkmmst_col.index("bkm_deposit")]
-        self.depdate = self.oldmst[self.sql.bkmmst_col.index("bkm_depdate")]
-        self.special = self.oldmst[self.sql.bkmmst_col.index("bkm_special")]
-        for num, dat in enumerate(self.oldmst[1:]):
-            if num == 17:
-                self.ccode = dat
-            elif num > 9:
-                if num == 10:
-                    self.df.loadEntry("T", 1, num, data=self.getBalance().work)
-                self.df.loadEntry("T", 1, num+1, data=dat)
-            else:
-                self.df.loadEntry("T", 1, num, data=dat)
-        inv = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
-            self.opts["conum"]), ("bkt_number", "=", self.number),
-            ("bkt_type", "=", 2)])
-        if inv:
-            self.invoiced = True
-        self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
-            "=", self.opts["conum"]), ("bkc_ccode", "=", self.ccode)], limit=1)
-        self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
-        self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
-        self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
-        self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
-        for num, dat in enumerate(self.oldcon[1:]):
-            self.df.loadEntry("T", 2, num, data=dat)
-        self.df.setWidget(self.df.B4, "normal")
-        if not self.state == "Q":
-            return "nd"
-
-    def doType(self, frt, pag, r, c, p, i, w):
-        if not self.state == "Q":
-            self.df.loadEntry(frt, pag, p, data=self.btype)
-            return "Invalid Type"
-        if not self.newmst:
-            if w == self.btype:
-                self.chgtyp = False
-            else:
-                ok = askQuestion(self.opts["mf"].window, "Change Type",
-                    "Do You Want to Change the Type of the Booking?",
-                    default="no")
-                if ok == "no":
-                    self.df.loadEntry(frt, pag, p, data=self.btype)
-                    return "Invalid Type"
-                self.doUnBook()
-                self.chgtyp = True
-                for x in range(6, 17):
-                    self.df.loadEntry("T", 1, x, data="")
-        self.btype = w
-
-    def doUnBook(self):
-        self.sql.updRec("bkmmst", cols=["bkm_units"], data=[""],
-            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
-            "=", self.number)])
-        self.sql.delRec("bkmrtt", where=[("brt_cono", "=", self.opts["conum"]),
-            ("brt_number", "=", self.number)])
-        self.units = ""
-        self.df.loadEntry("T", 1, 6, data=self.units)
-
-    def doGroup(self, frt, pag, r, c, p, i, w):
-        self.group = w
-
-    def doGuests(self, frt, pag, r, c, p, i, w):
-        self.guests = w
-
-    def doDate(self, frt, pag, r, c, p, i, w):
-        if p == 4:
-            self.arrive = w
-            if self.arrive < self.sysdtw:
-                return "Invalid Date, In the Past"
-            self.getExpiryDate()
-            self.df.loadEntry(frt, pag, p+5, data=self.depdate)
-        elif p == 5:
-            self.depart = w
-            if self.depart < self.arrive:
-                return "Invalid Date, Before Arrival Date"
-            if self.btype == "A" and self.depart == self.arrive:
-                return "Arrival and Departure Dates are the Same"
-        elif w and w < self.arrive or w > self.depart:
-            return "Invalid Date, Out of Booking Period"
-        elif not w:
-            for x in range(4):
-                self.df.loadEntry(frt, pag, p+1+x, data="")
-            return "sk4"
-
-    def getExpiryDate(self):
-        self.depdate = 0
-        day = 15
-        while self.depdate < self.sysdtw:
-            day -= 1
-            self.depdate = projectDate(self.arrive, day, act="-")
-
-    def showUnits(self):
-        # Get Available Units
-        where = [("bum_cono", "=", self.opts["conum"])]
-        if self.btype == "O":
-            where.append(("bum_type", "=", self.btype))
-        self.aunits = self.sql.getRec(tables="bkmunm", where=where,
-            order="bum_type, bum_code")
-        book = self.sql.getRec(tables="bkmmst", cols=["bkm_arrive",
-            "bkm_depart", "bkm_units"], where=[("bkm_cono", "=",
-            self.opts["conum"]), ("bkm_number", "<>", self.number),
-            ("bkm_state", "<>", "X")], order="bkm_arrive")
-        used = []
-        for bk in book:
-            u = False
-            if bk[0] <= self.arrive < bk[1]:
-                u = True
-            if bk[0] <= self.depart < bk[1]:
-                u = True
-            if u:
-                un = bk[2].split(":")
-                for u in un:
-                    used.append(u.split("-"))
-        test = copy.deepcopy(self.aunits)
-        for unit in test:
-            if unit[1:3] in used:
-                self.aunits.remove(unit)
-        if not self.aunits:
-            showError(self.opts["mf"].window, "No Vacancies",
-                "There are No Available Units for this Booking")
-            return
-        beds = 0
-        for unit in self.aunits:
-            beds += unit[4]
-        if beds < self.guests:
-            showError(self.opts["mf"].window, "Capacity Shortage",
-                "There is Not Enough Capacity for this Booking")
-            return
-        # Enter Units
-        tit = "Select Units and Rates"
-        unt = {
-            "stype": "M",
-            "func": self.getUnits}
-        rte = {
-            "stype": "R",
-            "tables": ("bkmrtm",),
-            "cols": (
-                ("brm_code", "", 0, "Cod"),
-                ("brm_desc", "", 0, "Description"),
-                ("brm_rate", "", 0, "Rate-Amnt"),
-                ("brm_base", "", 0, "B")),
-            "where": [],
-            "order": "brm_type, brm_code"}
-        fld = (
-            (("T",0,0,0),"OUI",3,"Number of Guests"),
-            (("C",0,0,0),"IUA",8,"Unit-Cod","Unit Combined Code",
-                "r","Y",self.doUUnit,unt,None,("notblank",)),
-            (("C",0,0,1),"OTX",25,"Description"),
-            (("C",0,0,2),"IUI",4,"Rate","Rate Code",
-                "r","N",self.doURate,rte,self.doUDelete,("notzero",)),
-            (("C",0,0,3),"OTX",25,"Description"),
-            (("C",0,0,4),"OUD",10.2,"Normal-Rte"),
-            (("C",0,0,5),"IUI",3,"Qty","",
-                0,"N",self.doUQty,None,self.doUDelete,("notzero",)),
-            (("C",0,0,6),"IUD",6.2,"Disc-%","",
-                0,"N",self.doUDisc,None,None,None),
-            (("C",0,0,7),"IUD",10.2,"Applied-Rt","Applied Rate",
-                0,"N",self.doUAmount,None,None,None))
-        state = self.df.disableButtonsTags()
-        widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
-        self.df.setWidget(widget, "disabled")
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        self.rt = TartanDialog(self.opts["mf"], tops=True, title=tit,
-            eflds=fld, tend=(None,), txit=(None,), cend=((self.doUEnd,"y"),),
-            cxit=(self.doUExit,))
-        self.doLoadUnits()
-        self.opts["mf"].startLoop()
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.enableButtonsTags(state=state)
-        return self.units
-
-    def doUDelete(self):
-        t, c = self.ucod.split("-")
-        if self.rt.idx == 2:
-            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
-                self.opts["conum"]), ("brt_number", "=", self.number),
-                ("brt_utype", "=", t), ("brt_ucode", "=", c)])
-        elif not self.found:
-            return
-        else:
-            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
-                self.opts["conum"]), ("brt_number", "=", self.number),
-                ("brt_utype", "=", t), ("brt_ucode", "=", t),
-                ("brt_rcode", "=", self.rcode)])
-        self.doLoadUnits()
-
-    def getUnits(self):
-        data = []
-        for unit in self.aunits:
-            bkt = self.sql.getRec(tables="bkmrtt", cols=["sum(brt_quant)"],
-                where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
-                "=", self.number), ("brt_utype", "=", unit[1]), ("brt_ucode",
-                "=", unit[2])], limit=1)
-            if not bkt or not bkt[0]:
-                bkt = [0]
-            data.append(["%s-%-6s" % (unit[1], unit[2]), unit[3],
-                CCD(unit[4], "UI", 3).disp, CCD(bkt[0], "UI", 3).disp])
-        opts = {
-            "stype": "C",
-            "titl": "Select the Required Unit",
-            "head": ("Unit-Cod", "Description", "Qty", "Bkd"),
-            "data": data}
-        rs = self.rt.selectItem(self.rt.pag, opts)
-        return rs
-
-    def doUUnit(self, frt, pag, r, c, p, i, w):
-        t, c = w.split("-")
-        rec = self.sql.getRec(tables="bkmunm", cols=["bum_desc", "bum_guests"],
-            where=[("bum_cono", "=", self.opts["conum"]), ("bum_type", "=", t),
-            ("bum_code", "=", c)], limit=1)
-        if not rec:
-            return "Invalid Unit Code"
-        self.ucod = w
-        self.udes = rec[0]
-        self.uqty = rec[1]
-        self.rt.loadEntry(frt, pag, p+1, data=self.udes)
-        self.rt.colf[0][2][8]["where"] = [
-            ("brm_cono", "=", self.opts["conum"]),
-            ("brm_type", "=", t)]
-        return "sk1"
-
-    def doURate(self, frt, pag, r, c, p, i, w):
-        t, c = self.ucod.split("-")
-        unit = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
-            self.opts["conum"]), ("brt_number", "=", self.number),
-            ("brt_utype", "=", t), ("brt_ucode", "=", c), ("brt_rcode",
-            "=", w)], limit=1)
-        if unit:
-            self.found = True
-            self.rcode = w
-            self.rdesc = unit[self.sql.bkmrtt_col.index("brt_rdesc")]
-            self.nrate = unit[self.sql.bkmrtt_col.index("brt_nrate")]
-            self.rqty = unit[self.sql.bkmrtt_col.index("brt_quant")]
-            arate = unit[self.sql.bkmrtt_col.index("brt_arate")]
-            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
-            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
-            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
-            if self.ucod.split("-")[0] == "A":
-                self.aqty -= self.rqty
-        else:
-            racc = self.sql.getRec(tables="bkmrtm", cols=["brm_desc",
-                "brm_rate"], where=[("brm_cono", "=", self.opts["conum"]),
-                ("brm_type", "=", self.ucod[0]), ("brm_code", "=", w)],
-                limit=1)
-            if not racc:
-                return "Invalid Rate Code"
-            self.found = False
-            self.rcode = w
-            self.rdesc = racc[0]
-            self.nrate = racc[1]
-            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
-            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
-            if self.ucod.split("-")[0] == "A":
-                bqty = self.guests - self.aqty
-                if self.uqty > bqty:
-                    self.rqty = bqty
-                else:
-                    self.rqty = self.uqty
-            elif self.uqty > self.guests:
-                self.rqty = self.guests
-            else:
-                self.rqty = self.uqty
-            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
-        return "sk2"
-
-    def doUQty(self, frt, pag, r, c, p, i, w):
-        if self.uqty and w > self.uqty:
-            ok = askQuestion(self.opts["mf"].window, "Quantity",
-                "Quantity Exceeds Unit Quantity", default="no")
-            if ok == "no":
-                return "rf"
-        if self.ucod.split("-")[0] == "A":
-            if (self.aqty + w) > self.guests:
-                return "Invalid Quantity, Exceeds Booking"
-        elif w > self.guests:
-            return "Invalid Quantity, Exceeds Booking"
-        self.rqty = w
-        if self.found and self.rqty == 0:
-            c_work = copy.deepcopy(self.rt.c_work[0])
-            self.rt.clearFrame("C", 0)
-            pos = 0
-            for num, dat in enumerate(c_work):
-                if not dat[0]:
-                    break
-                if dat[0] == self.ucod and dat[2] == self.rcode:
-                    continue
-                for n, d in enumerate(dat):
-                    self.rt.loadEntry("C", 0, pos+n, data=d)
-                pos += 8
-            return "ff%s" % (pos + 1)
-
-    def doUDisc(self, frt, pag, r, c, p, i, w):
-        self.rdisc = w
-        self.arate = int(self.nrate * (100 - self.rdisc) / 100)
-        dif = self.arate % 5
-        if dif:
-            self.arate = self.arate + (5 - dif)
-        self.rt.loadEntry(frt, pag, p+1, data=self.arate)
-
-    def doUAmount(self, frt, pag, r, c, p, i, w):
-        self.arate = w
-
-    def doUEnd(self):
-        t, c = self.ucod.split("-")
-        if self.found:
-            self.sql.updRec("bkmrtt", cols=["brt_quant", "brt_discp",
-                "brt_arate"], data=[self.rqty, self.rdisc, self.arate],
-                where=[("brt_cono", "=", self.opts["conum"]),
-                ("brt_number", "=", self.number), ("brt_utype", "=", t),
-                ("brt_ucode", "=", c), ("brt_rcode", "=", self.rcode)])
-        else:
-            self.sql.insRec("bkmrtt", data=[self.opts["conum"], self.number,
-                t, c, self.udes, self.rcode, self.rdesc, self.nrate,
-                self.rqty, self.rdisc, self.arate, 0, self.opts["capnm"],
-                self.sysdtw, 0])
-        self.doLoadUnits()
-
-    def doLoadUnits(self):
-        self.rt.clearFrame("C", 0)
-        self.rt.loadEntry("T", 0, 0, data=self.guests)
-        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
-            self.opts["conum"]), ("brt_number", "=", self.number)],
-            order="brt_ucode")
-        self.aqty = 0
-        if not recs:
-            self.rt.focusField("C", 0, 1)
-            return
-        for num, rec in enumerate(recs):
-            pos = num * 8
-            ut = rec[self.sql.bkmrtt_col.index("brt_utype")]
-            uc = rec[self.sql.bkmrtt_col.index("brt_ucode")]
-            uc = "%s-%s" % (ut, uc)
-            ud = rec[self.sql.bkmrtt_col.index("brt_udesc")]
-            rc = rec[self.sql.bkmrtt_col.index("brt_rcode")]
-            rd = rec[self.sql.bkmrtt_col.index("brt_rdesc")]
-            nr = rec[self.sql.bkmrtt_col.index("brt_nrate")]
-            qt = rec[self.sql.bkmrtt_col.index("brt_quant")]
-            ds = rec[self.sql.bkmrtt_col.index("brt_discp")]
-            ar = rec[self.sql.bkmrtt_col.index("brt_arate")]
-            self.rt.loadEntry("C", 0, pos, data=uc)
-            self.rt.loadEntry("C", 0, pos+1, data=ud)
-            self.rt.loadEntry("C", 0, pos+2, data=rc)
-            self.rt.loadEntry("C", 0, pos+3, data=rd)
-            self.rt.loadEntry("C", 0, pos+4, data=nr)
-            self.rt.loadEntry("C", 0, pos+5, data=qt)
-            self.rt.loadEntry("C", 0, pos+6, data=ds)
-            self.rt.loadEntry("C", 0, pos+7, data=ar)
-            if ut == "A":
-                self.aqty += qt
-            if num == self.rt.rows[0] - 1:
-                self.rt.scrollScreen(0)
-            else:
-                col = ((num + 1) * 8) + 1
-                self.rt.focusField("C", 0, col)
-
-    def doUExit(self):
-        recs = self.sql.getRec(tables="bkmrtt", cols=["brt_utype",
-            "brt_ucode"], where=[("brt_cono", "=", self.opts["conum"]),
-            ("brt_number", "=", self.number)], group="brt_utype, brt_ucode",
-            order="brt_utype, brt_ucode")
-        self.units = ""
-        done = []
-        for t, c in recs:
-            if not self.units:
-                self.units = "%s-%s" % (t, c)
-            else:
-                self.units = "%s:%s-%s" % (self.units, t, c)
-        self.rt.closeProcess()
-        self.opts["mf"].closeLoop()
-
-    def doUnits(self, frt, pag, r, c, p, i, w):
-        check = self.doCheckUnits(w)
-        if check:
-            return check
-        self.units = w
-        self.getValue()
-        self.df.loadEntry("T", 1, 7, data=self.value)
-        adays = dateDiff(self.sysdtw, self.arrive, "days")
-        if self.btype == "A" and self.group:
-            if adays > 134:
-                self.deposit = self.value * .10
-            elif adays > 120:
-                self.deposit = self.value * .60
-            else:
-                self.deposit = self.value
-        elif adays < 14:
-            self.deposit = self.value
-        else:
-            self.deposit = self.value * .50
-        self.df.loadEntry("T", 1, 8, data=self.deposit)
-        self.df.loadEntry(frt, pag, 10, data=self.getBalance().work)
-
-    def doCheckUnits(self, units):
-        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
-            self.opts["conum"]), ("brt_number", "=", self.number)])
-        quant = {}
-        units = units.split(":")
-        for unit in units:
-            t, c = unit.split("-")
-            chk = self.sql.getRec(tables="bkmrtt", where=[("brt_cono",
-                "=", self.opts["conum"]), ("brt_number", "=", self.number),
-                ("brt_utype", "=", t), ("brt_ucode", "=", c)])
-            if not chk:
-                return "Missing Rate for Unit %s-%s" % (t, c)
-            if not t in quant:
-                quant[t] = 0
-        for rec in recs:
-            quant[rec[2]] += rec[8]
-        for typ in quant:
-            if typ == "A" and not quant[typ] == self.guests:
-                return "Invalid Quantity (%s) for Type %s" % (quant[typ], typ)
-
-    def getValue(self):
-        self.value = 0
-        recs = self.sql.getRec(tables="bkmrtt", cols=["brt_quant",
-            "brt_arate"], where=[("brt_cono", "=", self.opts["conum"]),
-            ("brt_number", "=", self.number)])
-        if self.btype == "A":
-            bdays = dateDiff(self.arrive, self.depart, "days")
-        else:
-            bdays = dateDiff(self.arrive, self.depart, "days") + 1
-        self.sql.updRec("bkmrtt", cols=["brt_bdays"], data=[bdays],
-            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
-            "=", self.number)])
-        for qty, rte in recs:
-            self.value = float(ASD(self.value) + ASD(qty * rte * bdays))
-
-    def doRequests(self, frt, pag, r, c, p, i, w):
-        self.special = w
-
-    def doDeposit(self, frt, pag, r, c, p, i, w):
-        self.deposit = w
-
-    def doDepdate(self, frt, pag, r, c, p, i, w):
-        self.depdate = w
-        self.df.loadEntry(frt, pag, p+1, data=self.value)
-
-    def doContact(self, frt, pag, r, c, p, i, w):
-        if not self.state == "Q":
-            self.df.loadEntry(frt, pag, p, data=self.ccode)
-            return
-        self.ccode = w
-        if w:
-            self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
-                "=", self.opts["conum"]), ("bkc_ccode", "=", w)], limit=1)
-            if not self.oldcon:
-                return "Invalid Contact Code"
-            self.newcon = False
-            self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
-            self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
-            self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
-            self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
-            for num, dat in enumerate(self.oldcon[1:]):
-                self.df.loadEntry("T", 2, num, data=dat)
-        else:
-            self.newcon = True
-
-    def doTitle(self, frt, pag, r, c, p, i, w):
-        self.title = w
-
-    def doSurname(self, frt, pag, r, c, p, i, w):
-        self.sname = w
-
-    def doNames(self, frt, pag, r, c, p, i, w):
-        self.names = w
-
-    def doEmail(self, frt, pag, r, c, p, i, w):
-        self.email = w
-
-    def doEnd(self):
-        if self.df.pag == 1:
-            if self.newmst:
-                self.df.selPage("Contact", focus=False)
-                self.df.focusField("T", 2, 1)
-            else:
-                self.opts["mf"].updateStatus("Select Button or Tag to Continue")
-        elif self.df.pag == 2:
-            self.doAccept()
-
-    def doUpdate(self):
-        if self.newcon:
-            # Remove invalid characters
-            name = self.sname.replace(" ", "")
-            for c in (" ", ".", ",", ";", ":", "'", '"'):
-                name = name.replace(c, "")
-            if len(name) < 5:
-                name = name + ("0" * (5 - len(name)))
-            ccode = ""
-            for c in xrange(0, 5):
-                ccode = (ccode + name[c]).upper()
-            ccode = ccode.strip()
-            text = "%s%0" + str((7 - len(ccode))) + "d"
-            for x in xrange(1, 100):
-                self.ccode = text % (ccode, x)
-                chk = self.sql.getRec(tables="bkmcon",
-                    where=[("bkc_cono", "=", self.opts["conum"]),
-                    ("bkc_ccode", "=", self.ccode)], limit=1)
-                if not chk:
-                    break
-            self.df.loadEntry("T", 2, 0, data=self.ccode)
-        changed = False
-        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        data = [self.opts["conum"]]
-        for x in range(len(self.df.t_work[2][0])):
-            data.append(self.df.t_work[2][0][x])
-        if self.newcon:
-            changed = True
-            self.sql.insRec("bkmcon", data=data)
-            self.newcon = False
-        elif data != self.oldcon:
-            changed = True
-            self.sql.updRec("bkmcon", data=data, where=[("bkc_cono", "=",
-                self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
-            for num, dat in enumerate(self.oldcon):
-                if dat != data[num]:
-                    self.sql.insRec("chglog", data=["bkmcon", "U",
-                        "%03i%-7s" % (self.opts["conum"], self.ccode),
-                        self.sql.bkmcon_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
-        if not self.number:
-            changed = True
-            acc = self.sql.getRec(tables="bkmmst", cols=["max(bkm_number)"],
-                where=[("bkm_cono", "=", self.opts["conum"])], limit=1)
-            if not acc[0]:
-                self.number = 1001
-            else:
-                self.number = int(acc[0]) + 1
-            self.df.loadEntry("T", 1, 0, data=self.number)
-            self.sql.updRec("bkmrtt", cols=["brt_number"], data=[self.number],
-                where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
-                "=", 0)])
-            data = [self.opts["conum"], self.number, 1, self.getRef(),
-                self.batno, self.sysdtw, 0, 0, self.curdt, "Booking Enquiry",
-                "", "", self.opts["capnm"], self.sysdtw, 0]
-            self.sql.insRec("bkmtrn", data=data)
-        data = [self.opts["conum"]]
-        for x in range(len(self.df.t_work[1][0])):
-            if x == 10:
-                continue
-            data.append(self.df.t_work[1][0][x])
-        data.append(self.ccode)
-        if self.newmst:
-            changed = True
-            self.sql.insRec("bkmmst", data=data)
-        elif data != self.oldmst:
-            changed = True
-            self.sql.updRec("bkmmst", data=data, where=[("bkm_cono", "=",
-                self.opts["conum"]), ("bkm_number", "=", self.number)])
-            for num, dat in enumerate(self.oldmst):
-                if dat != data[num]:
-                    self.sql.insRec("chglog", data=["bkmmst", "U",
-                        "%03i%7s" % (self.opts["conum"], self.number),
-                        self.sql.bkmmst_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
-        return changed
-
-    def doAccept(self):
-        if not self.number and self.df.pag == 1:
-            return
-        if not self.value:
-            return
-        check = self.doCheckUnits(self.units)
-        if check:
-            self.df.focusField("T", 1, 6, err=check)
-            return
-        flds = ["T", 1, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]]
-        if self.df.t_work[1][0][12]:
-            flds[2].extend([12, 13, 14, 15, 16])
-        flds[2].append(17)
-        f, p, c, m = self.df.doCheckFields(flds)
-        if m:
-            self.df.selPage("Booking")
-            self.df.focusField(f, p, (c+1), err=m)
-            return
-        if not self.df.t_work[2][0][1]:
-            self.df.selPage("Contact")
-            self.df.focusField("T", 2, 1, err="Missing Contact")
-            return
-        f, p, c, m = self.df.doCheckFields(("T", 2, None))
-        if m:
-            self.df.selPage("Contact")
-            self.df.focusField(f, p, (c+1), err=m)
-            return
-        # Update Tables
-        changed = self.doUpdate()
-        if changed:
-            # Print/Email Booking
-            ok = askQuestion(self.opts["mf"].window, "Notify",
-                "Print/Email Booking", default="yes")
-            if ok == "yes":
-                self.doPrint()
-        self.opts["mf"].dbm.commitDbase()
-        # Loop for Next Booking
-        self.number = 0
-        self.df.selPage("Booking")
-        self.df.focusField("T", 1, 1)
-
-    def getRef(self):
-        rec = self.sql.getRec(tables="bkmtrn", cols=["max(bkt_refno)"],
-            where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
-            "=", self.number), ("bkt_refno", "like", "%7s%s" % (self.number,
-            "%"))], limit=1)
-        if not rec or not rec[0]:
-            num = 1
-        else:
-            num = int(rec[0][-2:]) + 1
-        return "%7s%02i" % (self.number, num)
-
     def doCalendar(self):
-        starter = self.sql.getRec(tables="bkmmst", cols=["min(bkm_arrive)"],
-            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_depart", ">",
-            self.sysdtw), ("bkm_state", "in", ("Q", "C", "S"))], limit=1)[0]
-        ender = self.sql.getRec(tables="bkmmst", cols=["max(bkm_depart)"],
-            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_state",
-            "in", ("Q", "C", "S"))], limit=1)[0]
-        if starter is None or ender is None:
-            return
         self.number = 0
-        self.opts["mf"].window.withdraw()
+        self.ptyp = None
+        self.newb = False
+        starter = projectDate(self.sysdtw, 7, "-")
+        ender = projectDate(starter, 365)
         days = dateDiff(starter, ender, "days") + 1
         units = self.sql.getRec(tables="bkmunm", where=[("bum_cono",
-            "=", self.opts["conum"])], order="bum_type, bum_code")
-        udic = {}
+            "=", self.opts["conum"]), ("bum_multi", "=", "N")],
+            order="bum_type, bum_code")
+        udics = {}
         for unit in units:
-            udic["%s-%s" % (unit[1], unit[2])] = \
-                [unit[3], CCD(unit[4], "UI", 3).disp] + [""] * days
+            if unit[1] == "A" and unit[2] == "ALL":
+                continue
+            udics["%s-%s" % (unit[1], unit[2])] = \
+                [unit[3], CCD(unit[5], "UI", 3).disp] + [""] * days
         books = self.sql.getRec(tables="bkmmst", cols=["bkm_number",
             "bkm_btype", "bkm_arrive", "bkm_depart", "bkm_units",
             "bkm_state"], where=[("bkm_cono", "=", self.opts["conum"]),
@@ -869,15 +89,25 @@
             eday = dateDiff(starter, book[3], "days")
             if book[1] == "O":
                 eday += 1
-            unts = book[4].split(":")
-            for unt in unts:
+            units = book[4].split(":")
+            if "A-ALL" in units:
+                whole = True
+                units.remove("A-ALL")
+                for unit in udics:
+                    if unit[0] == "A":
+                        units.append(unit)
+            else:
+                whole = False
+            for unit in units:
+                if not unit in udics:
+                    continue
                 for d in range(sday, eday):
                     if book[5] == "Q":
-                        udic[unt][d+2] = "Query|%s" % book[0]
+                        udics[unit][d+2] = "Query|%s" % book[0]
                     elif book[5] == "C":
-                        udic[unt][d+2] = "Confirmed|%s" % book[0]
+                        udics[unit][d+2] = "Confirmed|%s" % book[0]
                     elif book[5] == "S":
-                        udic[unt][d+2] = "Settled|%s" % book[0]
+                        udics[unit][d+2] = "Settled|%s" % book[0]
         titl = "Bookings Calendar"
         labs = (
             ("Code", 9),
@@ -895,16 +125,16 @@
             d2 = datetime.date(
                 d1.work / 10000, d1.work / 100 % 100, d1.work % 100)
             cols[0].append(("%s\n%s" % (d1.disp, d2.strftime("%A")), 10))
-        keys = udic.keys()
+        keys = udics.keys()
         keys.sort()
         data = []
         for row, key in enumerate(keys):
             cod = ("%s" % key, "label")
-            des = ("%s" % udic[key][0], "label")
-            qty = ("%-s" % udic[key][1], "label")
+            des = ("%s" % udics[key][0], "label")
+            qty = ("%-s" % udics[key][1], "label")
             lab = (cod, des, qty)
             col = []
-            for c, d in enumerate(udic[key][2:]):
+            for c, d in enumerate(udics[key][2:]):
                 if not d:
                     num = 0
                     txt = "\n"
@@ -920,671 +150,83 @@
                         tag = "settle"
                 col.append((txt, tag))
             data.append((lab, col))
-        cal = ScrollGrid(**{"mf": self.opts["mf"], "titl": titl, "chgt": 2,
-            "labs": labs, "tags": tags, "cols": cols, "data": data,
-            "font": ("Arial", self.opts["mf"].rcdic["dfs"]),
-            "bcmd": self.doBrowse})
-        self.opts["mf"].window.deiconify()
-        if self.number:
-            self.df.doKeyPressed("T", 1, 0, data=self.number)
-
-    def doBrowse(self, *args):
-        self.number = int(args[0][1].split("\n")[0])
-        self.opts["mf"].closeLoop()
-
-    def doTrans(self):
-        if not self.number or self.depart < self.sysdtw:
-            return
-        tit = "Transaction Data Capture"
-        if self.glint:
-            glm = {
-                "stype": "R",
-                "tables": ("genmst",),
-                "cols": (
-                    ("glm_acno", "", 0, "Acc-Num"),
-                    ("glm_desc", "", 0, "Description")),
-                "where": [
-                    ("glm_cono", "=", self.opts["conum"])],
-                "order": "glm_desc"}
-        r1s = (
-            ("EFT","1"),
-            ("Cash","2"),
-            ("Cheque","3"),
-            ("Refund","4"),
-            ("Journal","5"),
-            ("Cancel","6"),
-            ("Reinstate","7"))
-        r2s = (
-            ("Deposit","2"),
-            ("Other","1"))
-        if self.state == "Q":
-            dft = "2"
-        else:
-            dft = "1"
-        fld = [
-            (("T",0,0,0),"OSD",11.2,"Deposit"),
-            (("T",0,0,0),"OSD",11.2,"Balance"),
-            (("T",0,1,0),("IRB",r1s),0,"Type","",
-                "1","Y",self.doTType,None,None,None),
-            (("T",0,2,0),"ID1",10,"Date","",
-                self.sysdtw,"N",self.doTDate,None,None,("efld",)),
-            (("T",0,3,0),"ONa",9,"Reference"),
-            (("T",0,4,0),"ISD",11.2,"Amount","",
-                0,"N",self.doTAmount,None,None,("notzero",)),
-            (("T",0,5,0),"ITX",30,"Details","",
-                "","N",self.doTDesc,None,None,None)]
-        if self.glint:
-            fld.extend([
-            (("T",0,6,0),"IUI",7,"Acc-Num","G/L Account Number",
-                0,"N",self.doTGacc,glm,None,None),
-            (("T",0,6,0),"ONA",30,""),
-            (("T",0,7,0),"IUA",1,"VAT Code","",
-                0,"N",self.doTVcod,None,None,None),
-            (("T",0,8,0),"ISD",11.2,"VAT Amount","",
-                0,"N",self.doTVamt,None,None,("efld",))])
-        state = self.df.disableButtonsTags()
-        widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
-        self.df.setWidget(widget, "disabled")
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        self.tr = TartanDialog(self.opts["mf"], tops=True, title=tit,
-            eflds=fld, tend=((self.doTEnd,"y"),), txit=(self.doTExit,))
-        self.tr.loadEntry("T", 0, 0, data=self.deposit)
-        if self.state == "Q":
-            self.tr.loadEntry("T", 0, 1, data=self.value)
-        else:
-            self.tr.loadEntry("T", 0, 1, data=self.getBalance().work)
-        self.tr.focusField("T", 0, 3)
-        self.opts["mf"].startLoop()
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.enableButtonsTags(state=state)
-
-    def doTType(self, frt, pag, r, c, p, i, w):
-        self.ttype = int(w)
-        if self.ttype == 6:
-            if self.state == "Q":
-                return "nd"
-            else:
-                return "Cannot Cancel a Confirmed Booking"
-        if self.ttype == 7:
-            if self.state == "X":
-                return "nd"
-            else:
-                return "Can Only Reinstate a Cancelled Booking"
-
-    def doTDate(self, frt, pag, r, c, p, i, w):
-        self.tdate = w
-        self.tref = self.getRef()
-        self.tr.loadEntry(frt, pag, p+1, data=self.tref)
-
-    def doTRef(self, frt, pag, r, c, p, i, w):
-        self.tref = w
-
-    def doTAmount(self, frt, pag, r, c, p, i, w):
-        if self.ttype == 4:
-            chk = float(ASD(0) - ASD(w))
-        else:
-            chk = w
-        ok = "yes"
-        bal = self.getBalance().work
-        if self.state == "Q":
-            if self.ttype in (1, 2, 3) and w < self.deposit:
-                ok = askQuestion(self.opts["mf"].window, "Deposit",
-                    "This Amount is Less than the Deposit Amount, Confirm?")
-            elif chk > self.value:
-                ok = askQuestion(self.opts["mf"].window, "Value",
-                    "This Amount Exceeds the Total Value, Confirm?")
-        elif self.state == "C" and chk > self.getBalance().work:
-            ok = askQuestion(self.opts["mf"].window, "Balance",
-                    "This Amount is More than the Balance, Confirm?")
-        if ok == "no":
-            return "Invalid Amount"
-        self.tamount = w
-
-    def doTDesc(self, frt, pag, r, c, p, i, w):
-        self.tdesc = w
-        if not self.ttype == 5:
-            return "nd"
-
-    def doTGacc(self, frt, pag, r, c, p, i, w):
-        rec = self.sql.getRec(tables="genmst", cols=["glm_desc", "glm_vat"],
-            where=[("glm_cono", "=", self.opts["conum"]), ("glm_acno", "=", w),
-            ("glm_ind", "=", "Y")], limit=1)
-        if not rec:
-            return "Invalid Account Number"
-        self.tglac = w
-        self.tr.loadEntry(frt, pag, p+1, data=rec[0])
-        self.tr.loadEntry(frt, pag, p+2, data=rec[1])
-
-    def doTVcod(self, frt, pag, r, c, p, i, w):
-        rec = self.sql.getRec(tables="ctlvmf", where=[("vtm_cono", "=",
-            self.opts["conum"]), ("vtm_code", "=", w)], limit=1)
-        if not rec:
-            return "Invalid VAT Code"
-        self.tvcod = w
-        tvrte = getVatRate(self.sql, self.opts["conum"], w, self.sysdtw)[0]
-        tvamt = round(self.tamount * tvrte / (100 + tvrte), 2)
-        self.tr.loadEntry(frt, pag, p+1, tvamt)
-
-    def doTVamt(self, frt, pag, r, c, p, i, w):
-        self.tvamt = w
-
-    def doTEnd(self):
-        if self.ttype in (6, 7):
-            if self.ttype == 6:
-                desc = "Query Cancellation"
-                amt = float(ASD(0) - ASD(self.value))
-                self.state = "X"
-            else:
-                desc = "Query Re-Instatement"
-                amt = self.value
-                self.state = "Q"
-            self.sql.insRec("bkmtrn", data=[self.opts["conum"], self.number,
-                1, self.getRef(), self.batno, self.sysdtw, amt, 0, self.curdt,
-                desc, "", "", self.opts["capnm"], self.sysdtw, 0])
-            self.sql.updRec("bkmmst", cols=["bkm_state"], data=[self.state],
-                where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
-                "=", self.number)])
-            self.df.loadEntry("T", 1, 10, data=self.getBalance().work)
-            self.df.loadEntry("T", 1, 17, data=self.state)
-            self.doTExit()
-            return
-        if self.ttype in (1, 2, 3):
-            ttype = 3
-        else:
-            ttype = self.ttype
-        if ttype == 3:
-            tramt = float(ASD(0) - ASD(self.tamount))
-            vatind = ""
-            vatamt = 0
-        elif ttype == 4:
-            tramt = self.tamount
-            vatind = ""
-            vatamt = 0
-        else:
-            tramt = self.tamount
-            vatind = self.tvcod
-            vatamt = self.tvamt
-            excamt = float(ASD(tramt) - ASD(vatamt))
-        # Main Transaction
-        data = [self.opts["conum"], self.number, ttype, self.tref, self.batno,
-            self.tdate, tramt, vatamt, self.curdt, self.tdesc, vatind, "",
-            self.opts["capnm"], self.sysdtw, 0]
-        self.sql.insRec("bkmtrn", data=data)
-        if self.glint == "Y":
-            if ttype == 3:
-                gltyp = 6
-            elif ttype == 4:
-                gltyp = 2
-            else:
-                gltyp = 4
-            data = [self.opts["conum"], self.bkmctl, self.curdt, self.sysdtw,
-                gltyp, self.tref, self.batno, tramt, 0, self.tdesc,
-                "", "", 0, self.opts["capnm"], self.sysdtw, 0]
-            self.sql.insRec("gentrn", data=data)
-            tramt = float(ASD(0) - ASD(tramt))
-            vatamt = float(ASD(0) - ASD(vatamt))
-            excamt = float(ASD(tramt) - ASD(vatamt))
-            if ttype in (3, 4):
-                if self.ttype == 1:
-                    ctl = self.bnkctl
-                elif self.ttype == 2:
-                    ctl = self.cshctl
-                else:
-                    ctl = self.chqctl
-                data = [self.opts["conum"], ctl, self.curdt, self.sysdtw,
-                    gltyp, self.tref, self.batno, tramt, 0, self.tdesc,
-                    "", "", 0, self.opts["capnm"], self.sysdtw, 0]
-                self.sql.insRec("gentrn", data=data)
-            else:
-                data = [self.opts["conum"], self.tglac, self.curdt,
-                    self.sysdtw, gltyp, self.tref, self.batno, excamt,
-                    vatamt, self.tdesc, "", "", 0, self.opts["capnm"],
-                    self.sysdtw, 0]
-                self.sql.insRec("gentrn", data=data)
-                if vatamt:
-                    data = [self.opts["conum"], self.vatctl, self.curdt,
-                        self.sysdtw, gltyp, self.tref, self.batno, vatamt,
-                        0, self.tdesc, "", "", 0, self.opts["capnm"],
-                        self.sysdtw, 0]
-                    self.sql.insRec("gentrn", data=data)
-        if ttype == 5:
-            # VAT Transaction
-            data = [self.opts["conum"], vatind, "O", self.curdt, "B",
-                ttype, self.batno, self.tref, self.tdate, self.number,
-                self.tdesc, excamt, vatamt, 0, self.opts["capnm"],
-                self.sysdtw, 0]
-            self.sql.insRec("ctlvtf", data=data)
-        # Balance
-        bal = self.getBalance().work
-        self.df.loadEntry("T", 1, 10, data=bal)
-        # Status
-        if not bal:
-            self.state = "S"
-        elif bal == self.value:
-            self.state = "Q"
-        else:
-            self.state = "C"
-        self.sql.updRec("bkmmst", cols=["bkm_state"], data=[self.state],
-            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
-            "=", self.number)])
-        self.df.loadEntry("T", 1, 17, data=self.state)
-        self.doTExit()
-
-    def doTExit(self):
-        self.tr.closeProcess()
-        self.opts["mf"].closeLoop()
-
-    def doMoves(self):
-        whr = [
-            ("bkt_cono", "=", self.opts["conum"]),
-            ("bkt_number", "=", self.number)]
-        col = self.sql.bkmtrn_col
-        recs = self.sql.getRec(tables="bkmtrn", where=whr, order="bkt_date")
-        if recs:
-            data = []
-            for dat in recs:
-                data.append([
-                    dat[col.index("bkt_date")],
-                    dat[col.index("bkt_curdt")],
-                    dat[col.index("bkt_batch")],
-                    dat[col.index("bkt_type")],
-                    dat[col.index("bkt_refno")],
-                    dat[col.index("bkt_tramt")],
-                    dat[col.index("bkt_desc")]])
-            tit = "Transactions for Booking: %s" % self.number
-            col = (
-                ("bkt_date", "   Date", 10, "D1", "N"),
-                ("bkt_curdt", "Curr-Dt", 7, "D2", "N"),
-                ("bkt_batch", "Batch", 7, "Na", "N"),
-                ("bkt_type", "Typ", 3, ("XX", bktrtp), "N"),
-                ("bkt_refno", "Reference", 9, "Na", "Y"),
-                ("bkt_tramt", "    Amount", 11.2, "SD", "N"),
-                ("bkt_desc", "Details", 30, "NA", "N"))
-            state = self.df.disableButtonsTags()
-            while True:
-                rec = SelectChoice(self.opts["mf"].window, tit, col, data)
-                if rec.selection:
-                    self.df.setWidget(self.df.mstFrame, state="hide")
-                    whr = [
-                        ("bkt_cono", "=", self.opts["conum"]),
-                        ("bkt_number", "=", self.number),
-                        ("bkt_type", "=", rec.selection[4]),
-                        ("bkt_refno", "=", rec.selection[5])]
-                    TabPrt(self.opts["mf"], tabs="bkmtrn", where=whr,
-                        pdia=False)
-                    self.df.setWidget(self.df.mstFrame, state="show")
-                else:
-                    break
-            self.df.enableButtonsTags(state=state)
-
-    def doNotes(self):
-        if not self.number:
-            return
-        state = self.df.disableButtonsTags()
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        NotesCreate(self.opts["mf"], self.opts["conum"], self.opts["conam"],
-            self.opts["capnm"], "BKM", "%07i" % self.number)
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.enableButtonsTags(state=state)
-        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-
-    def doPrint(self):
-        if not self.number:
-            self.ptyp = None
-            self.tit = "Print Report"
-            r1s = (("Deposits","D"), ("Lists","L"))
-            fld = [
-                (("T",0,0,0),("IRB",r1s),0,"","",
-                    "D","N",self.doPList,None,None,None,None)]
-            view = None
-            mail = None
-        else:
-            self.ptyp = "B"
-            self.tit = "Print/Email Booking"
-            fld = []
-            view = ("N", "V")
-            if self.email:
-                mail = ("N","Y","Y")
-            else:
-                mail = None
-        state = self.df.disableButtonsTags()
-        self.pr = TartanDialog(self.opts["mf"], tops=True, title=self.tit,
-            eflds=fld, tend=((self.doPEnd,"n"),), txit=(self.doPExit,),
-            view=view, mail=mail)
-        self.opts["mf"].startLoop()
-        if self.ptyp == "B":
-            self.doPBooking()
+        self.cal = ScrollGrid(**{"mf": self.opts["mf"], "titl": titl,
+            "chgt": 2, "labs": labs, "tags": tags, "cols": cols,
+            "data": data, "font": ("Arial", self.opts["mf"].rcdic["dfs"]),
+            "butt": [("New Booking", self.doNew), ("Deposits List",
+            (self.doRep, "D")), ("Bookings List", (self.doRep, "L")),
+            ("Exit", self.doExit)], "bcmd": self.doBrowse,
+            "hcmd": self.doHover, "loop": False})
+        self.opts["mf"].startLoop()
+        self.cal.window.withdraw()
+        self.cal.window.destroy()
+        if not self.ptyp and not self.quit:
+            callModule(self.opts["mf"], None, "bk1020",
+                coy=(self.opts["conum"], self.opts["conam"]),
+                user=self.opts["capnm"], args=self.number)
         elif self.ptyp == "D":
             callModule(self.opts["mf"], None, "bk3010",
-                coy=(self.opts["conum"], self.opts["conam"]), args=True)
+                coy=(self.opts["conum"], self.opts["conam"]),
+                args=True)
         elif self.ptyp == "L":
             callModule(self.opts["mf"], None, "bk3030",
-                coy=(self.opts["conum"], self.opts["conam"]), args=True)
-        self.df.enableButtonsTags(state=state)
-        self.df.focusField("T", 1, 1)
-        self.number = 0
-
-    def doPExit(self):
-        self.ptyp = None
-        self.doPEnd()
-
-    def doPEnd(self):
-        self.pr.closeProcess()
-        self.opts["mf"].closeLoop()
-
-    def doPList(self, frt, pag, r, c, p, i, w):
-        self.ptyp = w
-
-    def doPBooking(self):
-        view = self.pr.repprt[0][1]
-        prtnam = self.pr.repprt[0][2]
-        if self.pr.repprt[1][1] == "Y":
-            mail = self.email
-        else:
-            mail = None
-        printm = self.pr.repprt[1][3]
-        self.form = DrawForm(self.opts["mf"].dbm, self.bktpl)
-        self.doLoadStatic()
-        self.form.doNewDetail()
-        self.doBookingDetails()
-        self.form.add_page()
-        tdc = self.form.sql.tpldet_col
-        nam = "%s %s %s" % (self.title, self.names[0], self.sname)
-        error = False
-        for key in self.form.newkey:
-            ln = self.form.newdic[key]
-            if ln[tdc.index("tpd_detseq")] == "booking_letter_C00":
-                body = self.sql.getRec(tables="bkmlet", cols=["bkl_body"],
-                    where=[("bkl_cono", "=", self.opts["conum"]), ("bkl_code",
-                    "=", self.state)], limit=1)
-                if not body:
-                    showError(self.opts["mf"].window, "Error",
-                        "Missing Letter Record for %s" % self.state)
-                    error = True
-                    break
-                ln[tdc.index("tpd_text")] = "Dear %s\n\n%s" % (nam, body[0])
-                if self.state == "Q":
-                    emess = ("Booking Enquiry", "Dear %s\n\nAttached "\
-                        "please find your booking enquiry." % nam)
-                elif self.state == "C":
-                    emess = ("Booking Enquiry", "Dear %s\n\nAttached "\
-                        "please find your booking confirmation." % nam)
-                elif self.state == "S":
-                    emess = ("Booking Settlement", "Dear %s\n\nAttached "\
-                        "please find your confirmation of settlement of "\
-                        "your booking." % nam)
-                elif self.state == "X":
-                    emess = ("Booking Cancellation", "Dear %s\n\nAttached "\
-                        "please find the expiry your booking enquiry." % nam)
-            if ln[tdc.index("tpd_detseq")] == "bank_details_T00":
-                if self.state in ("Q", "C"):
-                    ln[tdc.index("tpd_text")] = "Banking Details (Please use "\
-                        "%s as the EFT or Deposit Slip Reference Code)" % \
-                        self.number
-                else:
-                    del self.form.newdic[key]
-            self.form.doDrawDetail(ln)
-        if not error:
-            key = "%s_%s" % (self.opts["conum"], self.number)
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                key, ext="pdf")
-            self.form.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=view, prtnam=prtnam, mail=mail,
-                printm=printm, emess=emess)
-        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-
-    def doLoadStatic(self):
-        cmc = self.sql.ctlmst_col
-        ctm = self.sql.getRec(tables="ctlmst", where=[("ctm_cono", "=",
-            self.opts["conum"])], limit=1)
-        for fld in cmc:
-            dat = ctm[cmc.index(fld)]
-            if fld in self.form.tptp:
-                if fld == "ctm_logo":
-                    self.form.letterhead(cmc, ctm, fld, dat)
-                    continue
-                self.form.tptp[fld][1] = dat
-        if "letterhead" in self.form.tptp:
-            self.form.letterhead(cmc, ctm, "letterhead", None)
-        if "booking_number" in self.form.tptp:
-            if self.state == "Q":
-                text = "BOOKING ENQUIRY - %s" % self.number
-            elif self.state == "C":
-                text = "BOOKING CONFIRMATION/RECEIPT - %s" % self.number
-            elif self.state == "S":
-                text = "BOOKING SETTLEMENT/RECEIPT - %s" % self.number
-            elif self.state == "X":
-                text = "BOOKING CANCELLATION - %s" % self.number
-            self.form.tptp["booking_number"][1] = text
-        if "booking_date" in self.form.tptp:
-            self.form.tptp["booking_date"][1] = self.getDate(self.sysdtw)
-        if self.state in ("Q", "C"):
-            self.form.bank_details(cmc, ctm, 0)
-        else:
-            del self.form.tptp["bank_details"]
-
-    def doBookingDetails(self):
-        t = "booking_details"
-        if not t in self.form.tptp:
-            return
-        s = 0
-        nd = self.form.newdic
-        bd = self.df.t_disp[1][0]
-        cd = self.df.t_disp[2][0]
-        tc = self.form.sql.tpldet_col
-        bl = self.getBalance()
-        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Address:"
-        for x in range(3):
-            if not cd[x+4]:
-                break
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[x+4]
-            s += 1
-        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[7]
-        s += 1
-        if cd[8]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Phone:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[8]
-            s += 1
-        if cd[9]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Fax:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[9]
-            s += 1
-        if cd[10]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Mobile:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[10]
-            s += 1
-        if cd[11]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Email:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[11]
-            s += 1
-        if bd[2]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Group Name:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[2]
-            s += 1
-        if cd[12]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "V.A.T. Number:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[12]
-            s += 1
-        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Date of Arrival:"
-        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.getDate(bd[4])
-        s += 1
-        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Date of Departure:"
-        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.getDate(bd[5])
-        s += 1
-        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Number of Persons:"
-        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.guests
-        # Booked facilities
-        rtt = self.sql.getRec(tables="bkmrtt", cols=["brt_utype",
-            "brt_udesc", "brt_quant", "brt_arate"], where=[("brt_cono",
-            "=", self.opts["conum"]), ("brt_number", "=", self.number)],
-            order="brt_utype, brt_udesc")
-        text = ""
-        for n, u in enumerate(rtt):
-            s += 1
-            if not n:
-                txt = "Facilities:"
-            else:
-                txt = ""
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            qty = CCD(u[2], "UI", 3).disp
-            rte = CCD(u[3], "UD", 10.2).disp
-            txt = "%1s - %-40s %3s @ R%10s" % (u[0], u[1], qty, rte)
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
-        s += 1
-        if s >= 35:
-            return
-        # Wedding details
-        if bd[12]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Date of Ceremony:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.getDate(bd[12])
-            s += 1
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Time of Ceremony:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[13]
-            s += 1
-        if bd[11]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Special Requests:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[11]
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_lines")] = 2
-            s += self.getLines(nd, tc, t, s, bd[11])
-            if s >= 35:
-                return
-        if bd[12]:
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = \
-                    "Breakages & Cleaning Deposit:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "Cleaning Deposit"
-            s += 1
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Bride's Full Name:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[14]
-            s += 1
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Groom's Full Name:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[15]
-            s += 1
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Marriage Officer:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[16]
-            s += 1
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Facilities Req:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "Facilities"
-        # Values
-        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Value of Booking:"
-        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bd[7]
-        s += 1
-        if s >= 35:
-            return
-        if self.state == "Q":
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit Due:"
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bd[8]
-            s += 1
-            if s >= 35:
-                return
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Expiry Date:"
-            dte = self.getDate(bd[9])
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = dte
-        elif not self.state == "X" and bl.work:
-            txt = "Deposit Received:"
-            dp = CCD(float(ASD(self.value) - ASD(bl.work)), "SD", 11.2)
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + dp.disp
-            s += 1
-            if s >= 35:
-                return
-            txt = "Balance Due on Arrival:"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bl.disp
-            s += 2
-            if s >= 35:
-                return
-            txt = "(No Credit Cards Please, Only Cash or EFT)"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_bold")] = "Y"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_align")] = "C"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_x2")] = 200
-        elif not self.state == "X":
-            txt = "Balance Due"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bl.disp
-            s += 2
-            if s >= 35:
-                return
-            txt = "(Account Settled in Full)"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_bold")] = "Y"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_align")] = "C"
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_x2")] = 200
-
-    def getLines(self, nd, tc, t, s, text):
-        fm = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_font")]
-        fs = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_size")]
-        self.form.set_font(fm, size=fs)
-        w = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_x2")]
-        w -= nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_x1")]
-        h = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_y2")]
-        h -= nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_y1")]
-        txt = self.form.multi_cell(w=w, h=h, txt=text, split_only=True)
-        return len(txt)
-
-    def getBalance(self):
-        bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
-            where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
-            "=", self.number), ("bkt_type", "<>", 1)], limit=1)
-        if bal[0] is None:
-            bal = [0]
-        if self.invoiced:
-            return CCD(bal[0], "SD", 11.2)
-        else:
-            return CCD(float(ASD(self.value) + ASD(bal[0])), "SD", 11.2)
-
-    def getDate(self, date):
-        if type(date) == str:
-            date = int(date.replace("-", ""))
-        yy = date / 10000
-        mm = date / 100 % 100
-        dd = date % 100
-        return "%s %s %s" % (dd, mthnam[mm][1], yy)
-
-    def doQuit(self):
-        if self.state in ("Q", "C"):
-            ok = askQuestion(self.opts["mf"].window, "Quit",
-                "Would You Like to Quit?\n\nYou Will Lose Any "\
-                "Changes you might have Made.")
-            if ok == "yes":
-                self.quit = True
-                self.number = 0
-                self.opts["mf"].dbm.rollbackDbase()
-                self.df.selPage("Booking", focus=False)
-                self.df.focusField("T", 1, 1)
-        else:
-            self.quit = True
-            self.number = 0
-            self.df.selPage("Booking", focus=False)
-            self.df.focusField("T", 1, 1)
-
-    def chgPage(self):
-        if self.quit:
-            return
-        if self.df.pag == 1:
-            if self.state == "Q":
-                self.df.focusField("T", 1, 11)
-            else:
-                self.opts["mf"].updateStatus("Select Button or Tag to Continue")
-        elif self.state == "Q":
-            self.df.focusField("T", 2, 1)
-        else:
-            self.df.focusField("T", 2, 2)
-
-    def doExit(self):
-        if self.df.pag == 1:
-            self.df.closeProcess()
+                coy=(self.opts["conum"], self.opts["conam"]),
+                user=self.opts["capnm"], args=True)
+
+    def doExit(self, event=None):
+        self.quit = True
+        self.opts["mf"].closeLoop()
+
+    def doNew(self, *args):
+        self.newb = True
+        self.opts["mf"].closeLoop()
+
+    def doRep(self, *args):
+        self.ptyp = args[0]
+        self.opts["mf"].closeLoop()
+
+    def doBrowse(self, *args):
+        number = args[0][1].split("\n")
+        if number[0]:
+            self.number = int(number[0])
             self.opts["mf"].closeLoop()
         else:
-            self.df.selPage("Booking", focus=False)
+            self.number = None
 
-if __name__ == "__main__":
-    from TartanClasses import Dbase, MainFrame
-    from tartanFunctions import loadRcFile
-    mf = MainFrame(rcdic=loadRcFile("/home/paul/Data/Volmoed/volmoedrc"))
-    mf.dbm = Dbase(rcdic=mf.rcdic)
-    mf.dbm.openDbase()
-    rpt = bk1010(**{"mf": mf, "conum": 1, "conam": "Company One"})
+    def doHover(self, *args):
+        if self.tt and args[0][0] is None:
+            self.tt = None
+        elif args[0][0]:
+            number = args[0][1].split("\n")
+            if number[0]:
+                number = int(number[0])
+                data = self.sql.getRec(tables=["bkmmst", "bkmcon"],
+                    cols=["bkc_sname", "bkc_names", "bkm_group",
+                    "bkm_state", "bkm_value", "bkm_stddep"],
+                    where=[("bkm_cono", "=", self.opts["conum"]),
+                    ("bkm_number", "=", number), ("bkc_cono=bkm_cono",),
+                    ("bkc_ccode=bkm_ccode",)], limit=1)
+                name = "%s, %s" % (data[0], data[1])
+                text = "%-10s %s" % ("Name:", name)
+                if data[2]:
+                    text = "%s\n%-10s %s" % (text, "Group:", data[2])
+                val = CCD(data[4], "SD", 11.2).disp
+                text = "%s\n%-10s R%s" % (text, "Value:", val)
+                if data[3] == "Q":
+                    dep = CCD(data[5], "SD", 11.2).disp
+                    text = "%s\n%-10s R%s" % (text, "Deposit:", dep)
+                else:
+                    bal = self.sql.getRec(tables="bkmtrn",
+                        cols=["sum(bkt_tramt)"], where=[("bkt_cono", "=",
+                        self.opts["conum"]), ("bkt_number", "=", number),
+                        ("bkt_type", "<>", 1)], limit=1)
+                    if bal[0] is None:
+                        bal = CCD(0, "SD", 11.2).disp
+                    else:
+                        bal = CCD(bal[0], "SD", 11.2).disp
+                    text = "%s\n%-10s R%s" % (text, "Balance:", bal)
+                self.tt = ToolTip(args[0][2].widget, text,
+                    font=("Courier", self.cal.fs, "bold"))
+                self.tt.showTip(args[0][2])
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'bkm/bk1020.py'
--- bkm/bk1020.py	1970-01-01 00:00:00 +0000
+++ bkm/bk1020.py	2014-12-07 10:48:46 +0000
@@ -0,0 +1,1660 @@
+#! /usr/bin/python
+
+"""
+SYNOPSIS
+    Accommodation Bookings.
+
+    This file is part of Tartan Financial Systems (TARTAN).
+
+    flags used:
+
+        self.edit   - editing the booking
+        self.ender  - self.doEnd has been executed for page 2
+        self.found  - existing bkmrtt record
+        self.inv    - booking has been invoiced
+        self.mprint - print statement of movements
+        self.newcon - new contacts record
+        self.newmst - new booking
+        self.quit   - self.doQuit has been selected
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2014 Paul Malherbe.
+"""
+
+import copy, time
+from TartanClasses import ASD, CCD, DrawForm, GetCtl, NotesCreate
+from TartanClasses import SelectChoice, TartanDialog, Sql, TabPrt
+from tartanFunctions import askQuestion, callModule, dateDiff, doPrinter
+from tartanFunctions import getModName, getVatRate, projectDate, showError
+from tartanFunctions import textFormat
+from tartanWork import bktrtp, mthnam
+
+class bk1020:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        gc = GetCtl(self.opts["mf"])
+        ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
+        if not bkmctl:
+            return
+        self.glint = bkmctl["cbk_glint"]
+        self.bktpl = bkmctl["cbk_bkgtpl"]
+        self.terms = bkmctl["cbk_terms"]
+        if self.glint == "Y":
+            ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
+            ctls = ["bank_1", "vat_ctl", "bkm_chq", "bkm_csh", "bkm_ctl"]
+            if gc.chkRec(self.opts["conum"], ctlctl, ctls):
+                return
+            self.bnkctl = ctlctl["bank_1"]
+            self.vatctl = ctlctl["vat_ctl"]
+            self.chqctl = ctlctl["bkm_chq"]
+            self.cshctl = ctlctl["bkm_csh"]
+            self.bkmctl = ctlctl["bkm_ctl"]
+        tabs = [
+            "ctlmst", "chglog", "ctlnot", "ctlvmf", "ctlvtf", "bkmmst",
+            "bkmcon", "bkmunm", "bkmtrn", "bkmrtm", "bkmrtr", "bkmrtt",
+            "bkmlet", "tpldet"]
+        if self.glint == "Y":
+            tabs.extend(["genmst", "gentrn"])
+        self.sql = Sql(self.opts["mf"].dbm, tables=tabs, prog=__name__)
+        t = time.localtime()
+        self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
+        self.curdt = self.sysdtw / 100
+        self.batno = "B%s" % self.curdt
+        self.number = 0
+        return True
+
+    def mainProcess(self):
+        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Lodging and Function Bookings")
+        bkm = {
+            "stype": "R",
+            "tables": ["bkmmst", "bkmcon"],
+            "cols": [
+                ("bkm_number", "", 0, "Number"),
+                ("bkm_btype", "", 0, "B"),
+                ("bkm_state", "", 0, "S"),
+                ("bkc_sname", "", 20, "Surname", "Y"),
+                ("bkc_names", "", 20, "Names", "F"),
+                ("bkm_group", "", 20, "Group", "F"),
+                ("bkm_arrive", "d1", 10, "Arrive-Dt", "F"),
+                ("bkm_depart", "", 0, "Depart-Dt"),
+                ("bkm_units", "", 20, "Units")],
+            "where": [
+                ("bkm_cono", "=", self.opts["conum"]),
+                #("bkm_arrive", ">=", self.sysdtw),
+                ("bkc_cono=bkm_cono",),
+                ("bkc_ccode=bkm_ccode",)],
+            "order": "bkc_sname, bkm_arrive"}
+        unt = {
+            "stype": "M",
+            "func": self.showUnits}
+        bkc = {
+            "stype": "R",
+            "tables": ("bkmcon",),
+            "cols": (
+                ("bkc_ccode", "", 0, "Code"),
+                ("bkc_title", "", 0, "Title"),
+                ("bkc_sname", "", 0, "Surname", "Y"),
+                ("bkc_names", "", 0, "Names", "Y")),
+            "where": [
+                ("bkc_cono", "=", self.opts["conum"])],
+            "order": "bkc_sname"}
+        r1s = (
+            ("Accommodation","A"),
+            ("Other","O"))
+        r2s = (
+            ("Enquiry","Q"),
+            ("Confirmed","C"),
+            ("Settled","S"),
+            ("Cancelled","X"))
+        tag = (
+            ("Booking",self.chgPage,("T",1,1),None),
+            ("Contact",self.chgPage,(("T",1,2),("T",1,0)),("T",1,1)))
+        fld = [
+            (("T",1,0,0),"IUI",7,"Booking Number","",
+                0,"Y",self.doNumber,bkm,None,None),
+            [("T",1,1,0),("IRB",r1s),0,"Type","",
+                "A","N",self.doType,None,None,None],
+            (("T",1,2,0),"ITX",30,"Group Name","",
+                "","N",self.doGroup,None,None,None),
+            (("T",1,3,0),"IUI",3,"Number of Persons","",
+                0,"N",self.doGuests,None,None,("notzero",)),
+            (("T",1,4,0),"ID1",10,"Arrival (YYYYMMDD)","",
+                0,"N",self.doDate,None,None,("efld",)),
+            (("T",1,5,0),"ID1",10,"Departure (YYYYMMDD)","",
+                0,"N",self.doDate,None,None,("efld",)),
+            (("T",1,6,0),"ITX",50,"Allocated Units","",
+                "","N",self.doUnits,unt,None,("notblank",)),
+            (("T",1,7,0),"OSD",11.2,"Value"),
+            (("T",1,8,0),"ISD",11.2,"Initial Deposit","",
+                0,"N",self.doDeposit,None,None,None),
+            (("T",1,9,0),"ID1",10,"Initial Dep Due","",
+                0,"N",self.doDepdate,None,None,None),
+            (("T",1,10,0),"ISD",11.2,"Additional Deposit","",
+                0,"N",self.doDeposit,None,None,None),
+            (("T",1,11,0),"Id1",10,"Additional Dep Due","",
+                0,"N",self.doDepdate,None,None,None),
+            (("T",1,12,0),"OSD",11.2,"Account Balance"),
+            (("T",1,13,0),"ITX",50,"Special Requests","",
+                "","N",self.doRequests,None,None,None),
+            (("T",1,14,0),("ORB",r2s),0,"Booking Status"),
+            (("T",2,0,0),"IUA",7,"Contact Code","",
+                "","N",self.doContact,bkc,None,None),
+            (("T",2,1,0),"ITX",6,"Title","",
+                "","N",self.doTitle,None,None,("notblank",)),
+            (("T",2,2,0),"ITX",30,"Surname","",
+                "","N",self.doSurname,None,None,("notblank",)),
+            (("T",2,3,0),"ITX",30,"Names","",
+                "","N",self.doNames,None,None,("efld",)),
+            (("T",2,4,0),"ITX",30,"Address Line 1","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,5,0),"ITX",30,"Address Line 2","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,6,0),"ITX",30,"Address Line 3","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,7,0),"IUI",4,"Postal Code","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,8,0),"ITX",20,"Telephone Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,9,0),"ITX",20,"Fax Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,10,0),"ITX",20,"Mobile Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",2,11,0),"ITX",30,"E-Mail Address","",
+                "","N",self.doEmail,None,None,("email",)),
+            (("T",2,12,0),"IUI",10,"VAT Number","",
+                "","N",None,None,None,None)]
+        if "args" in self.opts:
+            fld[1][3] += "(noesc)"
+        on = (("T",1,0),("T",1,2))
+        off = ("T",1,1)
+        but = (
+            ("Edit",None,self.doEdit,2,None,None,
+                "Edit the current booking"),
+            ("Transact",None,self.doTrans,0,on,off,
+                "Create transactions for the current booking"),
+            ("Movements",None,self.doMoves,0,on,off,
+                "Display all movements for the current booking"),
+            ("Notes",None,self.doNotes,0,on,off,
+                "Create/Amend Notes for the currenr booking"),
+            ("Accept",None,self.doAccept,0,on,off,
+                "Save/Print and Exit the current booking"),
+            ("Quit",None,self.doQuit,1,None,off,
+                "Quit the current booking creation or amendment"))
+        tnd = (None, (self.doEnd,"n"), (self.doEnd,"n"))
+        txt = (None, self.doExit, None)
+        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
+            tags=tag, eflds=fld, butt=but, tend=tnd, txit=txt,
+            clicks=self.doClick)
+        if "args" in self.opts:
+            self.number = self.opts["args"]
+            self.df.doKeyPressed("T", 1, 0, data=self.number)
+
+    def doEdit(self):
+        if self.number:
+            self.edit = True
+            self.ender = False
+            self.df.setWidget(self.df.B0, "disabled")
+            if self.df.pag == 1:
+                self.df.focusField(self.df.frt, self.df.pag, 2)
+            else:
+                self.df.focusField(self.df.frt, self.df.pag, 1)
+
+    def doClick(self, *opts):
+        if not self.number or not self.edit:
+            return
+        if self.click:
+            self.df.loadEntry("T", self.click[0], self.click[1],
+                data=self.df.t_work[self.click[0]][0][self.click[1]])
+        self.click = opts[0]
+        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
+
+    def doNumber(self, frt, pag, r, c, p, i, w):
+        self.click = []
+        self.edit = False
+        self.quit = False
+        self.ender = False
+        self.inv = False
+        if not w:
+            if "args" in self.opts:
+                ok = "yes"
+            else:
+                ok = askQuestion(self.opts["mf"].window, "New Booking",
+                    "Is This a New Booking?", default="yes")
+            if ok == "no":
+                return "Invalid Booking Number"
+            else:
+                self.number = 0
+                self.state = "Q"
+                self.newmst = True
+                self.units = None
+                self.df.setWidget(self.df.B0, "disabled")
+                self.df.loadEntry(frt, pag, p+14, data=self.state)
+                return
+        self.oldmst = self.sql.getRec(tables="bkmmst", where=[("bkm_cono",
+            "=", self.opts["conum"]), ("bkm_number", "=", w)], limit=1)
+        if not self.oldmst:
+            return "Invalid Booking Number"
+        self.number = w
+        self.newmst = False
+        self.newcon = False
+        self.state = self.oldmst[self.sql.bkmmst_col.index("bkm_state")]
+        self.btype = self.oldmst[self.sql.bkmmst_col.index("bkm_btype")]
+        self.group = self.oldmst[self.sql.bkmmst_col.index("bkm_group")]
+        self.guests = self.oldmst[self.sql.bkmmst_col.index("bkm_guests")]
+        self.arrive = self.oldmst[self.sql.bkmmst_col.index("bkm_arrive")]
+        self.depart = self.oldmst[self.sql.bkmmst_col.index("bkm_depart")]
+        self.units = self.oldmst[self.sql.bkmmst_col.index("bkm_units")]
+        self.value = self.oldmst[self.sql.bkmmst_col.index("bkm_value")]
+        self.stddep = self.oldmst[self.sql.bkmmst_col.index("bkm_stddep")]
+        self.stddte = self.oldmst[self.sql.bkmmst_col.index("bkm_stddte")]
+        self.grpdep = self.oldmst[self.sql.bkmmst_col.index("bkm_grpdep")]
+        self.grpdte = self.oldmst[self.sql.bkmmst_col.index("bkm_grpdte")]
+        self.special = self.oldmst[self.sql.bkmmst_col.index("bkm_special")]
+        for num, dat in enumerate(self.oldmst[1:]):
+            if num == 14:
+                self.ccode = dat
+            elif num > 11:
+                if num == 12:
+                    self.df.loadEntry("T", 1, num, data=self.getBalance().work)
+                self.df.loadEntry("T", 1, num+1, data=dat)
+            else:
+                self.df.loadEntry("T", 1, num, data=dat)
+        inv = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
+            self.opts["conum"]), ("bkt_number", "=", self.number),
+            ("bkt_type", "=", 2)])
+        if inv:
+            self.inv = True
+        self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
+            "=", self.opts["conum"]), ("bkc_ccode", "=", self.ccode)], limit=1)
+        self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
+        self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
+        self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
+        self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
+        for num, dat in enumerate(self.oldcon[1:]):
+            self.df.loadEntry("T", 2, num, data=dat)
+        self.df.setWidget(self.df.B0, "normal")
+        self.df.setWidget(self.df.B5, "normal")
+        return "nd"
+
+    def doType(self, frt, pag, r, c, p, i, w):
+        if not self.state == "Q" and not w == self.btype:
+            self.df.loadEntry(frt, pag, p, data=self.btype)
+            return "Invalid Type"
+        if not self.newmst:
+            if not w == self.btype:
+                ok = askQuestion(self.opts["mf"].window, "Change Type",
+                    "Do You Want to Change the Type of the Booking?",
+                    default="no")
+                if ok == "no":
+                    self.df.loadEntry(frt, pag, p, data=self.btype)
+                    return "Invalid Type"
+                self.doUnBook()
+                for x in range(6, 14):
+                    self.df.loadEntry("T", 1, x, data="")
+        self.btype = w
+
+    def doUnBook(self):
+        self.sql.updRec("bkmmst", cols=["bkm_units"], data=[""],
+            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
+            "=", self.number)])
+        self.sql.delRec("bkmrtt", where=[("brt_cono", "=", self.opts["conum"]),
+            ("brt_number", "=", self.number)])
+        self.units = ""
+        self.df.loadEntry("T", 1, 6, data=self.units)
+
+    def doGroup(self, frt, pag, r, c, p, i, w):
+        self.group = w
+
+    def doGuests(self, frt, pag, r, c, p, i, w):
+        self.guests = w
+
+    def doDate(self, frt, pag, r, c, p, i, w):
+        if p == 4:
+            self.arrive = w
+            if self.arrive < self.sysdtw:
+                return "Invalid Date, In the Past"
+        else:
+            self.depart = w
+            if self.depart < self.arrive:
+                return "Invalid Date, Before Arrival Date"
+            if self.btype == "A" and self.depart == self.arrive:
+                return "Arrival and Departure Dates are the Same"
+            if not self.units:
+                if self.showUnits(False):
+                    self.df.doKeyPressed(frt, pag, p+1, data=self.units)
+
+    def showUnits(self, f1=True):
+        # Get Available Units
+        col = self.sql.bkmunm_col
+        where = [("bum_cono", "=", self.opts["conum"])]
+        if self.btype == "O":
+            where.append(("bum_type", "=", self.btype))
+        self.aunits = self.sql.getRec(tables="bkmunm", where=where,
+            order="bum_type, bum_code")
+        test = copy.deepcopy(self.aunits)
+        whole = False
+        for unit in test:
+            if not unit[col.index("bum_type")] == "A":
+                continue
+            if unit[col.index("bum_code")] == "ALL":
+                self.aunits.remove(unit)
+                whole = unit
+        book = self.sql.getRec(tables="bkmmst", cols=["bkm_arrive",
+            "bkm_depart", "bkm_units"], where=[("bkm_cono", "=",
+            self.opts["conum"]), ("bkm_number", "<>", self.number),
+            ("bkm_state", "<>", "X")], order="bkm_arrive")
+        self.used = []
+        for bk in book:
+            u = False
+            if self.btype == "A":
+                if bk[0] < self.depart and self.arrive < bk[1]:
+                    u = True
+            else:
+                if bk[0] <= self.depart and self.arrive <= bk[1]:
+                    u = True
+            if u:
+                un = bk[2].split(":")
+                for u in un:
+                    self.used.append(u.split("-"))
+                    if whole and u[0] == "A":
+                        whole = False
+        test = copy.deepcopy(self.aunits)
+        for unit in test:
+            cod = [
+                unit[col.index("bum_type")],
+                unit[col.index("bum_code")]]
+            if cod[0] == "A" and ["A", "ALL"] in self.used:
+                self.aunits.remove(unit)
+                whole = False
+            elif cod in self.used and unit[col.index("bum_multi")] == "N":
+                self.aunits.remove(unit)
+        if whole:
+            self.aunits.insert(0, whole)
+        if not self.aunits:
+            showError(self.opts["mf"].window, "No Vacancies",
+                "There are No Available Units for this Booking")
+            self.df.focusField("T", 1, 5)
+            return
+        beds = 0
+        for unit in self.aunits:
+            if unit[self.sql.bkmunm_col.index("bum_type")] == self.btype:
+                beds += unit[self.sql.bkmunm_col.index("bum_guests")]
+        if beds < self.guests:
+            showError(self.opts["mf"].window, "Capacity Shortage",
+                "There is Not Enough Capacity for this Booking")
+            self.df.focusField("T", 1, 5)
+            return
+        # Enter Units
+        tit = "Select Units and Rates"
+        unt = {
+            "stype": "M",
+            "func": self.getUnits}
+        rte = {
+            "stype": "R",
+            "tables": ("bkmrtm",),
+            "cols": (
+                ("brm_code", "", 0, "Cod"),
+                ("brm_desc", "", 0, "Description"),
+                ("brm_base", "", 0, "B")),
+            "where": [],
+            "order": "brm_type, brm_code"}
+        fld = (
+            (("T",0,0,0),"OUI",3,"Number of Guests"),
+            (("C",0,0,0),"IUA",8,"Unit-Cod","Unit Combined Code",
+                "r","Y",self.doUUnit,unt,None,("notblank",)),
+            (("C",0,0,1),"ITX",25,"Description","",
+                "","N",self.doUDesc,None,None,("notblank",)),
+            (("C",0,0,2),"IUI",4,"Rate","Rate Code",
+                "r","N",self.doURate,rte,self.doUDelete,("efld",)),
+            (("C",0,0,3),"OTX",25,"Description"),
+            (("C",0,0,4),"OUD",10.2,"Normal-Rte"),
+            (("C",0,0,5),"IUI",3,"Qty","",
+                0,"N",self.doUQty,None,self.doUDelete,("notzero",)),
+            (("C",0,0,6),"IUD",6.2,"Disc-%","",
+                0,"N",self.doUDisc,None,None,None),
+            (("C",0,0,7),"IUD",10.2,"Applied-Rt","Applied Rate",
+                0,"N",self.doUAmount,None,None,("efld",)))
+        but = (("Clear",None,self.doUClear,0,("C",0,1),("C",0,3),
+            "Remove All Units from the Booking"),)
+        state = self.df.disableButtonsTags()
+        widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
+        self.df.setWidget(widget, "disabled")
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.rt = TartanDialog(self.opts["mf"], tops=True, title=tit,
+            eflds=fld, tend=(None,), txit=(None,), cend=((self.doUEnd,"y"),),
+            cxit=(self.doUExit,), butt=but)
+        self.doLoadUnits()
+        self.opts["mf"].startLoop()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state=state)
+        return self.units
+
+    def doUClear(self):
+        ok = askQuestion(self.opts["mf"].window, "Clear",
+            "Are You Sure You Want to Clear All Units?", default="no")
+        if ok == "no":
+            self.rt.focusField(self.rt.frt, self.rt.pag, self.rt.col)
+            return
+        self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number)])
+        self.doLoadUnits()
+
+    def doUDelete(self):
+        t, c = self.ucod.split("-")
+        if self.rt.idx == 2:
+            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
+                self.opts["conum"]), ("brt_number", "=", self.number),
+                ("brt_utype", "=", t), ("brt_ucode", "=", c)])
+        elif not self.found:
+            return
+        else:
+            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
+                self.opts["conum"]), ("brt_number", "=", self.number),
+                ("brt_utype", "=", t), ("brt_ucode", "=", t),
+                ("brt_rcode", "=", self.rcode)])
+        self.doLoadUnits()
+
+    def getUnits(self):
+        data = []
+        for unit in self.aunits:
+            typ = unit[self.sql.bkmunm_col.index("bum_type")]
+            cod = unit[self.sql.bkmunm_col.index("bum_code")]
+            des = unit[self.sql.bkmunm_col.index("bum_desc")]
+            qty = unit[self.sql.bkmunm_col.index("bum_guests")]
+            bkt = self.sql.getRec(tables="bkmrtt", cols=["sum(brt_quant)"],
+                where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
+                "=", self.number), ("brt_utype", "=", typ), ("brt_ucode", "=",
+                cod)], limit=1)
+            if not bkt or not bkt[0]:
+                bkt = [0]
+            data.append(["%s-%-6s" % (typ, cod), des,
+                CCD(qty, "UI", 3).disp, CCD(bkt[0], "UI", 3).disp])
+        opts = {
+            "stype": "C",
+            "titl": "Select the Required Unit",
+            "head": ("Unit-Cod", "Description", "Qty", "Bkd"),
+            "data": data}
+        rs = self.rt.selectItem(self.rt.pag, opts)
+        return rs
+
+    def doUUnit(self, frt, pag, r, c, p, i, w):
+        t, c = w.split("-")
+        rec = self.sql.getRec(tables="bkmunm", cols=["bum_desc", "bum_multi",
+            "bum_guests"], where=[("bum_cono", "=", self.opts["conum"]),
+            ("bum_type", "=", t), ("bum_code", "=", c)], limit=1)
+        if not rec:
+            return "Invalid Unit Code"
+        found = False
+        for unit in self.aunits:
+            typ = unit[self.sql.bkmunm_col.index("bum_type")]
+            cod = unit[self.sql.bkmunm_col.index("bum_code")]
+            if typ == t and cod == c:
+                found = True
+                break
+        if not found:
+            return "Unit Not Available"
+        if t == "A" and c == "ALL":
+            for unit in self.used:
+                if unit[0] == "A":
+                    return "Units Already Allocated in his Period"
+        self.ucod = w
+        self.udes = rec[0]
+        self.uqty = rec[2]
+        self.rt.loadEntry(frt, pag, p+1, data=self.udes)
+        self.rt.colf[0][2][8]["where"] = [
+            ("brm_cono", "=", self.opts["conum"]),
+            ("brm_type", "=", t)]
+        #if rec[1] == "N":
+        #    return "sk1"
+
+    def doUDesc(self, frt, pag, r, c, p, i, w):
+        self.udes = w
+        #if self.ucod == "A-ALL":
+        #    self.rt.doKeyPressed("C", 0, p+1, data=0)
+
+    def doURate(self, frt, pag, r, c, p, i, w):
+        t, c = self.ucod.split("-")
+        unit = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number),
+            ("brt_utype", "=", t), ("brt_ucode", "=", c), ("brt_rcode",
+            "=", w)], limit=1)
+        if unit:
+            # Existing bkmrtt Record
+            self.found = True
+            self.rcode = w
+            self.rdesc = unit[self.sql.bkmrtt_col.index("brt_rdesc")]
+            self.nrate = unit[self.sql.bkmrtt_col.index("brt_nrate")]
+            self.rqty = unit[self.sql.bkmrtt_col.index("brt_quant")]
+            arate = unit[self.sql.bkmrtt_col.index("brt_arate")]
+            self.rt.loadEntry(frt, pag, p, data=self.rcode)
+            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
+            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
+            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
+            if self.ucod.split("-")[0] == "A":
+                self.aqty -= self.rqty
+        else:
+            # New bkmrtt Record
+            racc = self.sql.getRec(tables=["bkmrtm", "bkmrtr"],
+                cols=["brm_desc", "brm_base", "brr_rate"],
+                where=[("brm_cono", "=", self.opts["conum"]),
+                ("brm_type", "=", self.ucod[0]),
+                ("brm_code", "=", w), ("brr_cono=brm_cono",),
+                ("brr_type=brm_type",), ("brr_code=brm_code",),
+                ("brr_date", "<=", self.arrive)], limit=1)
+            if not racc:
+                return "Invalid Rate Code"
+            self.found = False
+            self.rcode = w
+            self.rdesc = racc[0]
+            self.rbase = racc[1]
+            self.nrate = racc[2]
+            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
+            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
+            if self.ucod.split("-")[0] == "A":
+                bqty = self.guests - self.aqty
+                if self.uqty > bqty:
+                    self.rqty = bqty
+                else:
+                    self.rqty = self.uqty
+            elif self.uqty > self.guests:
+                self.rqty = self.guests
+            else:
+                self.rqty = self.uqty
+            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
+        if self.nrate:
+            return "sk2"
+        else:
+            self.rqty = 1
+            self.rdisc = 0
+            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
+            self.rt.loadEntry(frt, pag, p+4, data=self.rdisc)
+            return "sk4"
+
+    def doUQty(self, frt, pag, r, c, p, i, w):
+        if self.uqty and w > self.uqty:
+            ok = askQuestion(self.opts["mf"].window, "Quantity",
+                "Quantity Exceeds Unit Quantity", default="no")
+            if ok == "no":
+                return "rf"
+        if self.ucod.split("-")[0] == "A":
+            if (self.aqty + w) > self.guests:
+                return "Invalid Quantity, Exceeds Booking"
+        elif w > self.guests:
+            return "Invalid Quantity, Exceeds Booking"
+        self.rqty = w
+        #if self.found and self.rqty == 0:
+        #    c_work = copy.deepcopy(self.rt.c_work[0])
+        #    self.rt.clearFrame("C", 0)
+        #    pos = 0
+        #    for num, dat in enumerate(c_work):
+        #        if not dat[0]:
+        #            break
+        #        if dat[0] == self.ucod and dat[2] == self.rcode:
+        #            continue
+        #        for n, d in enumerate(dat):
+        #            self.rt.loadEntry("C", 0, pos+n, data=d)
+        #        pos += 8
+        #    return "ff%s" % (pos + 1)
+
+    def doUDisc(self, frt, pag, r, c, p, i, w):
+        self.rdisc = w
+        self.arate = int(self.nrate * (100 - self.rdisc) / 100)
+        dif = self.arate % 5
+        if dif:
+            self.arate = self.arate + (5 - dif)
+        self.rt.loadEntry(frt, pag, p+1, data=self.arate)
+
+    def doUAmount(self, frt, pag, r, c, p, i, w):
+        self.arate = w
+
+    def doUEnd(self):
+        t, c = self.ucod.split("-")
+        if self.found:
+            self.sql.updRec("bkmrtt", cols=["brt_quant", "brt_discp",
+                "brt_arate"], data=[self.rqty, self.rdisc, self.arate],
+                where=[("brt_cono", "=", self.opts["conum"]),
+                ("brt_number", "=", self.number), ("brt_utype", "=", t),
+                ("brt_ucode", "=", c), ("brt_rcode", "=", self.rcode)])
+        else:
+            self.sql.insRec("bkmrtt", data=[self.opts["conum"], self.number,
+                t, c, self.udes, self.rcode, self.rdesc, self.rbase,
+                self.nrate, self.rqty, self.rdisc, self.arate, 0, 0, 0, 0,
+                self.opts["capnm"], self.sysdtw, 0])
+        self.doLoadUnits()
+
+    def doLoadUnits(self):
+        self.rt.clearFrame("C", 0)
+        self.rt.loadEntry("T", 0, 0, data=self.guests)
+        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number)],
+            order="brt_ucode")
+        self.aqty = 0
+        if not recs:
+            self.rt.focusField("C", 0, 1)
+            return
+        for num, rec in enumerate(recs):
+            pos = num * 8
+            ut = rec[self.sql.bkmrtt_col.index("brt_utype")]
+            uc = rec[self.sql.bkmrtt_col.index("brt_ucode")]
+            uc = "%s-%s" % (ut, uc)
+            ud = rec[self.sql.bkmrtt_col.index("brt_udesc")]
+            rc = rec[self.sql.bkmrtt_col.index("brt_rcode")]
+            rd = rec[self.sql.bkmrtt_col.index("brt_rdesc")]
+            nr = rec[self.sql.bkmrtt_col.index("brt_nrate")]
+            qt = rec[self.sql.bkmrtt_col.index("brt_quant")]
+            ds = rec[self.sql.bkmrtt_col.index("brt_discp")]
+            ar = rec[self.sql.bkmrtt_col.index("brt_arate")]
+            self.rt.loadEntry("C", 0, pos, data=uc)
+            self.rt.loadEntry("C", 0, pos+1, data=ud)
+            self.rt.loadEntry("C", 0, pos+2, data=rc)
+            self.rt.loadEntry("C", 0, pos+3, data=rd)
+            self.rt.loadEntry("C", 0, pos+4, data=nr)
+            self.rt.loadEntry("C", 0, pos+5, data=qt)
+            self.rt.loadEntry("C", 0, pos+6, data=ds)
+            self.rt.loadEntry("C", 0, pos+7, data=ar)
+            if ut == "A":
+                self.aqty += qt
+            if num == self.rt.rows[0] - 1:
+                self.rt.scrollScreen(0)
+            else:
+                col = ((num + 1) * 8) + 1
+                self.rt.focusField("C", 0, col)
+
+    def doUExit(self):
+        recs = self.sql.getRec(tables="bkmrtt", cols=["brt_utype", "brt_ucode"],
+            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number", "=",
+            self.number)], group="brt_utype, brt_ucode",
+            order="brt_utype, brt_ucode")
+        self.units = ""
+        done = []
+        for t, c in recs:
+            if not self.units:
+                self.units = "%s-%s" % (t, c)
+            else:
+                self.units = "%s:%s-%s" % (self.units, t, c)
+        self.rt.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doUnits(self, frt, pag, r, c, p, i, w):
+        check = self.doCheckUnits()
+        if check:
+            return check
+        self.units = w
+        self.df.loadEntry(frt, pag, p, data=self.units)
+        self.getBookingValue()
+        self.df.loadEntry("T", 1, 7, data=self.value)
+        self.stddep, self.stddte, self.grpdep, self.grpdte = self.getDeposit()
+        self.df.loadEntry("T", 1, 8, data=self.stddep)
+        self.df.loadEntry("T", 1, 9, data=self.stddte)
+        self.df.loadEntry("T", 1, 10, data=self.grpdep)
+        self.df.loadEntry("T", 1, 11, data=self.grpdte)
+        self.df.loadEntry("T", 1, 12, data=self.getBalance().work)
+        if not self.stddep:
+            return "sk4"
+
+    def doCheckUnits(self):
+        cols = self.sql.bkmrtt_col
+        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number)])
+        if not recs:
+            return "No Units Selected"
+        quant = {}
+        whole = True
+        for rec in recs:
+            typ = rec[cols.index("brt_utype")]
+            cod = rec[cols.index("brt_ucode")]
+            qty = rec[cols.index("brt_quant")]
+            if not typ in quant:
+                quant[typ] = qty
+            else:
+                quant[typ] += qty
+            if typ == "A" and cod == "ALL":
+                whole = True
+        if self.btype == "A" and not "A" in quant:
+            return "Missing Accomodation Unit"
+        for typ in quant:
+            if not whole and typ == "A" and not quant[typ] == self.guests:
+                return "Invalid Quantity (%s) for Type %s" % (quant[typ], typ)
+
+    def getBookingValue(self):
+        self.value = 0
+        col = self.sql.bkmrtt_col
+        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number)])
+        if self.btype == "A":
+            bdays = dateDiff(self.arrive, self.depart, "days")
+        else:
+            bdays = dateDiff(self.arrive, self.depart, "days") + 1
+        self.sql.updRec("bkmrtt", cols=["brt_bdays"], data=[bdays],
+            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
+            "=", self.number)])
+        for rec in recs:
+            rbase = rec[col.index("brt_rbase")]
+            quant = rec[col.index("brt_quant")]
+            arate = rec[col.index("brt_arate")]
+            if rbase == "A":
+                self.value = float(ASD(self.value) + ASD(quant * bdays * arate))
+            elif rbase == "B":
+                self.value = float(ASD(self.value) + ASD(quant * arate))
+            elif rbase == "C":
+                self.value = float(ASD(self.value) + ASD(bdays * arate))
+            else:
+                self.value = float(ASD(self.value) + ASD(arate))
+
+    def doDeposit(self, frt, pag, r, c, p, i, w):
+        if p == 8:
+            self.stddep = w
+            if not self.stddep:
+                self.stddte = 0
+                self.grpdep = 0
+                self.grpdte = 0
+                self.df.loadEntry(frt, pag, p+1, data=self.stddte)
+                self.df.loadEntry(frt, pag, p+2, data=self.grpdep)
+                self.df.loadEntry(frt, pag, p+3, data=self.grpdte)
+                return "sk3"
+        else:
+            self.grpdep = w
+            if not self.grpdep:
+                self.grpdte = 0
+                self.df.loadEntry(frt, pag, p+1, data=self.grpdte)
+                return "sk1"
+
+    def doDepdate(self, frt, pag, r, c, p, i, w):
+        if p == 9:
+            self.stddte = w
+        else:
+            self.grpdte = w
+
+    def doRequests(self, frt, pag, r, c, p, i, w):
+        self.special = w
+
+    def doContact(self, frt, pag, r, c, p, i, w):
+        #if not self.state == "Q":
+        #    self.df.loadEntry(frt, pag, p, data=self.ccode)
+        #    return
+        if w:
+            self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
+                "=", self.opts["conum"]), ("bkc_ccode", "=", w)], limit=1)
+            if not self.oldcon:
+                return "Invalid Contact Code"
+            self.newcon = False
+            self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
+            self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
+            self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
+            self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
+            for num, dat in enumerate(self.oldcon[1:]):
+                self.df.loadEntry("T", 2, num, data=dat)
+        else:
+            self.newcon = True
+        self.ccode = w
+
+    def doTitle(self, frt, pag, r, c, p, i, w):
+        self.title = w
+
+    def doSurname(self, frt, pag, r, c, p, i, w):
+        self.sname = w
+
+    def doNames(self, frt, pag, r, c, p, i, w):
+        self.names = w
+        if self.newcon:
+            chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
+                self.opts["conum"]), ("bkc_sname", "=", self.sname),
+                ("bkc_names", "=", self.names)], limit=1)
+            if chk:
+                self.ccode = chk[self.sql.bkmcon_col.index("bkc_ccode")]
+                self.df.doKeyPressed(frt, pag, p-3, self.ccode)
+
+    def doEmail(self, frt, pag, r, c, p, i, w):
+        self.email = w
+
+    def doEnd(self):
+        if self.df.pag == 1:
+            if self.newmst or self.edit:
+                self.df.selPage("Contact", focus=False)
+                self.df.focusField("T", 2, 1)
+            else:
+                self.opts["mf"].updateStatus("Select Button or Tag to Continue")
+        elif self.df.pag == 2:
+            self.ender = True
+            self.df.setWidget(self.df.B0, "normal")
+            self.opts["mf"].updateStatus("Select Button or Tag to Continue")
+
+    def doUpdate(self):
+        if self.newcon:
+            # Remove invalid characters
+            name = self.sname.replace(" ", "")
+            for c in (" ", ".", ",", ";", ":", "'", '"'):
+                name = name.replace(c, "")
+            if len(name) < 5:
+                name = name + ("0" * (5 - len(name)))
+            ccode = ""
+            for c in xrange(0, 5):
+                ccode = (ccode + name[c]).upper()
+            ccode = ccode.strip()
+            text = "%s%0" + str((7 - len(ccode))) + "d"
+            for x in xrange(1, 100):
+                self.ccode = text % (ccode, x)
+                chk = self.sql.getRec(tables="bkmcon",
+                    where=[("bkc_cono", "=", self.opts["conum"]),
+                    ("bkc_ccode", "=", self.ccode)], limit=1)
+                if not chk:
+                    break
+            self.df.loadEntry("T", 2, 0, data=self.ccode)
+        changed = False
+        data = [self.opts["conum"]]
+        trdt = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        for x in range(len(self.df.t_work[2][0])):
+            data.append(self.df.t_work[2][0][x])
+        if self.newcon:
+            changed = True
+            self.sql.insRec("bkmcon", data=data)
+            self.newcon = False
+        elif data != self.oldcon:
+            changed = True
+            self.sql.updRec("bkmcon", data=data, where=[("bkc_cono", "=",
+                self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
+            for num, dat in enumerate(self.oldcon):
+                if dat != data[num]:
+                    self.sql.insRec("chglog", data=["bkmcon", "U",
+                        "%03i%-7s" % (self.opts["conum"], self.ccode),
+                        self.sql.bkmcon_col[num], trdt, self.opts["capnm"],
+                        str(dat), str(data[num]), 0])
+        if not self.number:
+            changed = True
+            acc = self.sql.getRec(tables="bkmmst", cols=["max(bkm_number)"],
+                where=[("bkm_cono", "=", self.opts["conum"])], limit=1)
+            if not acc[0]:
+                self.number = 1001
+            else:
+                self.number = int(acc[0]) + 1
+            self.df.loadEntry("T", 1, 0, data=self.number)
+            self.sql.updRec("bkmrtt", cols=["brt_number"], data=[self.number],
+                where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
+                "=", 0)])
+            data = [self.opts["conum"], self.number, 1, self.getRef(),
+                self.batno, self.sysdtw, 0, 0, self.curdt, "Booking Enquiry",
+                "", "", self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("bkmtrn", data=data)
+        data = [self.opts["conum"]]
+        for x in range(len(self.df.t_work[1][0])):
+            if x == 12:
+                continue
+            data.append(self.df.t_work[1][0][x])
+        data.append(self.ccode)
+        if self.newmst:
+            changed = True
+            self.sql.insRec("bkmmst", data=data)
+        elif data != self.oldmst:
+            changed = True
+            self.sql.updRec("bkmmst", data=data, where=[("bkm_cono", "=",
+                self.opts["conum"]), ("bkm_number", "=", self.number)])
+            for num, dat in enumerate(self.oldmst):
+                if dat != data[num]:
+                    self.sql.insRec("chglog", data=["bkmmst", "U",
+                        "%03i%7s" % (self.opts["conum"], self.number),
+                        self.sql.bkmmst_col[num], trdt, self.opts["capnm"],
+                        str(dat), str(data[num]), 0])
+        self.opts["mf"].dbm.commitDbase()
+        return changed
+
+    def doAccept(self):
+        if not self.number and self.df.pag == 1:
+            return
+        if not self.units:
+            return
+        check = self.doCheckUnits()
+        if check:
+            self.df.focusField("T", 1, 6, err=check)
+            return
+        flds = ["T", 1, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]
+        flds[2].append(14)
+        f, p, c, m = self.df.doCheckFields(flds)
+        if m:
+            self.df.selPage("Booking")
+            self.df.focusField(f, p, (c+1), err=m)
+            return
+        if not self.df.t_work[2][0][1]:
+            self.df.selPage("Contact")
+            self.df.focusField("T", 2, 1, err="Missing Contact")
+            return
+        f, p, c, m = self.df.doCheckFields(("T", 2, None))
+        if m:
+            self.df.selPage("Contact")
+            self.df.focusField(f, p, (c+1), err=m)
+            return
+        # Update Tables
+        if self.state in ("Q", "C"):
+            if not self.value:
+                self.state = "S"
+            elif not self.stddep:
+                self.state = "C"
+            self.df.loadEntry("T", 1, 14, data=self.state)
+        changed = self.doUpdate()
+        if changed:
+            dflt = "yes"
+        else:
+            dflt = "no"
+        # Print/Email Booking
+        ok = askQuestion(self.opts["mf"].window, "Notify",
+            "Print/Email Booking", default=dflt)
+        if ok == "yes":
+            self.doPrint()
+        if "args" in self.opts:
+            # Exit
+            self.doExit()
+        else:
+            # Loop for Next Booking
+            self.number = 0
+            self.df.selPage("Booking")
+            self.df.setWidget(self.df.B0, "disabled")
+            self.df.focusField("T", 1, 1)
+
+    def getRef(self):
+        rec = self.sql.getRec(tables="bkmtrn", cols=["max(bkt_refno)"],
+            where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
+            "=", self.number), ("bkt_refno", "like", "%7s%s" % (self.number,
+            "%"))], limit=1)
+        if not rec or not rec[0]:
+            num = 1
+        else:
+            num = int(rec[0][-2:]) + 1
+        return "%7s%02i" % (self.number, num)
+
+    def doTrans(self):
+        if not self.number:
+            return
+        tit = "Transaction Data Capture"
+        if self.glint:
+            glm = {
+                "stype": "R",
+                "tables": ("genmst",),
+                "cols": (
+                    ("glm_acno", "", 0, "Acc-Num"),
+                    ("glm_desc", "", 0, "Description")),
+                "where": [
+                    ("glm_cono", "=", self.opts["conum"])],
+                "order": "glm_desc"}
+        r1s = (
+            ("Receipt","1"),
+            ("Refund","2"),
+            ("Journal","3"),
+            ("Cancel","4"),
+            ("Reinstate","5"))
+        r2s = (
+            ("EFT","1"),
+            ("Cash","2"),
+            ("Cheque","3"))
+        if self.state == "Q":
+            dft = "2"
+        else:
+            dft = "1"
+        fld = [
+            (("T",0,0,0),"OSD",11.2,"S-Deposit"),
+            (("T",0,0,0),"OSD",11.2,"G-Deposit"),
+            (("T",0,0,0),"OSD",11.2,"Balance"),
+            (("T",0,1,0),("IRB",r1s),0,"Type","",
+                "1","Y",self.doTType,None,None,None),
+            (("T",0,2,0),("IRB",r2s),0,"Method","",
+                "1","Y",self.doTMethod,None,None,None),
+            (("T",0,3,0),"ID1",10,"Date","",
+                self.sysdtw,"N",self.doTDate,None,None,("efld",)),
+            (("T",0,4,0),"ONa",9,"Reference"),
+            (("T",0,5,0),"ISD",11.2,"Amount","",
+                0,"N",self.doTAmount,None,None,("notzero",)),
+            (("T",0,6,0),"ITX",30,"Details","",
+                "","N",self.doTDesc,None,None,None)]
+        if self.glint:
+            fld.extend([
+            (("T",0,7,0),"IUI",7,"Acc-Num","G/L Account Number",
+                0,"N",self.doTGacc,glm,None,None),
+            (("T",0,7,0),"ONA",30,""),
+            (("T",0,8,0),"IUA",1,"VAT Code","",
+                0,"N",self.doTVcod,None,None,None),
+            (("T",0,9,0),"ISD",11.2,"VAT Amount","",
+                0,"N",self.doTVamt,None,None,("efld",))])
+        state = self.df.disableButtonsTags()
+        widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
+        self.df.setWidget(widget, "disabled")
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.tr = TartanDialog(self.opts["mf"], tops=True, title=tit,
+            eflds=fld, tend=((self.doTEnd,"y"),), txit=(self.doTExit,))
+        if self.state == "Q":
+            self.tr.loadEntry("T", 0, 0, data=self.stddep)
+            self.tr.loadEntry("T", 0, 1, data=self.grpdep)
+            self.tr.loadEntry("T", 0, 2, data=self.value)
+        else:
+            self.tr.loadEntry("T", 0, 0, data=0)
+            self.tr.loadEntry("T", 0, 1, data=self.getBalance().work)
+        self.tr.focusField("T", 0, 3)
+        self.opts["mf"].startLoop()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state=state)
+
+    def doTType(self, frt, pag, r, c, p, i, w):
+        self.ttype = int(w)
+        if self.ttype == 3:
+            return "sk1"
+        if self.ttype == 4:
+            if self.state == "Q":
+                return "nd"
+            else:
+                return "Cannot Cancel a Confirmed Booking"
+        if self.ttype == 5:
+            if self.state == "X":
+                return "nd"
+            else:
+                return "Can Only Reinstate a Cancelled Booking"
+
+    def doTMethod(self, frt, pag, r, c, p, i, w):
+        self.mtype = w
+
+    def doTDate(self, frt, pag, r, c, p, i, w):
+        self.tdate = w
+        self.tref = self.getRef()
+        self.tr.loadEntry(frt, pag, p+1, data=self.tref)
+
+    def doTRef(self, frt, pag, r, c, p, i, w):
+        self.tref = w
+
+    def doTAmount(self, frt, pag, r, c, p, i, w):
+        if self.ttype == 2:
+            chk = float(ASD(0) - ASD(w))
+        else:
+            chk = w
+        ok = "yes"
+        bal = self.getBalance().work
+        if self.state == "Q":
+            if self.ttype == 1 and w < self.stddep:
+                ok = askQuestion(self.opts["mf"].window, "Deposit",
+                    "This Amount is Less than the Deposit Amount, Confirm?")
+            elif chk > self.value:
+                ok = askQuestion(self.opts["mf"].window, "Value",
+                    "This Amount Exceeds the Total Value, Confirm?")
+        elif self.state == "C" and chk > self.getBalance().work:
+            ok = askQuestion(self.opts["mf"].window, "Balance",
+                    "This Amount is More than the Balance, Confirm?")
+        if ok == "no":
+            return "Invalid Amount"
+        self.tamount = w
+
+    def doTDesc(self, frt, pag, r, c, p, i, w):
+        self.tdesc = w
+        if not self.ttype == 3:
+            return "nd"
+
+    def doTGacc(self, frt, pag, r, c, p, i, w):
+        rec = self.sql.getRec(tables="genmst", cols=["glm_desc", "glm_vat"],
+            where=[("glm_cono", "=", self.opts["conum"]), ("glm_acno", "=", w),
+            ("glm_ind", "=", "Y")], limit=1)
+        if not rec:
+            return "Invalid Account Number"
+        self.tglac = w
+        self.tr.loadEntry(frt, pag, p+1, data=rec[0])
+        self.tr.loadEntry(frt, pag, p+2, data=rec[1])
+
+    def doTVcod(self, frt, pag, r, c, p, i, w):
+        rec = self.sql.getRec(tables="ctlvmf", where=[("vtm_cono", "=",
+            self.opts["conum"]), ("vtm_code", "=", w)], limit=1)
+        if not rec:
+            return "Invalid VAT Code"
+        self.tvcod = w
+        tvrte = getVatRate(self.sql, self.opts["conum"], w, self.sysdtw)[0]
+        tvamt = round(self.tamount * tvrte / (100 + tvrte), 2)
+        self.tr.loadEntry(frt, pag, p+1, tvamt)
+
+    def doTVamt(self, frt, pag, r, c, p, i, w):
+        self.tvamt = w
+
+    def doTEnd(self):
+        if self.ttype in (4, 5):
+            if self.ttype == 4:
+                desc = "Query Cancellation"
+                amt = 0
+                self.state = "X"
+            else:
+                desc = "Query Re-Instatement"
+                amt = 0
+                self.state = "Q"
+            self.sql.insRec("bkmtrn", data=[self.opts["conum"], self.number,
+                1, self.getRef(), self.batno, self.sysdtw, amt, 0, self.curdt,
+                desc, "", "", self.opts["capnm"], self.sysdtw, 0])
+            self.sql.updRec("bkmmst", cols=["bkm_state"], data=[self.state],
+                where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
+                "=", self.number)])
+            self.df.loadEntry("T", 1, 12, data=self.getBalance().work)
+            self.df.loadEntry("T", 1, 14, data=self.state)
+            self.doTExit()
+            return
+        if self.ttype == 1:
+            ttype = 3
+        else:
+            ttype = self.ttype + 2
+        if ttype == 3:
+            tramt = float(ASD(0) - ASD(self.tamount))
+            vatind = ""
+            vatamt = 0
+        elif ttype == 4:
+            tramt = self.tamount
+            vatind = ""
+            vatamt = 0
+        else:
+            tramt = self.tamount
+            vatind = self.tvcod
+            vatamt = self.tvamt
+            excamt = float(ASD(tramt) - ASD(vatamt))
+        # Main Transaction
+        data = [self.opts["conum"], self.number, ttype, self.tref, self.batno,
+            self.tdate, tramt, vatamt, self.curdt, self.tdesc, vatind, "",
+            self.opts["capnm"], self.sysdtw, 0]
+        self.sql.insRec("bkmtrn", data=data)
+        if self.glint == "Y":
+            if ttype == 3:
+                gltyp = 6
+            elif ttype == 4:
+                gltyp = 2
+            else:
+                gltyp = 4
+            data = [self.opts["conum"], self.bkmctl, self.curdt, self.sysdtw,
+                gltyp, self.tref, self.batno, tramt, 0, self.tdesc,
+                "", "", 0, self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("gentrn", data=data)
+            tramt = float(ASD(0) - ASD(tramt))
+            vatamt = float(ASD(0) - ASD(vatamt))
+            excamt = float(ASD(tramt) - ASD(vatamt))
+            if ttype in (3, 4):
+                if self.mtype == 1:
+                    ctl = self.bnkctl
+                elif self.mtype == 2:
+                    ctl = self.cshctl
+                else:
+                    ctl = self.chqctl
+                data = [self.opts["conum"], ctl, self.curdt, self.sysdtw,
+                    gltyp, self.tref, self.batno, tramt, 0, self.tdesc,
+                    "", "", 0, self.opts["capnm"], self.sysdtw, 0]
+                self.sql.insRec("gentrn", data=data)
+            else:
+                data = [self.opts["conum"], self.tglac, self.curdt,
+                    self.sysdtw, gltyp, self.tref, self.batno, excamt,
+                    vatamt, self.tdesc, "", "", 0, self.opts["capnm"],
+                    self.sysdtw, 0]
+                self.sql.insRec("gentrn", data=data)
+                if vatamt:
+                    data = [self.opts["conum"], self.vatctl, self.curdt,
+                        self.sysdtw, gltyp, self.tref, self.batno, vatamt,
+                        0, self.tdesc, "", "", 0, self.opts["capnm"],
+                        self.sysdtw, 0]
+                    self.sql.insRec("gentrn", data=data)
+        if ttype == 5:
+            # VAT Transaction
+            data = [self.opts["conum"], vatind, "O", self.curdt, "B",
+                ttype, self.batno, self.tref, self.tdate, self.number,
+                self.tdesc, excamt, vatamt, 0, self.opts["capnm"],
+                self.sysdtw, 0]
+            self.sql.insRec("ctlvtf", data=data)
+        # Balance
+        bal = self.getBalance().work
+        self.df.loadEntry("T", 1, 12, data=bal)
+        # Status
+        if not bal or bal == float(ASD(0) - ASD(self.value)):
+            self.state = "S"
+        elif bal == self.value:
+            self.state = "Q"
+        else:
+            self.state = "C"
+        self.sql.updRec("bkmmst", cols=["bkm_state"], data=[self.state],
+            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
+            "=", self.number)])
+        self.df.loadEntry("T", 1, 14, data=self.state)
+        self.doTExit()
+
+    def doTExit(self):
+        self.tr.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doMoves(self):
+        whr = [
+            ("bkt_cono", "=", self.opts["conum"]),
+            ("bkt_number", "=", self.number)]
+        col = self.sql.bkmtrn_col
+        recs = self.sql.getRec(tables="bkmtrn", where=whr, order="bkt_date")
+        if recs:
+            data = []
+            for dat in recs:
+                data.append([
+                    dat[col.index("bkt_date")],
+                    dat[col.index("bkt_curdt")],
+                    dat[col.index("bkt_batch")],
+                    dat[col.index("bkt_type")],
+                    dat[col.index("bkt_refno")],
+                    dat[col.index("bkt_tramt")],
+                    dat[col.index("bkt_desc")]])
+            tit = "Transactions for Booking: %s" % self.number
+            col = (
+                ("bkt_date", "   Date", 10, "D1", "N"),
+                ("bkt_curdt", "Curr-Dt", 7, "D2", "N"),
+                ("bkt_batch", "Batch", 7, "Na", "N"),
+                ("bkt_type", "Typ", 3, ("XX", bktrtp), "N"),
+                ("bkt_refno", "Reference", 9, "Na", "Y"),
+                ("bkt_tramt", "    Amount", 11.2, "SD", "N"),
+                ("bkt_desc", "Details", 30, "NA", "N"))
+            state = self.df.disableButtonsTags()
+            self.mprint = False
+            while True:
+                rec = SelectChoice(self.opts["mf"].window, tit, col,
+                    data, butt=[("Print", self.doMPrint)])
+                if self.mprint:
+                    self.df.setWidget(self.df.mstFrame, state="hide")
+                    callModule(self.opts["mf"], None, "bk3080",
+                        coy=(self.opts["conum"], self.opts["conam"]),
+                        args=self.number)
+                    self.df.setWidget(self.df.mstFrame, state="show")
+                    break
+                elif rec.selection:
+                    self.df.setWidget(self.df.mstFrame, state="hide")
+                    whr = [
+                        ("bkt_cono", "=", self.opts["conum"]),
+                        ("bkt_number", "=", self.number),
+                        ("bkt_type", "=", rec.selection[4]),
+                        ("bkt_refno", "=", rec.selection[5])]
+                    TabPrt(self.opts["mf"], tabs="bkmtrn", where=whr,
+                        pdia=False)
+                    self.df.setWidget(self.df.mstFrame, state="show")
+                else:
+                    break
+            self.df.enableButtonsTags(state=state)
+
+    def doMPrint(self):
+        self.mprint = True
+
+    def doNotes(self):
+        if not self.number:
+            return
+        state = self.df.disableButtonsTags()
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        NotesCreate(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+            self.opts["capnm"], "BKM", "%07i" % self.number)
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state=state)
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+
+    def doPrint(self):
+        if not self.number:
+            return
+        self.tit = "Print/Email Booking"
+        fld = []
+        view = ("N", "V")
+        if self.email:
+            mail = ("N","Y","N", "E-Mail Booking")
+        else:
+            mail = None
+        state = self.df.disableButtonsTags()
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.pr = TartanDialog(self.opts["mf"], tops=True, title=self.tit,
+            eflds=fld, tend=((self.doPEnd,"n"),), txit=(self.doPExit,),
+            view=view, mail=mail)
+        self.opts["mf"].startLoop()
+        self.doPBooking()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.setWidget(self.df.B0, "disabled")
+        self.df.enableButtonsTags(state=state)
+        self.df.mstFrame.focus_force()
+
+    def doPEnd(self):
+        self.pr.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doPExit(self):
+        self.ptyp = None
+        self.doPEnd()
+
+    def doPBooking(self):
+        view = self.pr.repprt[0][1]
+        prtnam = self.pr.repprt[0][2]
+        if self.pr.repprt[1][1] == "Y":
+            mail = self.email
+        else:
+            mail = None
+        printm = self.pr.repprt[1][3]
+        self.form = DrawForm(self.opts["mf"].dbm, self.bktpl)
+        self.doLoadStatic()
+        self.form.doNewDetail()
+        self.doBookingDetails()
+        self.form.add_page()
+        tdc = self.form.sql.tpldet_col
+        if self.names:
+            nam = "%s %s %s" % (self.title, self.names[0], self.sname)
+        else:
+            nam = "%s %s" % (self.title, self.sname)
+        error = False
+        for key in self.form.newkey:
+            ln = self.form.newdic[key]
+            if ln[tdc.index("tpd_detseq")] == "booking_letter_C00":
+                body = self.sql.getRec(tables="bkmlet", cols=["bkl_body"],
+                    where=[("bkl_cono", "=", self.opts["conum"]), ("bkl_code",
+                    "=", self.state)], limit=1)
+                if not body:
+                    showError(self.opts["mf"].window, "Error",
+                        "Missing Letter Record for %s" % self.state)
+                    error = True
+                    break
+                ln[tdc.index("tpd_text")] = "Dear %s\n\n%s" % (nam, body[0])
+                if self.state == "Q":
+                    emess = ["Booking Enquiry", "Dear %s\n\nAttached "\
+                        "please find your booking enquiry" % nam]
+                    if self.terms:
+                        emess[1] += " as well as a copy of our Terms "\
+                            "and Conditions."
+                    else:
+                        emess[1] += "."
+                elif self.state == "C":
+                    emess = ("Booking Enquiry", "Dear %s\n\nAttached "\
+                        "please find your booking confirmation." % nam)
+                elif self.state == "S":
+                    emess = ("Booking Settlement", "Dear %s\n\nAttached "\
+                        "please find your confirmation of settlement of "\
+                        "your booking." % nam)
+                elif self.state == "X":
+                    emess = ("Booking Cancellation", "Dear %s\n\nAttached "\
+                        "please find the expiry of your booking enquiry." %
+                        nam)
+            if ln[tdc.index("tpd_detseq")] == 7:
+                if self.state in ("Q", "C"):
+                    ln[tdc.index("tpd_text")] = "%-20s%60s" % \
+                        ("Banking Details:", "(Please use %s as the EFT or "\
+                        "Deposit Slip Reference Code)" % self.number)
+            self.form.doDrawDetail(ln)
+        if not error:
+            key = "%s_%s" % (self.opts["conum"], self.number)
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                key, ext="pdf")
+            if self.terms:
+                att = [self.terms]
+            self.form.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=view, prtnam=prtnam, mail=mail,
+                printm=printm, emess=emess, attach=att)
+
+    def doLoadStatic(self):
+        cmc = self.sql.ctlmst_col
+        ctm = self.sql.getRec(tables="ctlmst", where=[("ctm_cono", "=",
+            self.opts["conum"])], limit=1)
+        for fld in cmc:
+            dat = ctm[cmc.index(fld)]
+            if fld in self.form.tptp:
+                if fld == "ctm_logo":
+                    self.form.letterhead(cmc, ctm, fld, dat)
+                    continue
+                self.form.tptp[fld][1] = dat
+        if "letterhead" in self.form.tptp:
+            self.form.letterhead(cmc, ctm, "letterhead", None)
+        if "booking_number" in self.form.tptp:
+            if self.state == "Q":
+                text = "BOOKING ENQUIRY - %s" % self.number
+            elif self.state == "C":
+                text = "BOOKING CONFIRMATION/RECEIPT - %s" % self.number
+            elif self.state == "S":
+                text = "BOOKING SETTLEMENT/RECEIPT - %s" % self.number
+            elif self.state == "X":
+                text = "BOOKING CANCELLATION - %s" % self.number
+            self.form.tptp["booking_number"][1] = text
+        if "booking_date" in self.form.tptp:
+            self.form.tptp["booking_date"][1] = self.getDate(self.sysdtw)
+        if "company_name" in self.form.tptp:
+            self.form.tptp["company_name"][1] = self.opts["conam"]
+
+    def doBookingDetails(self):
+        t = "booking_details"
+        if not t in self.form.tptp:
+            return
+        s = 0
+        nd = self.form.newdic
+        tc = self.form.sql.tpldet_col
+        bd = self.df.t_disp[1][0]
+        bw = self.df.t_work[1][0]
+        cd = self.df.t_disp[2][0]
+        cw = self.df.t_work[2][0]
+        if cd[4]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Address:"
+            for x in range(3):
+                if not cd[x+4]:
+                    break
+                nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[x+4]
+                s += 1
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[7]
+            s += 1
+        if cw[8]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Phone:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[8]
+            s += 1
+        if cw[9]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Fax:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[9]
+            s += 1
+        if cw[10]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Mobile:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[10]
+            s += 1
+        if cw[11]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Email:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[11]
+            s += 1
+        if bw[2]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Group Name:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = bd[2]
+            s += 1
+        if cw[12]:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "V.A.T. Number:"
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = cd[12]
+            s += 1
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Date of Arrival:"
+        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.getDate(bw[4])
+        s += 1
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Date of Departure:"
+        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.getDate(bw[5])
+        s += 1
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Number of Persons:"
+        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.guests
+        # Booked facilities
+        rtt = self.sql.getRec(tables="bkmrtt", cols=["brt_utype", "brt_ucode",
+            "brt_udesc", "brt_rbase", "brt_quant", "brt_arate"],
+            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number", "=",
+            self.number)], order="brt_utype, brt_udesc")
+        text = ""
+        for n, u in enumerate(rtt):
+            s += 1
+            if not n:
+                txt = "Facilities:"
+            else:
+                txt = ""
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
+            bas = u[3]
+            qty = CCD(u[4], "UI", 3)
+            rte = CCD(u[5], "UD", 10.2)
+            if rte.work:
+                txt = "%1s - %-28s %-3s @ R%10s" % (u[0], u[2],
+                    qty.disp, rte.disp)
+                if bas in ("A", "C"):
+                    txt += " pd"
+            else:
+                txt = "%1s - %-28s" % (u[0], u[2])
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
+        # Special
+        if bd[13]:
+            lines = textFormat(bd[13], width=nd["%s_C%02i" %
+                (t, s)][tc.index("tpd_mrg_chrs")], blong=False)
+            for num, line in enumerate(lines):
+                s += 1
+                if  not num:
+                    nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Remarks:"
+                nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = line
+        # Values
+        s += 1
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Value of Booking:"
+        if not bd[7]:
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "N/C" + bd[7]
+        else:
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bd[7]
+        if not bd[7] or self.state == "X":
+            return
+        bl = self.getBalance()
+        if self.state == "S":
+            s += 2
+            txt = "(Account Settled in Full)"
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_bold")] = "Y"
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_align")] = "C"
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_x2")] = 200
+            return
+        if self.inv:
+            rc = CCD(float(ASD(bl.work) - ASD(self.value)), "SD", 11.2)
+        else:
+            rc = bl
+            bl = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
+        if self.state == "Q":
+            od = CCD(float(ASD(bw[8]) + ASD(bw[10])), "SD", 11.2)
+            da = CCD(float(ASD(self.value) - ASD(od.work)), "SD", 11.2)
+        elif self.state == "C" and bw[10]:
+            od = CCD(float(ASD(bw[8]) + ASD(bw[10]) + ASD(rc.work)), "SD", 11.2)
+            da = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
+        else:
+            od = CCD(0, "SD", 11.2)
+            da = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
+        s += 1
+        if self.state == "Q":
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
+            txt = "R%s due by %s" % (bd[8], self.getDate(bw[9]))
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
+            if bw[10]:
+                s += 1
+                nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
+                txt = "R%s due by %s" % (bd[10], self.getDate(bw[11]))
+                nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
+        elif self.state == "C" and bw[10] and od.work > 0:
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
+            txt = "R%s due by %s" % (od.disp, self.getDate(bw[11]))
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
+        elif bl.work:
+            txt = "Receipts:"
+            dp = CCD(float(ASD(self.value) - ASD(bl.work)), "SD", 11.2)
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + dp.disp
+        s += 1
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Balance:"
+        txt = "R%s due Before Arrival" % da.disp
+        nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
+        s += 2
+        txt = "(No Credit Cards Please, Only Cash or EFT)"
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_bold")] = "Y"
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_align")] = "C"
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
+        nd["%s_T%02i" % (t, s)][tc.index("tpd_x2")] = 200
+
+    def getDeposit(self):
+        if not self.value:
+            return 0, 0, 0, 0
+        if not self.number:
+            d1 = projectDate(self.sysdtw, 15)
+        else:
+            d1 = projectDate(self.sql.getRec(tables="bkmtrn",
+                cols=["bkt_capdt"], where=[("bkt_cono", "=",
+                self.opts["conum"]), ("bkt_number", "=",
+                self.number), ("bkt_type", "=", 1)],
+                limit=1)[0], 15)
+        if d1 > self.arrive:
+            d1 = self.arrive
+        if self.group:
+            v1 = self.value * .10
+            v2 = self.value * .50
+            d2 = projectDate(self.arrive, 120, "-")
+        else:
+            v1 = self.value * .50
+            v2 = 0
+            d2 = 0
+        if d2 > self.arrive:
+            d2 = self.arrive
+        return v1, d1, v2, d2
+
+    def getLines(self, nd, tc, t, s, text):
+        fm = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_font")]
+        fs = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_size")]
+        self.form.set_font(fm, size=fs)
+        w = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_x2")]
+        w -= nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_x1")]
+        h = nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_y2")]
+        h -= nd["%s_T%02i" % (t, s)][tc.index("tpd_mrg_y1")]
+        txt = self.form.multi_cell(w=w, h=h, txt=text, split_only=True)
+        return len(txt)
+
+    def getBalance(self):
+        bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
+            where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
+            "=", self.number), ("bkt_type", "<>", 1)], limit=1)
+        if not bal[0]:
+            return CCD(0, "SD", 11.2)
+        else:
+            return CCD(bal[0], "SD", 11.2)
+
+    def getDate(self, date):
+        if type(date) == str:
+            date = int(date.replace("-", ""))
+        if not date:
+            return None
+        yy = date / 10000
+        mm = date / 100 % 100
+        dd = date % 100
+        return "%s %s %s" % (dd, mthnam[mm][1], yy)
+
+    def doQuit(self):
+        if self.state in ("Q", "C"):
+            ok = askQuestion(self.opts["mf"].window, "Quit",
+                "Would You Like to Quit?\n\nYou Will Lose Any "\
+                "Changes you might have Made.")
+            if ok == "yes":
+                self.quit = True
+                if "args" in self.opts:
+                    self.doExit()
+                else:
+                    self.number = 0
+                    self.opts["mf"].dbm.rollbackDbase()
+                    self.df.selPage("Booking", focus=False)
+                    self.df.setWidget(self.df.B0, "disabled")
+                    self.df.focusField("T", 1, 1)
+        else:
+            self.quit = True
+            if "args" in self.opts:
+                self.doExit()
+            else:
+                self.number = 0
+                self.df.selPage("Booking", focus=False)
+                self.df.setWidget(self.df.B0, "disabled")
+                self.df.focusField("T", 1, 1)
+
+    def chgPage(self):
+        if self.ender or self.quit:
+            return
+        if self.df.pag == 1 and (self.state == "Q" or self.edit):
+            self.df.focusField("T", 1, 14)
+        elif self.df.pag == 2 and (self.state == "Q" or self.edit):
+            self.df.focusField("T", 2, 1)
+        else:
+            self.opts["mf"].updateStatus("Select Button or Tag to Continue")
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bkm/bk3010.py'
--- bkm/bk3010.py	2014-08-27 09:27:53 +0000
+++ bkm/bk3010.py	2014-12-03 13:38:45 +0000
@@ -15,7 +15,7 @@
 
 import time
 from textwrap import wrap
-from TartanClasses import CCD, GetCtl, MyFpdf, Sql, TartanDialog
+from TartanClasses import ASD, CCD, GetCtl, MyFpdf, Sql, TartanDialog
 from tartanFunctions import doPrinter, getModName, projectDate
 
 class bk3010:
@@ -26,7 +26,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bkmmst", "bkmcon"],
+        self.sql = Sql(self.opts["mf"].dbm, ["bkmmst", "bkmcon", "bkmtrn"],
             prog=__name__)
         if self.sql.error:
             return
@@ -41,6 +41,10 @@
     def mainProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
             "Deposits Due")
+        r1s = (("No","N"), ("Yes","Y"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Expired Only","",
+                "N","Y",self.doExpired,None,None,None),)
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         if "args" in self.opts:
@@ -48,45 +52,90 @@
         else:
             tops = False
         self.df = TartanDialog(self.opts["mf"], tops=tops, title=tit,
-            eflds=[], tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
+            eflds=fld, tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
+
+    def doExpired(self, frt, pag, r, c, p, i, w):
+        self.expired = w
 
     def doEnd(self):
         self.df.closeProcess()
         tab = ["bkmmst"]
         col = [
             "bkm_number",
-            "bkm_btype",
+            "bkm_group",
             "bkm_ccode",
             "bkm_arrive",
             "bkm_depart",
-            "bkm_deposit",
-            "bkm_depdate"]
+            "bkm_stddep",
+            "bkm_stddte",
+            "bkm_grpdep",
+            "bkm_grpdte",
+            "bkm_state"]
         whr = [
             ("bkm_cono", "=", self.opts["conum"]),
-            ("bkm_state", "=", "Q")]
+            ("bkm_state", "in", ("C", "Q"))]
         odr = "bkm_arrive, bkm_ccode"
         recs = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
         self.fpdf = MyFpdf(name=__name__, prog=__name__, head=80)
         self.pglin = 999
         for rec in recs:
-            if self.pglin > self.fpdf.lpp:
-                self.pageHeading()
-            a = CCD(rec[0], "UI", 6).disp
-            b = CCD(rec[6], "D1", 10).disp
+            if not rec[5] and not rec[7]:
+                continue
+            num = CCD(rec[0], "UI", 6)
+            trn = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
+                self.opts["conum"]), ("bkt_number", "=", num.work)])
+            inv = False
+            bal = 0.0
+            for tr in trn:
+                typ = tr[self.sql.bkmtrn_col.index("bkt_type")]
+                amt = tr[self.sql.bkmtrn_col.index("bkt_tramt")]
+                bal = float(ASD(bal) + ASD(amt))
+                if typ == 2:
+                    inv = True
+            if inv:
+                continue
+            dp1 = float(ASD(rec[5]) + ASD(bal))
+            dt1 = rec[6]
+            if dp1 > 0:
+                dp2 = rec[7]
+                dt2 = rec[8]
+            else:
+                dp2 = float(ASD(rec[7]) + ASD(dp1))
+                dt2 = rec[8]
+                dp1 = 0
+            if self.expired == "Y":
+                if dt1 > self.sysdtw:
+                    continue
+                elif dt2 and dt2 > self.sysdtw:
+                    continue
+            elif not dp1 > 0 and not dp2 > 0:
+                continue
+            if dp1:
+                b = CCD(dt1, "D1", 10).disp
+                if dp2:
+                    b = "%s\n%s" % (b, CCD(dt2, "D1", 10).disp)
+            elif dp2:
+                b = CCD(dt2, "D1", 10).disp
+            else:
+                continue
             con = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
                 self.opts["conum"]), ("bkc_ccode", "=", rec[2])], limit=1)
-            titl = con[self.sql.bkmcon_col.index("bkc_title")]
             snam = con[self.sql.bkmcon_col.index("bkc_sname")]
             fnam = con[self.sql.bkmcon_col.index("bkc_names")]
-            group = con[self.sql.bkmcon_col.index("bkc_group")]
-            if group:
-                c = "%s %s %s\n%-20s" % (titl, fnam.split()[0], snam, group)
-            else:
-                c = "%s %s %s" % (titl, fnam.split()[0], snam)
+            c = "%s %s" % (fnam.split()[0], snam)
+            if rec[1]:
+                c = "%s\n%s" % (c[:20], rec[1][:20])
             d = CCD(rec[3], "D1", 10).disp
             e = CCD(rec[4], "D1", 10).disp
-            f = CCD(rec[5], "UD", 10.2).disp
-            self.printLine(a, b, c, d, e, f)
+            if dp1:
+                f = CCD(dp1, "UD", 10.2).disp
+                if dp2:
+                    f = "%s\n%s" % (f, CCD(dp2, "UD", 10.2).disp)
+            else:
+                f = CCD(dp2, "UD", 10.2).disp
+            if self.pglin > self.fpdf.lpp:
+                self.pageHeading()
+            self.printLine(num.disp, b, c, d, e, f)
         if self.fpdf.page:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
@@ -108,12 +157,13 @@
         self.pglin = 4
 
     def printLine(self, a, b, c, d, e, f, fill=0):
-        lines = len(wrap(c, break_long_words=False, width=20))
-        h = lines * 8
-        if lines > 1:
+        lines = c.count("\n")
+        if lines:
             ctyp = "M"
+            h = 16
         else:
             ctyp = "S"
+            h = 8
         ft = ["courier", "B", 13]
         self.fpdf.set_font(ft[0], ft[1], ft[2])
         w = self.fpdf.get_string_width("X"*7)
@@ -122,29 +172,27 @@
         self.fpdf.drawText(a, x=x, y=y, w=w, h=h, border="TLB",
             fill=fill, ctyp=ctyp, font=ft)
         x += w
-        w = self.fpdf.get_string_width("X"*11)
-        h = self.fpdf.get_y() - y
-        self.fpdf.drawText(b, x=x, y=y, w=w, h=h, border="TLB",
-            fill=fill, ctyp=ctyp, font=ft)
-        x += w
         w = self.fpdf.get_string_width("X"*21)
-        h = self.fpdf.get_y() - y
         self.fpdf.drawText(c, x=x, y=y, w=w, h=8, border="TLB",
             fill=fill, ctyp=ctyp, font=ft)
         x += w
         w = self.fpdf.get_string_width("X"*11)
-        h = self.fpdf.get_y() - y
+        #h = self.fpdf.get_y() - y
         self.fpdf.drawText(d, x=x, y=y, w=w, h=h, border="TLB",
             fill=fill, ctyp=ctyp, font=ft)
         x += w
         w = self.fpdf.get_string_width("X"*11)
-        h = self.fpdf.get_y() - y
+        #h = self.fpdf.get_y() - y
         self.fpdf.drawText(e, x=x, y=y, w=w, h=h, border="TLB",
             fill=fill, ctyp=ctyp, font=ft)
         x += w
         w = self.fpdf.get_string_width("X"*11)
-        h = self.fpdf.get_y() - y
-        self.fpdf.drawText(f, x=x, y=y, w=w, h=h, border="TLRB",
+        self.fpdf.drawText(b, x=x, y=y, w=0, h=8, border="TLB",
+            fill=fill, ctyp=ctyp, font=ft)
+        x += w
+        w = self.fpdf.get_string_width("X"*11)
+        #h = self.fpdf.get_y() - y
+        self.fpdf.drawText(f, x=x, y=y, w=w, h=8, border="TLRB",
             fill=fill, ctyp=ctyp, font=ft)
 
     def doExit(self):

=== modified file 'bkm/bk3020.py'
--- bkm/bk3020.py	2014-10-01 14:07:50 +0000
+++ bkm/bk3020.py	2014-11-28 10:42:25 +0000
@@ -269,13 +269,13 @@
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
         if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.view, prtnam=self.prtnam, mail=self.mail)
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.view,
+                prtnam=self.prtnam, mail=self.mail)
 
     def getValues(self, data):
         bkmno = CCD(data[0], "UI", 7)

=== modified file 'bkm/bk3030.py'
--- bkm/bk3030.py	2014-10-01 14:07:50 +0000
+++ bkm/bk3030.py	2014-12-03 14:03:29 +0000
@@ -2,7 +2,7 @@
 
 """
 SYNOPSIS
-    Bookings Listing.
+    Booking Arrivals Listing.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -15,9 +15,10 @@
 
 import datetime, os, time
 from textwrap import wrap
-from TartanClasses import ASD, CCD, GetCtl, MyFpdf, Sql, TartanDialog
-from tartanFunctions import doDrawTable, doPrinter, getModName, getVatRate
-from tartanFunctions import projectDate
+from TartanClasses import ASD, CCD, GetCtl, MyFpdf, PrintBookingInvoice
+from TartanClasses import Sql, TartanDialog
+from tartanFunctions import dateDiff, doDrawTable, doPrinter, getModName
+from tartanFunctions import getVatRate, projectDate
 from tartanWork import mthnam
 
 class bk3030:
@@ -28,14 +29,27 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, tables=["bkmmst", "bkmcon",
+            "bkmrtt", "bkmtrn", "bkmunm", "ctlmst", "ctlvtf", "gentrn",
+            "tplmst"], prog=__name__)
+        if self.sql.error:
+            return
         gc = GetCtl(self.opts["mf"])
-        ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
-        if not ctlmst:
+        ctl = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctl:
             return
+        for col in (
+                "ctm_name", "ctm_add1", "ctm_add2", "ctm_add3", "ctm_pcode",
+                "ctm_regno", "ctm_taxno", "ctm_taxdf", "ctm_tel", "ctm_fax",
+                "ctm_b_name", "ctm_b_ibt", "ctm_b_acno", "ctm_logo"):
+            exec "self.%s = ctl['%s']" % (col, col)
+        if not self.ctm_logo or not os.path.exists(self.ctm_logo):
+            self.ctm_logo = None
         bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
         if not bkmctl:
             return
         self.glint = bkmctl["cbk_glint"]
+        self.tplnam = bkmctl["cbk_invtpl"]
         if self.glint == "Y":
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -45,18 +59,23 @@
                 return
             self.vatctl = ctlctl["vat_ctl"]
             self.bkmctl = ctlctl["bkm_ctl"]
-        self.sql = Sql(self.opts["mf"].dbm, tables=["bkmmst", "bkmcon",
-            "bkmrtt", "bkmtrn", "bkmunm", "bkmunt", "ctlvtf", "gentrn"],
-            prog=__name__)
-        if self.sql.error:
-            return
         t = time.localtime()
         self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
         return True
 
     def mainProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Bookings Listing (%s)" % __name__)
+            "Booking Arrivals Listing (%s)" % __name__)
+        tpm = {
+            "stype": "R",
+            "tables": ("tplmst",),
+            "cols": (
+                ("tpm_tname", "", 0, "Template"),
+                ("tpm_title", "", 0, "Title", "Y")),
+            "where": [
+                ("tpm_type", "=", "I"),
+                ("tpm_system", "=", "BKM")],
+            "order": "tpm_tname"}
         r1s = (("Weekdays","D"), ("Weekend","E"), ("Range", "R"))
         r2s = (("Yes","Y"), ("No","N"))
         fld = (
@@ -67,7 +86,9 @@
             (("T",0,2,0),"ID1",10,"Ending Date","",
                 0,"N",self.doEndDate,None,None,("efld",)),
             (("T",0,3,0),("IRB",r2s),0,"Print Invoices","",
-                "Y","Y",self.doPrintInv,None,None,None))
+                "Y","Y",self.doPrintInv,None,None,None),
+            (("T",0,4,0),"INA",20,"Template Name","",
+                self.tplnam,"N",self.doTplNam,tpm,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
         if "args" in self.opts:
@@ -75,7 +96,7 @@
         else:
             tops = False
         self.df = TartanDialog(self.opts["mf"], tops=tops, title=tit,
-            eflds=fld, tend=tnd, txit=txt, view=("N","P"))
+            eflds=fld, tend=tnd, txit=txt, view=("N","P"), mail=("Y","N"))
 
     def doPeriod(self, frt, pag, r, c, p, i, w):
         self.period = w
@@ -122,10 +143,22 @@
     def doEndDate(self, frt, pag, r, c, p, i, w):
         if w < self.start:
             return "Invalid End Date, Before Start Date"
+        days = dateDiff(self.start, w, ptype="days")
+        if days > 7:
+            return "Range More Than 7 Days"
         self.end = w
 
     def doPrintInv(self, frt, pag, r, c, p, i, w):
         self.prtinv = w
+        if self.prtinv == "N":
+            return "sk1"
+
+    def doTplNam(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
+            ("tpm_type", "=", "I"), ("tpm_system", "=", "BKM")], limit=1)
+        if not acc:
+            return "Invalid Template Name"
+        self.tname = w
 
     def doEnd(self):
         self.df.closeProcess()
@@ -136,15 +169,12 @@
         self.pglin = 999
         days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
         last = 0
+        books = []
         for rec in recs:
             number = rec[self.sql.bkmmst_col.index("bkm_number")]
-            inv = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono",
-                "=", self.opts["conum"]), ("bkt_number", "=", number),
-                ("bkt_type", "=", 2)])
-            if not inv:
-                self.doInvoice(number)
             ccode = rec[self.sql.bkmmst_col.index("bkm_ccode")]
             btype = rec[self.sql.bkmmst_col.index("bkm_btype")]
+            group = rec[self.sql.bkmmst_col.index("bkm_group")]
             arrive = rec[self.sql.bkmmst_col.index("bkm_arrive")]
             depart = rec[self.sql.bkmmst_col.index("bkm_depart")]
             units = rec[self.sql.bkmmst_col.index("bkm_units")]
@@ -153,10 +183,13 @@
                     continue
             elif depart <= self.start or arrive > self.end:
                 continue
+            books.append(number)
+            self.doRaiseInvoice(number, arrive)
             con = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
                 self.opts["conum"]), ("bkc_ccode", "=", ccode)], limit=1)
-            name = con[self.sql.bkmmst_col.index("bkm_group")]
-            if not name:
+            if group:
+                name = group
+            else:
                 sname = con[self.sql.bkmcon_col.index("bkc_sname")]
                 names = con[self.sql.bkmcon_col.index("bkc_names")]
                 name = "%s %s" % (names.split()[0], sname)
@@ -165,8 +198,8 @@
                 "=", number)], limit=1)
             units = self.sql.getRec(tables="bkmrtt", cols=["brt_udesc",
                 "sum(brt_quant)"], where=[("brt_cono", "=", self.opts["conum"]),
-                ("brt_number", "=", number)], group="brt_utype, brt_ucode",
-                order="brt_utype, brt_ucode")
+                ("brt_number", "=", number)], group="brt_utype, brt_ucode, "\
+                "brt_udesc", order="brt_utype, brt_ucode")
             namq = len(wrap(name, break_long_words=False, width=20))
             untq = 0
             for unit in units:
@@ -208,73 +241,101 @@
                 self.printLine(name, unit[0], unit[1], arr, dep, amt, hh)
                 self.pglin += 1
                 last = number
+        self.opts["mf"].dbm.commitDbase()
         if self.fpdf.page:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=1, rep=pdfnam,
                 view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2])
-        self.opts["mf"].dbm.commitDbase()
+        if self.prtinv:
+            invoices = []
+            books.sort()
+            for number in books:
+                invs = self.sql.getRec("bkmtrn", cols=["bkt_refno"],
+                    where=[("bkt_cono", "=", self.opts["conum"]),
+                    ("bkt_number", "=", number), ("bkt_type", "=", 2)])
+                for inv in invs:
+                    invoices.append(inv[0])
+            PrintBookingInvoice(self.opts["mf"], self.opts["conum"], "I",
+                invoices, tname=self.tname, prtnam=self.df.repprt[0][2])
         self.opts["mf"].closeLoop()
 
-    def doInvoice(self, number):
+    def doRaiseInvoice(self, number, trdt):
         # Raise the Invoice
         incamt = 0
         vatamt = 0
         excamt = 0
-        curdt = self.sysdtw / 100
+        curdt = trdt / 100
         batno = "B%s" % curdt
         gls = {}
-        recs = self.sql.getRec("bkmrtt", where=[("brt_number", "=", number)])
-        for r in recs:
-            tref = self.getRef(number)
-            utyp = r[self.sql.bkmrtt_col.index("brt_utype")]
-            ucod = r[self.sql.bkmrtt_col.index("brt_ucode")]
-            quan = r[self.sql.bkmrtt_col.index("brt_quant")]
-            rate = r[self.sql.bkmrtt_col.index("brt_arate")]
-            days = r[self.sql.bkmrtt_col.index("brt_bdays")]
-            btyp = self.sql.getRec(tables="bkmunt", where=[("but_cono", "=",
-                self.opts["conum"]), ("but_type", "=", utyp)], limit=1)
-            vatc = btyp[self.sql.bkmunt_col.index("but_vatc")]
-            vrte = getVatRate(self.sql, self.opts["conum"], vatc,
-                self.sysdtw)[0]
-            inca = quan * rate * days
+        recs = self.sql.getRec("bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", number),
+            ("brt_invno", "=", 0)])
+        if not recs:
+            return
+        invno = self.getRef(number)
+        for seq, rec in enumerate(recs):
+            utyp = rec[self.sql.bkmrtt_col.index("brt_utype")]
+            ucod = rec[self.sql.bkmrtt_col.index("brt_ucode")]
+            rcod = rec[self.sql.bkmrtt_col.index("brt_rcode")]
+            rbas = rec[self.sql.bkmrtt_col.index("brt_rbase")]
+            quan = rec[self.sql.bkmrtt_col.index("brt_quant")]
+            rate = rec[self.sql.bkmrtt_col.index("brt_arate")]
+            days = rec[self.sql.bkmrtt_col.index("brt_bdays")]
+            umst = self.sql.getRec(tables="bkmunm", where=[("bum_cono", "=",
+                self.opts["conum"]), ("bum_type", "=", utyp), ("bum_code", "=",
+                ucod)], limit=1)
+            vatc = umst[self.sql.bkmunm_col.index("bum_vatc")]
+            if not vatc:
+                vatc = self.ctm_taxdf
+            vrte = getVatRate(self.sql, self.opts["conum"], vatc, trdt)[0]
+            if rbas == "A":
+                inca = float(ASD(quan * days * rate))
+            elif rbas == "B":
+                inca = float(ASD(days * rate))
+            else:
+                inca = rate
             vata = round(inca * vrte / (100 + vrte), 2)
             exca = float(ASD(inca) - ASD(vata))
             incamt = float(ASD(incamt) + ASD(inca))
             vatamt = float(ASD(vatamt) - ASD(vata))
             if self.glint == "Y":
-                slsa = btyp[self.sql.bkmunt_col.index("but_slsa")]
+                slsa = umst[self.sql.bkmunm_col.index("bum_slsa")]
                 if not slsa in gls:
                     gls[slsa] = [0, 0, vatc]
                 gls[slsa][0] = float(ASD(gls[slsa][0]) - ASD(exca))
                 gls[slsa][1] = float(ASD(gls[slsa][1]) - ASD(vata))
-            data = [self.opts["conum"], number, 2, tref, batno, self.sysdtw,
-                inca, vata, curdt, "Booking %s-%s Raised" % (utyp, ucod),
-                vatc, "", self.opts["capnm"], self.sysdtw, 0]
+            data = [self.opts["conum"], number, 2, invno, batno, trdt, inca,
+                vata, curdt, "Booking %s-%s Raised" % (utyp, ucod), vatc, "",
+                self.opts["capnm"], trdt, 0]
             self.sql.insRec("bkmtrn", data=data)
+            self.sql.updRec("bkmrtt", cols=["brt_invno", "brt_invdt",
+                "brt_vrate"], data=[invno, trdt, vrte],
+                where=[("brt_cono", "=", self.opts["conum"]),
+                ("brt_number", "=", number), ("brt_utype", "=", utyp),
+                ("brt_ucode", "=", ucod), ("brt_rcode", "=", rcod)])
             if vata:
                 exc = float(ASD(0) - ASD(exca))
                 vat = float(ASD(0) - ASD(vata))
                 data = [self.opts["conum"], vatc, "O", curdt, "B", 1, batno,
-                    tref, self.sysdtw, number, "Booking %s" % number, exc,
-                    vat, 0, self.opts["capnm"], self.sysdtw, 0]
+                    invno, trdt, number, "Booking %s" % number, exc, vat, 0,
+                    self.opts["capnm"], trdt, 0]
                 self.sql.insRec("ctlvtf", data=data)
         if self.glint == "Y":
-            data = [self.opts["conum"], self.bkmctl, curdt, self.sysdtw, 1,
-                tref, batno, incamt, 0, "Booking %s" % number, "", "", 0,
-                self.opts["capnm"], self.sysdtw, 0]
+            data = [self.opts["conum"], self.bkmctl, curdt, trdt, 1, invno,
+                batno, incamt, 0, "Booking %s" % number, "", "", 0,
+                self.opts["capnm"], trdt, 0]
             self.sql.insRec("gentrn", data=data)
             for acc in gls:
-                data = [self.opts["conum"], acc, curdt, self.sysdtw, 1, tref,
+                data = [self.opts["conum"], acc, curdt, trdt, 1, invno,
                     batno, gls[acc][0], gls[acc][1], "Booking %s" % number,
-                    gls[acc][2], "", 0, self.opts["capnm"], self.sysdtw, 0]
+                    gls[acc][2], "", 0, self.opts["capnm"], trdt, 0]
                 self.sql.insRec("gentrn", data=data)
                 if gls[acc][1]:
-                    data = [self.opts["conum"], self.vatctl, curdt,
-                        self.sysdtw, 1, tref, batno, gls[acc][1], 0,
-                        "Booking %s" % number, "", "", 0, self.opts["capnm"],
-                        self.sysdtw, 0]
+                    data = [self.opts["conum"], self.vatctl, curdt, trdt, 1,
+                        invno, batno, gls[acc][1], 0, "Booking %s" % number,
+                        "", "", 0, self.opts["capnm"], trdt, 0]
                     self.sql.insRec("gentrn", data=data)
 
     def getRef(self, number):

=== modified file 'bkm/bk3040.py'
--- bkm/bk3040.py	2014-10-01 14:07:50 +0000
+++ bkm/bk3040.py	2014-11-12 15:31:19 +0000
@@ -138,11 +138,12 @@
                 vals[5].disp, vals[6].disp))
             self.pglin += 1
         p.closeProgress()
-        self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page:
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         num = CCD(data[0], "UI", 7)

=== modified file 'bkm/bk3050.py'
--- bkm/bk3050.py	2014-10-01 14:07:50 +0000
+++ bkm/bk3050.py	2014-11-04 16:22:59 +0000
@@ -41,7 +41,7 @@
 
     def mainProcess(self):
         self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Print Debtors Labels (%s)" % __name__)
+            "Print Contacts Labels (%s)" % __name__)
         lab = {
             "stype": "C",
             "head": ("Codes",),

=== added file 'bkm/bk3080.py'
--- bkm/bk3080.py	1970-01-01 00:00:00 +0000
+++ bkm/bk3080.py	2014-11-12 15:54:09 +0000
@@ -0,0 +1,322 @@
+#! /usr/bin/env python
+
+"""
+SYNOPSIS
+    Bookings Statements.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2014 Paul Malherbe.
+"""
+
+import time
+from TartanClasses import ASD, CCD, DrawForm, GetCtl, ProgressBar, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import doPrinter, getModName, showError
+from tartanWork import bktrtp
+
+class bk3080:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            if "args" in self.opts:
+                self.tname = self.stpl
+                self.snum = self.opts["args"]
+                self.enum = self.opts["args"]
+                self.doEnd()
+            else:
+                self.mainProcess()
+                self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        gc = GetCtl(self.opts["mf"])
+        bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
+        if not bkmctl:
+            return
+        self.stpl = bkmctl["cbk_statpl"]
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        self.sysdtd = CCD(self.sysdtw, "D1", 10).disp
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bkmcon", "bkmmst",
+            "bkmtrn", "tplmst"], prog=__name__)
+        if self.sql.error:
+            return
+        self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Bookings Statements (%s)" % __name__)
+        return True
+
+    def mainProcess(self):
+        tpm = {
+            "stype": "R",
+            "tables": ("tplmst",),
+            "cols": (
+                ("tpm_tname", "", 0, "Template"),
+                ("tpm_title", "", 0, "Title", "Y")),
+            "where": [
+                ("tpm_type", "=", "S"),
+                ("tpm_system", "=", "BKM")],
+            "order": "tpm_tname"}
+        bkm = {
+            "stype": "R",
+            "tables": ("bkmmst", "bkmcon"),
+            "cols": (
+                ("bkm_number", "", 0, "Booking"),
+                ("bkc_sname", "", 0, "Surname", "Y"),
+                ("bkc_names", "", 0, "Names", "F")),
+            "where": (
+                ("bkm_cono", "=", self.opts["conum"]),
+                ("bkm_state", "<>", "X"),
+                ("bkc_cono=bkm_cono",),
+                ("bkc_ccode=bkm_ccode",))}
+        r1s = (("Yes","Y"), ("Range","R"))
+        r2s = (("Number","N"),("Name","M"),("Postal Code","P"))
+        fld = (
+            (("T",0,0,0),"INA",20,"Template Name","",
+                self.stpl,"Y",self.doTplNam,tpm,None,None),
+            (("T",0,1,0),("IRB",r1s),0,"Whole File","",
+                "Y","N",self.doWhole,None,None,None),
+            (("T",0,2,0),"IUI",7,"From Booking","",
+                "","N",self.doAcc,bkm,None,None),
+            (("T",0,3,0),"IUI",7,"To Booking","",
+                "","N",self.doAcc,bkm,None,None))
+        tnd = ((self.doEnd,"Y"), )
+        txt = (self.doExit, )
+        self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
+            tend=tnd, txit=txt, view=("N","V"), mail=("N","Y"))
+
+    def doTplNam(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
+            ("tpm_type", "=", "S"), ("tpm_system", "=", "BKM")], limit=1)
+        if not acc:
+            return "Invalid Template Name"
+        self.tname = w
+
+    def doWhole(self, frt, pag, r, c, p, i, w):
+        self.whole = w
+        if self.whole in ("Y", "S"):
+            self.snum = 0
+            self.enum = 0
+            self.df.loadEntry("T", 0, p+1, data="")
+            self.df.loadEntry("T", 0, p+2, data="")
+            return "sk2"
+
+    def doAcc(self, frt, pag, r, c, p, i, w):
+        if p == 2:
+            self.snum = w
+        else:
+            self.enum = w
+        chk = self.sql.getRec(tables="bkmmst", where=[("bkm_cono", "=",
+            self.opts["conum"]), ("bkm_number", "=", w)], limit=1)
+        if not chk:
+            return "Invalid Booking Number"
+        if p == 2:
+            self.df.loadEntry(frt, pag, p+1, data=self.snum)
+
+    def doEnd(self):
+        if "args" in self.opts:
+            self.prtnam = "view"
+            self.email = "N"
+            self.printm = "Y"
+        else:
+            self.df.closeProcess()
+            self.prtnam = self.df.repprt[0][2]
+            self.email = self.df.repprt[1][1]
+            self.printm = self.df.repprt[1][3]
+        if not self.enum:
+            self.enum = 9999999
+        whr = [
+            ("bkm_cono", "=", self.opts["conum"]),
+            ("bkm_number", ">=", self.snum),
+            ("bkm_number", "<=", self.enum),
+            ("bkm_state", "<>", "X")]
+        odr = "bkm_number"
+        recs = self.sql.getRec(tables="bkmmst", where=whr, order=odr)
+        if not recs:
+            showError(self.opts["mf"].body, "Error",
+                "No Bookings Selected")
+        else:
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.doLoadStatic()
+            self.form.doNewDetail()
+            p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+            for num, rec in enumerate(recs):
+                can = p.displayProgress(num)
+                if can == "yes":
+                    break
+                self.doProcess(rec)
+            p.closeProgress()
+            if self.email == "N" and self.form.page:
+                self.doPrint()
+        if not "args" in self.opts:
+            self.opts["mf"].closeLoop()
+
+    def doLoadStatic(self):
+        cmc = self.sql.ctlmst_col
+        ctm = self.sql.getRec(tables="ctlmst", where=[("ctm_cono", "=",
+            self.opts["conum"])], limit=1)
+        for fld in cmc:
+            dat = ctm[cmc.index(fld)]
+            if fld in self.form.tptp:
+                if fld == "ctm_logo":
+                    self.form.letterhead(cmc, ctm, fld, dat)
+                    continue
+                self.form.tptp[fld][1] = dat
+        if "letterhead" in self.form.tptp:
+            self.form.letterhead(cmc, ctm, "letterhead", None)
+        self.form.document_date(self.sysdtd)
+        self.form.bank_details(cmc, ctm, 0)
+
+    def doProcess(self, bkm):
+        bmc = self.sql.bkmmst_col
+        ccc = self.sql.bkmcon_col
+        btc = self.sql.bkmtrn_col
+        tdc = self.form.sql.tpldet_col
+        self.num = bkm[bmc.index("bkm_number")]
+        self.cod = bkm[bmc.index("bkm_ccode")]
+        con = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
+            self.opts["conum"]), ("bkc_ccode", "=", self.cod)], limit=1)
+        if "contact_details" in self.form.tptp:
+            dat = "%s %s %s" % (
+                con[ccc.index("bkc_title")],
+                con[ccc.index("bkc_names")],
+                con[ccc.index("bkc_sname")])
+            dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr1")])
+            dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr2")])
+            dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr3")])
+            dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_pcode")])
+            self.form.newdic["contact_details_C00"][tdc.index("tpd_text")] = dat
+        for col in bmc:
+            d = "%s_C00" % col
+            if d in self.form.newdic:
+                dat = bkm[bmc.index(col)]
+                self.form.newdic[d][tdc.index("tpd_text")] = dat
+        bkt = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
+            self.opts["conum"]), ("bkt_number", "=", self.num)],
+            order="bkt_date, bkt_refno")
+        if not bkt:
+            return
+        self.doBody(btc, bkt, tdc)
+        self.doTotal(tdc)
+        self.doTail(tdc)
+        if self.email == "Y":
+            self.doPrint()
+
+    def doPrint(self):
+        if self.email == "Y":
+            key = "%s_%s" % (self.opts["conum"], self.num)
+        else:
+            key = "%s_all" % self.opts["conum"]
+        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, key,
+            ext="pdf")
+        if self.prtnam == "view":
+            view = "Y"
+        else:
+            view = "N"
+        if self.email == "N" or not self.eml:
+            mail = "N"
+        else:
+            mail = self.eml
+        self.form.output(pdfnam, "F")
+        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+            head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
+            printm=self.printm)
+        if self.email == "Y":
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.doLoadStatic()
+            self.form.doNewDetail()
+
+    def doBody(self, btc, bkt, tdc):
+        page = 0
+        count = 0
+        self.tbal = 0
+        text = tdc.index("tpd_text")
+        for trans in bkt:
+            if not count:
+                page += 1
+                count = self.doHeader(page)
+            if count == self.form.maxlines:
+                page = self.doCfwd(page)
+                count = self.doHeader(page)
+            for cod in self.form.body:
+                if cod == "type_code":
+                    c = "bkt_type"
+                elif cod == "line_paid":
+                    c = "paid"
+                elif cod == "line_balance":
+                    c = "balance"
+                else:
+                    c = cod
+                d = "%s_C%02i" % (cod, count)
+                if cod == "type_code":
+                    ttyp = trans[btc.index(c)]
+                    self.form.newdic[d][text] = bktrtp[ttyp - 1][0]
+                else:
+                    self.form.newdic[d][text] = trans[btc.index(c)]
+                self.form.doDrawDetail(self.form.newdic[d])
+            tramt = trans[btc.index("bkt_tramt")]
+            self.tbal = float(ASD(self.tbal) + ASD(tramt))
+            count += 1
+        for x in xrange(count, self.form.maxlines):
+            for cod in self.form.body:
+                d = "%s_C%02i" % (cod, x)
+                self.form.newdic[d][tdc.index("tpd_text")] = "BLANK"
+                self.form.doDrawDetail(self.form.newdic[d])
+
+    def doHeader(self, page):
+        self.form.add_page()
+        tdc = self.form.sql.tpldet_col
+        for key in self.form.newkey:
+            nl = self.form.newdic[key][:]
+            if not nl[tdc.index("tpd_place")] == "A":
+                continue
+            if nl[tdc.index("tpd_detseq")] == "bkm_number_C00":
+                nl[tdc.index("tpd_text")] = self.num
+            elif nl[tdc.index("tpd_detseq")] == "page_number_C00":
+                nl[tdc.index("tpd_text")] = str(page)
+            self.form.doDrawDetail(nl)
+        return 0
+
+    def doCfwd(self, page):
+        if "carried_forward" in self.form.tptp:
+            tdc = self.form.sql.tpldet_col
+            line = self.form.cfwd[:]
+            line[tdc.index("tpd_text")] = "Continued on Page %i" % (page + 1)
+            self.form.doDrawDetail(line)
+        return page + 1
+
+    def doTotal(self, tdc):
+        for c in self.form.total:
+            if not c == "total_balance":
+                continue
+            t = "%s_T00" % c
+            if c in self.form.newdic:
+                self.form.doDrawDetail(self.form.newdic[c])
+            elif t in self.form.newdic:
+                self.form.doDrawDetail(self.form.newdic[t])
+            d = "%s_C00" % c
+            if d in self.form.newdic:
+                line = self.form.newdic[d]
+                line[tdc.index("tpd_text")] = self.tbal
+                self.form.doDrawDetail(line)
+
+    def doTail(self, tdc):
+        for c in self.form.tail:
+            t = "%s_T00" % c
+            if c in self.form.newdic:
+                self.form.doDrawDetail(self.form.newdic[c])
+            elif t in self.form.newdic:
+                self.form.doDrawDetail(self.form.newdic[t])
+            d = "%s_C00" % c
+            if d in self.form.newdic:
+                self.form.doDrawDetail(self.form.newdic[d])
+
+    def doExit(self):
+        self.df.closeProcess()
+        if not "args" in self.opts:
+            self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'bkm/bk3090.py'
--- bkm/bk3090.py	1970-01-01 00:00:00 +0000
+++ bkm/bk3090.py	2014-12-01 10:35:41 +0000
@@ -0,0 +1,165 @@
+#! /usr/bin/python2
+
+"""
+SYNOPSIS
+    Reprinting of Booking Invoices.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2014 Paul Malherbe.
+"""
+
+from TartanClasses import PrintBookingInvoice, Sql, TartanDialog
+from tartanFunctions import getSingleRecords
+
+class bk3090:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, ["bkmctl", "bkmmst", "bkmcon",
+            "bkmtrn", "tplmst"], prog=__name__)
+        if self.sql.error:
+            return
+        ctl = self.sql.getRec(tables="bkmctl", where=[("cbk_cono", "=",
+            self.opts["conum"])], limit=1)
+        if not ctl:
+            self.tplnam = "booking_invoice"
+        else:
+            self.tplnam = ctl[self.sql.bkmctl_col.index("cbk_invtpl")]
+        return True
+
+    def mainProcess(self):
+        tit = ("Reprint Invoices",)
+        tpm = {
+            "stype": "R",
+            "tables": ("tplmst",),
+            "cols": (
+                ("tpm_tname", "", 0, "Template"),
+                ("tpm_title", "", 0, "Title", "Y")),
+            "where": [
+                ("tpm_type", "=", "I"),
+                ("tpm_system", "=", "BKM")],
+            "order": "tpm_tname"}
+        self.trn = {
+            "stype": "R",
+            "tables": ("bkmtrn", "bkmmst", "bkmcon"),
+            "cols": [
+                ("bkt_refno", "",  0, "Invoice-N"),
+                ("bkt_date", "",  0, "Invoice-Dt"),
+                ("bkt_number",  "", 0, "Booking"),
+                ("bkc_sname",  "", 0, "Surname", "Y"),
+                ("bkc_names",  "", 0, "Names", "F")],
+            "where": [
+                ("bkt_cono", "=", self.opts["conum"]),
+                ("bkt_type", "=", 2),
+                ("bkm_cono=bkt_cono",),
+                ("bkm_number=bkt_number",),
+                ("bkc_cono=bkt_cono",),
+                ("bkc_ccode=bkm_ccode",)],
+            "group": "bkt_refno",
+            "screen": self.opts["mf"].body}
+        r1s = (("Copies", "C"), ("Originals", "O"))
+        r2s = (
+            ("Inv","I"),
+            ("C-N","C"))
+        r3s = (("Range","R"),("Singles", "S"))
+        fld = (
+            (("T",0,0,0),"INA",20,"Template Name","",
+                self.tplnam,"N",self.doTplNam,tpm,None,None),
+            (("T",0,1,0),("IRB",r1s),0,"Document Mode","",
+                "C","N",self.doMode,None,None,None),
+            (("T",0,2,0),("IRB",r3s),0,"Documents","",
+                "S","Y",self.doSelect,None,None,None),
+            (("T",0,3,0),"INa",9,"From Number","From Document Number",
+                "","N",self.doDocno,self.trn,None,("notzero",)),
+            [("T",0,4,0),"INa",9,"To   Number","To Document Number",
+                "","N",self.doDocno,self.trn,None,("notzero",)])
+        self.df = TartanDialog(self.opts["mf"], screen=self.opts["mf"].body,
+            title=tit, eflds=fld, tend=((self.doEnd, "y"),),
+            txit=(self.doExit,), view=("N","V"), mail=("B","N"))
+
+    def doTplNam(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
+            ("tpm_type", "=", "I"), ("tpm_system", "=", "BKM")], limit=1)
+        if not acc:
+            return "Invalid Template Name"
+        self.tname = w
+
+    def doMode(self, frt, pag, r, c, p, i, w):
+        if w == "C":
+            self.copy = "y"
+        else:
+            self.copy = "n"
+            self.df.topf[pag][6][5] = "V"
+            if len(self.df.topf[pag]) == 8:
+                self.df.topf[pag][8][5] = "N"
+
+    def doSelect(self, frt, pag, r, c, p, i, w):
+        self.select = w
+        if self.select == "S":
+            self.frm = 0
+            self.to = 0
+            return "sk2"
+
+    def doDocno(self, frt, pag, r, c, p, i, w):
+        if w:
+            doc = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
+                self.opts["conum"]), ("bkt_type", "=", 2), ("bkt_refno",
+                "=", w)])
+            if not doc:
+                return "Document Number Does Not Exist"
+        if p == 3:
+            self.frm = w
+            self.df.topf[pag][4][5] = self.frm
+        elif w < self.frm:
+            return "Document Number Before From Number"
+        else:
+            self.to = w
+
+    def doEnd(self):
+        self.df.closeProcess()
+        prt = self.df.repprt[0][2]
+        eml = self.df.repprt[1][1:3]
+        tab = ["bkmtrn", "bkmmst", "bkmcon"]
+        col = ["bkt_refno", "bkt_date", "bkc_sname", "bkc_names"]
+        dic = {}
+        for c in col:
+            for t in tab:
+                exec "d = self.sql.%s_dic" % t
+                if c in d:
+                    dic[c] = d[c]
+        if self.select == "S":
+            recs = self.sql.getRec(tables=tab, cols=col, where=[("bkt_cono",
+                "=", self.opts["conum"]), ("bkt_type", "=", 2),
+                ("bkm_cono=bkt_cono",), ("bkm_number=bkt_number",),
+                ("bkc_cono=bkt_cono",), ("bkc_ccode=bkm_ccode",)],
+                group="bkt_refno, bkt_date, bkc_sname, bkc_names")
+            recs = getSingleRecords(self.opts["mf"], tab, col, dic=dic,
+                where=recs, ttype="D")
+        else:
+            recs = self.sql.getRec(tables="bkmtrn", cols=["bkt_refno"],
+                where=[("bkt_cono", "=", self.opts["conum"]),
+                ("bkt_type", "=", 2), ("bkt_refno", ">=", self.frm),
+                ("bkt_refno", "<=", self.to)])
+        doc = []
+        if recs:
+            for rec in recs:
+                doc.append(rec[0])
+        if doc:
+            PrintBookingInvoice(self.opts["mf"], self.opts["conum"], "I",
+                doc, prtnam=prt, tname=self.tname, email=eml, copy=self.copy)
+        self.opts["mf"].closeLoop()
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'bkm/bk3100.py'
--- bkm/bk3100.py	1970-01-01 00:00:00 +0000
+++ bkm/bk3100.py	2014-12-04 12:38:52 +0000
@@ -0,0 +1,110 @@
+#! /usr/bin/python
+
+"""
+SYNOPSIS
+    Bookings's Occupancy by Status Summary.
+
+    This file is part of Tartan Financial Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2014 Paul Malherbe.
+"""
+
+from TartanClasses import CreateChart, TartanDialog, Sql
+from tartanFunctions import dateDiff, mthendDate
+
+class bk3100:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, "memsta", prog=__name__)
+        if self.sql.error:
+            return
+        self.desc = {
+            "Q": ["Query",0,0,0,0,0,0,0,0,0,0,0,0],
+            "S": ["Settled",0,0,0,0,0,0,0,0,0,0,0,0],
+            "C": ["Confirmed",0,0,0,0,0,0,0,0,0,0,0,0],
+            "X": ["Cancelled",0,0,0,0,0,0,0,0,0,0,0,0],
+            "T": ["QSC Total",0,0,0,0,0,0,0,0,0,0,0,0]}
+        return True
+
+    def mainProcess(self):
+        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Bookings's Occupancy by Status Summary")
+        fld = (
+            (("T",0,0,0),"ID2",7,"Starting Period","",
+                "","N",self.doStartPer,None,None,None),
+            (("T",0,1,0),"ID2",7,"Ending   Period","",
+                "","N",self.doEndPer,None,None,None))
+        tnd = ((self.doEnd,"y"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
+            eflds=fld, tend=tnd, txit=txt)
+
+    def doStartPer(self, frt, pag, r, c, p, i, w):
+        self.sdate = (w * 100) + 1
+        y = w / 100
+        m = (w % 100) + 11
+        if m > 12:
+            y += 1
+            m -= 12
+        self.df.loadEntry(frt, pag, p+1, ((y * 100) + m))
+
+    def doEndPer(self, frt, pag, r, c, p, i, w):
+        self.edate = mthendDate((w * 100) + 1)
+        if dateDiff(self.sdate, self.edate, "months") > 11:
+            return "More than 12 month period"
+
+    def doEnd(self):
+        self.df.closeProcess()
+        rec = self.sql.getRec(tables="bkmmst", cols=["bkm_state", "bkm_guests",
+            "bkm_arrive", "bkm_depart"], where=[("bkm_btype", "=", "A"),
+            ("bkm_arrive", "between", self.sdate, self.edate, "or",
+            "bkm_depart", "between", self.sdate, self.edate)])
+        num = 1
+        lookup = {}
+        mth = (self.sdate / 100) % 100
+        end = (self.edate / 100) % 100
+        lookup[mth] = num
+        while not mth == end:
+            mth += 1
+            if mth > 12:
+                mth = 1
+            num += 1
+            lookup[mth] = num
+        for r in rec:
+            if r[2] / 100 == r[3] / 100:
+                days = dateDiff(r[2], r[3], "days")
+                mth = (r[2] / 100) % 100
+                self.desc[r[0]][lookup[mth]] += (days * r[1])
+                self.desc["T"][lookup[mth]] += (days * r[1])
+            else:
+                mnd = mthendDate(r[2])
+                days = dateDiff(r[2], mnd, "days")
+                mth = (r[2] / 100) % 100
+                self.desc[r[0]][lookup[mth]] += (days * r[1])
+                self.desc["T"][lookup[mth]] += (days * r[1])
+                mth = (r[3] / 100) % 100
+                days = dateDiff((((r[3]/100)*100)+1), r[3], "days")
+                self.desc[r[0]][lookup[mth]] += (days * r[1])
+                self.desc["T"][lookup[mth]] += (days * r[1])
+        achart = []
+        for s in self.desc:
+            achart.append([s] + self.desc[s])
+        CreateChart(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+            [self.sdate/100, self.edate/100], [[self.opts["conam"],
+            "Status Summary"], "Beds"], achart, achart)
+        self.opts["mf"].closeLoop()
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bkm/bkc110.py'
--- bkm/bkc110.py	2014-06-14 08:55:57 +0000
+++ bkm/bkc110.py	2014-11-22 07:13:30 +0000
@@ -32,7 +32,8 @@
             self.opts["conum"])], limit=1)
         if not self.acc:
             self.new = True
-            self.acc = [self.opts["conum"], "N", "booking_form"]
+            self.acc = [self.opts["conum"], "N", "booking_form",
+                "booking_invoice", "booking_statement", ""]
         else:
             self.new = False
         return True
@@ -40,7 +41,7 @@
     def drawDialog(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
                 "Bookings Control File Maintenance (%s)" % __name__)
-        tpm = {
+        tpb = {
             "stype": "R",
             "tables": ("tplmst",),
             "cols": (
@@ -51,12 +52,43 @@
                 ("tpm_type", "=", "B"),
                 ("tpm_system", "=", "BKM")],
             "order": "tpm_tname"}
+        tpi = {
+            "stype": "R",
+            "tables": ("tplmst",),
+            "cols": (
+                ("tpm_tname", "", 0, "Template"),
+                ("tpm_title", "", 0, "Title"),
+                ("tpm_type", "", 0, "T")),
+            "where": [
+                ("tpm_type", "=", "I"),
+                ("tpm_system", "=", "BKM")],
+            "order": "tpm_tname"}
+        tps = {
+            "stype": "R",
+            "tables": ("tplmst",),
+            "cols": (
+                ("tpm_tname", "", 0, "Template"),
+                ("tpm_title", "", 0, "Title"),
+                ("tpm_type", "", 0, "T")),
+            "where": [
+                ("tpm_type", "=", "S"),
+                ("tpm_system", "=", "BKM")],
+            "order": "tpm_tname"}
+        trm = {
+            "stype": "F",
+            "types": "fle"}
         r1s = (("Yes","Y"),("No","N"))
         self.fld = (
             (("T",0,0,0),("IRB",r1s),0,"G/L Integration","",
                 self.acc[1],"N",None,None,None,None),
             (("T",0,1,0),"INA",20,"Booking Template","",
-                self.acc[2],"N",self.doTplNam,tpm,None,None))
+                self.acc[2],"N",self.doBkgTpl,tpb,None,None),
+            (("T",0,2,0),"INA",20,"Invoice Template","",
+                self.acc[3],"N",self.doInvTpl,tpi,None,None),
+            (("T",0,3,0),"INA",20,"Statement Template","",
+                self.acc[4],"N",self.doStaTpl,tps,None,None),
+            (("T",0,4,0),"ITX",50,"Terms and Conditions","",
+                self.acc[5],"N",None,trm,None,("fle","blank")))
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -66,12 +98,24 @@
             for n, f in enumerate(self.acc[1:]):
                 self.df.loadEntry("T", 0, n, data=f)
 
-    def doTplNam(self, frt, pag, r, c, p, i, w):
+    def doBkgTpl(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
             ("tpm_type", "=", "B"), ("tpm_system", "=", "BKM")], limit=1)
         if not acc:
             return "Invalid Template Name"
 
+    def doInvTpl(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
+            ("tpm_type", "=", "I"), ("tpm_system", "=", "BKM")], limit=1)
+        if not acc:
+            return "Invalid Template Name"
+
+    def doStaTpl(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
+            ("tpm_type", "=", "S"), ("tpm_system", "=", "BKM")], limit=1)
+        if not acc:
+            return "Invalid Template Name"
+
     def doEnd(self):
         data = [self.opts["conum"]]
         for x in xrange(0, len(self.df.t_work[0][0])):

=== modified file 'bkm/bkc210.py'
--- bkm/bkc210.py	2014-08-06 15:44:15 +0000
+++ bkm/bkc210.py	2014-11-09 12:19:37 +0000
@@ -2,7 +2,7 @@
 
 """
 SYNOPSIS
-    Bookings Unit Types File Maintenance.
+    Bookings Unit File Maintenance.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -13,18 +13,19 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
+import time
 from TartanClasses import GetCtl, Sql, TartanDialog
 
 class bkc210:
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
-            self.mainProcess()
+            self.drawDialog()
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "genmst", "bkmunm",
-            "bkmunt"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "genmst", "bkmmst",
+            "bkmunm"], prog=__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -34,16 +35,24 @@
         self.glint = bkmctl["cbk_glint"]
         return True
 
-    def mainProcess(self):
+    def drawDialog(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-                "Unit Types File Maintenance (%s)" % __name__)
-        typ = {
+            "Booking Units File Maintenance (%s)" % __name__)
+        unm = {
             "stype": "R",
-            "tables": ("bkmunt",),
-            "cols": (
-                ("but_type", "", 0, "T"),
-                ("but_desc", "", 0, "Description", "Y")),
-            "where": [("but_cono", "=", self.opts["conum"])]}
+            "tables": ("bkmunm",),
+            "cols": [
+                ("bum_code", "", 0, "Code"),
+                ("bum_desc", "", 0, "Description"),
+                ("bum_multi", "", 0, "M"),
+                ("bum_guests", "", 0, "Qty"),
+                ("bum_vatc", "", 0, "V")],
+            "where": [
+                ("bum_cono", "=", self.opts["conum"])],
+            "whera": (("T", "bum_type", 0, 0),),
+            "order": "bum_type, bum_code"}
+        if self.glint == "Y":
+            unm["cols"].append(("bum_slsa", "", 0, "Acc-Num"))
         vtm = {
             "stype": "R",
             "tables": ("ctlvmf",),
@@ -58,43 +67,59 @@
                 ("glm_acno", "", 0, "Acc-Num"),
                 ("glm_desc", "", 0, "Description", "Y")),
             "where": [("glm_cono", "=", self.opts["conum"])]}
+        r1s = (("Accomodation","A"), ("Other","O"))
+        r2s = (("Yes","Y"), ("No","N"))
         self.fld = [
-            (("T",0,0,0),"IUA",1,"Unit Type","",
-                "","N",self.doType,typ,None,("notblank",)),
-            (("T",0,1,0),"INA",30,"Description","",
+            (("T",0,0,0),("IRB",r1s),0,"Type","",
+                "A","N",self.doType,None,None,None),
+            (("T",0,1,0),"IUA",6,"Code","",
+                "","N",self.doCode,unm,None,("notblank",)),
+            (("T",0,2,0),"ITX",30,"Description","",
                 "","N",None,None,self.doDelete,("notblank",)),
-            (("T",0,2,0),"IUA",1,"Vat Code","",
+            (("T",0,3,0),("IRB",r2s),0,"Multiple","Multiple Bookings Allowed",
+                "N","N",None,None,None,None),
+            (("T",0,4,0),"IUA",3,"Capacity","",
+                "","N",None,None,None,("notzero",)),
+            (("T",0,5,0),"IUA",1,"Vat Code","",
                 "","N",self.doVat,vtm,None,("notblank",))]
         if self.glint == "Y":
-            self.fld.append((("T",0,3,0),"IUI",7,"Sales Account",
+            self.fld.append((("T",0,6,0),"IUI",7,"Sales Account",
                 "Sales Account","","N",self.doSales,glm,None,("notzero",)))
-            self.fld.append((("T",0,3,0),"ONA",30,""))
-        but = (
-            ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
-            ("Cancel",None,self.doCancel,0,("T",0,2),("T",0,0)))
-        tnd = ((self.doEnd,"Y"), )
-        txt = (self.doCloseProcess, )
+            self.fld.append((("T",0,6,0),"ONA",30,""))
+        but = (("Quit",None,self.doExit,1,None,None),)
+        tnd = ((self.doEnd,"Y"),)
+        txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=self.fld,
             butt=but, tend=tnd, txit=txt)
 
     def doType(self, frt, pag, r, c, p, i, w):
         self.utyp = w
-        acc = self.sql.getRec(tables="bkmunt", where=[("but_cono", "=",
-            self.opts["conum"]), ("but_type", "=", self.utyp)], limit=1)
+
+    def doCode(self, frt, pag, r, c, p, i, w):
+        self.ucod = w
+        acc = self.sql.getRec(tables="bkmunm", where=[("bum_cono",
+            "=", self.opts["conum"]), ("bum_type", "=", self.utyp),
+            ("bum_code", "=", self.ucod)], limit=1)
         if not acc:
-            self.new = "Y"
+            self.new = True
         else:
-            self.new = "N"
-            col = self.sql.bkmunt_col
-            self.df.loadEntry(frt, pag, p+1,data=acc[col.index("but_desc")])
-            self.df.loadEntry(frt, pag, p+2,data=acc[col.index("but_vatc")])
+            self.new = False
+            des = acc[self.sql.bkmunm_col.index("bum_desc")]
+            mul = acc[self.sql.bkmunm_col.index("bum_multi")]
+            qty = acc[self.sql.bkmunm_col.index("bum_guests")]
+            cod = acc[self.sql.bkmunm_col.index("bum_vatc")]
+            sls = acc[self.sql.bkmunm_col.index("bum_slsa")]
+            self.df.loadEntry(frt, pag, p+1, data=des)
+            self.df.loadEntry(frt, pag, p+2, data=mul)
+            self.df.loadEntry(frt, pag, p+3, data=qty)
+            self.df.loadEntry(frt, pag, p+4, data=cod)
             if self.glint == "Y":
-                self.df.loadEntry(frt,pag,p+3,data=acc[col.index("but_slsa")])
-                des = self.getGenDesc(acc[col.index("but_slsa")])
+                self.df.loadEntry(frt, pag, p+5,data=sls)
+                des = self.getGenDesc(sls)
                 if not des:
-                    self.df.loadEntry(frt,pag,p+4,data="Invalid Sales Code")
+                    self.df.loadEntry(frt,pag,p+6,data="Invalid Sales Code")
                 else:
-                    self.df.loadEntry(frt,pag,p+4,data=des[0])
+                    self.df.loadEntry(frt,pag,p+6,data=des[0])
 
     def doVat(self, frt, pag, r, c, p, i, w):
         vat = self.sql.getRec(tables="ctlvmf", cols=["vtm_desc"],
@@ -102,60 +127,51 @@
             w)], limit=1)
         if not vat:
             return "Invalid VAT Code"
-        self.code = w
 
     def doSales(self, frt, pag, r, c, p, i, w):
         acc = self.getGenDesc(w)
         if not acc:
             return "Invalid Sales Code"
         self.sales = w
-        self.df.loadEntry("T", 0, 4, data=acc[0])
+        self.df.loadEntry("T", 0, p+1, data=acc[0])
+
+    def getGenDesc(self, acno):
+        return self.sql.getRec(tables="genmst", cols=["glm_desc"],
+            where=[("glm_cono", "=", self.opts["conum"]),
+            ("glm_acno", "=", acno)], limit=1)
 
     def doDelete(self):
-        st1 = self.sql.getRec(tables="bkmunm", cols=["count(*)"],
-            where=[("bum_cono", "=", self.opts["conum"]), ("bum_type", "=",
-            self.utyp)], limit=1)
-        if st1[0]:
-            return "Records Exist for this Type, Not Deleted"
-        self.sql.delRec("bkmunt", where=[("but_cono", "=", self.opts["conum"]),
-            ("but_type", "=", self.utyp)])
+        chk = self.sql.getRec(tables="bkmmst", cols=["bkm_units"],
+            where=[("bkm_cono", "=", self.opts["conum"])])
+        for bkm in chk:
+            unt = bkm[0].split(":")
+            for un in unt:
+                u = un.split(",")
+                if u[0] == self.utyp and u[1] == self.ucod:
+                    return "Unit Used, Not Deleted"
+        self.sql.delRec("bkmunm", where=[("bum_cono", "=", self.opts["conum"]),
+            ("bum_type", "=", self.utyp), ("bum_code", "=", self.ucod)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
     def doEnd(self):
         data = [self.opts["conum"]]
         for x in xrange(0, len(self.df.t_work[0][0])):
-            if self.glint == "Y" and x == 4:
+            if self.glint == "Y" and x == 7:
                 continue
             data.append(self.df.t_work[0][0][x])
-            if self.glint == "N" and x == 2:
-                data.append(0)
-                data.append(0)
-        if self.new == "Y":
-            self.sql.insRec("bkmunt", data=data)
+        if self.glint == "N":
+            data.append(0)
+        if self.new:
+            self.sql.insRec("bkmunm", data=data)
         else:
-            self.sql.updRec("bkmunt", data=data, where=[("but_cono", "=",
-            self.opts["conum"]), ("but_type", "=", self.utyp)])
+            self.sql.updRec("bkmunm", data=data, where=[("bum_cono", "=",
+                self.opts["conum"]), ("bum_type", "=", self.utyp),
+                ("bum_code", "=", self.ucod)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
-    def doAccept(self, widget=None):
-        frt, pag, col, mes = self.df.doCheckFields()
-        if mes:
-            self.df.focusField(frt, pag, (col+1), err=mes)
-        else:
-            self.df.doEndFrame("T", 0, cnf="N")
-
-    def getGenDesc(self, acno):
-        return self.sql.getRec(tables="genmst", cols=["glm_desc"],
-            where=[("glm_cono", "=", self.opts["conum"]), ("glm_acno", "=",
-            acno)], limit=1)
-
-    def doCancel(self, widget=None):
-        self.opts["mf"].dbm.rollbackDbase()
-        self.df.focusField("T", 0, 1)
-
-    def doCloseProcess(self):
+    def doExit(self, widget=None):
         self.df.closeProcess()
         self.opts["mf"].closeLoop()
 

=== modified file 'bkm/bkc310.py'
--- bkm/bkc310.py	2014-08-06 15:44:15 +0000
+++ bkm/bkc310.py	2014-12-02 11:50:48 +0000
@@ -2,7 +2,7 @@
 
 """
 SYNOPSIS
-    Bookings Unit File Maintenance.
+    Bookings Rate Records Maintenance.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -24,7 +24,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bkmunt", "bkmmst", "bkmunm"],
+        self.sql = Sql(self.opts["mf"].dbm, ["bkmrtm", "bkmrtr", "bkmrtt"],
             prog=__name__)
         if self.sql.error:
             return
@@ -32,37 +32,47 @@
 
     def drawDialog(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Booking Units File Maintenance (%s)" % __name__)
-        unt = {
-            "stype": "R",
-            "tables": ("bkmunt",),
-            "cols": (
-                ("but_type", "", 0, "T"),
-                ("but_desc", "", 0, "Description")),
-            "where": [
-                ("but_cono", "=", self.opts["conum"])],
-            "order": "but_type"}
-        unm = {
-            "stype": "R",
-            "tables": ("bkmunm",),
-            "cols": (
-                ("bum_code", "", 0, "Code"),
-                ("bum_desc", "", 0, "Description"),
-                ("bum_guests", "", 0, "Qty")),
-            "where": [
-                ("bum_cono", "=", self.opts["conum"])],
-            "whera": (("T", "bum_type", 0, 0),),
-            "order": "bum_type, bum_code"}
+                "Booking Rate Records Maintenance (%s)" % __name__)
+        brm = {
+            "stype": "R",
+            "tables": ("bkmrtm",),
+            "cols": (
+                ("brm_code", "", 0, "Code"),
+                ("brm_desc", "", 0, "Description"),
+                ("brm_base", "", 0, "B")),
+            "where": [("brm_cono", "=", self.opts["conum"])],
+            "whera": [("T", "brm_type", 0, 0)],
+            "order": "brm_code"}
+        brr = {
+            "stype": "R",
+            "tables": ("bkmrtr",),
+            "cols": (
+                ("brr_date", "", 0, "Start-Date"),
+                ("brr_rate", "", 0, "Rte-Amount")),
+            "where": [("brr_cono", "=", self.opts["conum"])],
+            "whera": [("T", "brr_type", 0, 0), ("T", "brr_code", 1, 0)],
+            "order": "brr_date"}
+        r1s = (
+            ("Accomodation","A"),
+            ("Other","O"))
+        r2s = (
+            ("/Unit/Person/Day","A"),
+            ("/Unit/Person","B"),
+            ("/Unit/Day","C"),
+            ("/Unit","D"))
         self.fld = (
-            (("T",0,0,0),"IUA",1,"Type","",
-                "A","N",self.doType,unt,None,None),
-            (("T",0,0,0),"ONA",30,""),
-            (("T",0,1,0),"IUA",6,"Code","",
-                "","N",self.doCode,unm,None,("notblank",)),
+            (("T",0,0,0),("IRB",r1s),0,"Unit Type","",
+                "A","N",self.doType,None,None,None),
+            (("T",0,1,0),"IUI",3,"Code","",
+                "","N",self.doCode,brm,None,None),
             (("T",0,2,0),"ITX",30,"Description","",
                 "","N",None,None,self.doDelete,("notblank",)),
-            (("T",0,3,0),"IUA",3,"Capacity","",
-                "","N",None,None,None,("notzero",)))
+            (("T",0,3,0),("IRB",r2s),0,"Rate Base","",
+                "A","N",self.doBase,None,None,None),
+            (("T",0,4,0),"Id1",10.2,"Starting Date","",
+                0,"N",self.doExpd,brr,None,("efld",)),
+            (("T",0,5,0),"IUD",10.2,"Rate Amount","",
+                0,"N",self.doRate,None,None,("efld",)))
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -70,54 +80,78 @@
             butt=but, tend=tnd, txit=txt)
 
     def doType(self, frt, pag, r, c, p, i, w):
-        rec = self.sql.getRec(tables="bkmunt", cols=["but_desc"],
-            where=[("but_cono", "=", self.opts["conum"]),
-            ("but_type", "=", w)], limit=1)
-        if not rec:
-            return "Invalid Type Code"
-        self.utyp = w
-        self.df.loadEntry(frt, pag, p+1, data=rec[0])
+        self.rtype = w
 
     def doCode(self, frt, pag, r, c, p, i, w):
-        self.code = w
-        acc = self.sql.getRec(tables="bkmunm", where=[("bum_cono", "=",
-            self.opts["conum"]), ("bum_type", "=", self.utyp), ("bum_code",
-            "=", self.code)], limit=1)
+        if not w:
+            acc = self.sql.getRec(tables="bkmrtm", cols=["max(brm_code)"],
+                where=[("brm_cono", "=", self.opts["conum"]), ("brm_type",
+                "=", self.rtype)], limit=1)
+            if not acc[0]:
+                w = 1
+            else:
+                w = acc[0] + 1
+            self.df.loadEntry(frt, pag, p, data=w)
+        self.rcode = w
+        acc = self.sql.getRec(tables="bkmrtm", where=[("brm_cono", "=",
+            self.opts["conum"]), ("brm_type", "=", self.rtype), ("brm_code",
+            "=", self.rcode)], limit=1)
         if not acc:
-            self.new = True
+            self.newr = True
         else:
-            self.new = False
-            des = acc[self.sql.bkmunm_col.index("bum_desc")]
-            qty = acc[self.sql.bkmunm_col.index("bum_guests")]
-            self.df.loadEntry(frt, pag, p+1, data=des)
-            self.df.loadEntry(frt, pag, p+2, data=qty)
+            self.newr = False
+            for num, dat in enumerate(acc[3:]):
+                self.df.loadEntry(frt, pag, p+num+1, data=dat)
+
+    def doBase(self, frt, pag, r, c, p, i, w):
+        self.rbase = w
+
+    def doExpd(self, frt, pag, r, c, p, i, w):
+        self.newx = True
+        if not self.newr:
+            acc = self.sql.getRec(tables="bkmrtr", cols=["brr_rate"],
+                where=[("brr_cono", "=", self.opts["conum"]),
+                ("brr_type", "=", self.rtype), ("brr_code", "=", self.rcode),
+                ("brr_date", "=", w)], limit=1)
+            if acc:
+                self.newx = False
+                self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.date = w
+
+    def doRate(self, frt, pag, r, c, p, i, w):
+        self.rate = w
 
     def doDelete(self):
-        chk = self.sql.getRec(tables="bkmmst", cols=["bkm_units"],
-            where=[("bkm_cono", "=", self.opts["conum"])])
-        for bkm in chk:
-            unt = bkm[0].split(":")
-            for un in unt:
-                u = un.split(",")
-                if u[0] == self.utyp and u[1] == self.code:
-                    return "Unit Used, Not Deleted"
-        self.sql.delRec("bkmunm", where=[("bum_cono", "=", self.opts["conum"]),
-            ("bum_type", "=", self.utyp), ("bum_code", "=", self.code)])
+        chk = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_utype", "=", self.rtype), ("brt_ucode",
+            "=", self.rcode)])
+        if chk:
+            return "Rate in Use, Not Deleted"
+        self.sql.delRec("bkmrtm", where=[("brm_cono", "=", self.opts["conum"]),
+            ("brm_type", "=", self.rtype), ("brm_code", "=", self.rcode)])
+        self.sql.delRec("bkmrtr", where=[("brr_cono", "=", self.opts["conum"]),
+            ("brr_type", "=", self.rtype), ("brr_code", "=", self.rcode)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
     def doEnd(self):
         data = [self.opts["conum"]]
-        for x in xrange(0, len(self.df.t_work[0][0])):
-            if x == 1:
-                continue
-            data.append(self.df.t_work[0][0][x])
-        if self.new:
-            self.sql.insRec("bkmunm", data=data)
-        else:
-            self.sql.updRec("bkmunm", data=data, where=[("bum_cono", "=",
-                self.opts["conum"]), ("bum_type", "=", self.utyp),
-                ("bum_code", "=", self.code)])
+        data.extend(self.df.t_work[0][0][:4])
+        if self.newr:
+            self.sql.insRec("bkmrtm", data=data)
+        else:
+            self.sql.updRec("bkmrtm", data=data, where=[("brm_cono", "=",
+                self.opts["conum"]), ("brm_type", "=", self.rtype),
+                ("brm_code", "=", self.rcode)])
+        data = [self.opts["conum"]]
+        data.extend(self.df.t_work[0][0][:2])
+        data.extend(self.df.t_work[0][0][4:6])
+        if self.newx:
+            self.sql.insRec("bkmrtr", data=data)
+        else:
+            self.sql.updRec("bkmrtr", data=data, where=[("brr_cono", "=",
+                self.opts["conum"]), ("brr_type", "=", self.rtype),
+                ("brr_code", "=", self.rcode), ("brr_date", "=", self.date)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'bkm/bkc410.py'
--- bkm/bkc410.py	2014-08-27 09:27:53 +0000
+++ bkm/bkc410.py	2014-11-27 11:00:00 +0000
@@ -1,8 +1,8 @@
-#! /usr/bin/env python
+#! /usr/bin/python2
 
 """
 SYNOPSIS
-    Bookings Rate Records Maintenance.
+    Bulk Mailing Utility.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -13,129 +13,62 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-import time
 from TartanClasses import Sql, TartanDialog
 
 class bkc410:
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
-            self.drawDialog()
+            self.mainProcess()
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bkmrtm", "bkmrtt", "bkmunm",
-            "bkmunt"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, tables="bkmlet", prog=__name__)
         if self.sql.error:
             return
         return True
 
-    def drawDialog(self):
+    def mainProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-                "Booking Rate Records Maintenance (%s)" % __name__)
-        unt = {
-            "stype": "R",
-            "tables": ("bkmunt",),
-            "cols": (
-                ("but_type", "", 0, "Code"),
-                ("but_desc", "", 0, "Description")),
-            "where": [("but_cono", "=", self.opts["conum"])],
-            "order": "but_type"}
-        rte = {
-            "stype": "R",
-            "tables": ("bkmrtm",),
-            "cols": (
-                ("brm_code", "", 0, "Code"),
-                ("brm_desc", "", 0, "Description")),
-            "where": [("brm_cono", "=", self.opts["conum"])],
-            "whera": [("T", "brm_type", 0, 0)],
-            "order": "brm_code"}
-        r1s = (("PPPN","A"),("PPPD","B"),("PUPN","C"),("PUPD","D"))
-        self.fld = (
-            (("T",0,0,0),"IUA",1,"Unit Type","",
-                "A","N",self.doType,unt,None,None),
-            (("T",0,1,0),"IUI",3,"Code","",
-                "","N",self.doCode,rte,None,None),
-            (("T",0,2,0),"ITX",30,"Description","",
-                "","N",None,None,self.doDelete,("notblank",)),
-            (("T",0,3,0),"IUD",10.2,"Rate Amount","",
-                0,"N",self.doRate,None,None,("efld",)),
-            (("T",0,4,0),("IRB",r1s),0,"Rate Basis","",
-                "P","N",None,None,None,None,None,
-                """PPPN - Per person per night
-PPPD - Per person per day
-PUPN - Per unit per night
-PUPD - Per unit per day"""),
-            (("T",0,5,0),"IUD",10.2,"Minimum Quantity","",
-                1,"N",self.doMinU,None,None,("efld",)),
-            (("T",0,6,0),"IUD",10.2,"Minimum Value","",
-                0,"N",None,None,None,("efld",)))
-        but = (("Quit",None,self.doExit,1,None,None),)
-        tnd = ((self.doEnd,"Y"),)
-        txt = (self.doExit,)
-        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=self.fld,
+                "Booking Letters")
+        r1s = (("Query","Q"),("Confirm","C"),("Settle","S"),("Cancel","X"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Letter Type","",
+                "Q","Y",self.doType,None,None,None),
+            (("T",0,1,0),"ITV",(80,10),"Body","",
+                "","N",None,None,None,("notblank",)))
+        but = (
+            ("Save", None, self.doEnd, 0, ("T",0,2), ("T",0,1)),
+            ("Quit", None, self.doQuit, 1, None, ("T",0,1)))
+        tnd = ((self.doEnd, "y"), )
+        txt = (self.doExit, )
+        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
             butt=but, tend=tnd, txit=txt)
 
     def doType(self, frt, pag, r, c, p, i, w):
-        rec = self.sql.getRec(tables="bkmunt", where=[("but_cono", "=",
-            self.opts["conum"]), ("but_type", "=", w)])
+        self.ltyp = w
+        rec = self.sql.getRec(tables="bkmlet", where=[("bkl_cono", "=",
+            self.opts["conum"]), ("bkl_code", "=", self.ltyp)], limit=1)
         if not rec:
-            return "Invalid Unit Type"
-        self.rtype = w
-
-    def doCode(self, frt, pag, r, c, p, i, w):
-        if not w:
-            acc = self.sql.getRec(tables="bkmrtm", cols=["max(brm_code)"],
-                where=[("brm_cono", "=", self.opts["conum"]), ("brm_type",
-                "=", self.rtype)], limit=1)
-            if not acc[0]:
-                w = 1
-            else:
-                w = acc[0] + 1
-            self.df.loadEntry(frt, pag, p, data=w)
-        self.rcode = w
-        acc = self.sql.getRec(tables="bkmrtm", where=[("brm_cono", "=",
-            self.opts["conum"]), ("brm_type", "=", self.rtype), ("brm_code",
-            "=", self.rcode)], limit=1)
-        if not acc:
-            self.new = True
+            self.lnew = True
         else:
-            self.new = False
-            for num, dat in enumerate(acc[3:]):
-                self.df.loadEntry(frt, pag, p+num+1, data=dat)
-
-    def doRate(self, frt, pag, r, c, p, i, w):
-        self.rate = w
-
-    def doMinU(self, frt, pag, r, c, p, i, w):
-        self.minu = w
-        self.mina = self.rate * self.minu
-        self.df.loadEntry(frt, pag, p+1, data=self.mina)
-
-    def doDelete(self):
-        chk = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
-            self.opts["conum"]), ("brt_utype", "=", self.rtype), ("brt_ucode",
-            "=", self.rcode)])
-        if chk:
-            return "Rate in Use, Not Deleted"
-        self.sql.delRec("bkmrtm", where=[("brm_cono", "=", self.opts["conum"]),
-            ("brm_type", "=", self.rtype), ("brm_code", "=", self.rcode)])
-        self.opts["mf"].dbm.commitDbase()
-        self.df.focusField("T", 0, 1)
+            self.lnew = False
+            self.df.loadEntry(frt, pag, p+1,
+                data=rec[self.sql.bkmlet_col.index("bkl_body")])
 
     def doEnd(self):
-        data = [self.opts["conum"]]
-        for x in xrange(0, len(self.df.t_work[0][0])):
-            data.append(self.df.t_work[0][0][x])
-        if self.new:
-            self.sql.insRec("bkmrtm", data=data)
+        data = [self.opts["conum"], self.ltyp, self.df.t_work[0][0][1]]
+        if self.lnew:
+            self.sql.insRec("bkmlet", data=data)
         else:
-            self.sql.updRec("bkmrtm", data=data, where=[("brm_cono", "=",
-                self.opts["conum"]), ("brm_type", "=", self.rtype),
-                ("brm_code", "=", self.rcode)])
+            self.sql.updRec("bkmlet", data=data, where=[("bkl_cono", "=",
+                self.opts["conum"]), ("bkl_code", "=", self.ltyp)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
+    def doQuit(self):
+        self.df.focusField("T", 0, 1)
+
     def doExit(self, widget=None):
         self.df.closeProcess()
         self.opts["mf"].closeLoop()

=== modified file 'bkm/bkc510.py'
--- bkm/bkc510.py	2014-10-01 14:07:50 +0000
+++ bkm/bkc510.py	2014-11-22 07:46:03 +0000
@@ -1,8 +1,8 @@
-#! /usr/bin/python2
+#! /usr/bin/env python
 
 """
 SYNOPSIS
-    Bulk Mailing Utility.
+    Booking Contacts Maintenance.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -13,7 +13,10 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import Sql, TartanDialog
+import time
+from TartanClasses import FileImport, GetCtl, ProgressBar, PwdConfirm, Sql
+from TartanClasses import TabPrt, TartanDialog
+from tartanFunctions import askQuestion, callModule, showError
 
 class bkc510:
     def __init__(self, **opts):
@@ -23,45 +26,239 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, tables="bkmlet", prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "bkmcon", "bkmmst"],
+            prog=__name__)
         if self.sql.error:
             return
+        gc = GetCtl(self.opts["mf"])
+        bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
+        if not bkmctl:
+            return
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         return True
 
     def mainProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-                "Booking Letters")
-        r1s = (("Query","Q"),("Confirm","C"),("Settle","S"),("Cancel","X"))
-        fld = (
-            (("T",0,0,0),("IRB",r1s),0,"Letter Type","",
-                "Q","Y",self.doType,None,None,None),
-            (("T",0,1,0),"ITV",(80,10),"Body","",
-                "","N",None,None,None,("notblank",)))
-        tnd = ((self.doEnd, "y"), )
-        txt = (self.doExit, )
-        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
-            tend=tnd, txit=txt)
-
-    def doType(self, frt, pag, r, c, p, i, w):
-        self.ltyp = w
-        rec = self.sql.getRec(tables="bkmlet", where=[("bkl_cono", "=",
-            self.opts["conum"]), ("bkl_code", "=", self.ltyp)], limit=1)
-        if not rec:
-            self.lnew = True
-        else:
-            self.lnew = False
-            self.df.loadEntry(frt, pag, p+1,
-                data=rec[self.sql.bkmlet_col.index("bkl_body")])
-
-    def doEnd(self):
-        data = [self.opts["conum"], self.ltyp, self.df.t_work[0][0][1]]
-        if self.lnew:
-            self.sql.insRec("bkmlet", data=data)
-        else:
-            self.sql.updRec("bkmlet", data=data, where=[("bkl_cono", "=",
-                self.opts["conum"]), ("bkl_code", "=", self.ltyp)])
-        self.opts["mf"].dbm.commitDbase()
-        self.df.focusField("T", 0, 1)
+                "Contacts Maintenance (%s)" % __name__)
+        con = {
+            "stype": "R",
+            "tables": ("bkmcon",),
+            "cols": (
+                ("bkc_ccode", "", 0, "Code"),
+                ("bkc_title", "", 0, "Title"),
+                ("bkc_sname", "", 0, "Surame", "Y"),
+                ("bkc_names", "", 0, "Names", "F"),
+                ("bkc_email", "", 0, "Email Address"))}
+        self.fld = (
+            (("T",0,0,0),"IUA",7,"Code","",
+                "","Y",self.doCode,con,None,None),
+            (("T",0,1,0),"ITX",6,"Title","",
+                "","N",self.doTitle,None,self.doDelete,("notblank",)),
+            (("T",0,2,0),"ITX",30,"Surname","",
+                "","N",self.doSurname,None,None,("notblank",)),
+            (("T",0,3,0),"ITX",30,"Names","",
+                "","N",self.doNames,None,None,("notblank",)),
+            (("T",0,4,0),"ITX",30,"Address Line 1","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,5,0),"ITX",30,"Address Line 2","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,6,0),"ITX",30,"Address Line 3","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,7,0),"IUI",4,"Postal Code","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,8,0),"ITX",20,"Telephone Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,9,0),"ITX",20,"Fax Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,10,0),"ITX",20,"Mobile Number","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,11,0),"ITX",30,"E-Mail Address","",
+                "","N",None,None,None,("email",)),
+            (("T",0,12,0),"INA",10,"V.A.T Number","",
+                "","N",None,None,None,("efld",)))
+        but = (
+            ("Import",None,self.doImport,0,("T",0,1),("T",0,2),
+                "Import Contact Details from a CSV or XLS File."),
+            ("Accept",None,self.doAccept,0,("T",0,2),("T",0,1)),
+            ("Print", None, self.doPrint,0,("T",0,2),("T",0,1)),
+            ("Quit", None, self.doExit,1,None,None))
+        tnd = ((self.doAccept,"N"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], title=tit,
+            screen=self.opts["mf"].body, eflds=self.fld,
+            butt=but, tend=tnd, txit=txt, clicks=self.doClick)
+
+    def doClick(self, *opts):
+        if self.click:
+            self.df.loadEntry("T", self.click[0], self.click[1],
+                data=self.df.t_work[self.click[0]][0][self.click[1]])
+        self.click = opts[0]
+        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
+
+    def doCode(self, frt, pag, r, c, p, i, w):
+        self.ccode = w
+        self.click = []
+        if w:
+            self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
+                "=", self.opts["conum"]), ("bkc_ccode", "=", w)], limit=1)
+            if not self.oldcon:
+                return "Invalid Contact Code"
+            self.newcon = False
+            self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
+            self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
+            self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
+            self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
+            for num, dat in enumerate(self.oldcon[1:]):
+                self.df.loadEntry("T", 0, num, data=dat)
+        else:
+            self.newcon = True
+        self.acno = w
+        self.click = []
+
+    def doTitle(self, frt, pag, r, c, p, i, w):
+        self.title = w
+
+    def doSurname(self, frt, pag, r, c, p, i, w):
+        self.sname = w
+
+    def doNames(self, frt, pag, r, c, p, i, w):
+        self.names = w
+
+    def doEmail(self, frt, pag, r, c, p, i, w):
+        self.email = w
+
+    def doDelete(self, widget=None):
+        chk = self.sql.getRec(tables="bkmmst", cols=["count(*)"],
+            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_ccode",
+            "=", self.ccode)], limit=1)
+        if chk[0]:
+            return "Bookings Exist, Not Deleted"
+        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        self.sql.delRec("bkmcon", where=[("bkc_cono", "=", self.opts["conum"]),
+            ("bkc_ccode", "=", self.ccode)])
+        self.sql.insRec("chglog", data=["bkmcon", "D", "%03i%-7s" % \
+            (self.opts["conum"], self.ccode), "", dte, self.opts["capnm"],
+            "", "", 0])
+        self.opts["mf"].dbm.commitDbase()
+        self.df.focusField("T", 0, 1)
+
+    def doAccept(self, widget=None):
+        frt, pag, col, mes = self.df.doCheckFields()
+        if mes:
+            self.df.focusField(frt, pag, (col+1), err=mes)
+            return
+        # Create/Update Record
+        if self.newcon:
+            self.ccode = self.genCode(self.sname)
+            self.df.loadEntry("T", 0, 0, data=self.ccode)
+        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        data = [self.opts["conum"]]
+        for x in range(len(self.df.t_work[0][0])):
+            data.append(self.df.t_work[0][0][x])
+        if self.newcon:
+            self.sql.insRec("bkmcon", data=data)
+        elif data != self.oldcon:
+            self.sql.updRec("bkmcon", data=data, where=[("bkc_cono", "=",
+                self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
+            for num, dat in enumerate(self.oldcon):
+                if dat != data[num]:
+                    self.sql.insRec("chglog", data=["bkmcon", "U",
+                        "%03i%-7s" % (self.opts["conum"], self.ccode),
+                        self.sql.bkmcon_col[num], dte, self.opts["capnm"],
+                        str(dat), str(data[num]), 0])
+        self.opts["mf"].dbm.commitDbase()
+        self.df.focusField("T", 0, 1)
+
+    def doImport(self, widget=None):
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        fi = FileImport(self.opts["mf"], imptab="bkmcon", impskp=["bkc_cono"])
+        sp = ProgressBar(self.opts["mf"].body,
+            typ="Importing Contacts", mxs=len(fi.impdat), esc=False)
+        err = None
+        for num, line in enumerate(fi.impdat):
+            sp.displayProgress(num)
+            if not line[0]:
+                if not line[2]:
+                    err = "Blank Code and Blank Surname"
+                    break
+                chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
+                    self.opts["conum"]), ("bkc_sname", "=", line[2]),
+                    ("bkc_names", "=", line[3])], limit=1)
+                if chk:
+                    err = "%s: %s %s: %s\n\nAlready Exists" % (fi.impcol[2][0],
+                        line[2], fi.impcol[3][0], line[3])
+                    break
+                for x in xrange(1, 100):
+                    line[0] = self.genCode(line[2])
+                    chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
+                        "=", self.opts["conum"]), ("bkc_ccode", "=", line[0])],
+                        limit=1)
+                    if not chk:
+                        break
+            else:
+                chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
+                    self.opts["conum"]), ("bkc_ccode", "=", line[0])], limit=1)
+                if chk:
+                    err = "%s: %s %s: %s\n\nAlready Exists" % (fi.impcol[0][0],
+                        line[0], fi.impcol[2][0], line[2])
+                    break
+            if not line[1]:
+                line[1] = "Ms"
+            if not line[2]:
+                err = "Blank Surname"
+                break
+            if not line[3]:
+                err = "Blank Names"
+                break
+            #if not line[4]:
+            #    err = "Blank Address"
+            #    break
+            line.insert(0, self.opts["conum"])
+            self.sql.insRec("bkmcon", data=line)
+        sp.closeProgress()
+        if err:
+            err = "Line %s: %s" % ((num + 1), err)
+            showError(self.opts["mf"].body, "Import Error", """%s
+
+Please Correct your Import File and then Try Again.""" % err)
+            self.opts["mf"].dbm.rollbackDbase()
+        else:
+            self.opts["mf"].dbm.commitDbase()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+
+    def doPrint(self, widget=None):
+        state = self.df.disableButtonsTagsTags()
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+            name=__name__, tabs="bkmcon", where=[("drm_cono", "=",
+            self.opts["conum"]), ("drm_chain", "=", self.chain),
+            ("drm_acno", "=", self.acno)])
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTagsTags(state=state)
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+
+    def genCode(self, sname):
+        # Remove invalid characters
+        sname = sname.replace(" ", "")
+        for c in (" ", ".", ",", ";", ":", "'", '"'):
+            sname = sname.replace(c, "")
+        if len(sname) < 5:
+            sname = sname + ("0" * (5 - len(sname)))
+        ccod1 = ""
+        for c in xrange(0, 5):
+            ccod1 = (ccod1 + sname[c]).upper()
+        ccod1 = ccod1.strip()
+        text = "%s%0" + str((7 - len(ccod1))) + "d"
+        for x in xrange(1, 100):
+            ccod2 = text % (ccod1, x)
+            chk = self.sql.getRec(tables="bkmcon",
+                where=[("bkc_cono", "=", self.opts["conum"]),
+                ("bkc_ccode", "=", ccod2)], limit=1)
+            if not chk:
+                break
+        return ccod2
 
     def doExit(self, widget=None):
         self.df.closeProcess()

=== removed file 'bkm/bkc610.py'
--- bkm/bkc610.py	2014-08-30 12:52:42 +0000
+++ bkm/bkc610.py	1970-01-01 00:00:00 +0000
@@ -1,270 +0,0 @@
-#! /usr/bin/env python
-
-"""
-SYNOPSIS
-    Booking Contacts Maintenance.
-
-    This file is part of Tartan Systems (TARTAN).
-
-AUTHOR
-    Written by Paul Malherbe, <paul@tartan.co.za>
-
-COPYING
-    Copyright (C) 2004-2014 Paul Malherbe.
-"""
-
-import time
-from TartanClasses import FileImport, GetCtl, ProgressBar, PwdConfirm, Sql
-from TartanClasses import TabPrt, TartanDialog
-from tartanFunctions import askQuestion, callModule, showError
-
-class bkc610:
-    def __init__(self, **opts):
-        self.opts = opts
-        if self.setVariables():
-            self.mainProcess()
-            self.opts["mf"].startLoop()
-
-    def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "bkmcon", "bkmmst"],
-            prog=__name__)
-        if self.sql.error:
-            return
-        gc = GetCtl(self.opts["mf"])
-        bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
-        if not bkmctl:
-            return
-        t = time.localtime()
-        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
-        return True
-
-    def mainProcess(self):
-        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-                "Contacts Maintenance (%s)" % __name__)
-        con = {
-            "stype": "R",
-            "tables": ("bkmcon",),
-            "cols": (
-                ("bkc_ccode", "", 0, "Code"),
-                ("bkc_title", "", 0, "Title"),
-                ("bkc_sname", "", 0, "Surame", "Y"),
-                ("bkc_names", "", 0, "Names", "F"),
-                ("bkc_addr1", "", 0, "Address Line 1"))}
-        self.fld = (
-            (("T",0,0,0),"IUA",7,"Code","",
-                "","Y",self.doCode,con,None,None),
-            (("T",0,1,0),"ITX",6,"Title","",
-                "","N",self.doTitle,None,self.doDelete,("notblank",)),
-            (("T",0,2,0),"ITX",30,"Surname","",
-                "","N",self.doSurname,None,None,("notblank",)),
-            (("T",0,3,0),"ITX",30,"Names","",
-                "","N",self.doNames,None,None,("notblank",)),
-            (("T",0,4,0),"ITX",30,"Address Line 1","",
-                "","N",None,None,None,("notblank",)),
-            (("T",0,5,0),"ITX",30,"Address Line 2","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,6,0),"ITX",30,"Address Line 3","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,7,0),"IUI",4,"Postal Code","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,8,0),"ITX",20,"Telephone Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,9,0),"ITX",20,"Fax Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,10,0),"ITX",20,"Mobile Number","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,11,0),"ITX",30,"E-Mail Address","",
-                "","N",None,None,None,("email",)),
-            (("T",0,12,0),"ITX",30,"Group Name","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,13,0),"INA",10,"V.A.T Number","",
-                "","N",None,None,None,("efld",)))
-        but = (
-            ("Import",None,self.doImport,0,("T",0,1),("T",0,2),
-                "Import Contact Details from a CSV or XLS File."),
-            ("Accept",None,self.doAccept,0,("T",0,2),("T",0,1)),
-            ("Print", None, self.doPrint,0,("T",0,2),("T",0,1)),
-            ("Quit", None, self.doExit,1,None,None))
-        tnd = ((self.doAccept,"N"),)
-        txt = (self.doExit,)
-        self.df = TartanDialog(self.opts["mf"], title=tit,
-            screen=self.opts["mf"].body, eflds=self.fld,
-            butt=but, tend=tnd, txit=txt, clicks=self.doClick)
-
-    def doClick(self, *opts):
-        if self.click:
-            self.df.loadEntry("T", self.click[0], self.click[1],
-                data=self.df.t_work[self.click[0]][0][self.click[1]])
-        self.click = opts[0]
-        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
-
-    def doCode(self, frt, pag, r, c, p, i, w):
-        self.ccode = w
-        self.click = []
-        if w:
-            self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
-                "=", self.opts["conum"]), ("bkc_ccode", "=", w)], limit=1)
-            if not self.oldcon:
-                return "Invalid Contact Code"
-            self.newcon = False
-            self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
-            self.sname = self.oldcon[self.sql.bkmcon_col.index("bkc_sname")]
-            self.names = self.oldcon[self.sql.bkmcon_col.index("bkc_names")]
-            self.email = self.oldcon[self.sql.bkmcon_col.index("bkc_email")]
-            for num, dat in enumerate(self.oldcon[1:]):
-                self.df.loadEntry("T", 0, num, data=dat)
-        else:
-            self.newcon = True
-        self.acno = w
-        self.click = []
-
-    def doTitle(self, frt, pag, r, c, p, i, w):
-        self.title = w
-
-    def doSurname(self, frt, pag, r, c, p, i, w):
-        self.sname = w
-
-    def doNames(self, frt, pag, r, c, p, i, w):
-        self.names = w
-
-    def doEmail(self, frt, pag, r, c, p, i, w):
-        self.email = w
-
-    def doDelete(self, widget=None):
-        chk = self.sql.getRec(tables="bkmmst", cols=["count(*)"],
-            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_ccode",
-            "=", self.ccode)], limit=1)
-        if chk[0]:
-            return "Bookings Exist, Not Deleted"
-        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        self.sql.delRec("bkmcon", where=[("bkc_cono", "=", self.opts["conum"]),
-            ("bkc_ccode", "=", self.ccode)])
-        self.sql.insRec("chglog", data=["bkmcon", "D", "%03i%-7s" % \
-            (self.opts["conum"], self.ccode), "", dte, self.opts["capnm"],
-            "", "", 0])
-        self.opts["mf"].dbm.commitDbase()
-        self.df.focusField("T", 0, 1)
-
-    def doAccept(self, widget=None):
-        frt, pag, col, mes = self.df.doCheckFields()
-        if mes:
-            self.df.focusField(frt, pag, (col+1), err=mes)
-            return
-        # Create/Update Record
-        if self.newcon:
-            self.ccode = self.genCode(self.sname)
-            self.df.loadEntry("T", 0, 0, data=self.ccode)
-        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        data = [self.opts["conum"]]
-        for x in range(len(self.df.t_work[0][0])):
-            data.append(self.df.t_work[0][0][x])
-        if self.newcon:
-            self.sql.insRec("bkmcon", data=data)
-        elif data != self.oldcon:
-            self.sql.updRec("bkmcon", data=data, where=[("bkc_cono", "=",
-                self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
-            for num, dat in enumerate(self.oldcon):
-                if dat != data[num]:
-                    self.sql.insRec("chglog", data=["bkmcon", "U",
-                        "%03i%-7s" % (self.opts["conum"], self.ccode),
-                        self.sql.bkmcon_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
-        self.opts["mf"].dbm.commitDbase()
-        self.df.focusField("T", 0, 1)
-
-    def doImport(self, widget=None):
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        fi = FileImport(self.opts["mf"], imptab="bkmcon", impskp=["bkc_cono"])
-        sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Contacts", mxs=len(fi.impdat), esc=False)
-        err = None
-        for num, line in enumerate(fi.impdat):
-            sp.displayProgress(num)
-            if not line[0]:
-                if not line[2]:
-                    err = "Blank Code and Blank Surname"
-                    break
-                chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
-                    self.opts["conum"]), ("bkc_sname", "=", line[2]),
-                    ("bkc_names", "=", line[3])], limit=1)
-                if chk:
-                    err = "%s: %s %s: %s\n\nAlready Exists" % (fi.impcol[2][0],
-                        line[2], fi.impcol[3][0], line[3])
-                    break
-                for x in xrange(1, 100):
-                    line[0] = self.genCode(line[2])
-                    chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
-                        "=", self.opts["conum"]), ("bkc_ccode", "=", line[0])],
-                        limit=1)
-                    if not chk:
-                        break
-            else:
-                chk = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
-                    self.opts["conum"]), ("bkc_ccode", "=", line[0])], limit=1)
-                if chk:
-                    err = "%s: %s %s: %s\n\nAlready Exists" % (fi.impcol[0][0],
-                        line[0], fi.impcol[2][0], line[2])
-                    break
-            if not line[2]:
-                err = "Blank Title"
-                break
-            if not line[2]:
-                err = "Blank Surname"
-                break
-            if not line[3]:
-                err = "Blank Names"
-                break
-            if not line[4]:
-                err = "Blank Address"
-                break
-            line.insert(0, self.opts["conum"])
-            self.sql.insRec("bkmcon", data=line)
-        sp.closeProgress()
-        if err:
-            err = "Line %s: %s" % ((num + 1), err)
-            showError(self.opts["mf"].body, "Import Error", """%s
-
-Please Correct your Import File and then Try Again.""" % err)
-            self.opts["mf"].dbm.rollbackDbase()
-        else:
-            self.opts["mf"].dbm.commitDbase()
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-
-    def doPrint(self, widget=None):
-        state = self.df.disableButtonsTagsTags()
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
-            name=__name__, tabs="bkmcon", where=[("drm_cono", "=",
-            self.opts["conum"]), ("drm_chain", "=", self.chain),
-            ("drm_acno", "=", self.acno)])
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.enableButtonsTagsTags(state=state)
-        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-
-    def genCode(self, sname):
-        # Remove invalid characters
-        sname = sname.replace(" ", "")
-        for c in (" ", ".", ",", ";", ":", "'", '"'):
-            sname = sname.replace(c, "")
-        if len(sname) < 5:
-            sname = sname + ("0" * (5 - len(sname)))
-        ccod1 = ""
-        for c in xrange(0, 5):
-            ccod1 = (ccod1 + sname[c]).upper()
-        ccod1 = ccod1.strip()
-        text = "%s%0" + str((7 - len(ccod1))) + "d"
-        for x in xrange(1, 100):
-            ccod2 = text % (ccod1, x)
-            chk = self.sql.getRec(tables="bkmcon",
-                where=[("bkc_cono", "=", self.opts["conum"]),
-                ("bkc_ccode", "=", ccod2)], limit=1)
-            if not chk:
-                break
-        return ccod2
-
-    def doExit(self, widget=None):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
-# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bwl/bc1010.py'
--- bwl/bc1010.py	2014-10-01 14:07:50 +0000
+++ bwl/bc1010.py	2014-10-08 13:15:58 +0000
@@ -13,9 +13,9 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import FileImport, GetCtl, ProgressBar, RepPrt, Sql
+from TartanClasses import CCD, FileImport, GetCtl, ProgressBar, RepPrt, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import getNextCode, showError
+from tartanFunctions import askQuestion, getNextCode, showError
 
 class bc1010:
     def __init__(self, **opts):
@@ -23,7 +23,7 @@
         if self.setVariables():
             self.mainProcess()
             if "args" in self.opts:
-                self.newmem = True
+                self.newtab = True
                 self.gentab = False
                 self.tab = self.opts["args"][0]
                 self.df.loadEntry("T", 0, 0, data=self.tab)
@@ -32,7 +32,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["bwlent", "bwlgme", "bwltab",
-            "bwldrt", "bwlskp", "memmst", "memkon"], prog=__name__, errs=False)
+            "bwldrt", "bwlflt", "memmst", "memkon"],
+            prog=__name__, errs=False)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -59,8 +60,7 @@
                 ("btb_surname", "", 0, "Surame", "Y"),
                 ("btb_names", "", 0, "Names"),
                 ("btb_memno", "", 0, "Mem-No"),
-                ("btb_bsano", "", 0, "BSA-No"),
-                ("btb_status", "", 0, "S")),
+                ("btb_bsano", "", 0, "BSA-No")),
             "where": [("btb_cono", "=", self.opts["conum"])],
             "order": "btb_surname"}
         if self.mlint == "N":
@@ -80,9 +80,10 @@
                 "where": [("mlm_cono", "=", self.opts["conum"])],
                 "order": "mlm_surname, mlm_names"}
         r1s = (("Male", "M"), ("Female", "F"))
-        r2s = (("Skip","4"), ("Third","3"), ("Second","2"), ("Lead","1"))
-        r3s = (("Act", "A"), ("Dec", "D"), ("Def", "X"),
-            ("Ina", "I"), ("Res", "R"), ("Sus", "S"))
+        if self.dbase == "R":
+            r2s = (("None", "0"),)
+        else:
+            r2s = (("Skip","4"), ("Third","3"), ("Second","2"), ("Lead","1"))
         fld = [
             (("T",0,0,0),"I@btb_tab",0,"","",
                 "","Y",self.doTab,tab,None,("efld",)),
@@ -94,26 +95,39 @@
                 "","N",self.doNames,None,None,("notblank",)),
             (("T",0,4,0),("IRB",r1s),0,"Gender","",
                 "M","N",self.doGender,None,None,None),
-            (("T",0,5,0),("IRB",r2s),0,"Position - Primary","",
+            (("T",0,5,0),"I@btb_add1",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,6,0),"I@btb_add2",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,7,0),"I@btb_add3",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,8,0),"I@btb_pcod",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,9,0),"I@btb_home",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,10,0),"I@btb_work",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,11,0),"I@btb_cell",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,12,0),"I@btb_mail",0,"","",
+                "","N",self.doEmail,None,None,("efld",)),
+            (("T",0,13,0),("IRB",r2s),0,"Position - Primary","",
                 "1","N",self.doPos,None,self.doDelete,None),
-            (("T",0,6,0),"I@btb_rate1",0,"","",
+            (("T",0,14,0),"I@btb_rate1",0,"","",
                 "","N",self.doRate,None,None,("efld",)),
-            (("T",0,7,0),("IRB",r2s),0,"Position - Mixed","",
-                "","N",self.doPos,None,None,None),
-            (("T",0,8,0),"I@btb_rate2",0,"","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,9,0),"I@btb_bsano",0,"","",
-                "","N",None,None,None,("efld",)),
-            [("T",0,10,0),["IRB",r3s],0,"Status","",
-                "A","N",None,None,None,None]]
-        if self.mlint == "Y":
-            fld[10][1][0] = "ORB"
-        else:
+            (("T",0,15,0),("IRB",r2s),0,"Position - Mixed","",
+                "1","N",self.doPos,None,None,None),
+            (("T",0,16,0),"I@btb_rate2",0,"","",
+                "","N",None,None,None,("efld",)),
+            (("T",0,17,0),"I@btb_bsano",0,"","",
+                "","N",None,None,None,("efld",))]
+        if self.mlint == "N":
             fld[1] = [("T",0,1,0),"O@btb_memno",0,""]
         but = (
-            ("Import Gradings",None,self.doImport,0,("T",0,1),("T",0,2),
-                "Import Gradings from a CSV or XLS File."),
-            ("Accept",None,self.doEnd,0,("T",0,2),("T",0,0)),
+            ("Import",None,self.doImport,0,("T",0,1),("T",0,2),
+                "Import Tabs and/or Ratings from a CSV or XLS File."),
+            ("Accept",None,self.doEnd,0,("T",0,2),("T",0,0),
+                "Accept All Fields and Continue"),
             ("Print",None,self.doPrint,1,None,None))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
@@ -132,71 +146,94 @@
     def doTab(self, frt, pag, r, c, p, i, w):
         self.click = []
         self.tab = w
-        if self.tab and not self.tab < self.nstart:
-            return "This Is a Non-Member"
         if not self.tab:
             self.gentab = True
+            self.newtab = True
         else:
             self.gentab = False
-        rec = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
-            self.opts["conum"]), ("btb_tab", "=", self.tab)], limit=1)
-        if not rec:
-            self.newmem = True
+            rec = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
+                self.opts["conum"]), ("btb_tab", "=", self.tab)], limit=1)
+            if not rec:
+                self.newtab = True
+            else:
+                self.newtab = False
+                for num, fld in enumerate(rec[1:]):
+                    if num in (13, 15):
+                        fld = str(fld)
+                    self.df.loadEntry(frt, pag, num, data=fld)
+        if self.tab:
+            if rec:
+                memno = rec[self.sql.bwltab_col.index("btb_memno")]
+            elif self.tab < self.nstart and self.samen == "Y":
+                memno = self.tab
+            else:
+                memno = 0
         else:
-            self.newmem = False
-        if self.tab and self.mlint and self.samen == "Y":
-            acc = self.sql.getRec(tables="memmst", cols=["mlm_surname",
-                "mlm_names", "mlm_gender", "mlm_state"], where=[("mlm_cono",
-                "=", self.opts["conum"]), ("mlm_memno", "=", self.tab)],
-                limit=1)
-            if not acc:
-                return "Member %s Does Not Exist" % self.tab
-            self.df.loadEntry(frt, pag, p+1, data=self.tab)
-            self.df.loadEntry(frt, pag, p+2, data=acc[0])
-            self.df.loadEntry(frt, pag, p+3, data=acc[1])
-            self.gender = acc[2]
-            self.df.loadEntry(frt, pag, p+4, data=self.gender)
-            self.df.loadEntry(frt, pag, p+10, data=acc[3])
-        if not self.newmem:
-            for num, fld in enumerate(rec[1:]):
-                if num in (5, 7):
-                    fld = str(fld)
-                self.df.loadEntry(frt, pag, num, data=fld)
-        if self.tab and self.mlint and self.samen == "Y":
-            return "sk4"
+            memno = 0
+        if memno:
+            chk = self.doLoadMember(memno)
+            if not chk:
+                return "Member %s Does Not Exist" % memno
+            if self.dbase == "R":
+                return "sk13"
+            return "sk12"
 
     def doMember(self, frt, pag, r, c, p, i, w):
         if w:
-            mem = self.sql.getRec(tables="memmst", cols=["mlm_surname",
-                "mlm_names", "mlm_gender", "mlm_state"], where=[("mlm_cono",
-                "=", self.opts["conum"]), ("mlm_memno", "=", w)], limit=1)
-            if not mem:
+            if self.newtab:
+                chk = self.sql.getRec(tables="bwltab", where=[("btb_cono",
+                    "=", self.opts["conum"]), ("btb_memno", "=", w)], limit=1)
+                if chk:
+                    return "Member Already Has a TAB"
+            chk = self.doLoadMember(w)
+            if not chk:
                 return "Invalid Membership Number"
-            acc = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
-                self.opts["conum"]), ("btb_memno", "=", w)], limit=1)
-            if self.newmem and acc:
-                return "Member Already Has a TAB"
-            self.df.loadEntry(frt, pag, p+1, data=mem[0])
-            self.df.loadEntry(frt, pag, p+2, data=mem[1])
-            self.gender = mem[2]
-            if self.newmem and not self.tab:
-                self.getNextTab()
-            self.df.loadEntry(frt, pag, p+3, data=self.gender)
-            self.df.loadEntry(frt, pag, p+9, data=mem[3])
-            if self.dbase in ("C","P") and self.df.t_work[0][0][5] == "0":
-                self.df.t_work[0][0][5] = "1"
+            if self.newtab and not self.tab:
+                chk = self.getNextTab()
+                if not chk:
+                    return "Invalid Membership Number"
             if self.dbase == "R":
-                self.pos1 = ""
-                self.df.loadEntry(frt, pag, p+4, data=self.pos1)
-                self.df.loadEntry(frt, pag, p+6, data=self.pos1)
-                return "sk4"
-            return "sk3"
+                return "sk12"
+            return "sk11"
+        elif self.tab and self.tab < self.nstart and self.mlint == "Y":
+            return "Invalid Membership Number"
+
+    def doLoadMember(self, memno):
+        acc = self.sql.getRec(tables="memmst", cols=["mlm_surname",
+            "mlm_names", "mlm_gender"], where=[("mlm_cono", "=",
+            self.opts["conum"]), ("mlm_memno", "=", memno)], limit=1)
+        if not acc:
+            return
+        self.df.loadEntry("T", 0, 1, data=memno)
+        self.df.loadEntry("T", 0, 2, data=acc[0])
+        self.df.loadEntry("T", 0, 3, data=acc[1])
+        self.gender = acc[2]
+        self.df.loadEntry("T", 0, 4, data=self.gender)
+        for typ in ("A", "P"):
+            ad = self.sql.getRec(tables="memadd", cols=["mla_add1", "mla_add2",
+                "mla_add3", "mla_code"], where=[("mla_cono", "=",
+                self.opts["conum"]), ("mla_memno", "=", memno), ("mla_type",
+                "=", typ)], limit=1)
+            if ad:
+                break
+        if ad:
+            self.df.loadEntry("T", 0, 5, data=ad[0])
+            self.df.loadEntry("T", 0, 6, data=ad[1])
+            self.df.loadEntry("T", 0, 7, data=ad[2])
+            self.df.loadEntry("T", 0, 8, data=ad[3])
+        for num, cod in enumerate((1, 2, 3, 5)):
+            kk = self.sql.getRec(tables="memkon", cols=["mlk_detail"],
+                where=[("mlk_cono", "=", self.opts["conum"]),
+                ("mlk_memno", "=", memno), ("mlk_code", "=", cod)], limit=1)
+            if kk:
+                self.df.loadEntry("T", 0, num+9, data=kk[0])
+        return True
 
     def doSurname(self, frt, pag, r, c, p, i, w):
         self.sname = w
 
     def doNames(self, frt, pag, r, c, p, i, w):
-        if self.newmem and self.sql.getRec(tables="bwltab", where=[("btb_cono",
+        if self.newtab and self.sql.getRec(tables="bwltab", where=[("btb_cono",
                 "=", self.opts["conum"]), ("btb_surname", "ilike", self.sname,
                 "and", "btb_names", "ilike", w)]):
             return "A Member with this Name Already Exists"
@@ -204,32 +241,37 @@
     def doGender(self, frt, pag, r, c, p, i, w):
         self.gender = w
         if self.gentab:
-            self.getNextTab()
-        if self.mstart < self.fstart:
-            if self.gender == "M" and self.tab >= self.fstart:
-                return "ff1|Invalid Tab Number for Gender"
-            elif self.gender == "F" and self.tab < self.fstart:
-                return "ff1|Invalid Tab Number for Gender"
-        else:
-            if self.gender == "F" and self.tab >= self.fstart:
-                return "ff1|Invalid Tab Number for Gender"
-            elif self.gender == "M" and self.tab < self.fstart:
-                return "ff1|Invalid Tab Number for Gender"
-        if self.dbase in ("C","P") and self.df.t_work[0][0][5] == "0":
-            self.df.t_work[0][0][5] = "1"
+            chk = self.getNextTab()
+            if not chk:
+                return "ff2|Invalid Membership Number"
+        if self.tab < self.nstart:
+            if self.mstart < self.fstart:
+                if self.gender == "M" and self.tab >= self.fstart:
+                    return "ff1|Invalid Tab Number for Gender"
+                elif self.gender == "F" and self.tab < self.fstart:
+                    return "ff1|Invalid Tab Number for Gender"
+            else:
+                if self.gender == "F" and self.tab >= self.fstart:
+                    return "ff1|Invalid Tab Number for Gender"
+                elif self.gender == "M" and self.tab < self.fstart:
+                    return "ff1|Invalid Tab Number for Gender"
+
+    def doEmail(self, frt, pag, r, c, p, i, w):
+        if self.dbase in ("C","P") and self.df.t_work[0][0][13] == "0":
+            self.df.t_work[0][0][13] = "1"
         if self.dbase == "R":
-            self.pos1 = ""
+            self.pos1 = "0"
             self.df.loadEntry(frt, pag, p+1, data="")
             self.df.loadEntry(frt, pag, p+1, data="")
             return "sk1"
 
     def doPos(self, frt, pag, r, c, p, i, w):
-        if p == 5:
+        if p == 13:
             self.pos1 = w
             self.df.loadEntry(frt, pag, p+2, data=w)
         if self.dbase == "P":
             self.df.loadEntry(frt, pag, p+1, data="")
-            if p == 5:
+            if p == 13:
                 self.df.loadEntry(frt, pag, p+3, data="")
             if self.gender == "M":
                 return "sk3"
@@ -249,81 +291,232 @@
             return "sk2"
 
     def getNextTab(self):
-        if self.gender == "M":
-            start = self.mstart
+        ok = askQuestion(self.opts["mf"].body, "Type",
+            "Is this TAB for a Visitor", default="no")
+        if ok == "no":
+            if self.samen == "Y":
+                return
+            if self.gender == "M":
+                start = self.mstart
+                if self.mstart < self.fstart:
+                    last = self.fstart
+                else:
+                    last = self.nstart
+            else:
+                start = self.fstart
+                if self.mstart < self.fstart:
+                    last = self.nstart
+                else:
+                    last = self.mstart
         else:
-            start = self.fstart
+            start = self.nstart
+            last = 900000
         self.tab = getNextCode(self.sql, "bwltab", "btb_tab",
-            where=[("btb_cono", "=", self.opts["conum"])], start=start)
+            where=[("btb_cono", "=", self.opts["conum"])],
+            start=start, last=last)
         self.df.loadEntry("T", 0, 0, data=self.tab)
+        return True
 
     def doDelete(self, widget=None):
-        if self.newmem:
+        if self.newtab:
             return
         error = False
-        for tab in (
-                ("bwldrt", "bdt_cono", "bdt_tab"),
-                ("bwlent", "bce_cono", "bce_scod"),
-                ("bwlflt", "bft_cono", "bft_player"),
-                ("bwlgme", "bcg_cono", "bcg_scod")):
-            chk = self.sql.getRec(tables=tab[0], where=[(tab[1], "=",
-                self.opts["conum"]), (tab[2], "=", self.tab)], limit=1)
+        keys = (
+            ("bwltab", "btb_cono", "btb_tab"),
+            ("bwldrt", "bdt_cono", "bdt_tab"),
+            ("bwlent", "bce_cono", "bce_scod"),
+            ("bwlflt", "bft_cono", "bft_player"),
+            ("bwlgme", "bcg_cono", "bcg_scod"))
+        for key in keys:
+            if key[0] == "bwltab":
+                continue
+            chk = self.sql.getRec(tables=key[0], where=[(key[1], "=",
+                self.opts["conum"]), (key[2], "=", self.tab)], limit=1)
             if chk:
                 error = True
                 break
         if error:
-            return "There are Movements for this Player, Not Deleted"
-        self.sql.delRec("bwltab", where=[("btb_cono", "=", self.opts["conum"]),
-            ("btb_tab", "=", self.tab)])
-        self.sql.delRec("bwlskp", where=[("bcs_cono", "=", self.opts["conum"]),
-            ("bcs_tab", "=", self.tab)])
+            if self.tab < self.nstart:
+                tab = getNextCode(self.sql, "bwltab", "btb_tab",
+                    where=[("btb_cono", "=", self.opts["conum"])],
+                    start=self.nstart, last=900000)
+                for key in keys:
+                    self.sql.updRec(key[0], cols=[key[2]], data=[tab],
+                        where=[(key[1], "=", self.opts["conum"]),
+                        (key[2], "=", self.tab)])
+            else:
+                return "There is History for this Player, Not Deleted"
+        else:
+            self.sql.delRec("bwltab", where=[("btb_cono", "=",
+                self.opts["conum"]), ("btb_tab", "=", self.tab)])
         self.opts["mf"].dbm.commitDbase()
 
     def doPrint(self, widget=None):
+        state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
-        cols = self.sql.bwltab_col[:]
-        cols.remove("btb_cono")
-        RepPrt(self.opts["mf"], name=__name__, conum=self.opts["conum"],
-            conam=self.opts["conam"], heads=["Tab's Listing"],
-            tables=["bwltab"], cols=cols, order="btb_surname",
-            prtdia=(("Y","V"), ("Y","N")))
+        self.colsd = [
+            ["Membership Number", "N", "btb_memno"],
+            ["Surname & Initials", "Y", "name"],
+            ["Surname", "N", "btb_surname"],
+            ["First Names", "N", "btb_names"],
+            ["Gender", "N", "btb_gender"],
+            ["Address", "N", "address"],
+            ["Telephone - Home", "N", "btb_home"],
+            ["Telephone - Work", "N", "btb_work"],
+            ["Telephone - Cell", "N", "btb_cell"],
+            ["Email Address", "N", "btb_mail"],
+            ["Ratings", "N", "ratings"]]
+        tit = ("Print Details",)
+        r1s = (("Members", "M"), ("Guests", "G"), ("All", "A"))
+        r2s = (("Males","M"), ("Females","F"), ("All","A"))
+        r3s = (("Yes", "Y"), ("No", "N"))
+        fld = [
+            (("T",0,0,0),("IRB",r1s),0,"Tab Group","",
+                "M","Y",self.doCGroup,None,None,None),
+            (("T",0,1,0),("IRB",r2s),0,"Gender","",
+                "A","Y",self.doCGender,None,None,None)]
+        for num, dat in enumerate(self.colsd):
+            des = dat[0]
+            dft = dat[1]
+            fld.append((("T",0,num+2,0),("IRB",r3s),0,des,"",
+                dft,"N",self.doCField,None,None,None))
+        tnd = ((self.doCEnd,"Y"), )
+        txt = (self.doCExit, )
+        self.cf = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
+            tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
+        self.opts["mf"].startLoop()
+        if self.cols:
+            cols = []
+            dic = self.sql.bwltab_dic
+            for col in self.cols:
+                if col == "name":
+                    cols.append(["name", "NA", 30, "Name"])
+                elif col == "address":
+                    cols.append(["address", "NA", 120, "Address"])
+                elif col == self.colsd[num][2] == "ratings":
+                    if self.dbase == "P":
+                        cols.append(["btb_pos1", dic["btb_pos1"][2],
+                            dic["btb_pos1"][3], dic["btb_pos1"][5]])
+                        cols.append(["btb_pos2", dic["btb_pos2"][2],
+                            dic["btb_pos2"][3], dic["btb_pos2"][5]])
+                    elif self.dbase == "R":
+                        cols.append(["btb_rate1", dic["btb_rate1"][2],
+                            dic["btb_rate1"][3], dic["btb_rate1"][5]])
+                        cols.append(["btb_rate2", dic["btb_rate2"][2],
+                            dic["btb_rate2"][3], dic["btb_rate2"][5]])
+                    else:
+                        cols.append(["btb_pos1", dic["btb_pos1"][2],
+                            dic["btb_pos1"][3], dic["btb_pos1"][5]])
+                        cols.append(["btb_rate1", dic["btb_rate1"][2],
+                            dic["btb_rate1"][3], dic["btb_rate1"][5]])
+                        cols.append(["btb_pos2", dic["btb_pos2"][2],
+                            dic["btb_pos2"][3], dic["btb_pos2"][5]])
+                        cols.append(["btb_rate2", dic["btb_rate2"][2],
+                            dic["btb_rate2"][3], dic["btb_rate2"][5]])
+                else:
+                    cols.append([col, dic[col][2], dic[col][3], dic[col][5]])
+            whr = [("btb_cono", "=", self.opts["conum"])]
+            if self.cgroup == "M":
+                whr.append(("btb_tab", "<", self.nstart))
+            elif self.cgroup == "G":
+                whr.append(("btb_tab", ">=", self.nstart))
+            if self.cgender in ("F", "M"):
+                whr.append(("btb_gender", "=", self.cgender))
+            recs = self.sql.getRec(tables="bwltab", where=whr,
+                order="btb_surname, btb_names")
+            data = []
+            for rec in recs:
+                dat = []
+                for col in self.cols:
+                    if col == "name":
+                        snam = rec[self.sql.bwltab_col.index("btb_surname")]
+                        fnam = rec[self.sql.bwltab_col.index("btb_names")]
+                        fnam = fnam.split()
+                        for num, nam in enumerate(fnam):
+                            if not num:
+                                init = nam[0].capitalize()
+                            else:
+                                init = "%s, %s" % (init, nam[0].capitalize())
+                        dat.append("%s, %s" % (snam, init))
+                    elif col == "address":
+                        txt = rec[self.sql.bwltab_col.index("btb_add1")]
+                        adr = rec[self.sql.bwltab_col.index("btb_add2")]
+                        if adr:
+                            txt = "%s, %s" % (txt, adr)
+                        adr = rec[self.sql.bwltab_col.index("btb_add3")]
+                        if adr:
+                            txt = "%s, %s" % (txt, adr)
+                        adr = rec[self.sql.bwltab_col.index("btb_pcod")]
+                        if adr:
+                            txt = "%s, %s" % (txt, adr)
+                        dat.append(CCD(txt, "NA", 120).work)
+                    else:
+                        dat.append(rec[self.sql.bwltab_col.index(col)])
+                data.append(dat)
+            tit = "Tabs Lising for"
+            if self.cgroup == "A":
+                tit = "%s Members and Guests" % tit
+            elif self.cgroup == "M":
+                tit = "%s Members Only" % tit
+            else:
+                tit = "%s Guests Only" % tit
+            if self.cgender == "A":
+                tit = "%s (All Genders)" % tit
+            elif self.cgender == "M":
+                tit = "%s (Males Only)" % tit
+            else:
+                tit = "%s (Females Only)" % tit
+            RepPrt(self.opts["mf"], name=__name__, conum=self.opts["conum"],
+                conam=self.opts["conam"], heads=[tit], ttype="D",
+                tables=data, cols=cols, view=self.cf.repprt[0][1],
+                prtnam=self.cf.repprt[0][2], mail=self.cf.repprt[1][2])
         self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state=state)
         self.df.focusField("T", 0, 1)
 
-    def doEnd(self, widget=None):
-        if widget:
-            frt, pag, col, mes = self.df.doCheckFields()
-            if mes:
-                self.df.focusField(frt, pag, (col+1), err=mes)
-                return
+    def doCGroup(self, frt, pag, r, c, p, i, w):
+        self.cgroup = w
+
+    def doCGender(self, frt, pag, r, c, p, i, w):
+        self.cgender = w
+
+    def doCField(self, frt, pag, r, c, p, i, w):
+        if p == 3 and w == "Y":
+            self.cf.loadEntry(frt, pag, p+1, data="N")
+            self.cf.loadEntry(frt, pag, p+2, data="N")
+            return "sk2"
+
+    def doCEnd(self):
+        self.cf.closeProcess()
+        self.cols = ["btb_tab"]
+        for num, dat in enumerate(self.cf.t_work[0][0][2:-4]):
+            if dat == "Y":
+                self.cols.append(self.colsd[num][2])
+        self.opts["mf"].closeLoop()
+
+    def doCExit(self):
+        self.cols = []
+        self.cf.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doEnd(self):
+        cols = []
+        for x in range(18):
+            cols.append(x)
+        if self.dbase == "R":
+            cols.remove(13)
+            cols.remove(15)
+        flds = ("T", 0, cols)
+        frt, pag, col, mes = self.df.doCheckFields(flds)
+        if mes:
+            self.df.focusField(frt, pag, (col+1), err=mes)
+            return
         tabdat = [self.opts["conum"]] + self.df.t_work[0][0]
-        skpdat = [self.opts["conum"], self.tab, self.tab]
-        skpdat.extend(self.df.t_work[0][0][2:5])
-        memno = tabdat[self.sql.bwltab_col.index("btb_memno")]
-        if memno:
-            kon = self.sql.getRec(tables="memkon", cols=["mlk_code",
-                "mlk_detail"], where=[("mlk_cono", "=", self.opts["conum"]),
-                ("mlk_memno", "=", memno)], order="mlk_code desc")
-            eml = ""
-            mbl = ""
-            for k in kon:
-                if k[0] == 5:
-                    eml = k[1]
-                elif k[0] == 3:
-                    mbl = k[1]
-                elif k[0] == 1 and not mbl:
-                    mbl = k[1]
-            skpdat.extend([self.opts["conum"], eml, mbl])
-        else:
-            skpdat.extend([self.opts["conum"], "", ""])
-        if self.newmem:
+        if self.newtab:
             self.sql.insRec("bwltab", data=tabdat)
-            self.sql.insRec("bwlskp", data=skpdat)
         else:
             self.sql.updRec("bwltab", data=tabdat, where=[("btb_cono", "=",
                 self.opts["conum"]), ("btb_tab", "=", self.tab)])
-            self.sql.updRec("bwlskp", data=skpdat, where=[("bcs_cono", "=",
-                self.opts["conum"]), ("bcs_code", "=", self.tab)])
         self.opts["mf"].dbm.commitDbase()
         if "args" in self.opts:
             self.doExit()
@@ -333,30 +526,40 @@
     def doImport(self, widget=None):
         state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
-        fi = FileImport(self.opts["mf"], imptab="bwltab", impskp=["btb_cono",
-            "btb_memno", "btb_surname", "btb_names", "btb_gender",
-            "btb_bsano", "btb_status"])
-        sp = ProgressBar(self.opts["mf"].body, typ="Importing Gradings",
+        tit = ("Import Details",)
+        r1s = (("Ratings Only", "R"), ("All Fields", "A"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Details","",
+                "R","N",self.doImpDet,None,None,None),)
+        self.ip = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, tend=((self.doImpEnd,"y"),), txit=(self.doImpExit,))
+        self.opts["mf"].startLoop()
+        if self.impdet is None:
+            self.df.setWidget(self.df.mstFrame, state="show")
+            self.df.enableButtonsTags(state=state)
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+            return
+        fi = FileImport(self.opts["mf"], imptab="bwltab", impskp=self.impskp)
+        sp = ProgressBar(self.opts["mf"].body, typ="Importing Ratings",
             mxs=len(fi.impdat), esc=False)
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)
-            chk = self.sql.getRec(tables="bwltab", where=[("btb_cono",
-                "=", self.opts["conum"]), ("btb_tab", "=", line[0])], limit=1)
+            chk = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
+                self.opts["conum"]), ("btb_tab", "=", line[0])], limit=1)
             if not chk:
                 err = "%s %s Does Not Exist" % (fi.impcol[0][0], line[0])
                 break
-            if not line[1]:
-                line[1] = chk[self.sql.bwltab_col.index("btb_pos1")]
-            if not line[2]:
-                line[2] = chk[self.sql.bwltab_col.index("btb_rate1")]
-            if not line[3]:
-                line[3] = chk[self.sql.bwltab_col.index("btb_pos2")]
-            if not line[4]:
-                line[4] = chk[self.sql.bwltab_col.index("btb_rate2")]
-            self.sql.updRec("bwltab", cols=["btb_pos1", "btb_rate1",
-                "btb_pos2", "btb_rate2"], data=line[1:], where=[("btb_cono",
-                "=", self.opts["conum"]), ("btb_tab", "=", line[0])])
+            if self.impdet == "R":
+                cols = ["btb_pos1", "btb_rate1", "btb_pos2", "btb_rate2"]
+            else:
+                cols = ["btb_surname", "btb_names", "btb_gender", "btb_add1",
+                    "btb_add2", "btb_add3", "btb_pcod", "btb_home",
+                    "btb_work", "btb_cell", "btb_mail", "btb_pos1",
+                    "btb_rate1", "btb_pos2", "btb_rate2", "btb_bsano"]
+            self.sql.updRec("bwltab", cols=cols, data=line[1:],
+                where=[("btb_cono", "=", self.opts["conum"]),
+                ("btb_tab", "=", line[0])])
         sp.closeProgress()
         if err:
             err = "Line %s: %s" % ((num + 1), err)
@@ -370,6 +573,23 @@
         self.df.enableButtonsTags(state=state)
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
+    def doImpDet(self, frt, pag, r, c, p, i, w):
+        self.impdet = w
+
+    def doImpEnd(self):
+        self.impskp = ["btb_cono", "btb_memno"]
+        if self.impdet == "R":
+            self.impskp.extend(["btb_surname", "btb_names", "btb_gender",
+                "btb_add1", "btb_add2", "btb_add3", "btb_pcod", "btb_home",
+                "btb_work", "btb_cell", "btb_mail", "btb_bsano"])
+        self.ip.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doImpExit(self):
+        self.impdet = None
+        self.ip.closeProcess()
+        self.opts["mf"].closeLoop()
+
     def doExit(self):
         self.df.closeProcess()
         self.opts["mf"].closeLoop()

=== modified file 'bwl/bc1020.py'
--- bwl/bc1020.py	2014-05-08 17:02:33 +0000
+++ bwl/bc1020.py	2014-10-07 05:53:33 +0000
@@ -46,24 +46,27 @@
             "types":  "fle",
             "initd": os.path.join(self.opts["mf"].rcdic["prgdir"], "img"),
             "ftype":  (("JPG Files", "*.jpg"),)}
-        r1s = (("Yes", "Y"), ("No", "N"))
-        r2s = (("One", "1"), ("Four", "4"))
+        r1s = (("Male", "M"), ("Female", "F"), ("Mixed", "B"))
+        r2s = (("Yes", "Y"), ("No", "N"))
+        r3s = (("One", "1"), ("Four", "4"))
         fld = (
             (("T",0,0,0),"I@bff_code",0,"","",
                 0,"Y",self.doTypCod,typ,None,("efld",)),
             (("T",0,1,0),"I@bff_desc",0,"","",
                 "","N",None,None,self.doDelete,("notblank",)),
-            (("T",0,2,0),("IRB",r1s),0,"Assessment Forms","",
+            (("T",0,2,0),("IRB",r1s),0,"Gender","",
+                "M","N",None,None,None,None),
+            (("T",0,3,0),("IRB",r2s),0,"Assessment Forms","",
                 "N","N",self.doAssess,None,None,None),
-            (("T",0,3,0),("IRB",r2s),0,"Number of Forms","",
+            (("T",0,4,0),("IRB",r3s),0,"Number of Forms","",
                 "1","N",self.doForms,None,None,None),
-            (("T",0,4,0),("IRB",r1s),0,"Assess Self","",
+            (("T",0,5,0),("IRB",r2s),0,"Assess Self","",
                 "Y","N",None,None,None,None),
-            (("T",0,5,0),"I@bff_rate",0,"","",
+            (("T",0,6,0),"I@bff_rate",0,"","",
                 10,"N",None,None,None,("notzero",)),
-            (("T",0,6,0),("IRB",r1s),0,"Sets Format","",
+            (("T",0,7,0),("IRB",r2s),0,"Sets Format","",
                 "N","N",None,None,self.doDelete,None),
-            (("T",0,7,0),"I@bff_logo",0,"","",
+            (("T",0,8,0),"I@bff_logo",0,"","",
                 "","N",self.doLogo,fle,None,None))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
@@ -73,7 +76,7 @@
     def doTypCod(self, frt, pag, r, c, p, i, w):
         if not w:
             self.code = getNextCode(self.sql, "bwlflf", "bff_code",
-                where=[("bff_cono", "=", self.opts["conum"])], last=99)
+                where=[("bff_cono", "=", self.opts["conum"])], last=9)
             self.df.loadEntry(frt, pag, p, data=self.code)
         else:
             self.code = w
@@ -112,10 +115,10 @@
     def doAssess(self, frt, pag, r, c, p, i, w):
         self.assess = w
         if self.assess == "N":
-            self.df.loadEntry(frt, pag, p+1, data="")
-            self.df.loadEntry(frt, pag, p+2, data="")
-            self.df.loadEntry(frt, pag, p+3, data="")
-            self.df.loadEntry(frt, pag, p+4, data="")
+            self.df.loadEntry(frt, pag, p+1, data="4")
+            self.df.loadEntry(frt, pag, p+2, data="N")
+            self.df.loadEntry(frt, pag, p+3, data=0)
+            self.df.loadEntry(frt, pag, p+4, data="N")
             return "sk4"
 
     def doForms(self, frt, pag, r, c, p, i, w):

=== modified file 'bwl/bc1030.py'
--- bwl/bc1030.py	2014-05-08 17:02:33 +0000
+++ bwl/bc1030.py	2014-10-07 04:32:32 +0000
@@ -86,7 +86,8 @@
     def doSide(self, frt, pag, r, c, p, i, w):
         if not w:
             self.side = getNextCode(self.sql, "bwlfls", "bfs_code",
-                where=[("bfs_fmat", "=", self.fmat)], last=999)
+                where=[("bfs_cono", "=", self.opts["conum"]),
+                ("bfs_fmat", "=", self.fmat)], last=999)
             self.df.loadEntry(frt, pag, p, data=self.side)
         else:
             self.side = w
@@ -100,6 +101,13 @@
             for num, fld in enumerate(chk[3:]):
                 self.df.loadEntry(frt, pag, num+3, data=fld)
 
+    def doDesc(self, frt, pag, r, c, p, i, w):
+        chk = self.sql.getRec(tables="bwlflm", where=[("bfm_cono", "=",
+            self.opts["conum"]), ("bfm_fmat", "=", self.fmat), ("bfm_team",
+            "=", self.side)])
+        if chk:
+            return "sk3"
+
     def doDelete(self, widget=None):
         if self.newfls:
             return
@@ -117,13 +125,6 @@
             ("bfs_fmat", "=", self.fmat), ("bfs_code", "=", self.side)])
         self.opts["mf"].dbm.commitDbase()
 
-    def doDesc(self, frt, pag, r, c, p, i, w):
-        chk = self.sql.getRec(tables="bwlflm", where=[("bfm_cono", "=",
-            self.opts["conum"]), ("bfm_fmat", "=", self.fmat), ("bfm_team",
-            "=", self.side)])
-        if chk:
-            return "sk3"
-
     def doEnd(self, widget=None):
         data = [self.opts["conum"], self.fmat] + self.df.t_work[0][0][2:]
         if self.newfls:

=== modified file 'bwl/bc1040.py'
--- bwl/bc1040.py	2014-10-01 14:07:50 +0000
+++ bwl/bc1040.py	2014-10-03 16:05:13 +0000
@@ -2,7 +2,7 @@
 
 """
 SYNOPSIS
-    Competition Player's Maintenance.
+    Competition Types Maintenance.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -13,87 +13,95 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import GetCtl, Sql, TartanDialog
-from tartanFunctions import askQuestion, getNextCode
+from TartanClasses import TartanDialog, Sql
+from tartanFunctions import getNextCode
 
 class bc1040:
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
             self.mainProcess()
-            if "args" in self.opts:
-                self.newskp = True
-                self.newclb = False
-                self.club = None
-                if self.opts["args"][0]:
-                    self.skip = self.opts["args"][0]
-                    self.df.loadEntry("T", 0, 0, data=self.skip)
-                    self.df.focusField("T", 0, 2)
-                else:
-                    self.df.focusField("T", 0, 1)
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlctl", "bwltab", "bwlclb",
-            "bwlent", "bwlgme", "bwlskp"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["bwltyp", "bwlcmp"],
+            prog=__name__)
         if self.sql.error:
             return
-        gc = GetCtl(self.opts["mf"])
-        bwlctl = gc.getCtl("bwlctl", self.opts["conum"])
-        if not bwlctl:
-            return
-        self.mlint = bwlctl["ctb_mlint"]
-        self.mstart = bwlctl["ctb_mstart"]
-        self.fstart = bwlctl["ctb_fstart"]
-        self.nstart = bwlctl["ctb_nstart"]
         return True
 
     def mainProcess(self):
-        tit = ("Player's Maintenance",)
-        skp = {
-            "stype": "R",
-            "tables": ("bwlskp",),
-            "cols": (
-                ("bcs_code", "", 0, "Cod"),
-                ("bcs_tab", "", 0, "Tab-No"),
-                ("bcs_surname", "", 0, "Surname", "Y"),
-                ("bcs_names", "", 0, "Names")),
-            "where": [("bcs_cono", "=", self.opts["conum"])],
-            "order": "bcs_surname"}
-        clb = {
-            "stype": "R",
-            "tables": ("bwlclb",),
-            "cols": (
-                ("bcc_code", "", 0, "Cod"),
-                ("bcc_name", "", 0, "Name", "Y")),
-            "butt": [("New Club", self.doNewClub)],
-            "order": "bcc_name"}
-        r1s = (("Male", "M"), ("Female", "F"))
-        if "args" in self.opts:
-            fld = [(("T",0,0,0),"O@bcs_code",0,"")]
-        else:
-            fld = [(("T",0,0,0),"I@bcs_code",0,"","",
-                "","Y",self.doSkpCod,skp,None,("efld",))]
-        fld.extend([
-            (("T",0,1,0),"I@bcs_surname",0,"","",
-                "","N",self.doSurname,None,self.doDelete,("notblank",)),
-            (("T",0,2,0),"I@bcs_names",0,"","",
-                "","N",self.doNames,None,None,("notblank",)),
-            (("T",0,3,0),("IRB",r1s),0,"Gender","",
-                "M","N",None,None,None,None),
-            (("T",0,4,0),"I@bcs_club",0,"","",
-                "","N",self.doClbCod,clb,None,("efld",)),
-            (("T",0,4,0),"INA",30,"","Club Name",
-                "","N",self.doClbNam,None,None,("notblank",)),
-            (("T",0,5,0),"I@bcs_email",30,"","",
+        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Competition Types Maintenance (%s)" % __name__)
+        typ = {
+            "stype": "R",
+            "tables": ("bwltyp",),
+            "cols": (
+                ("bct_code", "", 0, "Cod"),
+                ("bct_desc", "", 0, "Description", "Y")),
+            "where": [("bct_cono", "=", self.opts["conum"])]}
+        r1s = (("Tournament", "T"), ("Knockout", "K"), ("Round Robin", "R"))
+        r2s = (("Yes", "Y"), ("No", "N"))
+        fld = (
+            (("T",0,0,0),"I@bct_code",0,"","",
+                0,"Y",self.doTypCod,typ,None,("efld",)),
+            (("T",0,1,0),"I@bct_desc",0,"","",
+                "","N",None,None,self.doDelete,("notblank",)),
+            (("T",0,2,0),("IRB",r1s),0,"Competition Format","",
+                "T","N",self.doCFmat,None,None,None),
+            (("T",0,3,0),"I@bct_tsize",0,"","",
+                4,"N",self.doTSize,None,None,("notzero",)),
+            (("T",0,4,0),"I@bct_games",0,"","",
+                0,"N",None,None,None,("notzero",)),
+            (("T",0,5,0),"I@bct_ends",0,"","",
+                21,"N",self.doEnds,None,None,("notzero",)),
+            (("T",0,6,0),("IRB",r2s),0,"Groups by Position","",
+                "N","N",self.doGroups,None,None,None,None,
+                "Yes means that teams will be split into Groups after "\
+                "a certain number of games based on position. No means "\
+                "that teams will not be split into groups"),
+            (("T",0,7,0),"I@bct_grgame",0,"","",
+                0,"N",self.doGrGame,None,None,("efld",)),
+            (("T",0,8,0),("IRB",r2s),0,"Adjust Scores","",
+                "N","N",self.doAdjust,None,None,None),
+            (("T",0,9,0),"I@bct_expunge",0,"","",
                 "","N",None,None,None,("efld",)),
-            (("T",0,6,0),"I@bcs_phone",0,"","",
-                "","N",None,None,None,("efld",))])
-        but = (("Accept",None,self.doEnd,0,("T",0,2),("T",0,0)),)
+            (("T",0,10,0),"I@bct_percent",0,"","",
+                100,"N",None,None,None,("efld",)),
+            (("T",0,11,0),"I@bct_drawn",0,"","",
+                1,"N",self.doDrawn,None,None,("efld",)),
+            (("T",0,12,0),("IRB",r2s),0,"Strict S v S",
+                "Strict Strength v Strength",
+                "N","N",None,None,None,None,None,
+                "Yes means that teams could play against each other, again, "\
+                "in ANY game. No means that teams could only play against "\
+                "each other, again, in the Final game."),
+            (("T",0,13,0),("IRB",r2s),0,"Skins","",
+                "N","N",self.doSkins,None,None,None),
+            (("T",0,14,0),"I@bct_sends",0,"","",
+                0,"N",self.doEndsPerSkin,None,None,("efld",)),
+            (("T",0,15,0),("IRB",r2s),0,"Points Only","",
+                "N","N",self.doOnly,None,None,None,None,
+                "Yes means that No Shots are to be captured and that only "\
+                "Points will be used to determine positions. No means that "\
+                "Shots and Points are to be captured and used to determine "\
+                "positions."),
+            (("T",0,16,0),"I@bct_e_points",0,"","",
+                0,"N",self.doPoints,None,None,("efld",)),
+            (("T",0,17,0),"I@bct_s_points",0,"","",
+                0,"N",None,None,None,("efld",)),
+            (("T",0,18,0),"I@bct_g_points",0,"","",
+                0,"N",None,None,None,("efld",)),
+            (("T",0,19,0),("IRB",r2s),0,"Bonus Points","",
+                "N","N",self.doBonus,None,None,None),
+            (("T",0,20,0),"I@bct_win_by",0,"","",
+                0,"N",None,None,None,("efld",)),
+            (("T",0,21,0),"I@bct_lose_by",0,"","",
+                0,"N",None,None,None,("efld",)))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            eflds=fld, butt=but, tend=tnd, txit=txt, clicks=self.doClick)
+            eflds=fld, tend=tnd, txit=txt, clicks=self.doClick)
 
     def doClick(self, *opts):
         if self.df.col == 1:
@@ -104,128 +112,126 @@
         self.click = opts[0]
         self.df.focusField("T", opts[0][0], opts[0][1] + 1)
 
-    def doSkpCod(self, frt, pag, r, c, p, i, w):
+    def doTypCod(self, frt, pag, r, c, p, i, w):
         self.click = []
         if not w:
-            self.skip = getNextCode(self.sql, "bwlskp", "bcs_code",
-                start=self.nstart)
-            self.df.loadEntry(frt, pag, p, data=self.skip)
+            self.ctype = getNextCode(self.sql, "bwltyp", "bct_code",
+                where=[("bct_cono", "=", self.opts["conum"])], last=99)
+            self.df.loadEntry(frt, pag, p, data=self.ctype)
         else:
-            if self.mlint:
-                tab = self.sql.getRec(tables="bwltab", where=[("btb_cono",
-                "=", self.opts["conum"]), ("btb_tab", "=", w)], limit=1)
-                if tab:
-                    return "Please Use Member Records to Edit"
-            self.skip = w
-        self.newclb = False
-        self.club = None
-        chk = self.sql.getRec(tables="bwlskp", where=[("bcs_cono", "=",
-            self.opts["conum"]), ("bcs_code", "=", self.skip)], limit=1)
+            self.ctype = w
+        chk = self.sql.getRec(tables="bwltyp", where=[("bct_cono", "=",
+            self.opts["conum"]), ("bct_code", "=", self.ctype)], limit=1)
         if not chk:
-            self.newskp = True
-        else:
-            self.newskp = False
-            for num, fld in enumerate(chk[3:]):
-                if num > 3:
-                    pos = num + 2
-                else:
-                    pos = num + 1
-                self.df.loadEntry(frt, pag, pos, data=fld)
-                if num == 3:
-                    self.club = fld
-                    clb = self.sql.getRec(tables="bwlclb",
-                        where=[("bcc_code", "=", fld)], limit=1)
-                    self.df.loadEntry(frt, pag, pos+1, data=clb[1])
-
-    def doSurname(self, frt, pag, r, c, p, i, w):
-        self.sname = w
-
-    def doNames(self, frt, pag, r, c, p, i, w):
-        if self.newskp:
-            chk = self.sql.getRec(tables="bwlskp", where=[("bcs_cono", "=",
-                self.opts["conum"]), ("bcs_surname", "ilike", self.sname,
-                "and", "bcs_names", "ilike", "%s%s" % (w.split()[0], "%"))])
-            if chk:
-                return "A Player with this Name Already Exists"
+            self.newtyp = True
+        else:
+            self.newtyp = False
+            self.cfmat = chk[self.sql.bwltyp_col.index("bct_cfmat")]
+            for num, fld in enumerate(chk[1:]):
+                self.df.loadEntry(frt, pag, num, data=fld)
+        chk = self.sql.getRec(tables="bwlcmp", where=[("bcm_cono", "=",
+            self.opts["conum"]), ("bcm_type", "=", self.ctype)], limit=1)
+        if chk:
+            self.games = True
+        else:
+            self.games = False
 
     def doDelete(self, widget=None):
-        if self.newskp:
+        if self.newtyp:
             return
-        error = False
-        for tab in (("bwlent", "bce_cono", "bce_scod"),
-                    ("bwlgme", "bcg_cono", "bcg_scod")):
-            chk = self.sql.getRec(tables=tab[0], where=[(tab[1], "=",
-                self.opts["conum"]), (tab[2], "=", self.skip)], limit=1)
-            if chk:
-                error = True
-                break
-        if error:
-            return "There are Movements for this Player, Not Deleted"
-        self.sql.delRec("bwlskp", where=[("bcs_cono", "=", self.opts["conum"]),
-            ("bcs_code", "=", self.skip)])
+        if self.games:
+            return "There are Games of this Type, Not Deleted"
+        self.sql.delRec("bwltyp", where=[("bct_cono", "=", self.opts["conum"]),
+            ("bct_code", "=", self.ctype)])
         self.opts["mf"].dbm.commitDbase()
 
-    def doClbCod(self, frt, pag, r, c, p, i, w):
+    def doCFmat(self, frt, pag, r, c, p, i, w):
+        if self.games:
+            self.df.loadEntry(frt, pag, p, data=self.cfmat)
+            return "There are Games of this Type, No Changes Allowed"
+        self.cfmat = w
+
+    def doTSize(self, frt, pag, r, c, p, i, w):
+        self.tsize = w
+        if self.cfmat in ("K", "R"):
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            return "sk1"
+
+    def doEnds(self, frt, pag, r, c, p, i, w):
+        self.ends = w
+        if self.cfmat in ("K", "R"):
+            self.doClearFields(p+1)
+            return "nd"
+
+    def doClearFields(self, start):
+        defaults = [0,"",0,0,0,21,"N",0,"N","",0,0,"N",0,0,0,0,"N",0,0]
+        for p in xrange(start, len(defaults)):
+            self.df.loadEntry("T", 0, p, data=defaults[p])
+
+    def doGroups(self, frt, pag, r, c, p, i, w):
+        self.groups = w
+        if self.groups == "N":
+            self.adjust = "N"
+            self.df.loadEntry(frt, pag, p+1, data="")
+            self.df.loadEntry(frt, pag, p+2, data=self.adjust)
+            self.df.loadEntry(frt, pag, p+3, data="")
+            self.df.loadEntry(frt, pag, p+4, data="")
+            return "sk4"
+
+    def doGrGame(self, frt, pag, r, c, p, i, w):
         if not w:
-            self.club = getNextCode(self.sql, "bwlclb", "bcc_code")
-            self.df.loadEntry(frt, pag, p, data=self.club)
-        elif w == self.opts["conum"]:
-            return "Invalid Club Code"
-        else:
-            self.club = w
-        chk = self.sql.getRec(tables="bwlclb", where=[("bcc_code", "=",
-            self.club)], limit=1)
-        if not chk:
-            ok = askQuestion(self.opts["mf"].body, head="New Club",
-                mess="This Club Code Does Not Exist, Do You Want To Create "\
-                "It?")
-            if ok == "no":
-                return "rf"
-            self.doNewClub(self.club)
-        else:
-            self.newclb = False
-            self.df.loadEntry(frt, pag, p+1, data=chk[1])
-            return "sk1"
-
-    def doNewClub(self, club=None):
-        self.newclb = True
-        if not club:
-            self.club = getNextCode(self.sql, "bwlclb", "bcc_code")
-            self.df.loadEntry("T", 0, 5, data=self.club)
-            self.df.clearEntry("T", 0, 7)
-            self.df.focusField("T", 0, 7)
-        else:
-            self.club = club
-
-    def doClbNam(self, frt, pag, r, c, p, i, w):
-        if not self.club:
-            return "ff6|Invalid Club Code"
+            return "Invalid Game Number"
+
+    def doAdjust(self, frt, pag, r, c, p, i, w):
+        self.adjust = w
+        if self.adjust == "N":
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            self.df.loadEntry(frt, pag, p+2, data=0)
+            return "sk2"
+
+    def doDrawn(self, frt, pag, r, c, p, i, w):
+        if w == self.df.t_work[0][0][4]:
+            self.df.loadEntry(frt, pag, p+1, data="N")
+            return "sk1"
+
+    def doSkins(self, frt, pag, r, c, p, i, w):
+        self.skins = w
+        if self.skins == "N":
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            return "sk1"
+
+    def doEndsPerSkin(self, frt, pag, r, c, p, i, w):
+        if self.ends % w:
+            return "Invalid Ends per Skin, Not Divisible"
+
+    def doOnly(self, frt, pag, r, c, p, i, w):
+        self.only = w
+
+    def doPoints(self, frt, pag, r, c, p, i, w):
+        if self.skins == "N":
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            return "sk1"
+
+    def doBonus(self, frt, pag, r, c, p, i, w):
+        if w == "N":
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            self.df.loadEntry(frt, pag, p+2, data=0)
+            return "nd"
 
     def doEnd(self, widget=None):
         if widget:
             frt, pag, col, mes = self.df.doCheckFields()
             if mes:
-                if col == 6:
-                    self.df.focusField(frt, pag, (col), err=mes)
-                else:
-                    self.df.focusField(frt, pag, (col+1), err=mes)
+                self.df.focusField(frt, pag, (col+1), err=mes)
                 return
-        data = [self.opts["conum"], self.skip, 0]
-        data.extend(self.df.t_work[0][0][1:5])
-        data.extend(self.df.t_work[0][0][6:])
-        if self.newskp:
-            self.sql.insRec("bwlskp", data=data)
+        data = [self.opts["conum"]] + self.df.t_work[0][0]
+        if self.newtyp:
+            self.sql.insRec("bwltyp", data=data)
         else:
-            self.sql.updRec("bwlskp", data=data, where=[("bcs_cono", "=",
-                self.opts["conum"]), ("bcs_code", "=", self.skip)])
-        if self.newclb:
-            self.sql.insRec("bwlclb", data=[self.club,
-                self.df.t_work[0][0][6]])
+            self.sql.updRec("bwltyp", data=data, where=[("bct_cono", "=",
+                self.opts["conum"]), ("bct_code", "=", self.ctype)])
         self.opts["mf"].dbm.commitDbase()
-        if "args" in self.opts:
-            self.doExit()
-        else:
-            self.df.focusField("T", 0, 1)
+        self.df.focusField("T", 0, 1)
 
     def doExit(self):
         self.df.closeProcess()

=== removed file 'bwl/bc1050.py'
--- bwl/bc1050.py	2014-05-28 14:55:12 +0000
+++ bwl/bc1050.py	1970-01-01 00:00:00 +0000
@@ -1,239 +0,0 @@
-#! /usr/bin/python
-
-"""
-SYNOPSIS
-    Competition Types Maintenance.
-
-    This file is part of Tartan Systems (TARTAN).
-
-AUTHOR
-    Written by Paul Malherbe, <paul@tartan.co.za>
-
-COPYING
-    Copyright (C) 2004-2014 Paul Malherbe.
-"""
-
-from TartanClasses import TartanDialog, Sql
-from tartanFunctions import getNextCode
-
-class bc1050:
-    def __init__(self, **opts):
-        self.opts = opts
-        if self.setVariables():
-            self.mainProcess()
-            self.opts["mf"].startLoop()
-
-    def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwltyp", "bwlcmp"],
-            prog=__name__)
-        if self.sql.error:
-            return
-        return True
-
-    def mainProcess(self):
-        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Competition Types Maintenance (%s)" % __name__)
-        typ = {
-            "stype": "R",
-            "tables": ("bwltyp",),
-            "cols": (
-                ("bct_code", "", 0, "Cod"),
-                ("bct_desc", "", 0, "Description", "Y")),
-            "where": [("bct_cono", "=", self.opts["conum"])]}
-        r1s = (("Tournament", "T"), ("Knockout", "K"), ("Round Robin", "R"))
-        r2s = (("Yes", "Y"), ("No", "N"))
-        fld = (
-            (("T",0,0,0),"I@bct_code",0,"","",
-                0,"Y",self.doTypCod,typ,None,("efld",)),
-            (("T",0,1,0),"I@bct_desc",0,"","",
-                "","N",None,None,self.doDelete,("notblank",)),
-            (("T",0,2,0),("IRB",r1s),0,"Competition Format","",
-                "T","N",self.doCFmat,None,None,None),
-            (("T",0,3,0),"I@bct_tsize",0,"","",
-                4,"N",self.doTSize,None,None,("notzero",)),
-            (("T",0,4,0),"I@bct_games",0,"","",
-                0,"N",None,None,None,("notzero",)),
-            (("T",0,5,0),"I@bct_ends",0,"","",
-                21,"N",self.doEnds,None,None,("notzero",)),
-            (("T",0,6,0),("IRB",r2s),0,"Groups by Position","",
-                "N","N",self.doGroups,None,None,None,None,
-                "Yes means that teams will be split into Groups after "\
-                "a certain number of games based on position. No means "\
-                "that teams will not be split into groups"),
-            (("T",0,7,0),"I@bct_grgame",0,"","",
-                0,"N",self.doGrGame,None,None,("efld",)),
-            (("T",0,8,0),("IRB",r2s),0,"Adjust Scores","",
-                "N","N",self.doAdjust,None,None,None),
-            (("T",0,9,0),"I@bct_expunge",0,"","",
-                "","N",None,None,None,("efld",)),
-            (("T",0,10,0),"I@bct_percent",0,"","",
-                100,"N",None,None,None,("efld",)),
-            (("T",0,11,0),"I@bct_drawn",0,"","",
-                1,"N",self.doDrawn,None,None,("efld",)),
-            (("T",0,12,0),("IRB",r2s),0,"Strict S v S",
-                "Strict Strength v Strength",
-                "N","N",None,None,None,None,None,
-                "Yes means that teams could play against each other, again, "\
-                "in ANY game. No means that teams could only play against "\
-                "each other, again, in the Final game."),
-            (("T",0,13,0),("IRB",r2s),0,"Skins","",
-                "N","N",self.doSkins,None,None,None),
-            (("T",0,14,0),"I@bct_sends",0,"","",
-                0,"N",self.doEndsPerSkin,None,None,("efld",)),
-            (("T",0,15,0),("IRB",r2s),0,"Points Only","",
-                "N","N",self.doOnly,None,None,None,None,
-                "Yes means that No Shots are to be captured and that only "\
-                "Points will be used to determine positions. No means that "\
-                "Shots and Points are to be captured and used to determine "\
-                "positions."),
-            (("T",0,16,0),"I@bct_e_points",0,"","",
-                0,"N",self.doPoints,None,None,("efld",)),
-            (("T",0,17,0),"I@bct_s_points",0,"","",
-                0,"N",None,None,None,("efld",)),
-            (("T",0,18,0),"I@bct_g_points",0,"","",
-                0,"N",None,None,None,("efld",)),
-            (("T",0,19,0),("IRB",r2s),0,"Bonus Points","",
-                "N","N",self.doBonus,None,None,None),
-            (("T",0,20,0),"I@bct_win_by",0,"","",
-                0,"N",None,None,None,("efld",)),
-            (("T",0,21,0),"I@bct_lose_by",0,"","",
-                0,"N",None,None,None,("efld",)))
-        tnd = ((self.doEnd,"y"),)
-        txt = (self.doExit,)
-        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            eflds=fld, tend=tnd, txit=txt, clicks=self.doClick)
-
-    def doClick(self, *opts):
-        if self.df.col == 1:
-            return
-        if self.click:
-            self.df.loadEntry("T", self.click[0], self.click[1],
-                data=self.df.t_work[self.click[0]][0][self.click[1]])
-        self.click = opts[0]
-        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
-
-    def doTypCod(self, frt, pag, r, c, p, i, w):
-        self.click = []
-        if not w:
-            self.ctype = getNextCode(self.sql, "bwltyp", "bct_code", last=99)
-            self.df.loadEntry(frt, pag, p, data=self.ctype)
-        else:
-            self.ctype = w
-        chk = self.sql.getRec(tables="bwltyp", where=[("bct_cono", "=",
-            self.opts["conum"]), ("bct_code", "=", self.ctype)], limit=1)
-        if not chk:
-            self.newtyp = True
-        else:
-            self.newtyp = False
-            self.cfmat = chk[self.sql.bwltyp_col.index("bct_cfmat")]
-            for num, fld in enumerate(chk[1:]):
-                self.df.loadEntry(frt, pag, num, data=fld)
-        chk = self.sql.getRec(tables="bwlcmp", where=[("bcm_cono", "=",
-            self.opts["conum"]), ("bcm_type", "=", self.ctype)], limit=1)
-        if chk:
-            self.games = True
-        else:
-            self.games = False
-
-    def doDelete(self, widget=None):
-        if self.newtyp:
-            return
-        if self.games:
-            return "There are Games of this Type, Not Deleted"
-        self.sql.delRec("bwltyp", where=[("bct_cono", "=", self.opts["conum"]),
-            ("bct_code", "=", self.ctype)])
-        self.opts["mf"].dbm.commitDbase()
-
-    def doCFmat(self, frt, pag, r, c, p, i, w):
-        if self.games:
-            self.df.loadEntry(frt, pag, p, data=self.cfmat)
-            return "There are Games of this Type, No Changes Allowed"
-        self.cfmat = w
-
-    def doTSize(self, frt, pag, r, c, p, i, w):
-        self.tsize = w
-        if self.cfmat in ("K", "R"):
-            self.df.loadEntry(frt, pag, p+1, data=0)
-            return "sk1"
-
-    def doEnds(self, frt, pag, r, c, p, i, w):
-        self.ends = w
-        if self.cfmat in ("K", "R"):
-            self.doClearFields(p+1)
-            return "nd"
-
-    def doClearFields(self, start):
-        defaults = [0,"",0,0,0,21,"N",0,"N","",0,0,"N",0,0,0,0,"N",0,0]
-        for p in xrange(start, len(defaults)):
-            self.df.loadEntry("T", 0, p, data=defaults[p])
-
-    def doGroups(self, frt, pag, r, c, p, i, w):
-        self.groups = w
-        if self.groups == "N":
-            self.adjust = "N"
-            self.df.loadEntry(frt, pag, p+1, data="")
-            self.df.loadEntry(frt, pag, p+2, data=self.adjust)
-            self.df.loadEntry(frt, pag, p+3, data="")
-            self.df.loadEntry(frt, pag, p+4, data="")
-            return "sk4"
-
-    def doGrGame(self, frt, pag, r, c, p, i, w):
-        if not w:
-            return "Invalid Game Number"
-
-    def doAdjust(self, frt, pag, r, c, p, i, w):
-        self.adjust = w
-        if self.adjust == "N":
-            self.df.loadEntry(frt, pag, p+1, data=0)
-            self.df.loadEntry(frt, pag, p+2, data=0)
-            return "sk2"
-
-    def doDrawn(self, frt, pag, r, c, p, i, w):
-        if w == self.df.t_work[0][0][4]:
-            self.df.loadEntry(frt, pag, p+1, data="N")
-            return "sk1"
-
-    def doSkins(self, frt, pag, r, c, p, i, w):
-        self.skins = w
-        if self.skins == "N":
-            self.df.loadEntry(frt, pag, p+1, data=0)
-            return "sk1"
-
-    def doEndsPerSkin(self, frt, pag, r, c, p, i, w):
-        if self.ends % w:
-            return "Invalid Ends per Skin, Not Divisible"
-
-    def doOnly(self, frt, pag, r, c, p, i, w):
-        self.only = w
-
-    def doPoints(self, frt, pag, r, c, p, i, w):
-        if self.skins == "N":
-            self.df.loadEntry(frt, pag, p+1, data=0)
-            return "sk1"
-
-    def doBonus(self, frt, pag, r, c, p, i, w):
-        if w == "N":
-            self.df.loadEntry(frt, pag, p+1, data=0)
-            self.df.loadEntry(frt, pag, p+2, data=0)
-            return "nd"
-
-    def doEnd(self, widget=None):
-        if widget:
-            frt, pag, col, mes = self.df.doCheckFields()
-            if mes:
-                self.df.focusField(frt, pag, (col+1), err=mes)
-                return
-        data = [self.opts["conum"]] + self.df.t_work[0][0]
-        if self.newtyp:
-            self.sql.insRec("bwltyp", data=data)
-        else:
-            self.sql.updRec("bwltyp", data=data, where=[("bct_cono", "=",
-                self.opts["conum"]), ("bct_code", "=", self.ctype)])
-        self.opts["mf"].dbm.commitDbase()
-        self.df.focusField("T", 0, 1)
-
-    def doExit(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
-# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bwl/bc2010.py'
--- bwl/bc2010.py	2014-06-14 08:55:57 +0000
+++ bwl/bc2010.py	2014-11-26 10:26:17 +0000
@@ -91,13 +91,13 @@
 from TartanClasses import CCD, GetCtl, PrintDraw, SplashScreen
 from TartanClasses import SelectChoice, Sql, TartanDialog
 from tartanFunctions import askChoice, askQuestion, callModule, getGreens
-from tartanFunctions import projectDate, showError
+from tartanFunctions import getNextCode, projectDate, showError
 
 class bc2010:
     def __init__(self, **opts):
         self.opts = opts
         if not "test" in opts:
-            self.test = None
+            self.opts["test"] = None
         if self.setVariables():
             self.mainProcess()
             self.opts["mf"].startLoop()
@@ -123,9 +123,6 @@
         # Set font as big as possible
         self.dfs = self.opts["mf"].rcdic["dfs"]
         self.doSetFont()
-        # Delete all visitor's tabs
-        self.sql.delRec("bwltab", where=[("btb_cono", "=", self.opts["conum"]),
-            ("btb_tab", ">=", self.nstart)])
         t = time.localtime()
         self.sysdt = ((t[0] * 10000) + (t[1] * 100) + t[2])
         if t[3] >= 12:
@@ -279,15 +276,6 @@
                 if tab:
                     self.alltabs[draw[0]] = [tab[0], tab[1], tab[2], draw[4],
                         draw[5], "Y"]
-                elif draw[0] >= self.nstart:
-                    nam = draw[1].split(", ")
-                    self.sql.insRec("bwltab", data=[self.opts["conum"],
-                        draw[0], 0, nam[0], nam[1], "M", draw[4], draw[5],
-                        draw[4], draw[5], 0, "V"])
-                    self.alltabs[draw[0]] = [nam[0], nam[1], "M", draw[4],
-                        draw[5], "Y"]
-                    if draw[0] > self.lasttab:
-                        self.lasttab = draw[0]
                 else:
                     showError(self.opts["mf"].body, "Missing Tab",
                         "Tab Number %s is Not in the Database" % draw[0])
@@ -485,7 +473,9 @@
                 "Is This a Visitor?", default="no")
             if yn == "yes":
                 self.visitor = True
-                self.tab = self.lasttab + 1
+                self.tab = getNextCode(self.sql, "bwltab", "btb_tab",
+                    where=[("btb_cono", "=", self.opts["conum"])],
+                    start=self.nstart, last=900000)
                 if frt == "T":
                     self.df.loadEntry(frt, pag, p, data=self.tab)
                 else:
@@ -594,9 +584,6 @@
                             self.df.clearFrame("T", 1)
                             return ("T", 1, 1)
         if self.tab in self.alltabs:
-            if self.tab >= self.nstart:
-                self.sql.delRec("bwltab", where=[("btb_cono", "=",
-                    self.opts["conum"]), ("btb_tab", "=", self.tab)])
             del self.alltabs[self.tab]
             self.drawn = False
             self.printed = False
@@ -617,20 +604,20 @@
                 for b in xrange(3, 6):
                     exec "self.df.setWidget(self.df.B%i, 'normal')" % b
                 self.df.focusField("T", 1, 1)
-            elif self.test:
-                if type(self.test) == int and self.test > 20120000:
+            elif self.opts["test"]:
+                if type(self.opts["test"]) == int and self.opts["test"] > 20120000:
                     tabs = self.sql.getRec(tables="bwldrt", cols=["bdt_tab"],
                         where=[("bdt_cono", "=", self.opts["conum"]),
-                        ("bdt_date", "=", self.test)])
-                    self.test = []
+                        ("bdt_date", "=", self.opts["test"])])
+                    self.opts["test"] = []
                     for tab in tabs:
-                        self.test.append(tab[0])
-                if type(self.test) == list:
+                        self.opts["test"].append(tab[0])
+                if type(self.opts["test"]) == list:
                     tabs = self.sql.getRec(tables="bwltab", cols=["btb_tab",
                         "btb_surname", "btb_names", "btb_gender", "btb_pos1",
                         "btb_rate1", "btb_pos2", "btb_rate2"],
                         where=[("btb_cono", "=", self.opts["conum"]),
-                        ("btb_tab", "in", self.test)])
+                        ("btb_tab", "in", self.opts["test"])])
                     for tab in tabs:
                         if self.rating == "Y" and tab[3] == "F":
                             self.alltabs[tab[0]] = tab[1:4] + tab[6:] + ["Y"]
@@ -641,13 +628,13 @@
                         "btb_surname", "btb_names", "btb_gender", "btb_pos1",
                         "btb_rate1", "btb_pos2", "btb_rate2"],
                         where=[("btb_cono", "=", self.opts["conum"])])
-                    d = self.test - len(r)
+                    d = self.opts["test"] - len(r)
                     for x in xrange(d):
                         dat = r[x][:]
                         dat[0] += 300
                         r.append(dat)
                     random.shuffle(r)
-                    for t in xrange(0, self.test):
+                    for t in xrange(0, self.opts["test"]):
                         if self.rating == "Y" and r[t][3] == "F":
                             self.alltabs[r[t][0]] = r[t][1:4]+r[t][6:]+["Y"]
                         else:
@@ -666,9 +653,11 @@
             self.alltabs[self.tab] = self.df.t_work[1][0][1:]
             if self.visitor:
                 data = [self.opts["conum"], self.df.t_work[1][0][0], 0]
-                data.extend(self.df.t_work[1][0][1:6])
-                data.extend(self.df.t_work[1][0][4:6])
-                data.extend([0, "A"])
+                data.extend(self.df.t_work[1][0][1:4])
+                data.extend(["", "", "", "", "", "", "", ""])
+                data.extend(self.df.t_work[1][0][4:6])
+                data.extend(self.df.t_work[1][0][4:6])
+                data.append(0)
                 self.sql.insRec("bwltab", data=data)
                 self.lasttab += 1
             self.drawn = False
@@ -734,8 +723,8 @@
             eflds=fld, tend=((self.doDrawEnd,"y"),), txit=(self.doCancel,),
             butt=but)
         self.opts["mf"].startLoop()
+        self.df.setWidget(self.df.mstFrame, state="show")
         self.df.enableButtonsTags(state)
-        self.df.setWidget(self.df.mstFrame, state="show")
         self.df.focusField("T", 1, 1)
 
     def doCancel(self, widget=None):
@@ -1563,9 +1552,6 @@
             if yn == "no":
                 self.df.focusField(self.df.frt, self.df.pag, self.df.col)
                 return
-        # Delete all temporary tabs
-        self.sql.delRec("bwltab", where=[("btb_cono", "=", self.opts["conum"]),
-            ("btb_tab", ">=", self.nstart)])
         self.df.closeProcess()
         self.doSetFont(self.dfs)
         self.opts["mf"].closeLoop()
@@ -1576,21 +1562,34 @@
         self.opts["mf"].resizeChildren()
 
 if __name__ == "__main__":
+    import getopt
     from TartanClasses import Dbase, MainFrame
     from tartanFunctions import loadRcFile
-    rcdic = loadRcFile("/home/paul/rcf/tartanrc_bwlclb")
+    try:
+        opts, args = getopt.getopt(sys.argv[1:],"d:r:t:")
+    except:
+        print
+        print "Usage: -r rcfile -d use tabs from date -t list of comma separated tabs"
+        print
+        sys.exit()
+    rcfile = None
+    test = 0
+    for o, v in opts:
+        if o == "-r":
+            rcfile = v
+        elif o == "-d":
+            test = int(v)
+        elif o == "-t":
+            test = []
+            for t in v.split(","):
+                test.append(int(t))
+    if not rcfile:
+        sys.exit()
+    rcdic = loadRcFile(rcfile)
     mf = MainFrame(rcdic=rcdic)
     mf.dbm = Dbase(rcdic)
     if not mf.dbm.err:
         mf.dbm.openDbase()
-        if len(sys.argv) == 2:
-            test = int(sys.argv[1])
-        elif len(sys.argv) > 2:
-            test = []
-            for t in sys.argv[1:]:
-                test.append(int(t))
-        else:
-            test = 0
         bc2010(**{"mf": mf, "conum": 1, "conam": "WPCC Bowls", "test": test})
         mf.dbm.closeDbase()
 

=== modified file 'bwl/bc2020.py'
--- bwl/bc2020.py	2014-05-28 14:55:12 +0000
+++ bwl/bc2020.py	2014-10-07 05:47:15 +0000
@@ -13,7 +13,7 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import MyFpdf, TartanDialog, Sql
+from TartanClasses import GetCtl, MyFpdf, TartanDialog, Sql
 from tartanFunctions import askQuestion, dateDiff, doDrawTable, doPrinter
 from tartanFunctions import getModName, getNextCode, showError
 from tartanWork import mthnam
@@ -26,6 +26,11 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
+        gc = GetCtl(self.opts["mf"])
+        bwlctl = gc.getCtl("bwlctl", 1)
+        if not bwlctl:
+            return
+        self.nstart = bwlctl["ctb_nstart"]
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bwlclb", "bwlflf",
             "bwlflm", "bwlflo", "bwltab", "bwlfls", "bwlflt"], prog=__name__)
         if self.sql.error:
@@ -73,14 +78,15 @@
             "where": [("bfo_cono", "=", self.opts["conum"])],
             "whera": [("T", "bfo_fmat", 0, 0)],
             "order": "bfo_desc"}
-        plr = {
+        self.plr = {
             "stype": "R",
             "tables": ("bwltab",),
             "cols": (
                 ("btb_tab", "", 0, "Cod"),
                 ("btb_surname", "", 0, "Surname", "Y"),
                 ("btb_names", "", 0, "Names")),
-            "where": [("btb_cono", "=", self.opts["conum"])]}
+            "where": [],
+            "order": "btb_surname, btb_names"}
         r1s = (("Fixture", "F"), ("Practice", "P"))
         fld = (
             (("T",0,0,0),"I@bfm_fmat",0,"","",
@@ -104,19 +110,19 @@
             (("T",0,7,0),"INA",20," At (H/A/Name)","",
                 "H","N",self.doMPlace,None,None,("efld",)),
             (("T",0,8,0),"I@bfm_captain",0,"","",
-                "","N",self.doCaptain,plr,None,("notzero",)),
+                "","N",self.doCaptain,self.plr,None,("notzero",)),
             (("T",0,8,0),"ONA",30,""),
             (("C",0,0,1),"I@bft_skip",0,"Skp","",
-                "","N",self.doSkip,plr,None,("notzero",)),
+                "","N",self.doSkip,self.plr,None,("notzero",)),
             (("C",0,0,2),"ONA",20,""),
             (("C",0,0,3),"I@bft_player",0,"3rd","",
-                "","N",self.doPlayer,plr,None,("notzero",)),
+                "","N",self.doPlayer,self.plr,None,("notzero",)),
             (("C",0,0,4),"ONA",20,""),
             (("C",0,0,5),"I@bft_player",0,"2nd","",
-                "","N",self.doPlayer,plr,None,("notzero",)),
+                "","N",self.doPlayer,self.plr,None,("notzero",)),
             (("C",0,0,6),"ONA",20,""),
             (("C",0,0,7),"I@bft_player",0,"1st","",
-                "","N",self.doPlayer,plr,None,("notzero",)),
+                "","N",self.doPlayer,self.plr,None,("notzero",)),
             (("C",0,0,8),"ONA",20,""))
         but = (("Quit",None,self.doQuit,1,None,None),)
         tnd = ((self.doEnd,"n"),)
@@ -128,13 +134,19 @@
             cxit=cxt)
 
     def doFmat(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="bwlflf", cols=["bff_desc"],
-            where=[("bff_cono", "=", self.opts["conum"]), ("bff_code", "=",
-            w)], limit=1)
+        acc = self.sql.getRec(tables="bwlflf", where=[("bff_cono", "=",
+            self.opts["conum"]), ("bff_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Format"
         self.fmat = w
-        self.fdes = acc[0].upper()
+        self.fdes = acc[self.sql.bwlflf_col.index("bff_desc")].upper()
+        self.plr["where"] = [
+            ("btb_cono", "=", self.opts["conum"]),
+            ("btb_tab", "<", self.nstart)]
+        if acc[self.sql.bwlflf_col.index("bff_gender")] in ("M", "F"):
+            self.plr["where"].append(("btb_gender", "=",
+                acc[self.sql.bwlflf_col.index("bff_gender")]))
+        self.assess = acc[self.sql.bwlflf_col.index("bff_assess")]
         self.df.loadEntry(frt, pag, p+1, data=self.fdes)
 
     def doType(self, frt, pag, r, c, p, i, w):
@@ -539,7 +551,6 @@
                     (70, 2)), 4),
                 (10, 15, 80, 2))}
         for div in ("Main", "Friendly"):
-            fpdf.add_page()
             whr = [
                 ("bfm_cono", "=", self.opts["conum"]),
                 ("bfm_fmat", "=", self.fmat),
@@ -578,6 +589,7 @@
                 order="bfm_team")
             if not games:
                 continue
+            fpdf.add_page()
             if games[0][0] == 0:
                 h1 = h1.replace("FIXTURE", "PRACTICE")
             totp = 0
@@ -636,13 +648,16 @@
                 cnt += 1
             # Draw trailer
             fpdf.setFont("helvetica", "B", 14)
-            txt = """Please tick your names on the right hand side to indicate availability. If unavailable please inform skips and skips to inform selectors.
+            txt = """Please tick your names on the right hand side to indicate availability. If unavailable please inform skips and skips to inform selectors."""
+            if self.assess == "Y":
+                txt = """%s
 
-Captains (C) are responsible to distribute and return assessment forms, completed and initialled, to a selector.
+Captains (C) are responsible to distribute and return assessment forms, completed and initialled, to a selector.""" % txt
+            txt = """%s
 
 %s
 
-%s""" % (self.pr.t_work[0][0][0], self.pr.t_work[0][0][1])
+%s""" % (txt, self.pr.t_work[0][0][0], self.pr.t_work[0][0][1])
             fpdf.drawText(x=10.0*cw, y=(last+3)*ld, txt=txt, ctyp="M")
         fpdf.output(pdfnam, "F")
         head = "Match Selections for %s" % self.disp

=== modified file 'bwl/bc2030.py'
--- bwl/bc2030.py	2014-05-28 14:55:12 +0000
+++ bwl/bc2030.py	2014-10-07 05:30:24 +0000
@@ -134,6 +134,8 @@
             self.opts["conum"]), ("bff_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Format"
+        if acc[self.sql.bwlflf_col.index("bff_assess")] == "N":
+            return "Assessment Forms Disabled"
         self.fmat = w
         desc = acc[self.sql.bwlflf_col.index("bff_desc")]
         self.forms = acc[self.sql.bwlflf_col.index("bff_forms")]

=== modified file 'bwl/bc2040.py'
--- bwl/bc2040.py	2014-05-28 14:55:12 +0000
+++ bwl/bc2040.py	2014-10-06 16:10:05 +0000
@@ -24,8 +24,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlskp", "bwlclb",
-            "bwlent", "bwltab", "bwltyp", "bwlgme"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwltab", "bwlclb",
+            "bwlent", "bwltyp", "bwlgme"], prog=__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -55,26 +55,26 @@
             "where": [("bct_cono", "=", self.opts["conum"])]}
         sk1 = {
             "stype": "R",
-            "tables": ("bwlskp",),
+            "tables": ("bwltab",),
             "cols": (
-                ("bcs_code", "", 0, "Cod"),
-                ("bcs_surname", "", 0, "Surname", "Y"),
-                ("bcs_names", "", 0, "Names")),
-            "where": [("bcs_cono", "=", self.opts["conum"])],
-            "order": "bcs_surname"}
+                ("btb_tab", "", 0, "Cod"),
+                ("btb_surname", "", 0, "Surname", "Y"),
+                ("btb_names", "", 0, "Names")),
+            "where": [("btb_cono", "=", self.opts["conum"])],
+            "order": "btb_surname"}
         sk2 = {
             "stype": "R",
-            "tables": ("bwlent", "bwlskp"),
+            "tables": ("bwlent", "bwltab"),
             "cols": (
-                ("bcs_code", "", 0, "Cod"),
-                ("bcs_surname", "", 0, "Surame", "Y"),
-                ("bcs_names", "", 0, "Names"),
+                ("btb_tab", "", 0, "Cod"),
+                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_names", "", 0, "Names"),
                 ("bce_paid", "", 0, "P")),
             "where": [
-                ("bcs_cono", "=", self.opts["conum"]),
-                ("bcs_code=bce_scod",)],
+                ("btb_cono", "=", self.opts["conum"]),
+                ("btb_tab=bce_scod",)],
             "whera": [("T", "bce_ccod", 0, 0)],
-            "order": "bcs_surname",
+            "order": "btb_surname",
             "butt": [("Print", self.doPrint)]}
         fld = (
             (("T",0,0,0),"I@bcm_code",0,"Code","Competition Code",
@@ -85,11 +85,11 @@
                 "","N",None,None,None,("efld",)),
             (("T",0,0,0),"I@bcm_type",0,"Type","",
                 "","N",self.doCmpTyp,typ,None,("efld",)),
-            (("C",0,0,0),"I@bcs_code",0,"Skip","",
+            (("C",0,0,0),"I@btb_tab",0,"Skip","",
                 "","Y",self.doSkpCod,sk1,None,("efld",)),
             (("C",0,0,1),"ONA",30,"Name","",
                 "","N",None,None,None,("notblank",)),
-            (("C",0,0,2),"I@bcs_code",0,"Lead","",
+            (("C",0,0,2),"I@btb_tab",0,"Lead","",
                 "","n",self.doSkpCod,sk1,self.doDelSkp,("efld",)),
             (("C",0,0,3),"ONA",30,"Name","",
                 "","N",None,None,None,("notblank",)),
@@ -107,7 +107,8 @@
         self.skips = []
         self.parts = []
         if not w:
-            self.ccod = getNextCode(self.sql, "bwlcmp", "bcm_code", last=99)
+            self.ccod = getNextCode(self.sql, "bwlcmp", "bcm_code",
+                where=[("bcm_cono", "=", self.opts["conum"])], last=999)
             self.df.loadEntry(frt, pag, p, data=self.ccod)
         else:
             self.ccod = w
@@ -157,15 +158,13 @@
 
     def doSkpCod(self, frt, pag, r, c, p, i, w):
         if not w:
-            ok = askQuestion(self.opts["mf"].body, head="New Player",
-                mess="Is This a New Player?", default="yes")
+            ok = askQuestion(self.opts["mf"].body, head="New Non-Member",
+                mess="Is This a New Non-Member Player?", default="yes")
             if ok == "no":
-                return "Invalid Code"
-            cod = getNextCode(self.sql, "bwlskp", "bcs_code",
-                start=self.nstart, last=999)
-            callModule(self.opts["mf"], self.df, "bc1040",
-                coy=[self.opts["conum"], self.opts["conam"]],
-                args=(cod,))
+                return "Invalid Skip Code"
+            cod = self.doNewCode()
+            if not cod:
+                return "Invalid Skip Code"
             self.df.loadEntry(frt, pag, p, data=cod)
         else:
             cod = w
@@ -179,18 +178,11 @@
                 return "Invalid Partner, Already a Skip"
             self.parts.append(cod)
             self.pcod = cod
-        chk = self.sql.getRec(tables="bwlskp", cols=["bcs_surname",
-            "bcs_names"], where=[("bcs_cono", "=", self.opts["conum"]),
-            ("bcs_code", "=", self.scod)], limit=1)
+        chk = self.sql.getRec(tables="bwltab", cols=["btb_surname",
+            "btb_names"], where=[("btb_cono", "=", self.opts["conum"]),
+            ("btb_tab", "=", self.scod)], limit=1)
         if not chk:
-            tab = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
-                self.opts["conum"]), ("btb_tab", "=", self.scod)], limit=1)
-            if tab:
-                data = tab[:2]+[tab[1]]+tab[3:6]+[self.opts["conum"]]+["", ""]
-                self.sql.insRec("bwlskp", data=data)
-                chk = tab[3:5]
-            else:
-                return "Invalid Player Code"
+            return "Invalid Player Code"
         self.df.loadEntry(frt, pag, p+1, data=self.getName(chk))
         if i == 0:
             ent = self.sql.getRec(tables="bwlent", cols=["bce_pcod",
@@ -200,9 +192,9 @@
             if ent:
                 self.newent = False
                 if ent[0]:
-                    ptr = self.sql.getRec(tables="bwlskp", cols=["bcs_surname",
-                        "bcs_names"], where=[("bcs_cono", "=",
-                        self.opts["conum"]), ("bcs_code", "=", ent[0])],
+                    ptr = self.sql.getRec(tables="bwltab", cols=["btb_surname",
+                        "btb_names"], where=[("btb_cono", "=",
+                        self.opts["conum"]), ("btb_tab", "=", ent[0])],
                         limit=1)
                     self.df.loadEntry(frt, pag, p+2, data=ent[0])
                     self.df.loadEntry(frt, pag, p+3, data=self.getName(ptr))
@@ -215,6 +207,51 @@
                 self.pcod = 0
                 return "sk3"
 
+    def doNewCode(self):
+        tit = ("New Player",)
+        r1s = (("Male","M"), ("Female","F"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Gender","",
+                "M","Y",None,None,None,None),
+            (("T",0,1,0),"I@btb_surname",0,"","",
+                "","Y",None,None,None,("notblank",)),
+            (("T",0,2,0),"I@btb_names",0,"","",
+                "","Y",None,None,None,("notblank",)),
+            (("T",0,3,0),"I@btb_home",0,"","",
+                "","Y",None,None,None,("efld",)),
+            (("T",0,4,0),"I@btb_work",0,"","",
+                "","Y",None,None,None,("efld",)),
+            (("T",0,5,0),"I@btb_cell",0,"","",
+                "","Y",None,None,None,("efld",)),
+            (("T",0,6,0),"I@btb_mail",0,"","",
+                "","Y",None,None,None,("efld",)))
+        state = self.df.disableButtonsTags()
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.ns = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
+            tend=((self.doNEnd,"y"),), txit=(self.doNExit,))
+        self.opts["mf"].startLoop()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state)
+        return self.newcod
+
+    def doNEnd(self):
+        self.ns.closeProcess()
+        self.newcod = getNextCode(self.sql, "bwltab", "btb_tab",
+            where=[("btb_cono", "=", self.opts["conum"])],
+            start=self.nstart, last=900000)
+        data = [self.opts["conum"], self.newcod, 0]
+        data.extend(self.ns.t_work[0][0][1:3])
+        data.extend([self.ns.t_work[0][0][0], "", "", "", ""])
+        data.extend(self.ns.t_work[0][0][3:])
+        data.extend([0, 0, 0, 0, 0])
+        self.sql.insRec("bwltab", data=data)
+        self.opts["mf"].closeLoop()
+
+    def doNExit(self):
+        self.ns.closeProcess()
+        self.newcod = None
+        self.opts["mf"].closeLoop()
+
     def getName(self, chk):
         name = "%s," % chk[0]
         init = chk[1].split()
@@ -278,11 +315,11 @@
     def doPrint(self, widget=None):
         self.df.setWidget(self.df.mstFrame, state="hide")
         hdr = ["Skips Entered for the %s" % self.cmpnam]
-        tab = ["bwlent", "bwlskp"]
-        col = ["bcs_code", "bcs_surname", "bcs_names", "bcs_phone",
-            ["bcs_email", "TX", 30, "Email-Address"], "bce_paid"]
-        whr = [("bce_ccod", "=", self.ccod), ("bcs_code=bce_scod",)]
-        odr = "bcs_surname"
+        tab = ["bwlent", "bwltab"]
+        col = ["btb_tab", "btb_surname", "btb_names", "btb_cell",
+            ["btb_mail", "TX", 30, "Email-Address"], "bce_paid"]
+        whr = [("bce_ccod", "=", self.ccod), ("btb_tab=bce_scod",)]
+        odr = "btb_surname"
         RepPrt(self.opts["mf"], name=__name__, heads=hdr, tables=tab, cols=col,
             where=whr, order=odr, prtdia=(("Y","V"),("Y","N")))
         self.df.setWidget(self.df.mstFrame, state="show")

=== modified file 'bwl/bc2050.py'
--- bwl/bc2050.py	2014-10-01 14:07:50 +0000
+++ bwl/bc2050.py	2014-10-03 14:52:09 +0000
@@ -40,7 +40,7 @@
     def setVariables(self):
         t = time.localtime()
         self.today = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwlskp",
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwltab",
             "bwltyp", "bwlrnd", "bwlent", "tplmst"], prog=__name__)
         if self.sql.error:
             return
@@ -935,17 +935,17 @@
         tit = ("Seeded Players",)
         skp = {
             "stype": "R",
-            "tables": ("bwlent", "bwlskp"),
+            "tables": ("bwlent", "bwltab"),
             "cols": (
-                ("bcs_code", "", 0, "S-Code"),
-                ("bcs_surname", "", 0, "Surname","Y"),
-                ("bcs_names", "", 0, "Names")),
+                ("btb_tab", "", 0, "S-Code"),
+                ("btb_surname", "", 0, "Surname","Y"),
+                ("btb_names", "", 0, "Names")),
             "where": [
                 ("bce_cono", "=", self.opts["conum"]),
                 ("bce_ccod", "=", self.ccod),
-                ("bcs_cono=bce_cono",),
-                ("bcs_code=bce_scod",)],
-            "order": "bcs_surname, bcs_names"}
+                ("btb_cono=bce_cono",),
+                ("btb_tab=bce_scod",)],
+            "order": "btb_surname, btb_names"}
         fld = (
             (("T",0,0,0),"IUI",2,"Number of Seeds","",
                 0,"N",self.doSeedNum,None,None,("efld",)),
@@ -1014,10 +1014,10 @@
         self.showSeeds()
 
     def doSeedTab(self, frt, pag, r, c, p, i, w):
-        chk = self.sql.getRec(tables=["bwlent", "bwlskp"], cols=["bcs_surname",
-            "bcs_names"], where=[("bce_cono", "=", self.opts["conum"]),
+        chk = self.sql.getRec(tables=["bwlent", "bwltab"], cols=["btb_surname",
+            "btb_names"], where=[("bce_cono", "=", self.opts["conum"]),
             ("bce_ccod", "=", self.ccod), ("bce_scod", "=", w),
-            ("bcs_cono=bce_cono",), ("bcs_code=bce_scod",)], limit=1)
+            ("btb_cono=bce_cono",), ("btb_tab=bce_scod",)], limit=1)
         if not chk:
             return "Not a Valid Entered Tab"
         seeds = []
@@ -1273,9 +1273,9 @@
     def getSkip(self, skip, seed):
         if skip > 900000:
             return "Bye"
-        skp = self.sql.getRec(tables="bwlskp", cols=["bcs_surname",
-            "bcs_names"], where=[("bcs_cono", "=", self.opts["conum"]),
-            ("bcs_code", "=", skip)], limit=1)
+        skp = self.sql.getRec(tables="bwltab", cols=["btb_surname",
+            "btb_names"], where=[("btb_cono", "=", self.opts["conum"]),
+            ("btb_tab", "=", skip)], limit=1)
         name = "%s, %s" % (skp[0], skp[1][0])
         if seed:
             name = "%s (%s)" % (name, seed)
@@ -1297,21 +1297,21 @@
             ("bcg_cono", "=", self.opts["conum"]),
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "=", self.game),
-            ("bcs_code=bcg_scod",)]
+            ("btb_tab=bcg_scod",)]
         self.fpdf = MyFpdf(name=__name__, head=65)
         self.pglin = 999
         lastg = None
         for g in grp:
             where = whr[:]
             if self.game <= self.grgame:
-                recs = self.sql.getRec(tables=["bwlgme", "bwlskp"],
-                    cols=["bcs_code", "bcs_surname", "bcs_names", "bcg_ocod",
-                    "bcg_rink"], where=where, order="bcs_surname, bcs_names")
+                recs = self.sql.getRec(tables=["bwlgme", "bwltab"],
+                    cols=["btb_tab", "btb_surname", "btb_names", "bcg_ocod",
+                    "bcg_rink"], where=where, order="btb_surname, btb_names")
             else:
                 where.append(("bcg_group", "=", g[0]))
-                recs = self.sql.getRec(tables=["bwlgme", "bwlskp"],
-                    cols=["bcs_code", "bcs_surname", "bcs_names", "bcg_ocod",
-                    "bcg_rink"], where=where, order="bcs_surname, bcs_names")
+                recs = self.sql.getRec(tables=["bwlgme", "bwltab"],
+                    cols=["btb_tab", "btb_surname", "btb_names", "bcg_ocod",
+                    "bcg_rink"], where=where, order="btb_surname, btb_names")
             for skp in recs:
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading()
@@ -1323,9 +1323,9 @@
                 if self.cfmat == "R" and skp[3] == 900001:
                     opp = [900001, "** Bye **", ""]
                 else:
-                    opp = self.sql.getRec(tables="bwlskp", cols=["bcs_code",
-                        "bcs_surname", "bcs_names"], where=[("bcs_cono", "=",
-                        self.opts["conum"]), ("bcs_code", "=", skp[3])],
+                    opp = self.sql.getRec(tables="bwltab", cols=["btb_tab",
+                        "btb_surname", "btb_names"], where=[("btb_cono", "=",
+                        self.opts["conum"]), ("btb_tab", "=", skp[3])],
                         limit=1)
                 a = CCD("%s, %s" % (skp[1], skp[2].split()[0]), "NA", 30)
                 b = CCD(skp[4], "UA", 2)
@@ -1450,12 +1450,12 @@
                         self.form.newdic[fld][bdr] = "TLRB"
         for rec in skips:
             self.form.add_page()
-            skp = self.sql.getRec(tables="bwlskp", cols=["bcs_code",
-                "bcs_surname", "bcs_names"], where=[("bcs_cono", "=",
-                self.opts["conum"]), ("bcs_code", "=", rec[0])], limit=1)
-            opp = self.sql.getRec(tables="bwlskp", cols=["bcs_code",
-                "bcs_surname", "bcs_names"], where=[("bcs_cono", "=",
-                self.opts["conum"]), ("bcs_code", "=", rec[1])], limit=1)
+            skp = self.sql.getRec(tables="bwltab", cols=["btb_tab",
+                "btb_surname", "btb_names"], where=[("btb_cono", "=",
+                self.opts["conum"]), ("btb_tab", "=", rec[0])], limit=1)
+            opp = self.sql.getRec(tables="bwltab", cols=["btb_tab",
+                "btb_surname", "btb_names"], where=[("btb_cono", "=",
+                self.opts["conum"]), ("btb_tab", "=", rec[1])], limit=1)
             grn = rec[2]
             if "skip_C00" in self.form.newdic:
                 self.form.newdic["skip_C00"][txt] = self.getName(skp)

=== modified file 'bwl/bc2060.py'
--- bwl/bc2060.py	2014-05-28 14:55:12 +0000
+++ bwl/bc2060.py	2014-10-03 14:54:33 +0000
@@ -27,7 +27,7 @@
     def setVariables(self):
         t = time.localtime()
         self.today = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlskp", "bwlgme"],
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwltab", "bwlgme"],
             prog=__name__)
         if self.sql.error:
             return
@@ -46,22 +46,22 @@
             "where": [("bcm_cono", "=", self.opts["conum"])]}
         skp = {
             "stype": "R",
-            "tables": ("bwlskp", "bwlgme"),
+            "tables": ("bwltab", "bwlgme"),
             "cols": (
-                ("bcs_code", "", 0, "Cod"),
-                ("bcs_surname", "", 0, "Surame", "Y"),
-                ("bcs_names", "", 0, "Names"),
+                ("btb_tab", "", 0, "Cod"),
+                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_names", "", 0, "Names"),
                 ("bcg_rink", "", 0, "RK"),
                 ("bcg_ocod", "", 0, "Opp")),
             "where": [
-                ("bcs_cono", "=", self.opts["conum"]),
-                ("bcg_cono=bcs_cono",),
-                ("bcg_scod=bcs_code",)],
+                ("btb_cono", "=", self.opts["conum"]),
+                ("bcg_cono=btb_cono",),
+                ("bcg_scod=btb_tab",)],
             "whera": [
                 ("T", "bcg_ccod", 0, 0),
                 ("T", "bcg_game", 2, 0)],
-            "group": "bcs_code",
-            "order": "bcs_code"}
+            "group": "btb_tab",
+            "order": "btb_tab"}
         fld = (
             (("T",0,0,0),"I@bcm_code",0,"","",
                 "","Y",self.doCmpCod,com,None,("notzero",)),
@@ -164,11 +164,11 @@
             return "Not Enough Rinks"
 
     def doSkpCod(self, frt, pag, r, c, p, i, w):
-        skp = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=["bcs_surname",
-            "bcs_names", "bcg_ocod", "bcg_rink"], where=[("bcg_cono", "=",
+        skp = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=["btb_surname",
+            "btb_names", "bcg_ocod", "bcg_rink"], where=[("bcg_cono", "=",
             self.opts["conum"]), ("bcg_ccod", "=", self.ccod), ("bcg_scod",
-            "=", w), ("bcg_game", "=", self.game), ("bcs_cono=bcg_cono",),
-            ("bcs_code=bcg_scod",)], limit=1)
+            "=", w), ("bcg_game", "=", self.game), ("btb_cono=bcg_cono",),
+            ("btb_tab=bcg_scod",)], limit=1)
         if not skp:
             return "Invalid Skip Code"
         self.skip = w
@@ -178,20 +178,20 @@
         self.df.loadEntry(frt, pag, p+1, data=name)
         if self.old_opp:
             self.df.loadEntry(frt, pag, p+2, data=self.old_opp)
-            opp = self.sql.getRec(tables="bwlskp", cols=["bcs_surname",
-                "bcs_names"], where=[("bcs_cono", "=", self.opts["conum"]),
-                ("bcs_code", "=", skp[2])], limit=1)
+            opp = self.sql.getRec(tables="bwltab", cols=["btb_surname",
+                "btb_names"], where=[("btb_cono", "=", self.opts["conum"]),
+                ("btb_tab", "=", skp[2])], limit=1)
             name = "%s, %s" % tuple(opp[:2])
             self.df.loadEntry(frt, pag, p+3, data=name)
         if self.old_rink:
             self.df.loadEntry(frt, pag, p+4, data=self.old_rink)
 
     def doOppCod(self, frt, pag, r, c, p, i, w):
-        opp = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=["bcs_surname",
-            "bcs_names", "bcg_ocod", "bcg_rink"], where=[("bcg_cono", "=",
+        opp = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=["btb_surname",
+            "btb_names", "bcg_ocod", "bcg_rink"], where=[("bcg_cono", "=",
             self.opts["conum"]), ("bcg_ccod", "=", self.ccod), ("bcg_scod",
-            "=", w), ("bcg_game", "=", self.game), ("bcs_cono=bcg_cono",),
-            ("bcs_code=bcg_scod",)], limit=1)
+            "=", w), ("bcg_game", "=", self.game), ("btb_cono=bcg_cono",),
+            ("btb_tab=bcg_scod",)], limit=1)
         if not opp:
             return "Invalid Opponents Code"
         self.new_opp = w

=== modified file 'bwl/bc2070.py'
--- bwl/bc2070.py	2014-10-01 14:07:50 +0000
+++ bwl/bc2070.py	2014-10-06 09:05:04 +0000
@@ -24,7 +24,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlskp", "bwlent",
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwltab", "bwlent",
             "bwltyp", "bwlgme"], prog=__name__)
         if self.sql.error:
             return
@@ -53,19 +53,19 @@
             "group": "bcg_game"}
         skp = {
             "stype": "R",
-            "tables": ("bwlent", "bwlskp", "bwlgme"),
+            "tables": ("bwlent", "bwltab", "bwlgme"),
             "cols": (
-                ("bcs_code", "", 0, "Cod"),
-                ("bcs_surname", "", 0, "Surame", "Y"),
-                ("bcs_names", "", 0, "Names"),
+                ("btb_tab", "", 0, "Cod"),
+                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_names", "", 0, "Names"),
                 ("bcg_rink", "", 0, "RK"),
                 ("bcg_shots_for", "", 0, "For"),
                 ("bcg_shots_agt", "", 0, "Agt"),
                 ("bcg_points", "", 0, "Pts")),
             "where": [
                 ("bce_cono", "=", self.opts["conum"]),
-                ("bcs_cono=bce_cono",),
-                ("bcs_code=bce_scod",),
+                ("btb_cono=bce_cono",),
+                ("btb_tab=bce_scod",),
                 ("bcg_cono=bce_cono",),
                 ("bcg_scod=bce_scod",),
                 ("bcg_shots_for=0 and bcg_shots_agt=0",)],
@@ -137,7 +137,7 @@
         self.lose_by = [dif, dif * -1]
         chk = self.sql.getRec(tables="bwlgme", cols=["bcg_game",
             "sum(bcg_points)"], where=[("bcg_cono", "=", self.opts["conum"]),
-            ("bcg_ccod", "=", self.ccod), ("bcg_aflag", "=", "")],
+            ("bcg_ccod", "=", self.ccod), ("bcg_aflag", "in", ("", "D"))],
             group="bcg_game", order="bcg_game")
         for game in chk:
             self.gcod = game[0]
@@ -208,11 +208,11 @@
             self.totpts = self.totpts + ((w / self.sends) * self.spts)
 
     def doSkpCod(self, frt, pag, r, c, p, i, w):
-        chk = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=["bcs_surname",
-            "bcs_names", "bcg_ocod", "bcg_shots_for", "bcg_shots_agt",
+        chk = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=["btb_surname",
+            "btb_names", "bcg_ocod", "bcg_shots_for", "bcg_shots_agt",
             "bcg_points", "bcg_aflag"], where=[("bcg_cono", "=",
             self.opts["conum"]), ("bcg_ccod", "=", self.ccod), ("bcg_scod",
-            "=", w), ("bcg_game", "=", self.gcod), ("bcs_code=bcg_scod",)],
+            "=", w), ("bcg_game", "=", self.gcod), ("btb_tab=bcg_scod",)],
             limit=1)
         if not chk:
             return "Invalid Skip Code"
@@ -236,11 +236,11 @@
             self.df.loadEntry(frt, pag, p+2, data=chk[3])
         self.df.loadEntry(frt, pag, p+3, data=chk[5])
         self.df.loadEntry(frt, pag, p+4, data=self.opp)
-        chk = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=["bcs_surname",
-            "bcs_names", "bcg_shots_for", "bcg_shots_agt", "bcg_points"],
+        chk = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=["btb_surname",
+            "btb_names", "bcg_shots_for", "bcg_shots_agt", "bcg_points"],
             where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
             self.ccod), ("bcg_scod", "=", self.opp), ("bcg_game", "=",
-            self.gcod), ("bcs_code=bcg_scod",)], limit=1)
+            self.gcod), ("btb_tab=bcg_scod",)], limit=1)
         name = "%s, %s" % (chk[0], chk[1])
         self.df.loadEntry(frt, pag, p+5, data=name)
         if self.only == "N":
@@ -281,9 +281,9 @@
         if i == 3:
             self.p_for = w
             self.df.loadEntry(frt, pag, p+1, data=self.opp)
-            chk = self.sql.getRec(tables=["bwlskp"], cols=["bcs_surname",
-                "bcs_names"], where=[("bcs_cono", "=", self.opts["conum"]),
-                ("bcs_code", "=", self.opp)], limit=1)
+            chk = self.sql.getRec(tables=["bwltab"], cols=["btb_surname",
+                "btb_names"], where=[("btb_cono", "=", self.opts["conum"]),
+                ("btb_tab", "=", self.opp)], limit=1)
             name = "%s, %s" % tuple(chk)
             self.df.loadEntry(frt, pag, p+2, data=name)
             if self.only == "Y":
@@ -352,22 +352,22 @@
             if rec[0] in skips:
                 continue
             skips.extend(rec)
-            skp = self.sql.getRec(tables=["bwlgme", "bwlskp"],
-                cols=["bcs_surname", "bcs_names", "bcg_shots_for",
+            skp = self.sql.getRec(tables=["bwlgme", "bwltab"],
+                cols=["btb_surname", "btb_names", "bcg_shots_for",
                 "bcg_points"], where=[("bcg_cono", "=", self.opts["conum"]),
                 ("bcg_ccod", "=", self.ccod), ("bcg_scod", "=", rec[0]),
-                ("bcg_game", "=", self.gcod), ("bcs_code=bcg_scod",)], limit=1)
+                ("bcg_game", "=", self.gcod), ("btb_tab=bcg_scod",)], limit=1)
             idx = seq * 8
             self.df.loadEntry("C", 0, idx, data=rec[0])
             name = "%s, %s" % tuple(skp[:2])
             self.df.loadEntry("C", 0, idx+1, data=name)
             self.df.loadEntry("C", 0, idx+2, data=skp[2])
             self.df.loadEntry("C", 0, idx+3, data=skp[3])
-            opp = self.sql.getRec(tables=["bwlgme", "bwlskp"],
-                cols=["bcs_surname", "bcs_names", "bcg_shots_for",
+            opp = self.sql.getRec(tables=["bwlgme", "bwltab"],
+                cols=["btb_surname", "btb_names", "bcg_shots_for",
                 "bcg_points"], where=[("bcg_cono", "=", self.opts["conum"]),
                 ("bcg_ccod", "=", self.ccod), ("bcg_scod", "=", rec[1]),
-                ("bcg_game", "=", self.gcod), ("bcs_code=bcg_scod",)], limit=1)
+                ("bcg_game", "=", self.gcod), ("btb_tab=bcg_scod",)], limit=1)
             self.df.loadEntry("C", 0, idx+4, data=rec[1])
             name = "%s, %s" % tuple(opp[:2])
             self.df.loadEntry("C", 0, idx+5, data=name)
@@ -381,7 +381,7 @@
         if self.df.frt == "C" and self.df.col != 1:
             chk = self.sql.getRec(tables="bwlgme", where=[("bcg_cono", "=",
                 self.opts["conum"]), ("bcg_ccod", "=", self.ccod), ("bcg_game",
-                "=", self.gcod), ("bcg_aflag", "=", "")])
+                "=", self.gcod), ("bcg_aflag", "in", ("", "D"))])
             for c in chk:
                 scod = c[self.sql.bwlgme_col.index("bcg_scod")]
                 ocod = c[self.sql.bwlgme_col.index("bcg_ocod")]

=== modified file 'bwl/bc3030.py'
--- bwl/bc3030.py	2014-05-28 14:55:12 +0000
+++ bwl/bc3030.py	2014-10-07 05:31:18 +0000
@@ -68,11 +68,10 @@
             self.opts["conum"]), ("bff_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Format"
+        if acc[self.sql.bwlflf_col.index("bff_assess")] == "N":
+            return "Assessment Forms Disabled"
         self.fmat = w
         desc = acc[self.sql.bwlflf_col.index("bff_desc")]
-        self.assess = acc[self.sql.bwlflf_col.index("bff_assess")]
-        if self.assess == "N":
-            return "Assessment Forms Disabled"
         self.forms = acc[self.sql.bwlflf_col.index("bff_forms")]
         self.self = acc[self.sql.bwlflf_col.index("bff_self")]
         self.rate = acc[self.sql.bwlflf_col.index("bff_rate")]

=== modified file 'bwl/bc3050.py'
--- bwl/bc3050.py	2014-05-28 14:55:12 +0000
+++ bwl/bc3050.py	2014-10-07 05:34:01 +0000
@@ -65,14 +65,15 @@
             eflds=fld, tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
 
     def doFmat(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="bwlflf", cols=["bff_desc", "bff_forms"],
-            where=[("bff_cono", "=", self.opts["conum"]), ("bff_code", "=",
-            w)], limit=1)
+        acc = self.sql.getRec(tables="bwlflf", where=[("bff_cono", "=",
+            self.opts["conum"]), ("bff_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Format"
+        if acc[self.sql.bwlflf_col.index("bff_assess")] == "N":
+            return "Assessment Forms Disabled"
         self.fmat = w
-        self.fnam = acc[0]
-        self.forms = acc[1]
+        self.fnam = acc[self.sql.bwlflf_col.index("bff_desc")]
+        self.forms = acc[self.sql.bwlflf_col.index("bff_forms")]
         self.df.loadEntry(frt, pag, p+1, data=self.fnam)
 
     def doType(self, frt, pag, r, c, p, i, w):

=== modified file 'bwl/bc3060.py'
--- bwl/bc3060.py	2014-05-08 17:02:33 +0000
+++ bwl/bc3060.py	2014-10-07 05:40:49 +0000
@@ -63,14 +63,15 @@
             eflds=fld, tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
 
     def doFmat(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="bwlflf", cols=["bff_desc", "bff_forms"],
-            where=[("bff_cono", "=", self.opts["conum"]), ("bff_code", "=",
-            w)], limit=1)
+        acc = self.sql.getRec(tables="bwlflf", where=[("bff_cono", "=",
+            self.opts["conum"]), ("bff_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Format"
+        if acc[self.sql.bwlflf_col.index("bff_assess")] == "N":
+            return "Assessment Forms Disabled"
         self.fmat = w
-        self.fnam = acc[0]
-        self.forms = acc[1]
+        self.fnam = acc[self.sql.bwlflf_col.index("bff_desc")]
+        self.forms = acc[self.sql.bwlflf_col.index("bff_forms")]
         self.df.loadEntry(frt, pag, p+1, data=self.fnam)
 
     def doType(self, frt, pag, r, c, p, i, w):

=== modified file 'bwl/bc3070.py'
--- bwl/bc3070.py	2014-05-08 17:02:33 +0000
+++ bwl/bc3070.py	2014-10-06 08:47:44 +0000
@@ -25,7 +25,7 @@
         self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlent", "bwlskp"],
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlent", "bwltab"],
             prog=__name__)
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
@@ -46,7 +46,7 @@
         fld = (
             (("T",0,0,0),"I@bcm_code",0,"","",
                 "","N",self.doCmpCod,com,None,("notzero",)),
-            (("T",0,0,0),"O@bcm_name",0,""))
+            (("T",0,0,0),"ONA",30,""))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
@@ -64,16 +64,14 @@
 
     def doEnd(self):
         self.df.closeProcess()
-        col = ["bcs_surname", "bcs_names", "bcc_name", "bcs_email",
-            "bcs_phone"]
+        col = ["btb_surname", "btb_names", "btb_cell", "btb_mail"]
         whr=[
             ("bce_cono", "=", self.opts["conum"]),
             ("bce_ccod", "=", self.ccod),
-            ("bcs_cono=bce_cono",),
-            ("bcs_code=bce_scod",),
-            ("bcc_code=bcs_club",)]
-        recs = self.sql.getRec(tables=["bwlent", "bwlskp", "bwlclb"], cols=col,
-            where=whr, order="bcs_surname")
+            ("btb_cono=bce_cono",),
+            ("btb_tab=bce_scod",)]
+        recs = self.sql.getRec(tables=["bwlent", "bwltab"], cols=col,
+            where=whr, order="btb_surname")
         if recs:
             self.fpdf = MyFpdf(prog=__name__)
             self.fpdf.header = self.header
@@ -85,8 +83,7 @@
                 nm = rec[0].strip() + ", %s" % rec[1].split()[0]
                 self.fpdf.drawText(txt=nm, w=cwth*31, h=5, ln=0)
                 self.fpdf.drawText(txt=rec[2], w=cwth*16, h=5, ln=0)
-                self.fpdf.drawText(txt=rec[3], w=cwth*41, h=5, ln=0)
-                self.fpdf.drawText(txt=rec[4], w=cwth*16, h=5, ln=1)
+                self.fpdf.drawText(txt=rec[3], w=cwth*41, h=5, ln=1)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
@@ -103,8 +100,8 @@
         self.fpdf.cell(0,10,"Players Entered in the %s" % self.cnam,1,0,"C")
         self.fpdf.ln(20)
         self.fpdf.set_font("Courier","B",9)
-        self.fpdf.cell(0, 5, "%-30s %-15s %-40s %-15s" % \
-            ("Name", "Club", "E-Mail", "Mobile"), "B")
+        self.fpdf.cell(0, 5, "%-30s %-15s %-40s" % \
+            ("Name", "Mobile", "Email"), "B")
         self.fpdf.ln(5)
 
     def doExit(self):

=== modified file 'bwl/bc3090.py'
--- bwl/bc3090.py	2014-05-28 14:55:12 +0000
+++ bwl/bc3090.py	2014-10-03 14:59:39 +0000
@@ -29,7 +29,7 @@
                 self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwlskp",
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwltab",
             "bwltyp", "bwlent"], prog=__name__)
         if self.sql.error:
             return
@@ -91,8 +91,8 @@
         for l in lst:
             if l[1]:
                 lgame = l[0]
-        col = ["bce_scod", "bcs_surname", "bcs_names"]
-        grp = "bce_scod, bcs_surname, bcs_names, bcg_group"
+        col = ["bce_scod", "btb_surname", "btb_names"]
+        grp = "bce_scod, btb_surname, btb_names, bcg_group"
         if lgame <= self.grgame:
             col.extend(["sum(bcg_shots_for) as sfor",
                 "sum(bcg_shots_agt) as sagt",
@@ -106,13 +106,13 @@
         whr = [
             ("bce_cono", "=", self.opts["conum"]),
             ("bce_ccod", "=", self.ccod),
-            ("bcs_cono=bce_cono",),
-            ("bcs_code=bce_scod",),
+            ("btb_cono=bce_cono",),
+            ("btb_tab=bce_scod",),
             ("bcg_cono=bce_cono",),
             ("bcg_ccod=bce_ccod",),
             ("bcg_scod=bce_scod",)]
         odr = "bcg_group, pts desc, agg desc, sagt asc"
-        skips = self.sql.getRec(tables=["bwlent", "bwlskp", "bwlgme"],
+        skips = self.sql.getRec(tables=["bwlent", "bwltab", "bwlgme"],
             cols=col, where=whr, group=grp, order=odr)
         data = []
         for skip in skips:

=== modified file 'bwl/bc3100.py'
--- bwl/bc3100.py	2014-05-08 17:02:33 +0000
+++ bwl/bc3100.py	2014-10-03 15:01:36 +0000
@@ -24,7 +24,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwlskp",
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwltab",
             "bwltyp", "bwlent"], prog=__name__)
         if self.sql.error:
             return
@@ -126,20 +126,20 @@
             ("bcg_cono", "=", self.opts["conum"]),
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "=", self.game),
-            ("bcs_code=bcg_scod",)]
+            ("btb_tab=bcg_scod",)]
         self.fpdf = MyFpdf(name=__name__, head=65)
         self.pglin = 999
         lastg = None
         for g in keys:
             whr = where[:]
             whr.append(("bcg_scod", "in", grps[g]))
-            col = ["bcs_surname", "bcs_names"]
+            col = ["btb_surname", "btb_names"]
             col.extend(["sum(bcg_shots_for) as sfor",
                 "sum(bcg_shots_agt) as sagt",
                 "sum(bcg_shots_for - bcg_shots_agt) as agg",
                 "sum(bcg_points) as pts"])
-            recs = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=col,
-                where=whr, group="bcs_code, bcs_surname, bcs_names",
+            recs = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=col,
+                where=whr, group="btb_tab, btb_surname, btb_names",
                 order="pts desc, agg desc, sagt asc")
             if not recs:
                 continue

=== modified file 'bwl/bc3110.py'
--- bwl/bc3110.py	2014-05-28 14:55:12 +0000
+++ bwl/bc3110.py	2014-10-06 09:23:24 +0000
@@ -15,7 +15,7 @@
 
 import os
 from TartanClasses import CCD, MyFpdf, TartanDialog, Sql
-from tartanFunctions import doPrinter, getModName
+from tartanFunctions import askQuestion, doPrinter, getModName
 
 class bc3110:
     def __init__(self, **opts):
@@ -25,7 +25,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwlskp",
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlgme", "bwltab",
             "bwltyp", "bwlent"], prog=__name__)
         if self.sql.error:
             return
@@ -134,14 +134,14 @@
             ("bcg_cono", "=", self.opts["conum"]),
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "<=", self.lastgam),
-            ("bcs_code=bcg_scod",)]
+            ("btb_tab=bcg_scod",)]
         self.fpdf = MyFpdf(name=__name__, head=65)
         self.pglin = 999
         lastg = None
         for g in self.keys:
             whr = where[:]
             whr.append(("bcg_scod", "in", self.grps[g][0]))
-            col = ["bcs_surname", "bcs_names"]
+            col = ["btb_surname", "btb_names"]
             if self.lastgam <= self.grgame:
                 col.extend(["sum(bcg_shots_for) as sfor",
                     "sum(bcg_shots_agt) as sagt",
@@ -152,8 +152,8 @@
                     "sum(bcg_a_shots_agt) as sagt",
                     "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
                     "sum(bcg_a_points) as pts"])
-            recs = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=col,
-                where=whr, group="bcs_code, bcs_surname, bcs_names",
+            recs = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=col,
+                where=whr, group="btb_tab, btb_surname, btb_names",
                 order="pts desc, agg desc, sagt asc")
             if not recs:
                 continue
@@ -187,8 +187,8 @@
                 ("bcg_cono", "=", self.opts["conum"]),
                 ("bcg_ccod", "=", self.ccod),
                 ("bcg_game", "<=", self.lastgam),
-                ("bcs_cono=bcg_cono",),
-                ("bcs_code=bcg_scod",)]
+                ("btb_cono=bcg_cono",),
+                ("btb_tab=bcg_scod",)]
             for grp in xrange(gqty):
                 if self.groups == "Y":
                     gcod = grp + 1
@@ -197,13 +197,13 @@
                 whr = where[:]
                 whr.append(("bcg_group", "=", gcod))
                 col = [
-                    "bcg_scod", "bcs_surname", "bcs_names",
+                    "bcg_scod", "btb_surname", "btb_names",
                     "sum(bcg_a_shots_for) as sfor",
                     "sum(bcg_a_shots_agt) as sagt",
                     "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
                     "sum(bcg_a_points) as pts"]
-                recs = self.sql.getRec(tables=["bwlgme", "bwlskp"], cols=col,
-                    where=whr, group="bcg_scod, bcs_surname, bcs_names",
+                recs = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=col,
+                    where=whr, group="bcg_scod, btb_surname, btb_names",
                     order="pts desc, agg desc, sagt asc")
                 if not recs:
                     continue
@@ -216,20 +216,20 @@
             sess = {}
             for gme in xrange(1, self.games + 1):
                 col = [
-                    "bcg_scod", "bcs_surname", "bcs_names",
+                    "bcg_scod", "btb_surname", "btb_names",
                     "sum(bcg_shots_for) as sfor",
                     "sum(bcg_shots_agt) as sagt",
                     "sum(bcg_shots_for - bcg_shots_agt) as agg",
                     "sum(bcg_points) as pts"]
                 whr = where[:]
                 whr.append(("bcg_game", "=", gme))
-                grp = "bcg_scod, bcs_surname, bcs_names"
+                grp = "bcg_scod, btb_surname, btb_names"
                 odr = "pts desc, agg desc, sagt asc"
                 if self.sesgrp == "Y" and gme > self.grgame:
                     col.append("bcg_group")
                     grp = "bcg_group, %s" % grp
                     odr = "bcg_group, %s" % odr
-                recs = self.sql.getRec(tables=["bwlgme", "bwlskp"],
+                recs = self.sql.getRec(tables=["bwlgme", "bwltab"],
                     cols=col, where=whr, group=grp, order=odr)
                 done = None
                 for rec in recs:
@@ -273,7 +273,8 @@
                     self.fpdf.drawText(stxt, w=12, border="TLRB", ln=0)
                     if self.sesgrp == "Y":
                         self.fpdf.drawText("", w=12, border="TLRB", ln=0)
-                    self.fpdf.drawText("* Abandoned *", border="TLRB")
+                    self.fpdf.drawText("* No Valid Winner or Abandoned *",
+                        border="TLRB")
                     continue
                 grps = sess[gme].keys()
                 grps.sort()
@@ -420,7 +421,7 @@
         r1s = (("Yes", "Y"), ("No", "N"))
         fld = (
             (("T",0,0,0),"IUI",2,"Number of Prizes","",
-                3,"N",self.doPrzNum,None,None,("notzero",)),
+                3,"N",self.doPrzNum,None,None,("efld",)),
             (("T",0,1,0),("IRB",r1s),0,"EFT Forms","",
                 "N","N",self.doPrzEft,None,None,None),
             (("T",0,2,0),"IUI",5,"1st Prize","",
@@ -452,7 +453,16 @@
         self.opts["mf"].startLoop()
 
     def doPrzNum(self, frt, pag, r, c, p, i, w):
+        if not w:
+            ok = askQuestion(self.opts["mf"].body, "Prizes",
+                "Are You Sure that there are No Prizes?", default="no")
+            if ok == "no":
+                return "Invalid Number od Prizes"
         self.prznum = w
+        if not self.prznum:
+            self.przeft = []
+            self.pz.loadEntry(frt, pag, p+1, data="N")
+            return "nd"
 
     def doPrzEft(self, frt, pag, r, c, p, i, w):
         if w == "N":

=== modified file 'bwl/bc3120.py'
--- bwl/bc3120.py	2014-05-08 17:02:33 +0000
+++ bwl/bc3120.py	2014-10-03 15:14:03 +0000
@@ -24,7 +24,7 @@
         self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlent", "bwlskp"],
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwlent", "bwltab"],
             prog=__name__)
 
     def mainProcess(self):
@@ -58,35 +58,29 @@
 
     def doEnd(self):
         self.df.closeProcess()
-        col = ["bcs_surname", "bcs_names", "bcc_name", "bcs_email",
-            "bcs_phone"]
+        col = ["btb_surname", "btb_names", "btb_mail", "btb_cell"]
         whr=[
             ("bce_cono", "=", self.opts["conum"]),
             ("bce_ccod", "=", self.ccod),
-            ("bcs_cono=bce_cono",),
-            ("bcs_code=bce_scod",),
-            ("(", "bcs_email", "=", "", "or", "bcs_phone", "=", "", ")"),
-            ("bcc_code=bcs_club",)]
-        recs = self.sql.getRec(tables=["bwlent", "bwlskp", "bwlclb"], cols=col,
-            where=whr, order="bcs_surname")
+            ("btb_cono=bce_cono",),
+            ("btb_tab=bce_scod",),
+            ("(", "btb_mail", "=", "", "or", "btb_cell", "=", "", ")")]
+        recs = self.sql.getRec(tables=["bwlent", "bwltab"], cols=col,
+            where=whr, order="btb_surname")
         if recs:
             fpdf = MyFpdf(name=__name__, head=90)
             for num, rec in enumerate(recs):
-                if not num % 4:
+                if not num % 5:
                     fpdf.add_page()
                 fpdf.drawText("Contact Details", h=12, align="C",
                     font=["courier", "B", 24], border="TLRB", fill=1)
-                fpdf.drawText("Name", w=50, h=12, border="TLRB", fill=1, ln=0)
-                fpdf.drawText("%s, %s" % (rec[0], rec[1]), h=12,
+                fpdf.drawText("Name", w=50, h=10, fill=1, ln=0,
                     font=["courier", "B", 18], border="TLRB")
-                fpdf.drawText("Club", w=50, h=12, border="TLRB", fill=1, ln=0)
-                if rec[2] == "Unknown":
-                    rec[2] = ""
-                fpdf.drawText(rec[2], h=12, border="TLRB")
-                fpdf.drawText("Email", w=50, h=12, border="TLRB", fill=1, ln=0)
-                fpdf.drawText(rec[3], h=12, border="TLRB")
-                fpdf.drawText("Phone", w=50, h=12, border="TLRB", fill=1, ln=0)
-                fpdf.drawText(rec[4], h=12, border="TLRB")
+                fpdf.drawText("%s, %s" % (rec[0], rec[1]), h=10, border="TLRB")
+                fpdf.drawText("Email", w=50, h=10, border="TLRB", fill=1, ln=0)
+                fpdf.drawText(rec[2], h=10, border="TLRB")
+                fpdf.drawText("Phone", w=50, h=10, border="TLRB", fill=1, ln=0)
+                fpdf.drawText(rec[3], h=10, border="TLRB")
                 fpdf.drawText()
                 fpdf.drawText()
                 fpdf.drawText()

=== modified file 'bwl/bc6010.py'
--- bwl/bc6010.py	2014-05-28 14:55:12 +0000
+++ bwl/bc6010.py	2014-10-09 15:19:12 +0000
@@ -13,8 +13,8 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import GetCtl, Sql, TartanDialog
-from tartanFunctions import askQuestion, showError
+from TartanClasses import GetCtl, SplashScreen, Sql, TartanDialog
+from tartanFunctions import askQuestion
 
 class bc6010:
     def __init__(self, **opts):
@@ -31,7 +31,6 @@
             ("bwlflm", "bfm_cono", "bfm_captain"),
             ("bwlflt", "bft_cono", "bft_skip", "bft_player"),
             ("bwlgme", "bcg_cono", "bcg_scod", "bcg_ocod"),
-            ("bwlskp", "bcs_cono", "bcs_code", "bcs_tab"),
             ("bwltab", "btb_cono", "btb_tab"))
         tabs = []
         for tab in self.tables:
@@ -44,6 +43,10 @@
         bwlctl = gc.getCtl("bwlctl", self.opts["conum"])
         if not bwlctl:
             return
+        self.mlint = bwlctl["ctb_mlint"]
+        self.samen = bwlctl["ctb_samen"]
+        if self.mlint == "Y" and self.samen == "Y":
+            return
         self.mstart = bwlctl["ctb_mstart"]
         self.fstart = bwlctl["ctb_fstart"]
         self.nstart = bwlctl["ctb_nstart"]
@@ -85,21 +88,18 @@
             acc[4].split()[0]))
 
     def doNewTab(self, frt, pag, r, c, p, i, w):
-        if not w < self.nstart:
-            return "Invalid Tab Number, Non-Member Sequence"
-        err = False
-        if self.mstart < self.fstart:
-            if self.gender == "M" and w >= self.fstart:
-                err = True
-            elif self.gender == "F" and w < self.fstart:
-                err = True
-        else:
-            if self.gender == "F" and w >= self.fstart:
-                err = True
-            elif self.gender == "M" and w < self.fstart:
-                err = True
-        if err:
-            return "Invalid Tab Number for Gender"
+        if self.oldtab < self.nstart:
+            if self.mstart < self.fstart:
+                if self.gender == "M" and not w < self.fstart:
+                    return "Invalid Male Tab Number"
+                elif self.gender == "F" and w < self.fstart:
+                    return "Invalid Female Tab Number"
+            elif self.gender == "M" and not w < self.mstart:
+                return "Invalid Male Tab Number"
+            elif self.gender == "F" and w < self.mstart:
+                return "Invalid Female Tab Number"
+        elif w < self.nstart:
+            return "Invalid Non-Member Tab Number"
         acc = self.sql.getRec(tables="bwltab", where=[("btb_cono", "=",
             self.opts["conum"]), ("btb_tab", "=", w)], limit=1)
         if acc:
@@ -115,57 +115,51 @@
         if ok == "no":
             self.df.focusField("T", 0, 1)
             return
-        plrs = self.sql.getRec(tables="bwlskp", where=[("bcs_cono", "=",
-            self.opts["conum"]), ("bcs_tab", "=", 0)])
-        for plr in plrs:
-            if plr[self.sql.bwlskp_col.index("bcs_code")] < self.nstart:
-                showError(self.opts["mf"].body, "Sequence Error",
-                    "You Must First Generate Player's Codes by Selecting\n\n"\
-                    "Toolbox --> Change Player's Codes --> Generate")
-                self.df.closeProcess()
-                self.opts["mf"].closeLoop()
-                return
         self.df.closeProcess()
+        splash = SplashScreen(self.opts["mf"].body,
+            "Generating New Tab Numbers ... Please Wait")
+        # Create temporary tables
         for ot in self.tables:
             tt = "%s_temp" % ot[0]
             self.sql.sqlRec("Create table %s as Select * from %s "\
                 "where %s = %s" % (tt, ot[0], ot[1], self.opts["conum"]))
             self.sql.delRec(ot[0], where=[(ot[1], "=", self.opts["conum"])])
-        tabs = self.sql.sqlRec("Select * from bwltab_temp order by "\
-            "btb_surname, btb_names")
-        key = {}
+        mem = self.sql.sqlRec("Select * from bwltab_temp where btb_cono = %s "\
+            "and btb_tab < %s order by btb_surname, btb_names" %
+            (self.opts["conum"], self.nstart))
+        non = self.sql.sqlRec("Select * from bwltab_temp where btb_cono = %s "\
+            "and btb_tab >= %s order by btb_surname, btb_names" %
+            (self.opts["conum"], self.nstart))
         mstart = self.mstart
         fstart = self.fstart
-        for tab in tabs:
-            old = tab[self.sql.bwltab_col.index("btb_tab")]
-            if tab[self.sql.bwltab_col.index("btb_gender")] == "M":
+        nstart = self.nstart
+        key = {}
+        for tab in mem:
+            gdr = tab[self.sql.bwltab_col.index("btb_gender")]
+            if gdr == "M":
                 new = mstart
                 mstart += 1
             else:
                 new = fstart
                 fstart += 1
-            key[old] = new
+            key[tab[self.sql.bwltab_col.index("btb_tab")]] = new
+        for tab in non:
+            key[tab[self.sql.bwltab_col.index("btb_tab")]] = nstart
+            nstart += 1
         for ot in self.tables:
             tt = "%s_temp" % ot[0]
             exec "cc = self.sql.%s_col" % ot[0]
             recs = self.sql.sqlRec("Select * from %s" % tt)
             for rec in recs:
-                t = rec[cc.index(ot[2])]
-                if t not in key:
-                    key[t] = t
-                rec[cc.index(ot[2])] = key[t]
-                if ot[0] in ("bwldrt", "bwlflt", "bwlgme", "bwlskp"):
-                    for i in xrange(3, len(ot[3:]) + 3):
-                        if rec[cc.index(ot[i])]:
-                            t = rec[cc.index(ot[i])]
-                            if t not in key:
-                                key[t] = t
-                            rec[cc.index(ot[i])] = key[t]
+                for k in ot[2:]:
+                    c = rec[cc.index(k)]
+                    if not c in key:
+                        continue
+                    rec[cc.index(k)] = key[c]
                 self.sql.insRec(ot[0], data=rec)
-        for ot in self.tables:
-            tt = "%s_temp" % ot[0]
             self.sql.sqlRec("Drop table %s" % tt)
         self.opts["mf"].dbm.commitDbase(ask=True)
+        splash.closeSplash()
         self.opts["mf"].closeLoop()
 
     def doProcess(self):
@@ -176,7 +170,7 @@
             dat = [self.newtab]
             col = [tab[2]]
             self.sql.updRec(tab[0], where=whr, data=dat, cols=col)
-            if tab in ("bwlflt", "bwlgme", "bwlskp"):
+            if tab in ("bwlflt", "bwlgme"):
                 whr = [
                     (tab[1], "=", self.opts["conum"]),
                     (tab[3], "=", self.oldtab)]

=== modified file 'bwl/bc6020.py'
--- bwl/bc6020.py	2014-05-08 17:02:33 +0000
+++ bwl/bc6020.py	2014-10-09 15:23:32 +0000
@@ -2,9 +2,9 @@
 
 """
 SYNOPSIS
-    Bowls Player's Code Change.
+    Bowls League Clear History Dialog.
 
-    This file is part of Tartan Systems (TARTAN).
+    This file is part of Tartan Financial Systems (TARTAN).
 
 AUTHOR
     Written by Paul Malherbe, <paul@tartan.co.za>
@@ -13,8 +13,7 @@
     Copyright (C) 2004-2014 Paul Malherbe.
 """
 
-from TartanClasses import GetCtl, Sql, TartanDialog
-from tartanFunctions import askQuestion
+from TartanClasses import TartanDialog, Sql
 
 class bc6020:
     def __init__(self, **opts):
@@ -24,139 +23,44 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.tables = (
-            ("bwlent", "bce_cono", "bce_scod"),
-            ("bwlgme", "bcg_cono", "bcg_scod", "bcg_ocod"),
-            ("bwlskp", "bcs_cono", "bcs_code"))
-        tabs = []
-        for tab in self.tables:
-            if tab[0] not in tabs:
-                tabs.append(tab[0])
-        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, prog=__name__)
         if self.sql.error:
             return
-        gc = GetCtl(self.opts["mf"])
-        bwlctl = gc.getCtl("bwlctl", self.opts["conum"])
-        if not bwlctl:
-            return
-        self.nstart = bwlctl["ctb_nstart"]
         return True
 
     def mainProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Player's Code Changes (%s)" % __name__)
-        tab = {
-            "stype": "R",
-            "tables": ("bwlskp",),
-            "cols": (
-                ("bcs_code", "", 0, "Cod-No"),
-                ("bcs_surname", "", 0, "Surname", "Y"),
-                ("bcs_names", "", 0, "Names")),
-            "where": [("bcs_cono", "=", self.opts["conum"])],
-            "order": "bcs_code"}
-        fld = [
-            (["T",0,0,0],"I@bcs_code",0,"Old Code","",
-                "","Y",self.doOldCode,tab,None,("notzero",)),
-            (["T",0,0,18],"ONA",30,""),
-            (["T",0,1,0],"I@bcs_code",0,"New Code","",
-                "","Y",self.doNewCode,None,None,("notzero",))]
-        tnd = ((self.doProcess,"y"), )
-        txt = (self.doExit, )
-        but = [("Generate",None,self.doGenerate,0,("T",0,1),("T",0,2),
-            "Auto Generate New Codes Based on Names and Membership")]
-        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld, tend=tnd,
-            txit=txt, butt=but)
-
-    def doOldCode(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="bwlskp", where=[("bcs_cono", "=",
-            self.opts["conum"]), ("bcs_code", "=", w)], limit=1)
-        if not acc:
-            return "Invalid Code, Does Not exist"
-        self.oldcod = w
-        self.df.loadEntry(frt, pag, p+1, data="%s, %s" % (acc[3],
-            acc[4].split()[0]))
-        tab = acc[self.sql.bwlskp_col.index("bcs_tab")]
-        if not tab:
-            return
-        if tab == w:
-            return "This is a Tab, Please Use the Tab Change Module"
-        else:
-            self.newcod = tab
-            self.df.loadEntry(frt, pag, p+2, data=tab)
-            return "sk2"
-
-    def doNewCode(self, frt, pag, r, c, p, i, w):
-        if w < self.nstart:
-            return "Invalid Number, Member's Range"
-        acc = self.sql.getRec(tables="bwlskp", where=[("bcs_cono", "=",
-            self.opts["conum"]), ("bcs_code", "=", w)], limit=1)
-        if acc:
-            return "Invalid Code, Already Exists"
-        self.newcod = w
-
-    def doGenerate(self, widget=None):
-        self.opts["mf"].updateStatus("")
-        ok = askQuestion(self.opts["mf"].body, "ARE YOU SURE???",
-            "Are you Certain this is what you Want To Do? This Will "\
-            "Automatically Generate New Codes For All Players Based "\
-            "On The Players Names!", default="no")
-        if ok == "no":
-            self.df.focusField("T", 0, 1)
-            return
+            "Clear Selection History (%s)" % __name__)
+        r1s = (("Yes","Y"), ("No","N"))
+        fld = ((("T",0,1,0),("IRB",r1s),0,"Clear Opponents","",
+                "Y","N",self.doOpps,None,None,None),)
+        tnd = ((self.doEnd,"y"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
+            eflds=fld, tend=tnd, txit=txt)
+
+    def doPlay(self, frt, pag, r, c, p, i, w):
+        self.play = w
+
+    def doOpps(self, frt, pag, r, c, p, i, w):
+        self.opps = w
+
+    def doEnd(self):
         self.df.closeProcess()
-        for ot in self.tables:
-            tt = "%s_temp" % ot[0]
-            self.sql.sqlRec("Create table %s as Select * from %s "\
-                "where %s = %s" % (tt, ot[0], ot[1], self.opts["conum"]))
-            self.sql.delRec(ot[0], where=[(ot[1], "=", self.opts["conum"])])
-        plrs = self.sql.sqlRec("Select * from bwlskp_temp order by "\
-            "bcs_surname, bcs_names")
-        key = {}
-        nstart = self.nstart
-        for plr in plrs:
-            old = plr[self.sql.bwlskp_col.index("bcs_code")]
-            if plr[self.sql.bwlskp_col.index("bcs_tab")]:
-                new = plr[self.sql.bwlskp_col.index("bcs_tab")]
-            else:
-                new = nstart
-                nstart += 1
-            key[old] = new
-        for ot in self.tables:
-            tt = "%s_temp" % ot[0]
-            exec "cc = self.sql.%s_col" % ot[0]
-            recs = self.sql.sqlRec("Select * from %s" % tt)
-            for rec in recs:
-                rec[cc.index(ot[2])] = key[rec[cc.index(ot[2])]]
-                if ot[0] == "bwlgme":
-                    if rec[cc.index(ot[3])]:
-                        rec[cc.index(ot[3])] = key[rec[cc.index(ot[3])]]
-                self.sql.insRec(ot[0], data=rec)
-        for ot in self.tables:
-            tt = "%s_temp" % ot[0]
-            self.sql.sqlRec("Drop table %s" % tt)
+        if self.opps == "Y":
+            self.sql.delRec("bwlflo", where=[("bfo_cono", "=",
+                self.opts["conum"])])
+        self.sql.delRec("bwlfls", where=[("bfs_cono", "=",
+            self.opts["conum"])])
+        self.sql.delRec("bwlflm", where=[("bfm_cono", "=",
+            self.opts["conum"])])
+        self.sql.delRec("bwlflt", where=[("bft_cono", "=",
+            self.opts["conum"])])
         self.opts["mf"].dbm.commitDbase(ask=True)
         self.opts["mf"].closeLoop()
 
-    def doProcess(self):
-        for tab in self.tables:
-            whr = [
-                (tab[1], "=", self.opts["conum"]),
-                (tab[2], "=", self.oldcod)]
-            dat = [self.newcod]
-            col = [tab[2]]
-            self.sql.updRec(tab[0], where=whr, data=dat, cols=col)
-            if tab[0] == "bwlgme":
-                whr = [
-                    (tab[1], "=", self.opts["conum"]),
-                    (tab[3], "=", self.oldcod)]
-                dat = [self.newcod]
-                col = [tab[3]]
-                self.sql.updRec(tab[0], where=whr, data=dat, cols=col)
-        self.df.focusField("T", 0, 1)
-
     def doExit(self):
         self.df.closeProcess()
-        self.opts["mf"].dbm.commitDbase(ask=True)
         self.opts["mf"].closeLoop()
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== removed file 'bwl/bc6030.py'
--- bwl/bc6030.py	2014-05-08 17:02:33 +0000
+++ bwl/bc6030.py	1970-01-01 00:00:00 +0000
@@ -1,66 +0,0 @@
-#! /usr/bin/python
-
-"""
-SYNOPSIS
-    Bowls League Clear History Dialog.
-
-    This file is part of Tartan Financial Systems (TARTAN).
-
-AUTHOR
-    Written by Paul Malherbe, <paul@tartan.co.za>
-
-COPYING
-    Copyright (C) 2004-2014 Paul Malherbe.
-"""
-
-from TartanClasses import TartanDialog, Sql
-
-class bc6030:
-    def __init__(self, **opts):
-        self.opts = opts
-        if self.setVariables():
-            self.mainProcess()
-            self.opts["mf"].startLoop()
-
-    def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, prog=__name__)
-        if self.sql.error:
-            return
-        return True
-
-    def mainProcess(self):
-        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "Clear Selection History (%s)" % __name__)
-        r1s = (("Yes","Y"), ("No","N"))
-        fld = ((("T",0,1,0),("IRB",r1s),0,"Clear Opponents","",
-                "N","N",self.doOpps,None,None,None),)
-        tnd = ((self.doEnd,"y"),)
-        txt = (self.doExit,)
-        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            eflds=fld, tend=tnd, txit=txt)
-
-    def doPlay(self, frt, pag, r, c, p, i, w):
-        self.play = w
-
-    def doOpps(self, frt, pag, r, c, p, i, w):
-        self.opps = w
-
-    def doEnd(self):
-        self.df.closeProcess()
-        if self.opps == "y":
-            self.sql.delRec("bwlflo", where=[("bfo_cono", "=",
-                self.opts["conum"])])
-        self.sql.delRec("bwlfls", where=[("bfs_cono", "=",
-            self.opts["conum"])])
-        self.sql.delRec("bwlflm", where=[("bfm_cono", "=",
-            self.opts["conum"])])
-        self.sql.delRec("bwlflt", where=[("bft_cono", "=",
-            self.opts["conum"])])
-        self.opts["mf"].dbm.commitDbase(ask=True)
-        self.opts["mf"].closeLoop()
-
-    def doExit(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
-# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bwl/bcc110.py'
--- bwl/bcc110.py	2014-10-01 14:07:50 +0000
+++ bwl/bcc110.py	2014-10-06 06:48:29 +0000
@@ -49,7 +49,7 @@
             (("T",0,0,0),("IRB",r1s),0,"M/L Integration","",
                 self.acc[1],"N",self.doMlint,None,None,None),
             (("T",0,1,0),("IRB",r1s),0,"Same Numbers","",
-                self.acc[2],"N",None,None,None,None),
+                self.acc[2],"N",self.doSame,None,None,None),
             (("T",0,2,0),"IUI",6,"Male Start Seq","",
                 self.acc[3],"N",self.doMStart,None,None,("notzero",)),
             (("T",0,3,0),"IUI",6,"Female Start Seq","",
@@ -86,19 +86,44 @@
             return "Invalid Selection, Member's System Not Set Up"
         if w == "N":
             self.df.loadEntry(frt, pag, p+1, data="N")
+            self.same = "N"
             return "sk1"
 
+    def doSame(self, frt, pag, r, c, p, i, w):
+        self.same = w
+
     def doMStart(self, frt, pag, r, c, p, i, w):
         self.mstart = w
 
     def doFStart(self, frt, pag, r, c, p, i, w):
+        if w == self.mstart and self.same == "N":
+            return "Invalid Number, Same as Male"
+        if not w == self.mstart:
+            if w < self.mstart:
+                r = self.mstart - w
+                g = "Female"
+            else:
+                r = w - self.mstart
+                g = "Male"
+            if r < 200:
+                return "ff3|Invalid Numbers, Too Few %s Tabs. (Minimum 200)" % g
         self.fstart = w
 
     def doNStart(self, frt, pag, r, c, p, i, w):
-        if self.mstart < self.fstart and w < self.fstart + 200:
-            return "Invalid Range, Too close to Female Start"
-        if self.fstart < self.mstart and w < self.mstart + 200:
-            return "Invalid Range, Too close to Male Start"
+        if w < self.mstart or w < self.fstart:
+            return "Invalid Number, Must be Greater than Male and Female"
+        if self.mstart == self.fstart:
+            r = w - self.mstart
+            m = 400
+        elif self.fstart < self.mstart:
+            r = w - self.mstart
+            m = 200
+        else:
+            r = w - self.fstart
+            m = 200
+        if r < m:
+            return "Invalid Number, Too Few Visitor Tabs. (Minimum %s)" % m
+        self.nstart = w
 
     def doBase(self, frt, pag, r, c, p, i, w):
         if w == "P":
@@ -112,22 +137,40 @@
         self.df.loadEntry(frt, pag, p, data=w)
 
     def doEnd(self):
-        data = [self.opts["conum"]]
-        for x in xrange(0, len(self.df.t_work[0][0])):
-            data.append(self.df.t_work[0][0][x])
-        if self.new:
-            self.sql.insRec("bwlctl", data=data)
-        elif data != self.acc:
-            self.sql.updRec("bwlctl", data=data, where=[("ctb_cono", "=",
-                self.opts["conum"])])
-            dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-            for num, dat in enumerate(self.acc):
-                if dat != data[num]:
-                    self.sql.insRec("chglog", data=["bwlctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.bwlctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
-        self.opts["mf"].dbm.commitDbase()
-        self.doExit()
+        err = None
+        if self.same == "Y":
+            if self.mstart + 400 > self.nstart:
+                err = "Invalid Range, Too Few Members Allowed For"
+        elif self.mstart == self.fstart and not self.same == "Y":
+            err = "Same Male and Female Starting Numbers"
+        elif self.mstart < self.fstart:
+            if self.fstart - self.mstart < 200:
+                err = "Invalid Range, Too Few Male Numbers"
+            elif self.nstart < self.fstart + 200:
+                err = "Invalid Range, Too Few Female Numbers"
+        elif self.mstart - self.fstart < 200:
+            err = "Invalid Range, Too Few Female Numbers"
+        elif self.nstart < self.mstart + 200:
+            err = "Invalid Range, Too Few Male Numbers"
+        if err:
+            self.df.focusField("T", 0, 3, err=err)
+        else:
+            data = [self.opts["conum"]]
+            for x in xrange(0, len(self.df.t_work[0][0])):
+                data.append(self.df.t_work[0][0][x])
+            if self.new:
+                self.sql.insRec("bwlctl", data=data)
+            elif data != self.acc:
+                self.sql.updRec("bwlctl", data=data, where=[("ctb_cono", "=",
+                    self.opts["conum"])])
+                dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+                for num, dat in enumerate(self.acc):
+                    if dat != data[num]:
+                        self.sql.insRec("chglog", data=["bwlctl", "U", "%03i" %
+                            self.opts["conum"], self.sql.bwlctl_col[num], dte,
+                            self.opts["capnm"], str(dat), str(data[num]), 0])
+            self.opts["mf"].dbm.commitDbase()
+            self.doExit()
 
     def doAccept(self, widget=None):
         frt, pag, col, mes = self.df.doCheckFields()

=== modified file 'bwl/bcc210.py'
--- bwl/bcc210.py	2014-05-08 17:02:33 +0000
+++ bwl/bcc210.py	2014-10-03 16:39:23 +0000
@@ -24,8 +24,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bwlclb", "bwlflo",
-            "bwlskp"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bwlclb", "bwlflo"],
+            prog=__name__)
         if self.sql.error:
             return
         acc = self.sql.getRec(tables="bwlclb", where=[("bcc_code", "=",
@@ -81,8 +81,7 @@
         if self.club == self.opts["conum"]:
             return "Cannot Delete Own Club"
         error = False
-        for tab in (("bwlflo", "bfo_cono", "bfo_club"),
-                    ("bwlskp", "bcs_cono", "bcs_club")):
+        for tab in (("bwlflo", "bfo_cono", "bfo_club"),):
             chk = self.sql.getRec(tables=tab[0], where=[(tab[1], "=",
                 self.opts["conum"]), (tab[2], "=", self.club)], limit=1)
             if chk:

=== modified file 'crs/cr3070.py'
--- crs/cr3070.py	2014-05-28 14:55:12 +0000
+++ crs/cr3070.py	2014-11-10 06:48:16 +0000
@@ -71,7 +71,7 @@
             self.sort = "crm_name"
 
     def doEnd(self):
-        self.df.closeProcess()
+        self.df.setWidget(self.df.mstFrame, state="hide")
         self.view = self.df.repprt[0][1]
         self.prtnam = self.df.repprt[0][2]
         self.emadd = self.df.repprt[1][2]
@@ -103,7 +103,8 @@
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=self.view, prtnam=self.prtnam,
                 mail=self.emadd)
-        self.closeProcess()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.focusField("T", 0, 1)
 
     def doProcess(self, crm):
         self.pgnum = 0

=== modified file 'crs/cr3070_rne.py'
--- crs/cr3070_rne.py	2014-05-28 14:55:12 +0000
+++ crs/cr3070_rne.py	2014-11-10 09:08:01 +0000
@@ -71,7 +71,7 @@
             self.sort = "crm_name"
 
     def doEnd(self):
-        self.df.closeProcess()
+        self.df.setWidget(self.df.mstFrame, state="hide")
         self.view = self.df.repprt[0][1]
         self.prtnam = self.df.repprt[0][2]
         self.emadd = self.df.repprt[1][2]
@@ -105,7 +105,8 @@
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=self.view, prtnam=self.prtnam,
                 mail=self.emadd)
-        self.closeProcess()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.focusField("T", 0, 1)
 
     def doProcess(self, crm):
         self.pgnum = 0

=== modified file 'csv/bkmcon_fld.csv'
--- csv/bkmcon_fld.csv	2014-10-01 14:07:50 +0000
+++ csv/bkmcon_fld.csv	2014-12-08 06:01:17 +0000
@@ -6,9 +6,9 @@
 5,"bkc_addr1","TX","30.0","Address Line 1","Address-Line-1"
 6,"bkc_addr2","TX","30.0","Address Line 2","Address-Line-2"
 7,"bkc_addr3","TX","30.0","Address Line 3","Address-Line-3"
-8,"bkc_pcode","UI","4.0","Postal Code","P-Code"
+8,"bkc_pcode","TX","4.0","Postal Code","P-Code"
 9,"bkc_telno","TX","20.0","Telephone Number","Telephone"
 10,"bkc_faxno","TX","20.0","Fax Number","Fax"
 11,"bkc_celno","TX","20.0","Mobile Number","Mobile"
-12,"bkc_email","TX","30.0","Email Address","Email"
-13,"bkc_vatno","UI","10.0","VAT Number","VAT-Number"
+12,"bkc_email","TX","50.0","Email Address","Email"
+13,"bkc_vatno","NA","10.0","VAT Number","VAT-Number"

=== modified file 'csv/bkmctl_fld.csv'
--- csv/bkmctl_fld.csv	2014-06-14 08:55:57 +0000
+++ csv/bkmctl_fld.csv	2014-11-18 08:49:47 +0000
@@ -1,3 +1,6 @@
 0,"cbk_cono","UI","3.0","Company Number","Coy"
 1,"cbk_glint","UA","1.0","Integration","I"
-2,"cbk_tplnam","NA","20.0","Booking Template","Template-Name"
+2,"cbk_bkgtpl","NA","20.0","Booking Template","Booking-Template"
+3,"cbk_invtpl","NA","20.0","Invoice Template","Invoice-Template"
+4,"cbk_statpl","NA","20.0","Statement Template","Statement-Template"
+5,"cbk_terms","TX","50.0","Terms and Conditions","Terms-and-Conditions"

=== modified file 'csv/bkmmst_fld.csv'
--- csv/bkmmst_fld.csv	2014-10-01 14:07:50 +0000
+++ csv/bkmmst_fld.csv	2014-11-20 05:58:58 +0000
@@ -7,13 +7,10 @@
 6,"bkm_depart","D1","10.0","Departure Date","Depart-Dt"
 7,"bkm_units","TX","50.0","Booked Units","Units"
 8,"bkm_value","UD","10.2","Value","Value"
-9,"bkm_deposit","UD","10.2","Deposit Value","Deposit"
-10,"bkm_depdate","D1","10.0","Deposit Date","Deposit-Dt"
-11,"bkm_special","TX","50.0","Special Requests","Special-Requests"
-12,"bkm_cdate","D1","10.0","Date of Ceremony","Ceremony-D"
-13,"bkm_ctime","TM","5.0","Time of Ceremony","Ceremony-T"
-14,"bkm_bride","TX","30.0","Bride's Name","Bride-Name"
-15,"bkm_groom","TX","30.0","Groom's Name","Groom-Name"
-16,"bkm_officer","TX","30.0","Marriage Officer","Marriage-Officer"
-17,"bkm_state","UA","1.0","Booking Status","S"
-18,"bkm_ccode","UA","7.0","Contact Code","Contact"
+9,"bkm_stddep","UD","10.2","Deposit I-Value","I-Dep-Val"
+10,"bkm_stddte","D1","10.0","Deposit I-Date","I-Due-Date"
+11,"bkm_grpdep","UD","10.2","Deposit G-Value","G-Dep-Val"
+12,"bkm_grpdte","D1","10.0","Deposit G-Date","G-Due-Date"
+13,"bkm_special","TX","50.0","Special Requests","Special-Requests"
+14,"bkm_state","UA","1.0","Booking Status","S"
+15,"bkm_ccode","UA","7.0","Contact Code","Contact"

=== modified file 'csv/bkmrtm_fld.csv'
--- csv/bkmrtm_fld.csv	2014-08-27 09:27:53 +0000
+++ csv/bkmrtm_fld.csv	2014-11-20 11:32:09 +0000
@@ -2,7 +2,4 @@
 1,"brm_type","UA","1.0","Rate Type","T"
 2,"brm_code","UI","3.0","Rate Code","Cod"
 3,"brm_desc","TX","30.0","Description","Description"
-4,"brm_rate","UD","10.2","Rate Amount","Amount"
-5,"brm_base","UA","1.0","Rate Base","B"
-6,"brm_minq","UI","3.0","Minimum Quantity","Qty"
-7,"brm_mina","UD","10.2","Minimum Value","Min-Value"
+4,"brm_base","UA","1.0","Rate Base (A/B/C)","B"

=== added file 'csv/bkmrtr_fld.csv'
--- csv/bkmrtr_fld.csv	1970-01-01 00:00:00 +0000
+++ csv/bkmrtr_fld.csv	2014-11-21 09:00:13 +0000
@@ -0,0 +1,5 @@
+0,"brr_cono","UI","3.0","Company Number","Coy"
+1,"brr_type","UA","1.0","Rate Type","T"
+2,"brr_code","UI","3.0","Rate Code","Cod"
+3,"brr_date","d1","10.0","Starting Date","Start-Date"
+4,"brr_rate","UD","10.2","Rate Amount","Rte-Amount"

=== added file 'csv/bkmrtr_idx.csv'
--- csv/bkmrtr_idx.csv	1970-01-01 00:00:00 +0000
+++ csv/bkmrtr_idx.csv	2014-11-21 08:55:25 +0000
@@ -0,0 +1,1 @@
+"Bookings Rate Amounts",1,"U","brr_cono","brr_type","brr_code","brr_date"

=== modified file 'csv/bkmrtt_fld.csv'
--- csv/bkmrtt_fld.csv	2014-08-06 15:44:15 +0000
+++ csv/bkmrtt_fld.csv	2014-11-21 09:14:55 +0000
@@ -5,11 +5,15 @@
 4,"brt_udesc","TX","30.0","Unit Description","Unit-Description"
 5,"brt_rcode","UI","3.0","Rate Code","Cod"
 6,"brt_rdesc","TX","30.0","Rate Description","Rate-Description"
-7,"brt_nrate","UD","10.2","Normal Rate","Normal-Rte"
-8,"brt_quant","UI","3.0","Quantity","Qty"
-9,"brt_discp","UD","6.2","Discount Percentage","Disc-%"
-10,"brt_arate","UD","10.2","Applied Rate","Applied-Rt"
-11,"brt_bdays","UI","3","Booked Days","Bkd"
-12,"brt_capnm","TX","20.0","Capture Name","Capture-Name"
-13,"brt_capdt","d1","10.0","Capture Date","Capture-Dt"
-14,"brt_seq","US","10.0","Sequence","Sequence"
+7,"brt_rbase","UA","1.0","Rate Base","B"
+8,"brt_nrate","UD","10.2","Normal Rate","Normal-Rte"
+9,"brt_quant","UI","3.0","Quantity","Qty"
+10,"brt_discp","UD","6.2","Discount Percentage","Disc-%"
+11,"brt_arate","UD","10.2","Applied Rate","Applied-Rt"
+12,"brt_bdays","UI","3","Booked Days","Bkd"
+13,"brt_invno","UI","9","Invoice Number","Invoice-N"
+14,"brt_invdt","UI","9","Invoice Date","Invoice-Dt"
+15,"brt_vrate","UD","5.2","V.A.T. Rate","VAT-R"
+16,"brt_capnm","TX","20.0","Capture Name","Capture-Name"
+17,"brt_capdt","d1","10.0","Capture Date","Capture-Dt"
+18,"brt_seq","US","10.0","Sequence","Sequence"

=== modified file 'csv/bkmunm_fld.csv'
--- csv/bkmunm_fld.csv	2014-07-19 07:58:06 +0000
+++ csv/bkmunm_fld.csv	2014-11-09 11:51:44 +0000
@@ -2,4 +2,7 @@
 1,"bum_type","UA","1.0","Unit Type","T"
 2,"bum_code","UA","6.0","Unit Code","U-Code"
 3,"bum_desc","TX","30.0","Description","Description"
-4,"bum_guests","UI","3.0","Number of Guests","Qty"
+4,"bum_multi","UA","1.0","Multiple Bookings","M"
+5,"bum_guests","UI","3.0","Maximum Guests","Qty"
+6,"bum_vatc","UA","1.0","Vat Code","V"
+7,"bum_slsa","UI","7.0","G/L Sales Account","Acc-Num"

=== removed file 'csv/bkmunt_fld.csv'
--- csv/bkmunt_fld.csv	2014-08-06 15:44:15 +0000
+++ csv/bkmunt_fld.csv	1970-01-01 00:00:00 +0000
@@ -1,5 +0,0 @@
-0,"but_cono","UI","3.0","Company Number","Coy"
-1,"but_type","UA","1.0","Unit Type","T"
-2,"but_desc","NA","30.0","Description","Description"
-3,"but_vatc","UA","1.0","Vat Code","V"
-4,"but_slsa","UI","7.0","G/L Sales Account","Acc-Num"

=== removed file 'csv/bkmunt_idx.csv'
--- csv/bkmunt_idx.csv	2014-08-06 15:44:15 +0000
+++ csv/bkmunt_idx.csv	1970-01-01 00:00:00 +0000
@@ -1,1 +0,0 @@
-"Bookings Unit Type",1,"U","but_cono","but_type","","","","","","","",""

=== added file 'csv/bowls.sys'
--- csv/bowls.sys	1970-01-01 00:00:00 +0000
+++ csv/bowls.sys	2014-11-03 09:01:45 +0000
@@ -0,0 +1,60 @@
+bwlclb
+bwlcmp
+bwlctl
+bwldrm
+bwldrt
+bwlent
+bwlflf
+bwlflm
+bwlflo
+bwlfls
+bwlflt
+bwlgme
+bwlrnd
+bwltab
+bwltyp
+chglog
+ctlare
+ctlbat
+ctlctl
+ctldep
+ctlmes
+ctlmst
+ctlnot
+ctlpwm
+ctlpwr
+ctlpwu
+ctlrep
+ctlsys
+ctlvmf
+ctlvrf
+ctlvtf
+ctlynd
+emllog
+frelat
+memadd
+memage
+memcat
+memctc
+memctk
+memctl
+memcto
+memctp
+memkon
+memlnk
+memmst
+memsta
+memtrn
+memtrs
+rptcol
+rptexc
+rptjon
+rptmst
+rptord
+rpttab
+rptvar
+telmst
+telcon
+tplmst
+tpldet
+verupd

=== modified file 'csv/bwlflf_fld.csv'
--- csv/bwlflf_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/bwlflf_fld.csv	2014-10-07 04:44:09 +0000
@@ -1,9 +1,10 @@
 0,"bff_cono","UI","3.0","Company Number","Coy"
 1,"bff_code","UI","1.0","Format Code","F"
 2,"bff_desc","NA","30.0","Description","Description"
-3,"bff_assess","UA","1.0","Assessments (Y/N)","A"
-4,"bff_forms","UI","1.0","Forms (1/4)","F"
-5,"bff_self","UA","1.0","Assess Self (Y/N)","O"
-6,"bff_rate","UI","2.0","Rating Out Of","R"
-7,"bff_sets","UA","1.0","Sets Format (Y/N)","S"
-8,"bff_logo","TX","50.0","Logo","Logo"
+3,"bff_gender","UA","1.0","Gender","G"
+4,"bff_assess","UA","1.0","Assessments (Y/N)","A"
+5,"bff_forms","UI","1.0","Forms (1/4)","F"
+6,"bff_self","UA","1.0","Assess Self (Y/N)","O"
+7,"bff_rate","UI","2.0","Rating Out Of","R"
+8,"bff_sets","UA","1.0","Sets Format (Y/N)","S"
+9,"bff_logo","TX","50.0","Logo","Logo"

=== removed file 'csv/bwlskp_fld.csv'
--- csv/bwlskp_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/bwlskp_fld.csv	1970-01-01 00:00:00 +0000
@@ -1,9 +0,0 @@
-0,"bcs_cono","UI","3.0","Company Number","Coy"
-1,"bcs_code","UI","6.0","Skip Code","S-Code"
-2,"bcs_tab","UI","6.0","Tab Number","Tab-No"
-3,"bcs_surname","UA","30.0","Surname","Surname"
-4,"bcs_names","UA","30.0","Names","Names"
-5,"bcs_gender","UA","1.0","Gender Code","G"
-6,"bcs_club","UI","3.0","Club Code","CCd"
-7,"bcs_email","TX","20.0","Email Address","Email-Address"
-8,"bcs_phone","TX","20.0","Phone Number","Phone-Number"

=== removed file 'csv/bwlskp_idx.csv'
--- csv/bwlskp_idx.csv	2014-03-28 07:32:49 +0000
+++ csv/bwlskp_idx.csv	1970-01-01 00:00:00 +0000
@@ -1,1 +0,0 @@
-"Competition Skips",1,"U","bcs_cono","bcs_code"

=== modified file 'csv/bwltab_fld.csv'
--- csv/bwltab_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/bwltab_fld.csv	2014-12-08 06:01:49 +0000
@@ -4,9 +4,16 @@
 3,"btb_surname","UA","20.0","Surname","Surname"
 4,"btb_names","UA","20.0","Names","Names"
 5,"btb_gender","UA","1.0","Gender","G"
-6,"btb_pos1","UI","1.0","Position - Primary","P"
-7,"btb_rate1","UI","2.0","Rating - Primary","RP"
-8,"btb_pos2","UI","1.0","Position - Mixed","P"
-9,"btb_rate2","UI","2.0","Rating - Mixed","RM"
-10,"btb_bsano","UI","6.0","Association Number","BA-Num"
-11,"btb_status","UA","1.0","Status","S"
+6,"btb_add1","TX","20.0","Address Line 1","Address-Line-1"
+7,"btb_add2","TX","20.0","Address Line 2","Address-Line-2"
+8,"btb_add3","TX","20.0","Address Line 3","Address-Line-3"
+9,"btb_pcod","TX","4.0","Postal Code","Code"
+10,"btb_home","TX","20.0","Home Number","Home-Number"
+11,"btb_work","TX","20.0","Work Number","Work-Number"
+12,"btb_cell","TX","20.0","Cell Number","Cell-Number"
+13,"btb_mail","TX","50.0","Email Address","Email-Address"
+14,"btb_pos1","UI","1.0","Position - Primary","P"
+15,"btb_rate1","UI","2.0","Rating - Primary","RP"
+16,"btb_pos2","UI","1.0","Position - Mixed","P"
+17,"btb_rate2","UI","2.0","Rating - Mixed","RM"
+18,"btb_bsano","UI","6.0","Association Number","BA-Num"

=== modified file 'csv/frelat.dat'
--- csv/frelat.dat	2014-05-21 15:05:50 +0000
+++ csv/frelat.dat	2014-11-20 16:06:18 +0000
@@ -22,7 +22,6 @@
 ctlmst|ctm_cono|bwlflt|bft_cono
 ctlmst|ctm_cono|bwlgme|bcg_cono
 ctlmst|ctm_cono|bwlrnd|bcr_cono
-ctlmst|ctm_cono|bwlskp|bcs_cono
 ctlmst|ctm_cono|bwltab|btb_cono
 ctlmst|ctm_cono|bwltyp|bct_cono
 ctlmst|ctm_cono|crsage|cra_cono
@@ -327,13 +326,25 @@
 memctc|mcc_code|memctc|mcc_code
 memctc|mcc_type|memcat|mlc_type
 memctc|mcc_code|memcat|mlc_code
+# Bookings
+bkmmst|bkm_cono|bkmcon|bkc_cono
+bkmmst|bkm_ccode|bkmcon|bkc_ccode
+bkmmst|bkm_cono|bkmrtt|brt_cono
+bkmmst|bkm_number|bkmrtt|brt_number
+bkmmst|bkm_cono|bkmtrn|bkt_cono
+bkmmst|bkm_number|bkmtrn|bkt_number
+bkmrtm|brm_cono|bkmrtr|brr_cono
+bkmrtm|brm_type|bkmrtr|brr_type
+bkmrtm|brm_code|bkmrtr|brr_code
+bkmunm|bum_cono|bkmrtt|brt_cono
+bkmunm|bum_type|bkmrtt|brt_utype
+bkmunm|bum_code|bkmrtt|brt_ucode
 # Bowls
-bwlclb|bcc_code|bwlskp|bcs_club
-bwlent|bce_scod|bwlskp|bcs_code
 bwlent|bce_ccod|bwlgme|bcg_ccod
+bwlent|bce_scod|bwltab|btb_tab
 bwlent|bce_scod|bwlgme|bcg_scod
-bwlgme|bcg_scod|bwlskp|bcs_code
-bwlgme|bcg_ocod|bwlskp|bcs_code
+bwlgme|bcg_scod|bwltab|btb_tab
+bwlgme|bcg_ocod|bwltab|btb_tab
 bwltab|btb_tab|bwldrt|bdt_tab
 # Competitions
 scpclb|scc_ccod|scpmem|scm_ccod

=== modified file 'csv/tartan.sys'
--- csv/tartan.sys	2014-08-06 15:44:15 +0000
+++ csv/tartan.sys	2014-11-20 11:46:58 +0000
@@ -8,10 +8,10 @@
 bkmlet
 bkmmst
 bkmrtm
+bkmrtr
 bkmrtt
 bkmtrn
 bkmunm
-bkmunt
 bwlclb
 bwlcmp
 bwlctl
@@ -25,7 +25,6 @@
 bwlflt
 bwlgme
 bwlrnd
-bwlskp
 bwltab
 bwltyp
 chglog

=== modified file 'csv/telmst_fld.csv'
--- csv/telmst_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/telmst_fld.csv	2014-12-09 16:12:18 +0000
@@ -1,10 +1,10 @@
-0,"tdm_name","NA","50.0","Name","Name"
-1,"tdm_adr1","NA","30.0","Address Line 1","Address-Line-1"
-2,"tdm_adr2","NA","30.0","Address Line 2","Address-Line-2"
-3,"tdm_adr3","NA","30.0","Address Line 3","Address-Line-3"
-4,"tdm_pcode","NA","10.0","Postal Code","Post-Code"
-5,"tdm_telcd","NA","10.0","Dialing Code","Dial-Code"
-6,"tdm_telno","NA","20.0","Phone Number","Phone-Number"
-7,"tdm_faxno","NA","20.0","Fax Number","Facsimile-Number"
-8,"tdm_mobile","NA","20.0","Mobile Number","Mobile-Number"
+0,"tdm_name","TX","50.0","Name","Name"
+1,"tdm_adr1","TX","30.0","Address Line 1","Address-Line-1"
+2,"tdm_adr2","TX","30.0","Address Line 2","Address-Line-2"
+3,"tdm_adr3","TX","30.0","Address Line 3","Address-Line-3"
+4,"tdm_pcode","TX","4.0","Postal Code","Post-Code"
+5,"tdm_telcd","TX","10.0","Dialing Code","Dial-Code"
+6,"tdm_telno","TX","20.0","Phone Number","Phone-Number"
+7,"tdm_faxno","TX","20.0","Fax Number","Facsimile-Number"
+8,"tdm_mobile","TX","20.0","Mobile Number","Mobile-Number"
 9,"tdm_email","TX","50.0","Email Address","Email-Address"

=== modified file 'csv/tpldet.dat'
--- csv/tpldet.dat	2014-10-01 14:07:50 +0000
+++ csv/tpldet.dat	2014-11-29 10:21:35 +0000
@@ -1,10 +1,89 @@
 booking_form|1.0|I|A||||0||||||||10.0|0|201.0|10.0|40.0|0.0|letterhead||0||||||||0.0|0|0.0|0.0|0.0|0|0
-booking_form|2.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_number|helvetica|14|#000000|Y|N|N|L||N|10.0|40|145.0|48.0|54.0|1|1
-booking_form|3.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_date|helvetica|14|#000000|Y|N|N|R||N|140.0|17|199.0|48.0|54.0|1|1
-booking_form|4.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_letter|helvetica|12|#000000|N|N|N|L||N|10.0|66|201.0|60.0|65.0|6|1
-booking_form|5.0|T|B||Booking Details|helvetica|12|#000000|Y|N|N|L|TLRB|Y|10.0|66|201.0|100.0|106.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
-booking_form|6.0|C|B|L||helvetica|10|#000000|Y|N|N|L||N|10.0|30|98.0|107.0|111.0|0.0|booking_details|helvetica|10|#000000|N|N|N|L||N|98.0|35|200.0|107.0|111.0|1|35
-booking_form|7.0|C|D|H||helvetica|12|#000000|Y|N|N|L|TLRB|Y|10.0|66|201.0|250.0|256.0|0.0|bank_details|helvetica|12|#000000|N|N|N|L|TLRB|N|10.0|66|201.0|256.0|262.0|5|1
+booking_form|2.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|10.0|30|128.0|15.0|20.0|1|1
+booking_form|3.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|10.0|30|76.0|21.0|25.0|1|1
+booking_form|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|80.0|7|97.0|21.0|25.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|97.0|20|141.0|21.0|25.0|1|1
+booking_form|5.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add2|courier|10|#000000|Y|N|N|L||N|10.0|30|76.0|25.0|29.0|1|1
+booking_form|6.0|C|A|L|TaxNo:|courier|10|#000000|Y|N|N|L||N|80.0|7|97.0|25.0|29.0|0.0|ctm_taxno|courier|10|#000000|Y|N|N|L||N|97.0|20|141.0|25.0|29.0|1|1
+booking_form|7.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add3|courier|10|#000000|Y|N|N|L||N|10.0|30|76.0|29.0|33.0|1|1
+booking_form|8.0|C|A|L|TelNo:|courier|10|#000000|Y|N|N|L||N|80.0|7|97.0|29.0|33.0|0.0|ctm_tel|courier|10|#000000|Y|N|N|L||N|97.0|15|131.0|29.0|33.0|1|1
+booking_form|9.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|#000000|Y|N|N|L||N|10.0|4|21.0|33.0|37.0|1|1
+booking_form|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|80.0|7|97.0|33.0|37.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|97.0|15|131.0|33.0|37.0|1|1
+booking_form|11.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_number|helvetica|14|#000000|Y|N|N|L||N|10.0|40|145.0|48.0|54.0|1|1
+booking_form|12.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_date|helvetica|14|#000000|Y|N|N|R||N|140.0|17|199.0|48.0|54.0|1|1
+booking_form|13.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|booking_letter|helvetica|12|#000000|N|N|N|L||N|10.0|66|201.0|60.0|65.0|6|1
+booking_form|14.0|T|B||Booking Details|helvetica|12|#000000|Y|N|N|L|TLRB|Y|10.0|66|201.0|100.0|106.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
+booking_form|15.0|C|B|L||helvetica|10|#000000|Y|N|N|L||N|10.0|30|83.0|107.0|111.0|0.0|booking_details|courier|10|#000000|N|N|N|L||N|83.0|35|168.0|107.0|111.0|1|35
+booking_form|16.0|T|D||Banking Details|helvetica|12|#000000|Y|N|N|L|TLRB|Y|10.0|66|201.0|250.0|256.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
+booking_form|17.0|C|D|L|Account Name:|helvetica|12|#000000|Y|N|N|L|L|N|10.0|20|69.0|256.0|262.0|0.0|company_name|helvetica|12|#000000|N|N|N|L|R|N|69.0|45|201.0|256.0|262.0|1|1
+booking_form|18.0|C|D|L|Bank Name:|helvetica|12|#000000|Y|N|N|L|L|N|10.0|20|69.0|262.0|268.0|0.0|ctm_b_name|helvetica|12|#000000|N|N|N|L|R|N|69.0|45|201.0|262.0|268.0|1|1
+booking_form|19.0|C|D|L|Branch Code:|helvetica|12|#000000|Y|N|N|L|L|N|10.0|20|69.0|268.0|274.0|0.0|ctm_b_ibt|helvetica|12|#000000|N|N|N|L|R|N|69.0|45|201.0|268.0|274.0|1|1
+booking_form|20.0|C|D|L|Account Number:|helvetica|12|#000000|Y|N|N|L|LB|N|10.0|20|69.0|274.0|280.0|0.0|ctm_b_acno|helvetica|12|#000000|N|N|N|L|RB|N|69.0|45|201.0|274.0|280.0|1|1
+booking_invoice|1.0|I|A||||0|#000000|||||||30.0|0|160.0|7.0|34.0|0.0|ctm_logo||0|#000000|N||||||0.0|0|0.0|0.0|0.0|0|0
+booking_invoice|2.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|30.0|30|144.0|7.0|12.0|1|1
+booking_invoice|3.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|30.0|30|93.0|14.0|19.0|1|1
+booking_invoice|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|124.0|7|139.0|14.0|19.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|139.0|20|181.0|14.0|19.0|1|1
+booking_invoice|5.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add2|courier|10|#000000|Y|N|N|L||N|30.0|30|93.0|18.0|23.0|1|1
+booking_invoice|6.0|C|A|L|TaxNo:|courier|10|#000000|Y|N|N|L||N|124.0|7|139.0|18.0|23.0|0.0|ctm_taxno|courier|10|#000000|Y|N|N|L||N|139.0|20|181.0|18.0|23.0|1|1
+booking_invoice|7.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add3|courier|10|#000000|Y|N|N|L||N|30.0|30|93.0|22.0|27.0|1|1
+booking_invoice|8.0|C|A|L|TelNo:|courier|10|#000000|Y|N|N|L||N|124.0|7|139.0|22.0|27.0|0.0|ctm_tel|courier|10|#000000|Y|N|N|L||N|139.0|15|171.0|22.0|27.0|1|1
+booking_invoice|9.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|#000000|Y|N|N|L||N|30.0|4|38.0|26.0|31.0|1|1
+booking_invoice|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|124.0|7|139.0|26.0|31.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|139.0|15|171.0|26.0|31.0|1|1
+booking_invoice|11.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|document_type|courier|12|#000000|Y|N|N|R||N|222.0|22|278.0|15.0|20.0|1|1
+booking_invoice|12.0|C|A|H|Charge To:|courier|10|#000000|Y|N|N|L|TLRB|Y|30.0|30|96.0|35.0|40.0|0.0|contact_details|courier|10|#000000|N|N|N|L|TLRB|N|30.0|30|96.0|40.0|44.0|5|1
+booking_invoice|13.0|C|A|H|Booking|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|36.0|41.0|0.0|bkm_number|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|41.0|45.0|1|1
+booking_invoice|14.0|C|A|H|Page No|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|45.0|50.0|0.0|page_number|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|50.0|54.0|1|1
+booking_invoice|15.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|54.0|59.0|0.0|document_date|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|59.0|63.0|1|1
+booking_invoice|16.0|C|A|H|Arrival|courier|10|#000000|Y|N|N|C|TLRB|Y|30.0|10|53.0|63.0|68.0|0.0|bkm_arrive|courier|10|#000000|N|N|N|C|TLRB|N|30.0|10|53.0|68.0|72.0|1|1
+booking_invoice|17.0|C|A|H|Departure|courier|10|#000000|Y|N|N|C|TLRB|Y|53.0|10|76.0|63.0|68.0|0.0|bkm_depart|courier|10|#000000|N|N|N|C|TLRB|N|53.0|10|76.0|68.0|72.0|1|1
+booking_invoice|18.0|C|A|H|Group Name|courier|10|#000000|Y|N|N|C|TLRB|Y|76.0|67|221.0|63.0|68.0|0.0|bkm_group|courier|10|#000000|N|N|N|C|TLRB|N|76.0|67|221.0|68.0|72.0|1|1
+booking_invoice|19.0|C|A|H|V.A.T. Number|courier|10|#000000|Y|N|N|C|TLRB|Y|221.0|15|255.0|63.0|68.0|0.0|bkc_vatno|courier|10|#000000|N|N|N|C|TLRB|N|221.0|15|255.0|68.0|72.0|1|1
+booking_invoice|20.0|C|A|H|Contact|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|63.0|68.0|0.0|bkc_ccode|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|68.0|72.0|1|1
+booking_invoice|21.0|C|B|H|T|courier|10|#000000|Y|N|N|C|TLRB|Y|30.0|1|34.0|72.0|77.0|0.0|brt_utype|courier|10|#000000|N|N|N|L|LR|N|30.0|1|34.0|77.0|81.0|1|20
+booking_invoice|22.0|C|B|H|U-Code|courier|10|#000000|Y|N|N|L|TLRB|Y|34.0|6|49.0|72.0|77.0|0.0|brt_ucode|courier|10|#000000|N|N|N|L|R|N|34.0|6|49.0|77.0|81.0|1|20
+booking_invoice|23.0|C|B|H|Unit Description|courier|10|#000000|Y|N|N|L|TLRB|Y|49.0|37|129.0|72.0|77.0|0.0|brt_udesc|courier|10|#000000|N|N|N|L|R|N|49.0|37|129.0|77.0|81.0|1|20
+booking_invoice|24.0|C|B|H|Qty|courier|10|#000000|Y|N|N|R|TLRB|Y|129.0|3|137.0|72.0|77.0|0.0|brt_quant|courier|10|#000000|N|N|N|R|R|N|129.0|3|137.0|77.0|81.0|1|20
+booking_invoice|25.0|C|B|H|Rate Description|courier|10|#000000|Y|N|N|L|TLRB|Y|137.0|35|214.0|72.0|77.0|0.0|brt_rdesc|courier|10|#000000|N|N|N|L|R|N|137.0|35|214.0|77.0|81.0|1|20
+booking_invoice|26.0|C|B|H|Rate|courier|10|#000000|Y|N|N|R|TLRB|Y|214.0|10|237.0|72.0|77.0|0.0|brt_arate|courier|10|#000000|N|N|N|R|R|N|214.0|10|237.0|77.0|81.0|1|20
+booking_invoice|27.0|C|B|H|Days|courier|10|#000000|Y|N|N|R|TLRB|Y|237.0|4|248.0|72.0|77.0|0.0|brt_bdays|courier|10|#000000|N|N|N|R|R|N|237.0|4|248.0|77.0|81.0|1|20
+booking_invoice|28.0|C|B|H|Value|courier|10|#000000|Y|N|N|R|TLRB|Y|248.0|13|278.0|72.0|77.0|0.0|line_value|courier|10|#000000|N|N|N|R|R|N|248.0|13|278.0|77.0|81.0|1|20
+booking_invoice|29.0|C|C|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|carried_forward|courier|10|#000000|Y|N|N|R|TLRB|N|229.0|22|278.0|157.0|162.0|1|1
+booking_invoice|30.0|C|C|L|Taxable|courier|10|#000000|Y|N|N|L|TLRB|Y|30.0|13|60.0|157.0|162.0|0.0|total_taxable|courier|10|#000000|Y|N|N|R|TLRB|N|60.0|13|90.0|157.0|162.0|1|1
+booking_invoice|31.0|C|C|L|Non-Taxable|courier|10|#000000|Y|N|N|L|TLRB|Y|90.0|15|124.0|157.0|162.0|0.0|total_nontaxable|courier|10|#000000|Y|N|N|R|TLRB|N|124.0|13|154.0|157.0|162.0|1|1
+booking_invoice|32.0|C|C|L|Total Tax|courier|10|#000000|Y|N|N|L|TLRB|Y|154.0|15|188.0|157.0|162.0|0.0|total_tax|courier|10|#000000|Y|N|N|R|TLRB|N|188.0|13|218.0|157.0|162.0|1|1
+booking_invoice|33.0|C|C|L|Total Value|courier|10|#000000|Y|N|N|L|TLRB|Y|218.0|13|248.0|157.0|162.0|0.0|total_value|courier|10|#000000|Y|N|N|R|TLRB|N|248.0|13|278.0|157.0|162.0|1|1
+booking_invoice|34.0|C|D|H|Message:|courier|10|#000000|Y|N|N|L|TLRB|Y|30.0|30|96.0|163.0|168.0|0.0|message|courier|10|#000000|N|N|N|L|LRB|N|30.0|30|96.0|168.0|172.0|5|1
+booking_invoice|35.0|T|D||Banking Details:|courier|10|#000000|Y|N|N|L|TLRB|Y|111.0|39|196.0|163.0|168.0|0.0|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+booking_invoice|36.0|C|D|L|Name:|courier|10|#000000|Y|N|N|L|L|N|111.0|8|130.0|168.0|172.0|0.0|ctm_b_name|courier|10|#000000|N|N|N|L|R|N|130.0|30|196.0|168.0|172.0|1|1
+booking_invoice|37.0|C|D|L|Branch:|courier|10|#000000|Y|N|N|L|L|N|111.0|8|130.0|172.0|176.0|0.0|ctm_b_branch|courier|10|#000000|N|N|N|L|R|N|130.0|30|196.0|172.0|176.0|1|1
+booking_invoice|38.0|C|D|L|Code:|courier|10|#000000|Y|N|N|L|L|N|111.0|8|130.0|176.0|180.0|0.0|ctm_b_ibt|courier|10|#000000|N|N|N|L|R|N|130.0|30|196.0|176.0|180.0|1|1
+booking_invoice|39.0|C|D|L|Account:|courier|10|#000000|Y|N|N|L|LB|N|111.0|8|130.0|180.0|184.0|0.0|ctm_b_acno|courier|10|#000000|N|N|N|L|RB|N|130.0|30|196.0|180.0|184.0|1|1
+booking_invoice|40.0|C|C|L|Movements|courier|10|#000000|Y|N|N|L|TLRB|Y|218.0|13|248.0|162.0|167.0|0.0|total_movements|courier|10|#000000|Y|N|N|R|TLRB|N|248.0|13|278.0|162.0|167.0|1|1
+booking_invoice|41.0|C|C|L|Balance|courier|10|#000000|Y|N|N|L|TLRB|Y|218.0|13|248.0|167.0|172.0|0.0|total_balance|courier|10|#000000|Y|N|N|R|TLRB|N|248.0|13|278.0|167.0|172.0|1|1
+booking_statement|1.0|I|A||||0|#000000|||||||15.0|0|130.0|15.0|35.0|0.0|ctm_logo||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+booking_statement|2.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|15.0|30|129.0|15.0|20.0|1|1
+booking_statement|3.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|21.0|25.0|1|1
+booking_statement|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|21.0|25.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|100.0|20|142.0|21.0|25.0|1|1
+booking_statement|5.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add2|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|25.0|28.0|1|1
+booking_statement|6.0|C|A|L|TaxNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|25.0|29.0|0.0|ctm_taxno|courier|10|#000000|Y|N|N|L||N|100.0|20|142.0|25.0|29.0|1|1
+booking_statement|7.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add3|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|29.0|33.0|1|1
+booking_statement|8.0|C|A|L|TelNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|29.0|33.0|0.0|ctm_tel|courier|10|#000000|Y|N|N|L||N|100.0|15|132.0|29.0|33.0|1|1
+booking_statement|9.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|#000000|Y|N|N|L||N|15.0|4|23.0|33.0|37.0|1|1
+booking_statement|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|33.0|37.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|100.0|15|132.0|33.0|37.0|1|1
+booking_statement|11.0|T|A||STATEMENT|courier|14|#000000|Y|N|N|R|TLRB|N|148.0|9|178.0|15.0|20.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
+booking_statement|12.0|C|A|H|Contact:|courier|10|#000000|Y|N|N|L|TLRB|Y|15.0|30|81.0|45.0|50.0|0.0|contact_details|courier|10|#000000|N|N|N|L|TLRB|N|15.0|30|81.0|50.0|54.0|5|1
+booking_statement|13.0|C|A|H|Booking|courier|10|#000000|Y|N|N|C|TLRB|Y|148.0|13|178.0|65.0|70.0|0.0|bkm_number|courier|10|#000000|N|N|N|C|TLRB|N|148.0|13|178.0|70.0|74.0|1|1
+booking_statement|14.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|148.0|13|178.0|74.0|79.0|0.0|document_date|courier|10|#000000|N|N|N|C|TLRB|N|148.0|13|178.0|79.0|83.0|1|1
+booking_statement|15.0|C|B|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|15.0|10|38.0|85.0|90.0|0.0|bkt_date|courier|10|#000000|N|N|N|C|LR|N|15.0|10|38.0|90.0|94.0|1|38
+booking_statement|16.0|C|B|H|Reference|courier|10|#000000|Y|N|N|C|TLRB|Y|38.0|9|59.0|85.0|90.0|0.0|bkt_refno|courier|10|#000000|N|N|N|L|R|N|38.0|9|59.0|90.0|94.0|1|38
+booking_statement|17.0|C|B|H|Typ|courier|10|#000000|Y|N|N|C|TLRB|Y|59.0|3|67.0|85.0|90.0|0.0|type_code|courier|10|#000000|N|N|N|C|R|N|59.0|3|67.0|90.0|94.0|1|38
+booking_statement|18.0|C|B|H|Details|courier|10|#000000|Y|N|N|C|TLRB|Y|67.0|30|148.0|85.0|90.0|0.0|bkt_desc|courier|10|#000000|N|N|N|L|R|N|67.0|30|148.0|90.0|94.0|1|38
+booking_statement|19.0|C|B|H|Amount|courier|10|#000000|Y|N|N|R|TLRB|Y|148.0|13|178.0|85.0|90.0|0.0|bkt_tramt|courier|10|#000000|N|N|N|R|R|N|148.0|13|178.0|90.0|94.0|1|38
+booking_statement|20.0|C|C|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|carried_forward|courier|10|#000000|Y|N|N|R|LRB|N|129.0|22|178.0|244.0|249.0|1|1
+booking_statement|21.0|C|C|H|Total Due|courier|10|#000000|Y|N|N|R|TLRB|Y|148.0|13|178.0|244.0|249.0|0.0|total_balance|courier|10|#000000|Y|N|N|R|TLRB|N|148.0|13|178.0|249.0|253.0|1|1
+booking_statement|22.0|T|D||Banking Details:|courier|10|#000000|Y|N|N|L|TLRB|Y|15.0|30|178.0|255.0|260.0|0.0|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+booking_statement|23.0|C|D|L|Bank:|courier|10|#000000|Y|N|N|L|LB|N|15.0|5|28.0|260.0|264.0|0.0|ctm_b_name|courier|10|#000000|N|N|N|L|B|N|28.0|27|87.0|260.0|264.0|1|1
+booking_statement|24.0|C|D|L|Branch:|courier|10|#000000|Y|N|N|L|B|N|87.0|7|104.0|260.0|264.0|0.0|ctm_b_ibt|courier|10|#000000|N|N|N|L|B|N|104.0|8|123.0|260.0|264.0|1|1
+booking_statement|25.0|C|D|L|Account:|courier|10|#000000|Y|N|N|L|B|N|123.0|8|142.0|260.0|264.0|0.0|ctm_b_acno|courier|10|#000000|N|N|N|L|RB|N|142.0|16|178.0|260.0|264.0|1|1
 comp_cards|1.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|bcm_name|courier|14|Y|N|N|C||N|58.5|30|150.5|6.0|11.0|1|1
 comp_cards|2.0|C|A|L|Game Number:|courier|10|Y|N|N|L||N|58.5|12|86.5|12.0|16.0|0.0|bcg_game|courier|10|N|N|N|L||N|86.5|2|92.5|12.0|16.0|1|1
 comp_cards|3.0|C|A|L|Rink:|courier|10|Y|N|N|L||N|93.5|5|106.5|12.0|16.0|0.0|bcg_rink|courier|10|N|N|N|L||N|106.5|2|112.5|12.0|16.0|1|1

=== modified file 'csv/tplmst.dat'
--- csv/tplmst.dat	2014-06-14 08:55:57 +0000
+++ csv/tplmst.dat	2014-11-12 16:48:56 +0000
@@ -1,4 +1,6 @@
 booking_form|Booking Form|B|BKM||A4|P
+booking_invoice|Booking Invoice|I|BKM||A4|L
+booking_statement|Booking Statement|S|BKM|N|A4|P
 comp_cards|Competition Cards|C|BWL||A4|P
 member_cards|Membership Cards|M|MEM||CC|P
 payslip|Payslip|P|WAG||A4|P

=== modified file 'doc/BC.rst'
--- doc/BC.rst	2014-05-08 17:02:33 +0000
+++ doc/BC.rst	2014-10-09 15:23:10 +0000
@@ -7,14 +7,14 @@
 Use this routine to create the bowls control record.
 
 + **M/L Integration** - Select whether or not the bowls system is integrated with the Member's system.
-+ **Same Numbers** - If integrated with the member's system is the tab number the same as the member's number.
++ **Same Numbers** - If integrated with the member's system is the tab number the same as the member number.
 + **Male Start Seq** - The number range for male bowler's tab numbers.
 + **Female Start Seq** - The number range for female bowler's tab numbers.
-+ **Non-member Start Seq** - The number range for non-member's player codes.
-+ **Draw Base** - By pre allocated Position, Rating or a Combination of both.
-+ **Rating Order** - Whether the rating system is ascending or descending like golf.
-+ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours.
-+ **Weeks Between Draws** - The number of weeks that team members should not be drawn together.
++ **Non-member Start Seq** - The number range for non-member's player codes. This number must be greater than the male and female numbers.
++ **Draw Base** - By pre-allocated Position, Rating or a Combination of both.
++ **Rating Order** - Whether the rating system is ascending or descending, like golf handicaps.
++ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours for eight players.
++ **Weeks Between Draws** - The minimum number of weeks that team members should not be in the same team again. The could however be drawn to play against them.
 + **Rate - Member** - The member's rate.
 + **Rate - Visitor** - The visitor's rate.
 + **Greens** - The available green codes e.g. AB
@@ -31,16 +31,27 @@
 Use this routine to create, delete or amend tab records.
 
 + **Tab Number** - The number of the tab or zero for the next available number depending on the gender of the member.
-+ **Membership Number** - If the Member system is integrated enter the member's membership number and the surname, names, gender and status will be obtained from there.
-+ **Surname** - The member's surname.
-+ **Names** - The member's names.
-+ **Gender** - The member's gender.
-+ **Position - Primary** - The position the member normally plays.
-+ **Rating - Primary** - The member's rating as rated by the selectors.
-+ **Position - Mixed** - The position the member plays in mixed bowls.
-+ **Rating - Mixed** - The member's rating in mixed bowls.
-+ **Association Number** - The member's number with the bowl's association.
-+ **Status** - The member's membership status i.e. Active, Deceased, Defaulted, Inactive, Resigned or Suspended.
++ **Membership Number** - If the Member system is integrated enter the member's membership number and the details will be obtained from there.
++ **Surname** - The person's surname.
++ **Names** - The person's names.
++ **Gender** - The person's gender.
++ **Address Line 1** - The person's address line 1.
++ **Address Line 2** - The person's address line 2.
++ **Address Line 3** - The person's address line 3.
++ **Postal Code** - The person's postal code.
++ **Home Number** - The person's home phone number.
++ **Work Number** - The person's work phone number.
++ **Cell Number** - The person's mobile phone number.
++ **Email Address** - The person's email address.
++ **Position - Primary** - The position the person should normally play.
++ **Rating - Primary** - The person's rating as graded by the selectors.
++ **Position - Mixed** - The position the person should play in mixed bowls.
++ **Rating - Mixed** - The person's rating in mixed bowls.
++ **Association Number** - The person's number with the bowling association.
+
+In addtion there is the following button.
+
++ **Import** - Use this button to import, only tab ratings for existing tabs or all tab details for existing and new members, from an excel (xls) or comma separated (csv) file.
 
 League Formats
 ++++++++++++++
@@ -53,7 +64,7 @@
 + **Assess Self** - Whether the player must assess himself.
 + **Rating Out Of** - What the maximum assessment rating could be.
 + **Sets Format** - Whether sets are to be played.
-+ **Logo** - The logo image file of the sponsor.
++ **Logo** - The logo image file of the sponsor, if applicable.
 
 Side's Maintenance
 ++++++++++++++++++
@@ -143,7 +154,7 @@
     + **Tabs Draw Board** - Print an emulation of a tabs draw board.
     + **Include Empty Rinks** - Whether to include or exclude empty rinks when printing a tabs draw board.
 + **Edit Draw** - Use this button to manually change a draw.
-+ **Exit** - Use this button to exit the program. If the draw has not yet been saved you will be prompted to do so.
++ **Exit** - Use this button to exit the program. If the draw has not yet been done you will be prompted to confirm exiting.
 
 Reprint Draw
 ++++++++++++
@@ -336,7 +347,7 @@
 + **Old Code** - The old code
 + **New Code** - The new code
 
-The **Generate** button is used to automatically renumber codes in surname and names sequence.
+The **Generate** button is used to automatically generate new codes in surname and names order.
 
 Clear League History
 ++++++++++++++++++++

=== added file 'doc/BK.rst'
--- doc/BK.rst	1970-01-01 00:00:00 +0000
+++ doc/BK.rst	2014-12-01 06:57:06 +0000
@@ -0,0 +1,105 @@
+Bookings Manager
+~~~~~~~~~~~~~~~~
+File Maintenance (BK)
+.....................
+Control Record (BK)
++++++++++++++++++++
+Use this routine to maintain a bookings control record.
+
++ **G/L Integration** - Yes to integrate else No.
++ **Booking Template** - The template to use for the booking forms.
++ **Booking Template** - The template to use for the booking invoice.
++ **Booking Template** - The template to use for the booking statement.
++ **Terms and Conditions** - The terms and conditions file to attach to the booking query.
+
+Unit Records
+++++++++++++
+Use this routine to maintain unit records.
+
++  **Type** - Select the type of unit.
++  **Code** - Enter a code which can be up to 6 alphanumeric characters.
++  **Description** - Enter a description for the unit.
++  **Multiple** - Select whether the unit can appear on multiple bookings.
++  **Capacity** - Enter the minimum capacity for bookings.
++  **Vat Code** - Enter the vat code applicable to this unit.
++  **y** - Enter the G/L sales account, if integrated.
+
+Rate Records (BK)
++++++++++++++++++
+Use this routine to maintain rate records as follows:
+
++ **Unit Type** - Enter a type of unit this rate applies to.
++ **Code** - Enter a code which can be up to 3 numeris digits.
++ **Description** - Enter the description of the rate record.
++ **Rate Base** - Select the applicable base rate.
++ **Starting Date** - Enter the date this rate becomes applicable.
++ **Rate Amount** - Enter the rate amount.
+
+Booking Letters
++++++++++++++++
+Use this routine to maintain booking letters.
+
++ **Letter Type** - Select the type of letter.
++ **Body** - Enter body of the letter.
+
+Booking Contacts
+++++++++++++++++
+Use this routine to maintain contacts. The fields are self explanatory with the exception of the following:
+
++ **Code** - Enter the code for the contact or blank for a new contact.
+
+XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+Reporting
+.........
+Groups Listing
+++++++++++++++
+Use this routine to produce a report of all asset groups.
+
+Batch Error Listing (AR)
+++++++++++++++++++++++++
+Use this routine to print any unbalanced batches.
+
++ **Type** - The transaction type or 0 for all.
++ **Batch-Number** - The batch number or blank for all.
+
+Transaction Audit Trail (AR)
+++++++++++++++++++++++++++++
+Use this routine to print lists of transactions either by financial period or date of capture.
+
++ **Starting Period** - The first financial period to include in the report.
++ **Ending Period** - The last financial period to include in the report.
++ **Type** - The transaction type or 0 for all.
++ **Batch-Number** - The batch number or blank for all.
++ **Totals Only** - Yes or No.
+
+Asset Statements
+++++++++++++++++
+Use this routine to produce asset statements.
+
++ **Start Period** - The starting period.
++ **End Period** - The ending period.
++ **Product Group** - The asset group or blank for all.
++ **Asset per Page** - Whether or not to start each asset on a new page.
+
+Asset Register
+++++++++++++++
+Use this routine to print an asset register.
+
++ **Cut-Off Period** - The last month period to take into account.
++ **Report Type** - If applicable select either Company or Receiver.
++ **Asset Group** - Select an asset group or leave blank for all groups.
++ **Ignore Zero Items** - Select Yes to ignore all items sold or written off.
+
+Notes Listing (AR)
+++++++++++++++++++
+Use this routine to print any notes on the asset records.
+
++ **Action Flag** - Normal or Urgent.
++ **From Capture Date** - The starting creation date.
++ **To Capture Date** - The ending creation date.
++ **From Action Date** - The starting action date.
++ **To Action Date** - The ending action date.
+
+Interrogation (AR)
+..................
+This routine is for querying individual assets.

=== modified file 'doc/Bowls.rst'
--- doc/Bowls.rst	2014-08-06 15:44:15 +0000
+++ doc/Bowls.rst	2014-10-09 06:16:02 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.0.0
+:Version:   5.0.1
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -76,7 +76,7 @@
 
 or
 
-+ Mysql >= 5.0.0
++ Mysql >= 5.0.1
 + Mysql-python >= 1.2.0
 
 Download the following file from ftp://ftp.tartan.co.za
@@ -447,6 +447,10 @@
 ....................
 Use this routine to change the financial year end date from a specific period.
 
+.. raw:: pdf
+
+    PageBreak
+
 Bowls Clubs
 ~~~~~~~~~~~
 File Maintenance
@@ -456,14 +460,14 @@
 Use this routine to create the bowls control record.
 
 + **M/L Integration** - Select whether or not the bowls system is integrated with the Member's system.
-+ **Same Numbers** - If integrated with the member's system is the tab number the same as the member's number.
++ **Same Numbers** - If integrated with the member's system is the tab number the same as the member number.
 + **Male Start Seq** - The number range for male bowler's tab numbers.
 + **Female Start Seq** - The number range for female bowler's tab numbers.
-+ **Non-member Start Seq** - The number range for non-member's player codes.
-+ **Draw Base** - By pre allocated Position, Rating or a Combination of both.
-+ **Rating Order** - Whether the rating system is ascending or descending like golf.
-+ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours.
-+ **Weeks Between Draws** - The number of weeks that team members should not be drawn together.
++ **Non-member Start Seq** - The number range for non-member's player codes. This number must be greater than the male and female numbers.
++ **Draw Base** - By pre-allocated Position, Rating or a Combination of both.
++ **Rating Order** - Whether the rating system is ascending or descending, like golf handicaps.
++ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours for eight players.
++ **Weeks Between Draws** - The minimum number of weeks that team members should not be drawn to be play with each other.
 + **Rate - Member** - The member's rate.
 + **Rate - Visitor** - The visitor's rate.
 + **Greens** - The available green codes e.g. AB
@@ -480,16 +484,15 @@
 Use this routine to create, delete or amend tab records.
 
 + **Tab Number** - The number of the tab or zero for the next available number depending on the gender of the member.
-+ **Membership Number** - If the Member system is integrated enter the member's membership number and the surname, names, gender and status will be obtained from there.
-+ **Surname** - The member's surname.
-+ **Names** - The member's names.
-+ **Gender** - The member's gender.
-+ **Position - Primary** - The position the member normally plays.
-+ **Rating - Primary** - The member's rating as rated by the selectors.
-+ **Position - Mixed** - The position the member plays in mixed bowls.
-+ **Rating - Mixed** - The member's rating in mixed bowls.
-+ **Association Number** - The member's number with the bowl's association.
-+ **Status** - The member's membership status i.e. Active, Deceased, Defaulted, Inactive, Resigned or Suspended.
++ **Membership Number** - If the Member system is integrated enter the member's membership number and the details will be obtained from there.
++ **Surname** - The surname.
++ **Names** - The person's names.
++ **Gender** - The person's gender.
++ **Position - Primary** - The position the person normally plays.
++ **Rating - Primary** - The person's rating as rated by the selectors.
++ **Position - Mixed** - The position the person plays in mixed bowls.
++ **Rating - Mixed** - The person's rating in mixed bowls.
++ **Association Number** - The person's number with the bowl's association.
 
 League Formats
 ++++++++++++++
@@ -502,7 +505,7 @@
 + **Assess Self** - Whether the player must assess himself.
 + **Rating Out Of** - What the maximum assessment rating could be.
 + **Sets Format** - Whether sets are to be played.
-+ **Logo** - The logo image file of the sponsor.
++ **Logo** - The logo image file of the sponsor, if applicable.
 
 Side's Maintenance
 ++++++++++++++++++
@@ -592,7 +595,7 @@
     + **Tabs Draw Board** - Print an emulation of a tabs draw board.
     + **Include Empty Rinks** - Whether to include or exclude empty rinks when printing a tabs draw board.
 + **Edit Draw** - Use this button to manually change a draw.
-+ **Exit** - Use this button to exit the program. If the draw has not yet been saved you will be prompted to do so.
++ **Exit** - Use this button to exit the program. If the draw has not yet been done you will be prompted to confirm exiting.
 
 Reprint Draw
 ++++++++++++
@@ -794,6 +797,10 @@
 + **Clear Players** - Select whether or not to also erase all player's details.
 + **Clear Opponents** - Select whether or not to also erase all opponent's details.
 
+.. raw:: pdf
+
+    PageBreak
+
 Utilities
 ~~~~~~~~~
 Bulk Mail Utility
@@ -979,4 +986,3 @@
 Tartan Manual
 .............
 This routine will display this manual using your default browser.
-

=== modified file 'doc/Downloads.rst'
--- doc/Downloads.rst	2014-08-30 12:52:42 +0000
+++ doc/Downloads.rst	2014-12-09 16:32:44 +0000
@@ -11,16 +11,16 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.0.1 and was released on the 30th August, 2014.
+The latest version of Tartan is 5.0.2 and was released on the 9th December, 2014.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Documentation: http://www.tartan.co.za/cgi-bin/simple_web.py/Documentation
-.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.0.1.tar.gz
+.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.0.2.tar.gz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.10.tar.gz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tar.gz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tar.gz
-.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.0.1.exe
+.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.0.2.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.10.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
 .. _Tartan-2-win: ftp://tartan.co.za/Tartan_2.5.29.exe

=== modified file 'doc/Main.rst'
--- doc/Main.rst	2014-08-30 12:52:42 +0000
+++ doc/Main.rst	2014-12-09 16:32:44 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.0.1
+:Version:   5.0.2
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -76,7 +76,7 @@
 
 or
 
-+ Mysql >= 5.0.1
++ Mysql >= 5.0.2
 + Mysql-python >= 1.2.0
 
 Download the following file from ftp://ftp.tartan.co.za

=== modified file 'doc/Manual.rst'
--- doc/Manual.rst	2014-08-06 15:44:15 +0000
+++ doc/Manual.rst	2014-10-06 08:26:37 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.0.0
+:Version:   5.0.1
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -76,7 +76,7 @@
 
 or
 
-+ Mysql >= 5.0.0
++ Mysql >= 5.0.1
 + Mysql-python >= 1.2.0
 
 Download the following file from ftp://ftp.tartan.co.za
@@ -447,6 +447,10 @@
 ....................
 Use this routine to change the financial year end date from a specific period.
 
+.. raw:: pdf
+
+    PageBreak
+
 General Ledger
 ~~~~~~~~~~~~~~
 File Maintenance (GL)
@@ -938,6 +942,10 @@
 ..................
 This routine is for querying individual general ledger accounts.
 
+.. raw:: pdf
+
+    PageBreak
+
 Creditor's Ledger
 ~~~~~~~~~~~~~~~~~
 File Maintenance (CR)
@@ -1122,6 +1130,10 @@
 ..................
 This routine is for querying individual creditor's ledger accounts.
 
+.. raw:: pdf
+
+    PageBreak
+
 Debtor's Ledger
 ~~~~~~~~~~~~~~~
 File Maintenance (DR)
@@ -1380,6 +1392,10 @@
 ..................
 This routine is for querying individual debtor's accounts.
 
+.. raw:: pdf
+
+    PageBreak
+
 Store's Ledger
 ~~~~~~~~~~~~~~
 File Maintenance (ST)
@@ -1546,6 +1562,10 @@
 ..................
 This routine is for querying individual Store's Ledger Accounts.
 
+.. raw:: pdf
+
+    PageBreak
+
 Sales Invoicing
 ~~~~~~~~~~~~~~~
 File Maintenance (SI)
@@ -1628,6 +1648,10 @@
     + **Exit** - To exit the sales routine.
     + **Accept** - This button is to accept and complete the document.
 
+.. raw:: pdf
+
+    PageBreak
+
 Asset's Register
 ~~~~~~~~~~~~~~~~
 File Maintenance (AR)
@@ -1755,6 +1779,10 @@
 ..................
 This routine is for querying individual assets.
 
+.. raw:: pdf
+
+    PageBreak
+
 Rental's Ledger (Standard)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 File Maintenance (RT)
@@ -1843,6 +1871,10 @@
 ......................
 This routine is used to close off a month and raise rentals for the following month.
 
+.. raw:: pdf
+
+    PageBreak
+
 Rental's Ledger (Extended)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 File Maintenance (RC)
@@ -2029,6 +2061,10 @@
 ......................
 This routine is used to close off a month and raise rentals for the following month.
 
+.. raw:: pdf
+
+    PageBreak
+
 Salaries and Wages
 ~~~~~~~~~~~~~~~~~~
 File Maintenance (WG)
@@ -2142,6 +2178,10 @@
 +++++++++++++++++
 Use this routine to capture employee terminations.
 
+.. raw:: pdf
+
+    PageBreak
+
 Staff Loans
 ~~~~~~~~~~~
 File Maintenance (SL)
@@ -2229,6 +2269,10 @@
 ..................
 This routine is for querying individual loans.
 
+.. raw:: pdf
+
+    PageBreak
+
 Member's Ledger
 ~~~~~~~~~~~~~~~
 File Maintenance (ML)
@@ -2516,6 +2560,10 @@
 
 You will be asked whether you want to print certain reports and finally whether you want to save all entries. Please read the relevant questions and answer appropriately. Please note that if you do not save the entries it will be as if the month end was never run.
 
+.. raw:: pdf
+
+    PageBreak
+
 Bowls Clubs
 ~~~~~~~~~~~
 File Maintenance
@@ -2525,14 +2573,14 @@
 Use this routine to create the bowls control record.
 
 + **M/L Integration** - Select whether or not the bowls system is integrated with the Member's system.
-+ **Same Numbers** - If integrated with the member's system is the tab number the same as the member's number.
++ **Same Numbers** - If integrated with the member's system is the tab number the same as the member number.
 + **Male Start Seq** - The number range for male bowler's tab numbers.
 + **Female Start Seq** - The number range for female bowler's tab numbers.
-+ **Non-member Start Seq** - The number range for non-member's player codes.
-+ **Draw Base** - By pre allocated Position, Rating or a Combination of both.
-+ **Rating Order** - Whether the rating system is ascending or descending like golf.
-+ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours.
-+ **Weeks Between Draws** - The number of weeks that team members should not be drawn together.
++ **Non-member Start Seq** - The number range for non-member's player codes. This number must be greater than the male and female numbers.
++ **Draw Base** - By pre-allocated Position, Rating or a Combination of both.
++ **Rating Order** - Whether the rating system is ascending or descending, like golf handicaps.
++ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours for eight players.
++ **Weeks Between Draws** - The minimum number of weeks that team members should not be drawn to be play with each other.
 + **Rate - Member** - The member's rate.
 + **Rate - Visitor** - The visitor's rate.
 + **Greens** - The available green codes e.g. AB
@@ -2549,16 +2597,15 @@
 Use this routine to create, delete or amend tab records.
 
 + **Tab Number** - The number of the tab or zero for the next available number depending on the gender of the member.
-+ **Membership Number** - If the Member system is integrated enter the member's membership number and the surname, names, gender and status will be obtained from there.
-+ **Surname** - The member's surname.
-+ **Names** - The member's names.
-+ **Gender** - The member's gender.
-+ **Position - Primary** - The position the member normally plays.
-+ **Rating - Primary** - The member's rating as rated by the selectors.
-+ **Position - Mixed** - The position the member plays in mixed bowls.
-+ **Rating - Mixed** - The member's rating in mixed bowls.
-+ **Association Number** - The member's number with the bowl's association.
-+ **Status** - The member's membership status i.e. Active, Deceased, Defaulted, Inactive, Resigned or Suspended.
++ **Membership Number** - If the Member system is integrated enter the member's membership number and the details will be obtained from there.
++ **Surname** - The surname.
++ **Names** - The person's names.
++ **Gender** - The person's gender.
++ **Position - Primary** - The position the person normally plays.
++ **Rating - Primary** - The person's rating as rated by the selectors.
++ **Position - Mixed** - The position the person plays in mixed bowls.
++ **Rating - Mixed** - The person's rating in mixed bowls.
++ **Association Number** - The person's number with the bowl's association.
 
 League Formats
 ++++++++++++++
@@ -2571,7 +2618,7 @@
 + **Assess Self** - Whether the player must assess himself.
 + **Rating Out Of** - What the maximum assessment rating could be.
 + **Sets Format** - Whether sets are to be played.
-+ **Logo** - The logo image file of the sponsor.
++ **Logo** - The logo image file of the sponsor, if applicable.
 
 Side's Maintenance
 ++++++++++++++++++
@@ -2661,7 +2708,7 @@
     + **Tabs Draw Board** - Print an emulation of a tabs draw board.
     + **Include Empty Rinks** - Whether to include or exclude empty rinks when printing a tabs draw board.
 + **Edit Draw** - Use this button to manually change a draw.
-+ **Exit** - Use this button to exit the program. If the draw has not yet been saved you will be prompted to do so.
++ **Exit** - Use this button to exit the program. If the draw has not yet been done you will be prompted to confirm exiting.
 
 Reprint Draw
 ++++++++++++
@@ -2863,6 +2910,10 @@
 + **Clear Players** - Select whether or not to also erase all player's details.
 + **Clear Opponents** - Select whether or not to also erase all opponent's details.
 
+.. raw:: pdf
+
+    PageBreak
+
 Utilities
 ~~~~~~~~~
 Bulk Mail Utility
@@ -3036,6 +3087,10 @@
 ...................
 Use this routine to manage a telephone directory.
 
+.. raw:: pdf
+
+    PageBreak
+
 Help
 ~~~~
 About Tartan
@@ -3049,6 +3104,10 @@
 .............
 This routine will display this manual using your default browser.
 
+.. raw:: pdf
+
+    PageBreak
+
 Quick Start
 -----------
 Once Tartan Systems has been installed, the following procedures have to be performed before any meaningful work can be done. These procedures obviously depend on which modules are going to be used but this will be explained as we progress.
@@ -3206,4 +3265,3 @@
         * To change Match Cards select `Change Match Cards`_ from the menu. After changing the cards you must reprint them as per above. Please note that to only reprint certain cards you must select `All Cards No`.
         * After the games have been played enter the results by selecting `Capture Results`_ from the menu.
         * Print the game and match results by selecting the applicable routines from the menu.
-

=== modified file 'doc/SC.rst'
--- doc/SC.rst	2014-03-28 07:32:49 +0000
+++ doc/SC.rst	2014-12-02 15:56:40 +0000
@@ -194,26 +194,37 @@
 +++++++++++++++
 Use this routine to create a new competition and to capture entries to the competition.
 
-+ **Code** - The relevant competition number or zero for the next available number.
++ **Code** - The relevant competition code or zero for the next available code.
 + **Name** - The name of the competition.
++ **Gender** - The gender of the entrants.
 + **Team Size** - The number of players per team.
 + **Format** - The initial format of the competition.
 + **Logo** - The logo file of the sponsor, if applicable.
 
 Enter the Codes of the Entered Members.
 
-+ **Skp** - The skip's code as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
-+ **Ptr** - The partner's code, in the case of pairs, as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
++ **Skip** - The skip's code as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
++ **Lead** - The partner's code, in the case of pairs, as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
+
+List Entries
+++++++++++++
+Use this routine to generate a list of entered players.
+
++ **Code** - The relevant competition code.
++ **Output** - Select whether to view or print the draw.
++ **Printer Name** - The printer to use for printing.
 
 Competiton Draw
 +++++++++++++++
 Once all the entries have been captured you can perform the draw for the competition as follow:
 
 + **Competition Code** - The relevant competition code.
++ **Type** - The relevant draw type, main or play-offs.
 + **Number of Entries** - The number of entries will be displayed.
 + **Entries per Section** - The relevant number of entries per section or
-+ **Number of Section** - The total number of sections to create.
++ **Number of Sections** - The total number of sections to create.
 + **Sub-Sections** - Whether or not the sections must be split into sub-sections.
++ **Possible Qualifiers** - The number of possible qualifiers per section.
 + **Closed-Up** - In the case of Knockout competitions select whether to produce a closed-up draw or a fixed draw.
 + **Output** - Select whether to view or print the draw.
 + **Printer Name** - The printer to use for printing.
@@ -223,24 +234,11 @@
 Use this routine to capture completed games of Round Robin matches as follows:
 
 + **Competition Code** - The relevant competition code.
++ **Type** - The relevant draw type, main or play-offs.
 + **Round** - The relevant round number.
 
 Enter the results by section as follows:
 
++ **S-Code** - The skips code.
 + **SF** - Shots scored by the skip's side.
-+ **Pnts** - Points scored by the skip's side, if applicable.
 + **SA** - Shots scored by the opposing side.
-+ **Pnts** - Points scored by the opposing side, if applicable.
-
-Competiton Results
-++++++++++++++++++
-Use this routine to print the competition results as follows:
-
-+ **Competition Code** - The relevant competition code.
-+ **Last Game** - The last game to take into account.
-+ **Session Prizes by Group** - Whether session prizes are to be awarded by group or overall.
-
-Prizes by Group or the Match if not Grouped
-
-+ **Number Prizes** - The number of prizes being awarded.
-+ **EFT Forms** - Whether to print EFT Forms in which case you will be required to enter the total value of each prize.

=== modified file 'doc/Tartan.rst'
--- doc/Tartan.rst	2014-03-28 07:32:49 +0000
+++ doc/Tartan.rst	2014-11-13 16:58:53 +0000
@@ -36,10 +36,6 @@
    :target: http://www.python.org
 .. |pgsql| image:: /images/postgresql.png
    :target: http://www.postgresql.org
-.. |gtk| image:: /images/gtk.png
-   :target: http://www.gtk.org
-.. |pygtk| image:: /images/pygtk.jpg
-   :target: http://www.pygtk.org
 .. |gnu-head| image:: /images/gnu-head.png
    :target: /images/gnugpl.html
 .. |launchpad| image:: /images/launchpad.png
@@ -50,9 +46,5 @@
    :width: 80px
    :height: 40px
    :target: http://sourceforge.net/projects/tartansystems/
-.. |silogo| image:: /images/silogo.png
-   :width: 80px
-   :height: 40px
-   :target: http://tartan.software.informer.com
 
-|python| |pygtk| |gtk| |gnu-head| |pgsql| |launchpad| |sourceforge| |silogo|
+|python| |gnu-head| |pgsql| |launchpad| |sourceforge|

=== modified file 'doc/Utils.rst'
--- doc/Utils.rst	2014-08-06 15:44:15 +0000
+++ doc/Utils.rst	2014-10-09 06:31:26 +0000
@@ -108,6 +108,7 @@
 
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
+    + **Colour** - The line colour.
     + **Bold** - Whether to display the line in bold format.
     + **X1 Co-Ordinate** - The left hand position of the line in mm.
     + **Chrs** - The number of characters the line should extend.
@@ -120,6 +121,7 @@
 
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
+    + **Colour** - The text colour.
     + **Bold** - Whether to display the text in bold format.
     + **Italic** - Whether to display the text in italic format.
     + **Underline** - Whether to underline the text.
@@ -139,6 +141,7 @@
     + **Text Detail** - The text.
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
+    + **Colour** - The text colour.
     + **Bold** - Whether to display the text in bold format.
     + **Italic** - Whether to display the text in italic format.
     + **Underline** - Whether to underline the text.
@@ -153,6 +156,7 @@
     + **Merge Code** - The code to use to import data.
     + **Font Name** - The name of the font to use for the imported data.
     + **Size** - The font size to use for the imported data.
+    + **Colour** - The text colour.
     + **Bold** - Whether to display the imported data in bold format.
     + **Italic** - Whether to display the imported data in italic format.
     + **Underline** - Whether to underline the imported data.

=== added file 'doc/stylesheet'
--- doc/stylesheet	1970-01-01 00:00:00 +0000
+++ doc/stylesheet	2014-10-09 06:12:44 +0000
@@ -0,0 +1,585 @@
+
+  # List any fonts you would like to embed in the PDF here
+  embeddedFonts: []
+
+  # Default page setup.  Can be overridden by including other
+  # stylesheets with -s
+
+  pageSetup:
+    size: A4-landscape
+    width: 0
+    height: 0
+    margin-top: 1cm
+    margin-bottom: 1cm
+    margin-left: 1cm
+    margin-right: 1cm
+    margin-gutter: 0cm
+    spacing-header: 5mm
+    spacing-footer: 5mm
+
+    # The first template is one of the 'pageTemplates"
+    # (See next section)
+
+    firstTemplate: twoColumn
+
+  # pageTemplates can be accessed with the .. raw:: pdf PageBreak command
+
+  pageTemplates:
+    coverPage:
+        frames: []
+            [0cm, 0cm, 100%, 100%]
+        showHeader : false
+        showFooter : false
+
+    emptyPage:
+        frames: []
+            [0cm, 0cm, 100%, 100%]
+        showHeader : false
+        showFooter : false
+
+    oneColumn:
+        frames: []
+            [0cm, 0cm, 100%, 100%]
+        showHeader : true
+        showFooter : true
+
+    twoColumn:
+        frames: []
+            [0cm, 0cm, 49%, 100%]
+            [51%, 0cm, 49%, 100%]
+        showHeader : true
+        showFooter : true
+
+    threeColumn:
+        frames: []
+            [2%, 0cm, 29.333%, 100%]
+            [35.333%, 0cm, 29.333%, 100%]
+            [68.666%, 0cm, 29.333%, 100%]
+        showHeader : true
+        showFooter : true
+
+    cutePage:
+        frames: []
+            [0%, 0%, 100%, 100%]
+        showHeader : true
+        showFooter : true
+        defaultFooter : ###Page###
+        defaultHeader : ###Section###
+
+  fontsAlias:
+    stdFont: Helvetica
+    stdBold: Helvetica-Bold
+    stdItalic: Helvetica-Oblique
+    stdBoldItalic: Helvetica-BoldOblique
+    stdSans: Helvetica
+    stdSansBold: Helvetica-Bold
+    stdSansItalic: Helvetica-Oblique
+    stdSansBoldItalic: Helvetica-BoldOblique
+    stdMono: Courier
+    stdMonoItalic: Courier-Oblique
+    stdMonoBold: Courier-Bold
+    stdMonoBoldItalic: Courier-BoldOblique
+    stdSerif: Times-Roman
+
+  linkColor: navy
+
+  styles:
+    base:
+      parent: null
+      fontName: stdFont
+      fontSize: 10
+      leading: 12
+      leftIndent: 0
+      rightIndent: 0
+      firstLineIndent: 0
+      alignment: TA_LEFT
+      spaceBefore: 0
+      spaceAfter: 0
+      bulletFontName: stdFont
+      bulletFontSize: 10
+      bulletIndent: 0
+      textColor: black
+      backColor: null
+      wordWrap: null
+      borderWidth: 0
+      borderPadding: 0
+      borderColor: null
+      borderRadius: null
+      allowWidows: false
+      allowOrphans: false
+      hyphenation: false
+      kerning: false
+      underline: false
+      strike: false
+      commands: []
+
+    normal:
+      parent: base
+
+    title-reference:
+      parent: normal
+      fontName: stdItalic
+
+    bodytext:
+      parent: normal
+      spaceBefore: 6
+      alignment: TA_JUSTIFY
+      hyphenation: true
+
+    toc:
+      parent: normal
+
+    blockquote:
+      parent: bodytext
+      leftIndent: 20
+
+    lineblock:
+      parent: bodytext
+
+    line:
+      parent: lineblock
+      spaceBefore: 0
+
+    toc1:
+      parent: toc
+      fontName: stdBold
+
+    toc2:
+      parent: toc
+      leftIndent: 20
+
+    toc3:
+      parent: toc
+      leftIndent: 40
+
+    toc4:
+      parent: toc
+      leftIndent: 60
+
+    toc5:
+      parent: toc
+      leftIndent: 80
+
+    toc6:
+      parent: toc
+      leftIndent: 100
+
+    toc7:
+      parent: toc
+      leftIndent: 100
+
+    toc8:
+      parent: toc
+      leftIndent: 100
+
+    toc9:
+      parent: toc
+      leftIndent: 100
+
+    toc10:
+      parent: toc
+      leftIndent: 100
+
+    toc11:
+      parent: toc
+      leftIndent: 100
+
+    toc12:
+      parent: toc
+      leftIndent: 100
+
+    toc13:
+      parent: toc
+      leftIndent: 100
+
+    toc14:
+      parent: toc
+      leftIndent: 100
+
+    toc15:
+      parent: toc
+      leftIndent: 100
+
+    footer:
+      parent: normal
+      alignment: TA_CENTER
+
+    header:
+      parent: normal
+      alignment: TA_CENTER
+
+    attribution:
+      parent: bodytext
+      alignment: TA_RIGHT
+
+    image:
+      parent: bodytext
+      alignment: TA_CENTER
+
+    figure:
+      parent: bodytext
+      alignment: TA_CENTER
+      commands: []
+             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+             [ALIGN, [ 0, 0 ], [ -1, -1 ], CENTER ]
+      colWidths: [100%]
+
+    figure-caption:
+      parent: bodytext
+      fontName: stdItalic
+      alignment: TA_CENTER
+
+    figure-legend:
+      parent: bodytext
+
+    bullet-list:
+      parent: bodytext
+      commands: []
+             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+             [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
+      colWidths: ["20", null]
+
+    bullet-list-item:
+      parent: bodytext
+
+    item-list:
+      parent: bodytext
+      commands: []
+             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+             [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
+      colWidths: [20pt,null]
+
+    item-list-item:
+      parent: bodytext
+
+    definition-list-term:
+      parent: normal
+      fontName: stdBold
+      spaceBefore: 4
+      spaceAfter: 0
+      keepWithNext: false
+
+    definition-list-classifier:
+      parent: normal
+      fontName: stdItalic
+
+    definition:
+      parent: bodytext
+      firstLineIndent: 0
+      bulletIndent: 0
+      spaceBefore: 0
+      colWidths: [20pt,null]
+      commands: []
+                    [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+                    [LEFTPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+                    [BOTTOMPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+                    [RIGHTPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+                    
+    fieldname:
+      parent: bodytext
+      alignment: TA_RIGHT
+      fontName: stdBold
+
+    fieldvalue:
+      parent: bodytext
+
+    rubric:
+      parent: bodytext
+      textColor: darkred
+      alignment: TA_CENTER
+
+    italic:
+      parent: bodytext
+      fontName: stdItalic
+
+    heading:
+      parent: normal
+      keepWithNext: true
+      spaceBefore: 12
+      spaceAfter: 6
+
+    title:
+      parent: heading
+      fontName: stdBold
+      fontSize: 200%
+      alignment: TA_CENTER
+      keepWithNext: false
+      spaceAfter: 10
+
+    subtitle:
+      parent: title
+      spaceBefore: 12
+      fontSize: 75%
+
+    heading1:
+      parent: heading
+      fontName: stdBold
+      fontSize: 175%
+
+    heading2:
+      parent: heading
+      fontName: stdBold
+      fontSize: 150%
+
+    heading3:
+      parent: heading
+      fontName: stdBoldItalic
+      fontSize: 125%
+
+    heading4:
+      parent: heading
+      fontName: stdBoldItalic
+
+    heading5:
+      parent: heading
+      fontName: stdBoldItalic
+
+    heading6:
+      parent: heading
+      fontName: stdBoldItalic
+
+    topic-title:
+      parent: heading3
+
+    sidebar-title:
+      parent: heading3
+
+    sidebar-subtitle:
+      parent: heading4
+
+    sidebar:
+      float: none
+      width: 100%
+      parent: normal
+      backColor: beige
+      borderColor: darkgray
+      borderPadding: 8
+      borderWidth: 0.5
+
+    admonition:
+      parent: normal
+      spaceBefore: 12
+      spaceAfter: 6
+      borderPadding: [16,16,16,16]
+      backColor: beige
+      borderColor: darkgray
+      borderWidth: 0.5
+      commands:[]
+             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+
+    attention:
+      parent: admonition
+
+    caution:
+      parent: admonition
+
+    danger:
+      parent: admonition
+
+    error:
+      parent: admonition
+
+    hint:
+      parent: admonition
+
+    important:
+      parent: admonition
+
+    note:
+      parent: admonition
+
+    tip:
+      parent: admonition
+
+    warning:
+      parent: admonition
+
+    admonition-title:
+      parent: heading3
+
+    admonition-heading:
+      parent: heading3
+
+    attention-heading:
+      parent: admonition-heading
+
+    caution-heading:
+      parent: admonition-heading
+
+    danger-heading:
+      parent: admonition-heading
+
+    error-heading:
+      parent: admonition-heading
+
+    hint-heading:
+      parent: admonition-heading
+
+    important-heading:
+      parent: admonition-heading
+
+    note-heading:
+      parent: admonition-heading
+
+    tip-heading:
+      parent: admonition-heading
+
+    warning-heading:
+      parent: admonition-heading
+
+    literal:
+      parent: normal
+      fontName: stdMono
+      firstLineIndent: 0
+      hyphenation: false
+      wordWrap: null
+
+    aafigure:
+      parent: literal
+
+    table:
+      spaceBefore:6
+      spaceAfter:0
+      alignment: TA_CENTER
+      commands: []
+             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+             [INNERGRID, [ 0, 0 ], [ -1, -1 ], 0.25, black ]
+             [ROWBACKGROUNDS, [0, 0], [-1, -1], [white,#E0E0E0]]
+             [BOX, [ 0, 0 ], [ -1, -1 ], 0.25, black ]
+
+    table-title:
+      parent : heading4
+      keepWithNext: false
+      alignment : TA_CENTER
+
+    table-heading:
+      parent : heading
+      backColor : beige
+      alignment : TA_CENTER
+      valign : BOTTOM
+      borderPadding : 0
+
+    table-body:
+      parent : normal
+
+    dedication:
+      parent : normal
+
+    abstract:
+      parent : normal
+
+    contents:
+      parent : normal
+
+    tableofcontents:
+      parent : normal
+
+    code:
+      parent: literal
+      leftIndent: 0
+      spaceBefore: 8
+      spaceAfter: 8
+      backColor: beige
+      borderColor: darkgray
+      borderWidth: 0.5
+      borderPadding: 6
+
+    linenumber:
+      parent: code
+
+    right:
+      parent: bodytext
+      alignment: right
+
+    center:
+      parent: bodytext
+      alignment: center
+
+    pygments-n: parent: code
+    pygments-nx: parent: code
+    pygments-p: parent: code
+    pygments-hll: {parent: code, backColor: #ffffcc}
+    pygments-c: {textColor: #008800, parent: code}
+    pygments-err: {parent: code}
+    pygments-k: {textColor: #AA22FF, parent: code}
+    pygments-o: {textColor: #666666, parent: code}
+    pygments-cm: {textColor: #008800, parent: code}
+    pygments-cp: {textColor: #008800, parent: code}
+    pygments-c1: {textColor: #008800, parent: code}
+    pygments-cs: {textColor: #008800, parent: code}
+    pygments-gd: {textColor: #A00000, parent: code}
+    pygments-ge: {parent: code}
+    pygments-gr: {textColor: #FF0000, parent: code}
+    pygments-gh: {textColor: #000080, parent: code}
+    pygments-gi: {textColor: #00A000, parent: code}
+    pygments-go: {textColor: #808080, parent: code}
+    pygments-gp: {textColor: #000080, parent: code}
+    pygments-gs: {parent: code}
+    pygments-gu: {textColor: #800080, parent: code}
+    pygments-gt: {textColor: #0040D0, parent: code}
+    pygments-kc: {textColor: #AA22FF, parent: code}
+    pygments-kd: {textColor: #AA22FF, parent: code}
+    pygments-kn: {textColor: #AA22FF, parent: code}
+    pygments-kp: {textColor: #AA22FF, parent: code}
+    pygments-kr: {textColor: #AA22FF, parent: code}
+    pygments-kt: {textColor: #00BB00, parent: code}
+    pygments-m: {textColor: #666666, parent: code}
+    pygments-s: {textColor: #BB4444, parent: code}
+    pygments-na: {textColor: #BB4444, parent: code}
+    pygments-nb: {textColor: #AA22FF, parent: code}
+    pygments-nc: {textColor: #0000FF, parent: code}
+    pygments-no: {textColor: #880000, parent: code}
+    pygments-nd: {textColor: #AA22FF, parent: code}
+    pygments-ni: {textColor: #999999, parent: code}
+    pygments-ne: {textColor: #D2413A, parent: code}
+    pygments-nf: {textColor: #00A000, parent: code}
+    pygments-nl: {textColor: #A0A000, parent: code}
+    pygments-nn: {textColor: #0000FF, parent: code}
+    pygments-nt: {textColor: #008000, parent: code}
+    pygments-nv: {textColor: #B8860B, parent: code}
+    pygments-ow: {textColor: #AA22FF, parent: code}
+    pygments-w: {textColor: #bbbbbb, parent: code}
+    pygments-mf: {textColor: #666666, parent: code}
+    pygments-mh: {textColor: #666666, parent: code}
+    pygments-mi: {textColor: #666666, parent: code}
+    pygments-mo: {textColor: #666666, parent: code}
+    pygments-sb: {textColor: #BB4444, parent: code}
+    pygments-sc: {textColor: #BB4444, parent: code}
+    pygments-sd: {textColor: #BB4444, parent: code}
+    pygments-s2: {textColor: #BB4444, parent: code}
+    pygments-se: {textColor: #BB6622, parent: code}
+    pygments-sh: {textColor: #BB4444, parent: code}
+    pygments-si: {textColor: #BB6688, parent: code}
+    pygments-sx: {textColor: #008000, parent: code}
+    pygments-sr: {textColor: #BB6688, parent: code}
+    pygments-s1: {textColor: #BB4444, parent: code}
+    pygments-ss: {textColor: #B8860B, parent: code}
+    pygments-bp: {textColor: #AA22FF, parent: code}
+    pygments-vc: {textColor: #B8860B, parent: code}
+    pygments-vg: {textColor: #B8860B, parent: code}
+    pygments-vi: {textColor: #B8860B, parent: code}
+    pygments-il: {textColor: #666666, parent: code}
+
+    endnote:
+        parent: bodytext
+        commands: []
+            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+            [BOTTOMPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+            [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
+        colWidths: [3cm, null]
+
+    field-list:
+        parent: bodytext
+        commands: []
+            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+        colWidths: [3cm, null]
+        spaceBefore: 6
+
+    option-list:
+        commands: []
+            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
+            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
+        colWidths: [null,null]
+

=== modified file 'gen/glc110.py'
--- gen/glc110.py	2014-08-06 15:44:15 +0000
+++ gen/glc110.py	2014-11-28 07:00:17 +0000
@@ -69,6 +69,9 @@
                     ("bkm_ctl", "Bookings Control"),
                     ("bkm_chq", "Cheques Received"),
                     ("bkm_csh", "Cash Received")])
+                if not mod.count("DR"):
+                    self.glctrl.extend([
+                        ("dis_all", "Discount Allowed")])
         if mod.count("CR"):
             crsctl = gc.getCtl("crsctl", self.opts["conum"], error=False)
             if crsctl and crsctl["ctc_glint"] == "Y":

=== modified file 'mem/ml1010.py'
--- mem/ml1010.py	2014-08-27 09:27:53 +0000
+++ mem/ml1010.py	2014-10-04 06:34:02 +0000
@@ -42,8 +42,7 @@
     def setVariables(self):
         tabs = ["chglog", "ctlvrf", "memadd", "memcat", "memctc", "memctk",
             "memctp", "memctl", "memcto", "memkon", "memlnk", "memmst",
-            "memsta", "memtrn", "memtrs", "bwlctl",  "bwltab", "bwlskp",
-            "tplmst"]
+            "memsta", "memtrn", "memtrs", "bwlctl",  "bwltab", "tplmst"]
         self.sql = Sql(self.opts["mf"].dbm, tabs, prog=__name__)
         if self.sql.error:
             return
@@ -1277,32 +1276,29 @@
                     tab[3] = self.df.t_work[0][0][3]
                     tab[4] = self.df.t_work[1][0][0]
                     tab[5] = self.df.t_work[1][0][1]
-                    self.sql.updRec("bwltab", data=tab, where=[("btb_cono",
-                        "=", self.opts["conum"]), ("btb_memno", "=",
-                        self.memno)])
-                    skp = self.sql.getRec(tables="bwlskp", where=[("bcs_cono",
-                        "=", tab[0]), ("bcs_tab", "=", tab[1])], limit=1)
-                    if skp:
-                        skp[3] = self.df.t_work[0][0][3]
-                        skp[4] = self.df.t_work[1][0][0]
-                        skp[5] = self.df.t_work[1][0][1]
-                        kon = self.sql.getRec("memkon", cols=["mlk_detail"],
+                    for typ in ("A", "P"):
+                        ad = self.sql.getRec(tables="memadd", cols=["mla_add1",
+                            "mla_add2", "mla_add3", "mla_code"],
+                            where=[("mla_cono", "=", self.opts["conum"]),
+                            ("mla_memno", "=", self.memno), ("mla_type",
+                            "=", typ)], limit=1)
+                        if ad:
+                            break
+                    if ad:
+                        tab[6] = ad[0]
+                        tab[7] = ad[1]
+                        tab[8] = ad[2]
+                        tab[9] = ad[3]
+                    for num, cod in enumerate((1, 2, 3, 5)):
+                        kk = self.sql.getRec(tables="memkon",
+                            cols=["mlk_detail"],
                             where=[("mlk_cono", "=", self.opts["conum"]),
                             ("mlk_memno", "=", self.memno), ("mlk_code",
-                            "=", 5)], limit=1)
-                        if kon:
-                            skp[7] = kon[0]
-                        for code in (3, 1, 2):
-                            kon = self.sql.getRec("memkon",
-                                cols=["mlk_detail"], where=[("mlk_cono", "=",
-                                self.opts["conum"]), ("mlk_memno", "=",
-                                self.memno), ("mlk_code", "=", code)], limit=1)
-                            if kon:
-                                skp[8] = kon[0]
-                                break
-                        self.sql.updRec("bwlskp", data=skp, where=[("bcs_cono",
-                            "=", self.opts["conum"]), ("bcs_tab", "=",
-                            tab[1])])
+                            "=", cod)], limit=1)
+                        if kk:
+                            tab[num+10] = kk[0]
+                    self.sql.updRec("bwltab", data=tab, where=[("btb_cono", "=",
+                        self.opts["conum"]), ("btb_memno", "=", self.memno)])
             self.opts["mf"].dbm.commitDbase()
             if self.acs == "Y":
                 self.dba.commitDbase()

=== modified file 'mem/ml3070.py'
--- mem/ml3070.py	2014-05-28 14:55:12 +0000
+++ mem/ml3070.py	2014-10-08 12:06:56 +0000
@@ -279,18 +279,18 @@
         self.opts["mf"].closeLoop()
 
     def printReport(self, recs):
-        tabs = []
+        data = []
         typ = "Generating the Report ... Please Wait"
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), typ=typ, esc=True)
         for num, dat in enumerate(recs):
             can = p.displayProgress(num)
             if can == "yes":
                 break
-            tabs.append(self.getValues(dat))
+            data.append(self.getValues(dat))
         p.closeProgress()
         if not can == "yes":
             head = ["Member's Master Report as at %s" % self.repdtd]
-            self.colsh = []
+            colsh = []
             for n1 in self.cnums:
                 for n2, d2 in enumerate(self.colsd[n1][2:]):
                     if n1 in (20, 21) and self.df.repprt[0][2] == "export":
@@ -300,25 +300,25 @@
                         else:
                             prefix = "S"
                             col = self.sadcol[:]
-                        self.colsh.append(("name1%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name1%s_%s" % (n1, n2), "NA",
                             col[0], "%s-Address-Line-1" % prefix, "y"))
-                        self.colsh.append(("name2%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name2%s_%s" % (n1, n2), "NA",
                             col[1], "%s-Address-Line-2" % prefix, "y"))
-                        self.colsh.append(("name3%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name3%s_%s" % (n1, n2), "NA",
                             col[2], "%s-Address-Line-3" % prefix, "y"))
-                        self.colsh.append(("name4%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name4%s_%s" % (n1, n2), "NA",
                             col[3], "%s-City" % prefix, "y"))
-                        self.colsh.append(("name5%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name5%s_%s" % (n1, n2), "NA",
                             col[4], "%s-Code" % prefix, "y"))
-                        self.colsh.append(("name6%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name6%s_%s" % (n1, n2), "NA",
                             col[5], "%s-Region" % prefix, "y"))
-                        self.colsh.append(("name7%s_%s" % (n1, n2), "NA",
+                        colsh.append(("name7%s_%s" % (n1, n2), "NA",
                             col[6], "%s-Country" % prefix, "y"))
                     else:
-                        self.colsh.append(("name%s_%s" % (n1, n2), d2[1],
+                        colsh.append(("name%s_%s" % (n1, n2), d2[1],
                             d2[2], d2[0], "y"))
-            RepPrt(self.opts["mf"], name=__name__, heads=head, tables=tabs,
-                cols=self.colsh, opts=self.getDes(), conum=self.opts["conum"],
+            RepPrt(self.opts["mf"], name=__name__, heads=head, tables=data,
+                cols=colsh, opts=self.getDes(), conum=self.opts["conum"],
                 conam=self.opts["conam"], ttype="D", pbar="P",
                 view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
                 mail=self.df.repprt[1][2])

=== modified file 'mem/ml3120.py'
--- mem/ml3120.py	2014-05-08 17:02:33 +0000
+++ mem/ml3120.py	2014-12-04 09:03:55 +0000
@@ -14,7 +14,7 @@
 """
 
 from TartanClasses import CreateChart, TartanDialog, Sql
-from tartanFunctions import mthendDate
+from tartanFunctions import dateDiff, mthendDate
 
 class ml3120:
     def __init__(self, **opts):
@@ -51,18 +51,37 @@
 
     def doStartPer(self, frt, pag, r, c, p, i, w):
         self.sdate = (w * 100) + 1
+        y = w / 100
+        m = (w % 100) + 11
+        if m > 12:
+            y += 1
+            m -= 12
+        self.df.loadEntry(frt, pag, p+1, ((y * 100) + m))
 
     def doEndPer(self, frt, pag, r, c, p, i, w):
         self.edate = mthendDate((w * 100) + 1)
+        if dateDiff(self.sdate, self.edate, "months") > 11:
+            return "More than 12 month period"
 
     def doEnd(self):
         self.df.closeProcess()
         rec = self.sql.getRec(tables="memsta", cols=["mls_status",
             "mls_date/100 as date", "count(*)"], where=[("mls_date",
             "between", self.sdate, self.edate)], group="mls_status, date")
+        num = 1
+        lookup = {}
+        mth = (self.sdate / 100) % 100
+        end = (self.edate / 100) % 100
+        lookup[mth] = num
+        while not mth == end:
+            mth += 1
+            if mth > 12:
+                mth = 1
+            num += 1
+            lookup[mth] = num
         for r in rec:
-            month = r[1] % 100
-            self.desc[r[0]][month] = r[2]
+            mth = r[1] % 100
+            self.desc[r[0]][lookup[mth]] = r[2]
         achart = []
         for s in self.desc:
             achart.append([s] + self.desc[s])

=== modified file 'mem/mlc110.py'
--- mem/mlc110.py	2014-05-28 14:55:12 +0000
+++ mem/mlc110.py	2014-10-06 06:34:52 +0000
@@ -96,7 +96,7 @@
             (("T",0,9,0),"IHA",20,"Access Password","",
                 self.acc[10],"N",None,None,None,None),
             (("T",0,10,0),"ITX",50,"Club Logo Image","",
-                self.acc[11],"N",None,fle,None,("fle",)),
+                self.acc[11],"N",None,fle,None,None),
             (("T",0,11,0),"INA",20,"Card Front Template","",
                 self.acc[12],"N",self.doCTpl,tpc,None,("notblank",)),
             (("T",0,12,0),"INA",20,"Card Back Template","",

=== added file 'men/bwlmen.py'
--- men/bwlmen.py	1970-01-01 00:00:00 +0000
+++ men/bwlmen.py	2014-10-03 15:21:41 +0000
@@ -0,0 +1,143 @@
+"""
+Module Types
+------------
+F     = Function
+P123  = Program where:
+        1 = Company Number (Y/N)
+        2 = Period Selection (Y/N/L) (L = Last Period)
+        3 = Pass User Name to Module
+CY  = System Command requiring a terminal session
+CN  = System Command not requiring a terminal session
+S   = A standard callable python class
+U   = A Program without normal arguments only username.
+
+Security Levels
+---------------
+0 - Enquiries Only
+1 - + Reporting
+2 - + Data Capture
+3 - + File Maintenance
+4 - + Month and Year End Routines
+5 - + Control Routines
+6 - + Financial Year End Routine
+7 - + User and Module Pasword Maintenance
+8 - + Database tables update
+9 -   Everything
+"""
+
+# Systems
+systems = [
+    ["ms", "Control Routines"],
+    ["ml", "Member's Ledger"],
+    ["bc", "Bowling Clubs"],
+    ["rp", "Reporting Tools"]]
+
+# Control Routines
+msmen = [
+    ["MM","mm_sy","System"],
+    ["MM","mm_ms","Control"],
+    ["MM","mm_ml","Member's Ledger"],
+    ["MM","mm_bc","Bowling Clubs"],
+    ["MM","mm_uy","Utilities"],
+    ["MM","mm_hp","Help"]]
+msmod = [
+    ["F","mm_sy","chgUsr",0,"Change User"],
+    ["F","mm_sy","chgPwd",0,"Change Password"],
+    ["F","mm_sy","tarUsr",7,"User's Maintenance"],
+    ["F","mm_sy","sysUpd",0,"Upgrade System"],
+    ["F","mm_sy","tarUpd",8,"Update File Formats"],
+    ["PNNN","mm_sy","tb1040",9,"Copy Tables"],
+    ["F","mm_sy","tarBck",0,"Backup Database"],
+    ["F","mm_sy","tarRes",5,"Restore Database"],
+    ["F","mm_sy","tarCfg",0,"Preferences"],
+    ["F","mm_sy","sysEnd",0,"Quit"],
+    ["PNNY","mm_ms","msc110",7,"System Record Maintenance"],
+    ["PNNY","mm_ms","ms1010",5,"Company Records Maintenance"],
+    ["PYNN","mm_ms","ms1020",5,"Department Records Maintenance"],
+    ["PNNN","mm_ms","ms1030",7,"Module Passwords Maintenance"],
+    ["PNNN","mm_ms","ms3020",7,"Module Passwords Listing"],
+    ["PYNY","mm_ms","ms1040",3,"V.A.T. Records Maintenance"],
+    ["PYNN","mm_ms","ms3010",3,"V.A.T. Statement"],
+    ["PNNN","mm_ms","ms3030",3,"Email Log Report"],
+    ["PYYY","mm_ms","msy010",6,"Financial Year End Routine"],
+    ["PYYN","mm_ms","msy020",6,"Change Year End Date"],
+    ["PYNN","mm_uy","bm1010",3,"Bulk Mail/SMS Utility"],
+    ["PNNN","mm_uy","fc1010",0,"Loan/Lease Calculator"],
+    ["PNNY","mm_uy","pm1010",0,"Personal Password Manager"],
+    ["PNNY","mm_uy","rp1010",2,"Report Generator"],
+    ["PNNN","mm_uy","pw1010",5,"Server User Maintenance"],
+    ["PNNY","mm_uy","td1010",0,"Telephone Directory"],
+    ["PNNN","mm_uy","tp1010",5,"Template Manager"],
+    ["F","mm_hp","doAbout",0,"About"],
+    ["F","mm_hp","doManual",0,"Manual"]]
+
+# Member's Ledger
+mlmen = [
+    ["CM","mm_ml","ml_fm","File Maintenance"],
+    ["CM","mm_ml","ml_dc","Data Capture"],
+    ["CM","mm_ml","ml_rp","Reporting"],
+    ["CM","mm_ml","ml_tb","Toolbox"]]
+mlmod = [
+    ["PYNY","ml_fm","mlc110",5,"Control Record"],
+    ["PYNY","ml_fm","mlc210",3,"Category Records"],
+    ["PNNN","ml_fm","mlc310",3,"Message Records"],
+    ["PNNN","ml_fm","mlc410",3,"Contact Records"],
+    ["PYYY","ml_dc","ml2010",2,"Invoices",1],
+    ["PYYY","ml_dc","ml2010",2,"Payments",2],
+    ["PYYY","ml_dc","ml2010",2,"Journals",3],
+    ["PYYY","ml_dc","ml2010",2,"Credit Notes",4],
+    ["PYYY","ml_dc","ml2020",2,"Receipts",5],
+    ["PYNN","ml_rp","ml3010",1,"Batch Error Listing"],
+    ["PYYN","ml_rp","ml3020",1,"Transaction Audit Trail"],
+    ["PYNN","ml_rp","ml3030",1,"Age Analysis"],
+    ["PYLY","ml_rp","ml3040",1,"Statements"],
+    ["PYNN","ml_rp","ml3050",1,"Notes Listing"],
+    ["PYNN","ml_rp","ml3060",1,"Category Changes"],
+    ["PYLY","ml_rp","ml3070",1,"Master Report"],
+    ["PYNY","ml_rp","ml3080",2,"Suspension Report"],
+    ["PYNN","ml_rp","ml3090",2,"Detail Update Request"],
+    ["PYNN","ml_rp","ml3100",2,"Member's Birthday Report"],
+    ["PYNN","ml_rp","ml3110",2,"Name and Address Labels"],
+    ["PYNN","ml_rp","ml3120",2,"Status Summary"],
+    ["PYNN","ml_tb","ml6010",3,"Transaction Reallocations"],
+    ["PYNN","ml_tb","ml6020",3,"Synchronise Access Control"],
+    ["PYNN","ml_tb","ml6030",3,"Export Access Control"],
+    ["PYLY","mm_ml","ml1010",1,"Member Records"],
+    ["PYYY","mm_ml","mlm010",4,"Month End Routine",0]]
+
+# Bowling Clubs
+bcmen = [
+    ["CM","mm_bc","bc_fm","File Maintenance"],
+    ["CM","mm_bc","bc_ti","Tabs Draw"],
+    ["CM","mm_bc","bc_ls","League Selections"],
+    ["CM","mm_bc","bc_cc","Club Competitions"],
+    ["CM","mm_bc","bc_tb","Toolbox"]]
+bcmod = [
+    ["PYNY","bc_fm","bcc110",0,"Control Record"],
+    ["PYNN","bc_fm","bcc210",0,"Club's Records"],
+    ["PYNN","bc_fm","bc1010",1,"Tabs Maintenance"],
+    ["PYNN","bc_fm","bc1020",0,"League Formats"],
+    ["PYNN","bc_fm","bc1030",0,"Side's Maintenance"],
+    ["PYNN","bc_fm","bc1040",0,"Competition Types"],
+    ["PYNN","bc_ti","bc2010",0,"Draw"],
+    ["PYNN","bc_ti","bc3010",0,"Reprint Draw"],
+    ["PYNN","bc_ti","bc3020",0,"Draws Summary"],
+    ["PYNN","bc_ls","bc2020",0,"Capture Selections"],
+    ["PYNN","bc_ls","bc3030",0,"Assessment Forms"],
+    ["PYNN","bc_ls","bc3040",0,"Declaration Forms"],
+    ["PYNN","bc_ls","bc2030",0,"Capture Assessments"],
+    ["PYNN","bc_ls","bc3050",0,"Match Assessment Report"],
+    ["PYNN","bc_ls","bc3060",0,"Assessment Summary"],
+    ["PYNN","bc_cc","bc2040",0,"Capture Entries"],
+    ["PYNN","bc_cc","bc3070",0,"Entries Listing"],
+    ["PYNN","bc_cc","bc3080",0,"Competition Format"],
+    ["PYNN","bc_cc","bc2050",0,"Competiton Draw"],
+    ["PYNN","bc_cc","bc3090",0,"Draw Summary"],
+    ["PYNN","bc_cc","bc2060",0,"Change Draw"],
+    ["PYNN","bc_cc","bc2070",0,"Capture Results"],
+    ["PYNN","bc_cc","bc3100",0,"Game Results Report"],
+    ["PYNN","bc_cc","bc3110",0,"Match Results Report"],
+    ["PYNN","bc_cc","bc3120",0,"Contact Request Forms"],
+    ["PYNN","bc_tb","bc6010",3,"Change Tab Numbers"],
+    ["PYNN","bc_tb","bc6020",0,"Clear League History"]]
+# End

=== modified file 'men/stdmen.py'
--- men/stdmen.py	2014-10-01 14:07:50 +0000
+++ men/stdmen.py	2014-12-04 06:58:57 +0000
@@ -299,19 +299,22 @@
     ["CM","mm_bk","bk_rp","Reporting"],
     ["CM","mm_bk","bk_tb","Toolbox"]]
 bkmod = [
-    ["PYNY","bk_fm","bkc110",5,"Bookings Control"],
-    ["PYNY","bk_fm","bkc210",5,"Unit Types"],
-    ["PYNY","bk_fm","bkc310",5,"Unit Records"],
-    ["PYNY","bk_fm","bkc410",5,"Rate Records"],
-    ["PYNY","bk_fm","bkc510",5,"Booking Letters"],
-    ["PYNY","bk_fm","bkc610",5,"Contacts"],
-    ["PYNY","mm_bk","bk1010",5,"Bookings"],
+    ["PYNY","bk_fm","bkc110",5,"Control Record"],
+    ["PYNY","bk_fm","bkc210",3,"Unit Records"],
+    ["PYNY","bk_fm","bkc310",3,"Rate Records"],
+    ["PYNY","bk_fm","bkc410",3,"Booking Letters"],
+    ["PYNY","bk_fm","bkc510",3,"Contacts"],
+    ["PYNY","mm_bk","bk1010",2,"Calendar"],
+    ["PYNY","mm_bk","bk1020",2,"Bookings"],
     ["PYNN","bk_rp","bk3010",1,"Deposits Listing"],
     ["PYYN","bk_rp","bk3020",1,"Transaction Audit Trail"],
     ["PYNY","bk_rp","bk3030",1,"Arrivals Listing"],
     ["PYNN","bk_rp","bk3040",1,"Balances Listing"],
     ["PYNN","bk_rp","bk3050",1,"Name and Address Labels"],
-    ["PYNN","bk_rp","bk3070",1,"Notes Listing"]]
+    ["PYNN","bk_rp","bk3060",1,"Notes Listing"],
+    ["PYNN","bk_rp","bk3080",1,"Account Statements"],
+    ["PYNN","bk_rp","bk3090",1,"Reprint Invoices"],
+    ["PYNN","bk_rp","bk3100",1,"Summary Report"]]
     #["PYNN","bk_rp","bk3070",1,"Sales History"]]
 
 # Rental's Ledger (Basic)
@@ -459,8 +462,7 @@
     ["PYNN","bc_fm","bc1010",0,"Tabs Maintenance"],
     ["PYNN","bc_fm","bc1020",0,"League Formats"],
     ["PYNN","bc_fm","bc1030",0,"Side's Maintenance"],
-    ["PYNN","bc_fm","bc1040",0,"Player's Maintenance"],
-    ["PYNN","bc_fm","bc1050",0,"Competition Types"],
+    ["PYNN","bc_fm","bc1040",0,"Competition Types"],
     ["PYNN","bc_ti","bc2010",0,"Draw"],
     ["PYNN","bc_ti","bc3010",0,"Reprint Draw"],
     ["PYNN","bc_ti","bc3020",0,"Draws Summary"],
@@ -481,6 +483,5 @@
     ["PYNN","bc_cc","bc3110",0,"Match Results Report"],
     ["PYNN","bc_cc","bc3120",0,"Contact Request Forms"],
     ["PYNN","bc_tb","bc6010",3,"Change Tab Numbers"],
-    ["PYNN","bc_tb","bc6020",3,"Change Player's Codes"],
-    ["PYNN","bc_tb","bc6030",0,"Clear League History"]]
+    ["PYNN","bc_tb","bc6020",0,"Clear League History"]]
 # End

=== modified file 'mst/ms0000.py'
--- mst/ms0000.py	2014-10-01 14:07:50 +0000
+++ mst/ms0000.py	2014-12-09 16:32:44 +0000
@@ -35,9 +35,9 @@
 # Set the version of Tartan
 if "TARVER" in os.environ:
     temp = tuple(os.environ["TARVER"].split("."))
-    VERSION = (int(temp[0]), int(temp[1]), int(temp[2]))
+VERSION = (5, 0, 2)
 else:
-    VERSION = (5, 0, 1)
+VERSION = (5, 0, 2)
 if __name__ == "__main__":
     # Run Tartan
     try:

=== modified file 'mst/msc000.py'
--- mst/msc000.py	2014-10-01 14:07:50 +0000
+++ mst/msc000.py	2014-11-23 06:05:22 +0000
@@ -1295,7 +1295,7 @@
 
     def doAbout(self, event=None):
         self.mf.destroyChildren()
-        self.about = AboutTartan(self.mf)
+        self.about = AboutTartan(self.mf, self.current[1])
 
     def doManual(self):
         doc = os.path.join(self.rcdic["prgdir"], "doc", "Manual.pdf")

=== modified file 'scp/sc1010.py'
--- scp/sc1010.py	2014-05-08 17:02:33 +0000
+++ scp/sc1010.py	2014-10-03 16:42:32 +0000
@@ -101,7 +101,8 @@
     def doSkpCod(self, frt, pag, r, c, p, i, w):
         self.click = []
         if not w:
-            self.skip = getNextCode(self.sql, "scpmem", "scm_scod")
+            self.skip = getNextCode(self.sql, "scpmem", "scm_scod",
+                where=[("scm_cono", "=", self.opts["conum"])], last=899999)
             self.df.loadEntry(frt, pag, p, data=self.skip)
         else:
             self.skip = w
@@ -155,7 +156,7 @@
 
     def doClbCod(self, frt, pag, r, c, p, i, w):
         if not w:
-            self.club = getNextCode(self.sql, "scpclb", "scc_club")
+            self.club = getNextCode(self.sql, "scpclb", "scc_club", last=999)
             self.df.loadEntry(frt, pag, p, data=self.club)
         else:
             self.club = w
@@ -175,7 +176,7 @@
     def doNewClub(self, club=None):
         self.newclb = True
         if not club:
-            self.club = getNextCode(self.sql, "scpclb", "scc_club")
+            self.club = getNextCode(self.sql, "scpclb", "scc_club", last=999)
             self.df.loadEntry("T", 0, 5, data=self.club)
             self.df.clearEntry("T", 0, 7)
             self.df.focusField("T", 0, 7)

=== modified file 'scp/sc2010.py'
--- scp/sc2010.py	2014-05-08 17:02:33 +0000
+++ scp/sc2010.py	2014-12-02 15:47:25 +0000
@@ -95,11 +95,11 @@
                 "K","N",self.doCmpTyp,fmt,None,None),
             (("T",0,4,0),"I@scp_logo",0,"Logo","Sponsor's Logo",
                 "","N",self.doCmpLogo,log,None,("fle","blank")),
-            (("C",0,0,0),"I@scm_scod",0,"Skip","",
+            (("C",0,0,0),"I@scm_scod",0,"Skip  ","",
                 "","Y",self.doSkpCod,sk1,None,("efld",)),
             (("C",0,0,1),"ONA",30,"Name","",
                 "","N",None,None,None,("notblank",)),
-            (("C",0,0,2),"I@scm_scod",0,"Lead","",
+            (("C",0,0,2),"I@scm_scod",0,"Lead  ","",
                 "","n",self.doSkpCod,sk1,None,("efld",)),
             (("C",0,0,3),"ONA",30,"Name","",
                 "","N",None,None,None,("notblank",)))
@@ -114,7 +114,8 @@
     def doCmpCod(self, frt, pag, r, c, p, i, w):
         self.skips = []
         self.parts = []
-        nxtcod = getNextCode(self.sql, "scpcmp", "scp_ccod", last=99)
+        nxtcod = getNextCode(self.sql, "scpcmp", "scp_ccod",
+            where=[("scp_cono", "=", self.opts["conum"])], last=999)
         if not w or w > nxtcod:
             self.ccod = nxtcod
             self.df.loadEntry(frt, pag, p, data=self.ccod)
@@ -201,7 +202,8 @@
                 mess="Is This a New Player?", default="yes")
             if ok == "no":
                 return "Invalid Code"
-            cod = getNextCode(self.sql, "scpmem", "scm_scod", last=899999)
+            cod = getNextCode(self.sql, "scpmem", "scm_scod",
+                where=[("scm_cono", "=", self.opts["conum"])], last=899999)
             callModule(self.opts["mf"], self.df, "sc1010",
                 coy=[self.opts["conum"], self.opts["conam"]], args=(cod,))
             self.df.loadEntry(frt, pag, p, data=cod)

=== modified file 'scp/sc2020.py'
--- scp/sc2020.py	2014-05-28 14:55:12 +0000
+++ scp/sc2020.py	2014-11-26 08:30:05 +0000
@@ -33,7 +33,7 @@
     def __init__(self, **opts):
         self.opts = opts
         if not "test" in opts:
-            self.test = None
+            self.opts["test"] = None
         if self.setVariables():
             self.mainProcess()
             self.opts["mf"].startLoop()
@@ -118,7 +118,7 @@
                 showError(self.opts["mf"].window, "Invalid Type",
                     "Main not Completed or All results Not yet Entered")
                 return "Main Not Completed"
-        elif self.ctyp == "M" and self.test:
+        elif self.ctyp == "M" and self.opts["test"]:
             # Populate test data
             self.state = 0
             self.sql.updRec("scpcmp", cols=["scp_state"], data=[self.state],
@@ -137,14 +137,14 @@
                 "=", self.opts["conum"]), ("scm_scod", ">", 500)],
                 order="scm_scod")
             random.shuffle(ent)
-            if len(ent) < self.test:
+            if len(ent) < self.opts["test"]:
                 ext = self.sql.getRec(tables=["scpmem"], cols=["scm_scod",
                     "scm_surname", "scm_names", "scm_club"],
                     where=[("scm_cono", "=", self.opts["conum"]), ("scm_scod",
                     "<", 500)], order="scm_scod")
                 random.shuffle(ext)
-                ent.extend(ext[:self.test-len(ent)])
-            for x in xrange(self.test):
+                ent.extend(ext[:self.opts["test"]-len(ent)])
+            for x in xrange(self.opts["test"]):
                 self.sql.insRec("scpent", data=[self.opts["conum"], self.ccod,
                     ent[x][0], 0])
             self.opts["mf"].dbm.commitDbase()
@@ -364,7 +364,7 @@
         doPrinter(mf=self.opts["mf"], conum=1, rep=pdfnam,
             view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2])
         if not self.reprint:
-            if self.test:
+            if self.opts["test"]:
                 self.opts["mf"].dbm.commitDbase()
             else:
                 self.opts["mf"].dbm.commitDbase(ask=True)
@@ -666,7 +666,7 @@
         self.opts["mf"].closeLoop()
 
     def doMatchDetails(self):
-        if self.test:
+        if self.opts["test"]:
             self.doMatchEnd()
             return
         tit = ("Match Details",)
@@ -696,7 +696,7 @@
         self.rtime = w
 
     def doMatchEnd(self, widget=None):
-        if self.test:
+        if self.opts["test"]:
             for num in xrange(self.xtra):
                 self.sql.insRec("scprnd", data=[self.opts["conum"], self.ccod,
                     num+1, self.sysdw, 1415])
@@ -722,7 +722,7 @@
         self.opts["mf"].closeLoop()
 
     def doSectionDetails(self):
-        if self.test:
+        if self.opts["test"]:
             self.doSecEnd()
             return
         tit = ("Section %s Details" % self.rsecnum,)
@@ -755,7 +755,7 @@
         self.sd.loadEntry(frt, pag, p+1, data=chk[1])
 
     def doSecEnd(self, widget=None):
-        if self.test:
+        if self.opts["test"]:
             for num in xrange(self.xtra):
                 chk = self.sql.getRec(tables="scpclb", where=[("scc_club",
                     "=", num+1)], limit=1)
@@ -1964,10 +1964,17 @@
         self.opts["mf"].closeLoop()
 
 if __name__ == "__main__":
-    import sys
+    import getopts, sys
     from TartanClasses import Dbase, MainFrame
     from tartanFunctions import loadRcFile
-    rcdic = loadRcFile("/home/paul/rcf/tartanrc_seccmp")
+    try:
+        opts, args = getopt.getopt(sys.argv[1:],"r:")
+    except:
+        print
+        print "Usage: -r rcfile"
+        print
+        sys.exit()
+    rcdic = loadRcFile(opts[0][1])
     dbm = Dbase(rcdic)
     if not dbm.err:
         mf = MainFrame(rcdic=rcdic)
@@ -1977,7 +1984,7 @@
             test = int(sys.argv[1])
         else:
             test = 0
-        sc2020(**{"mf": mf, "conum":1, "conam": "Western Province Bowls",
+        sc2020(**{"mf": mf, "conum":1, "conam": "Bowls Association",
             "test": test})
         mf.dbm.closeDbase()
 

=== modified file 'scp/sc2030.py'
--- scp/sc2030.py	2014-05-28 14:55:12 +0000
+++ scp/sc2030.py	2014-11-26 08:30:40 +0000
@@ -21,9 +21,9 @@
     def __init__(self, **opts):
         self.opts = opts
         if not "test" in opts:
-            self.test = None
+            self.opts["test"] = None
         if self.setVariables():
-            if self.test:
+            if self.opts["test"]:
                 self.doImport()
             else:
                 self.mainProcess()
@@ -216,8 +216,8 @@
 
     def doImport(self, widget=None):
         self.doimport = True
-        if self.test:
-            self.ccod, self.rnum, impfle = self.test
+        if self.opts["test"]:
+            self.ccod, self.rnum, impfle = self.opts["test"]
             err = self.doCmpCod("T", 0, 0, 0, 0, 0, self.ccod)
             if err:
                 print err
@@ -301,7 +301,7 @@
                 if not self.ierr:
                     self.opts["mf"].dbm.commitDbase()
         self.doTopExit()
-        if not self.test:
+        if not self.opts["test"]:
             self.df.setWidget(self.df.mstFrame, state="show")
             self.df.focusField("T", 0, 1)
 
@@ -334,9 +334,9 @@
             self.df.focusField("C", 1, 1)
 
     def doTopExit(self, widget=None):
-        if self.test:
+        if self.opts["test"]:
             self.opts["mf"].closeLoop()
-        elif self.df.pag == 0 and not self.test:
+        elif self.df.pag == 0 and not self.opts["test"]:
             self.df.closeProcess()
             self.opts["mf"].closeLoop()
         else:
@@ -547,7 +547,7 @@
                     byes.append(scod)
                 nums[scod] = skp
             for skp in byes:
-                if self.test:
+                if self.opts["test"]:
                     ok = "B"
                 else:
                     ok = askChoice(self.opts["mf"].body, "Capture Error",
@@ -743,10 +743,17 @@
         return snum, subs
 
 if __name__ == "__main__":
-    import sys
+    import getopt, sys
     from TartanClasses import Dbase, MainFrame
     from tartanFunctions import loadRcFile
-    rcdic = loadRcFile("/home/paul/rcf/tartanrc_seccmp")
+    try:
+        opts, args = getopt.getopt(sys.argv[1:],"r:")
+    except:
+        print
+        print "Usage: -r rcfile"
+        print
+        sys.exit()
+    rcdic = loadRcFile(opts[0][1])
     dbm = Dbase(rcdic)
     if not dbm.err:
         mf = MainFrame(rcdic=rcdic)
@@ -756,7 +763,7 @@
             test = (int(sys.argv[1]), int(sys.argv[2]), sys.argv[3])
         else:
             test = None
-        sc2030(**{"mf": mf, "conum":1, "conam": "Western Province Bowls",
+        sc2030(**{"mf": mf, "conum":1, "conam": "Bowls Association",
             "test": test})
         mf.dbm.closeDbase()
 

=== modified file 'scp/scc210.py'
--- scp/scc210.py	2014-05-08 17:02:33 +0000
+++ scp/scc210.py	2014-10-03 16:11:36 +0000
@@ -53,8 +53,7 @@
 
     def doClbCod(self, frt, pag, r, c, p, i, w):
         if not w:
-            self.club = getNextCode(self.sql, "scpclb", "scc_club",
-                last=899999)
+            self.club = getNextCode(self.sql, "scpclb", "scc_club", last=999)
             self.df.loadEntry(frt, pag, p, data=self.club)
         else:
             self.club = w

=== modified file 'std/TartanClasses.py'
--- std/TartanClasses.py	2014-10-01 14:07:50 +0000
+++ std/TartanClasses.py	2014-12-09 10:34:52 +0000
@@ -93,6 +93,7 @@
     aliases = {
         "accept": os.path.join(imgdir, "apply.png"),
         "back": os.path.join(imgdir, "left.png"),
+        "bookings": os.path.join(imgdir, "print.png"),
         "chgpwd": os.path.join(imgdir, "users.png"),
         "change": os.path.join(imgdir, "convert.png"),
         "chgusr": os.path.join(imgdir, "users.png"),
@@ -102,6 +103,7 @@
         "crsmaint": os.path.join(imgdir, "edit.png"),
         "crsquery": os.path.join(imgdir, "question.png"),
         "deladd": os.path.join(imgdir, "truck.png"),
+        "deposits": os.path.join(imgdir, "print.png"),
         "doabout": os.path.join(imgdir, "about.png"),
         "domanual": os.path.join(imgdir, "info.png"),
         "drsmaint": os.path.join(imgdir, "edit.png"),
@@ -391,9 +393,9 @@
                 locale, fwday, fdate, titlebg, titlefg, calendarbg, font
             """
             params = {
-                "locale": None,
                 "fwday": 0,
                 "fdate": None,
+                "locale": None,
                 "font": "Courier 10 bold"}
             params.update(kw)
             for arg, val in params.iteritems():
@@ -935,23 +937,30 @@
         data = [
             (((label, tag) (label, tag) (label, tag)),
             ((text, tag), (text, tag), (text, tag), (text, tag)),)]
+        butt = A list of additional buttons e.g. [("hello", cmd)]
         bcmd = A browse command
+        hcmd = A hover command
         font = (family, size)
+        loop = Mainloop, True or False
         """
         def __init__(self, **opts):
             if not "chgt" in opts:
                 opts["chgt"] = 1
+            if not "loop" in opts:
+                opts["loop"] = True
             self.opts = opts
             self.drawGrid()
-            self.window.mainloop()
+            if self.opts["loop"]:
+                self.window.mainloop()
 
         def drawGrid(self):
             # Draw main window
+            self.quit = False
             self.window = MkWindow(modal=True, remov=True).newwin
-            ww = int(self.window.winfo_screenwidth() - 20)
-            wh = int(self.window.winfo_screenheight() * .9)
+            ww = int(self.window.winfo_screenwidth())
+            wh = int(self.window.winfo_screenheight())
             try:
-                self.window.wm_state('zoomed')
+                self.window.wm_state("zoomed")
             except:
                 geom_string = "%dx%d+0+0" % (ww, wh)
                 self.window.wm_geometry(geom_string)
@@ -961,13 +970,13 @@
             style.configure("TScrollbar", arrowsize=30)
             if "font" in self.opts:
                 ft = self.opts["font"][0]
-                fs = self.opts["font"][1]
+                self.fs = self.opts["font"][1]
             elif "mf" in self.opts:
                 ft = self.opts["mf"].rcdic["dft"]
-                fs = self.opts["mf"].rcdic["mfs"]
+                self.fs = self.opts["mf"].rcdic["mfs"]
             else:
-                ft = "Courier"
-                fs = 14
+                ft = "Arial"
+                self.fs = 14
             # pixbuf size limitation of 32767
             if len(self.opts["cols"]) == 1:
                 cqty = len(self.opts["cols"][0])
@@ -975,11 +984,11 @@
                 cqty = len(self.opts["cols"][1])
             size = 32768
             while size > 32767:
-                font = tkFont.Font(font=(ft, fs))
-                bold = tkFont.Font(font=(ft, fs, "bold"))
+                font = tkFont.Font(font=(ft, self.fs))
+                bold = tkFont.Font(font=(ft, self.fs, "bold"))
                 cell = MyLabel(None, borderwidth=0, width=10, font=bold)
                 size = cqty * (cell.winfo_reqwidth() + 2)
-                fs -= 1
+                self.fs -= 1
             # Draw widgets
             # Main Heading
             lb1 = MyLabel(self.window, justify="center", anchor="center",
@@ -1048,7 +1057,7 @@
             if len(self.opts["cols"]) == 2:
                 # Extra label for extra column heading
                 lbd = MyLabel(labh, text="", anchor="nw", font=font,
-                    borderwidth=0)
+                    borderwidth=2)
                 lbd.grid(row=0, column=0, columnspan=len(self.opts["labs"]),
                     sticky="ew", padx=1, pady=1)
                 r = 1
@@ -1061,7 +1070,7 @@
                 else:
                     txt = lab[0]
                 lbd = MyLabel(labh, text=txt, anchor="nw", font=bold,
-                    borderwidth=0, justify="left", width=lab[1])
+                    borderwidth=2, justify="left", width=lab[1])
                 lbd.grid(row=r, column=num, padx=1, pady=1)
                 cw += lab[1]
             labh.update()
@@ -1074,7 +1083,7 @@
             else:
                 c = 0
                 for t in self.opts["cols"][0]:
-                    cel = MyLabel(colh, text=t[0], borderwidth=0, font=bold,
+                    cel = MyLabel(colh, text=t[0], borderwidth=2, font=bold,
                         anchor="center", justify="center")
                     cel.grid(row=0, column=c, columnspan=t[1], sticky="ew",
                         padx=1, pady=1)
@@ -1085,7 +1094,7 @@
                     w = t[1][1]
                 else:
                     w = t[1]
-                cel = MyLabel(colh, text=t[0], borderwidth=0, width=w,
+                cel = MyLabel(colh, text=t[0], borderwidth=2, width=w,
                     font=bold, anchor="center", justify="center")
                 cel.grid(row=r, column=c, padx=1, pady=1)
             # Label and Column data
@@ -1103,8 +1112,8 @@
                         cl = False
                         st = "%s.TLabel" % l[1]
                     w = self.opts["labs"][n][1]
-                    lbl = MyLabel(labd, text=txt, borderwidth=0, width=w,
-                        font=bold, color=cl, style=st)
+                    lbl = MyLabel(labd, text=txt, borderwidth=2, width=w,
+                        font=font, color=cl, style=st)
                     lbl.grid(row=row, column=n, sticky="ew", padx=1, pady=1)
                     labd.grid_columnconfigure(n, weight=1)
                 for n, c in enumerate(dat[1]):
@@ -1129,21 +1138,35 @@
                     else:
                         cl = False
                         st = "%s.TLabel" % c[1]
-                    bod = MyLabel(cold, text=txt, borderwidth=0, font=font,
+                    bod = MyLabel(cold, text=txt, borderwidth=2, font=font,
                         anchor="center", justify="center", width=w, color=cl,
                         style=st)
-                    bod.bind("<ButtonRelease-1>",
-                        functools.partial(self._get_cell, (row, n), c[0]))
+                    if "bcmd" in self.opts:
+                        bod.bind("<ButtonRelease-1>",
+                            functools.partial(self._get_cell, (row, n), c[0]))
+                    if "hcmd" in self.opts:
+                        bod.bind("<Enter>",
+                            functools.partial(self._hover, (row, n), c[0]))
+                        bod.bind("<Leave>",
+                            functools.partial(self._hover, None))
                     bod.grid(row=row, column=n, padx=1, pady=1)
             # Arrow keys
             self.window.bind("<Left>", self._scroll)
             self.window.bind("<Right>", self._scroll)
             self.window.bind("<Up>", self._scroll)
             self.window.bind("<Down>", self._scroll)
-            # Close and Escape buttons
+            # Close and Other buttons
+            close = True
             box = ButtonBox(self.window)
-            box.addButton("Close", self._quit)
-            self.window.bind("<Escape>", self._quit)
+            if "butt" in self.opts:
+                for but in self.opts["butt"]:
+                    box.addButton(but[0], but[1])
+                    if but[0] in ("Close", "Exit"):
+                        close = False
+                        self.window.bind("<Escape>", but[1])
+            if close:
+                box.addButton("Close", self._quit)
+                self.window.bind("<Escape>", self._quit)
             # Pack frame
             mframe.pack(fill="both", expand="yes")
             # Place window
@@ -1153,10 +1176,13 @@
                 placeWindow(self.window, expose=True)
 
         def _get_cell(self, *args):
-            if not "bcmd" in self.opts or not args[0] or args[0][1] == "blank":
+            if not args[0] or args[0][1] == "blank":
                 return
             self.opts["bcmd"](args[:2])
 
+        def _hover(self, *args):
+            self.opts["hcmd"](args)
+
         def _xview(self, *args):
             apply(self.cv2.xview, args)
             apply(self.cv3.xview, args)
@@ -1179,6 +1205,8 @@
                 self._yview(tk.SCROLL, 1, tk.UNITS)
 
         def _quit(self, *args):
+            self.quit = True
+            self.window.withdraw()
             self.window.destroy()
             self.window.quit()
 
@@ -1849,8 +1877,11 @@
                 self.dbdsn = self.dbname
         try:
             if self.dbase == "FBird":
-                dbmod = "fdb"
-                import fdb as engine
+                dbmod = "fdb/kinterbasdb"
+                try:
+                    import fdb as engine
+                except:
+                    import kinterbasdb as engine
                 self.dbf = "?"
             elif self.dbase == "MsSQL":
                 dbmod = "adodbapi"
@@ -3798,7 +3829,9 @@
                    "Y" = Address Field (noblank)
                    "B" = Address Field (efld)
                    "N" = No Address Field (default N)
-                prt is "Y" or "N" to choose to view/print emailed docs or not
+                prt  is "Y" or "N" to choose to view/print emailed docs or not
+                dflt is the default answer
+                desc is the description to replace the default
               A list self.repprt[1] is created having 3 fields as follows:
                 1) "Y" or "N" mail widget created
                 2) query widget contents
@@ -4002,10 +4035,12 @@
                         "head": ("Name", "Contact", "Designation", "Address"),
                         "typs": (("NA",0,"Y"),("NA",0),("NA",0),("NA",0)),
                         "data": data,
-                        "index": 3}
+                        "mode": "M",
+                        "index": 3,
+                        "comnd": self.getAddr}
                     row += 1
-                    a = [("T",0,row,col),"ITX",50,"E-Mail Address","","",
-                        "Y",self.setAddr,adr,None]
+                    a = [("T",0,row,col),"ITX",50,"E-Mail Address","",
+                        "","N",self.setAddr,adr,None]
                     if self.mail[0] == "Y":
                         a.append(("email", False))
                     else:
@@ -4271,6 +4306,16 @@
                 self.loadEntry(frt, pag, p+x, data="")
             return "sk%s" % skp
 
+    def getAddr(self, frt, pag, r, c, p, i, w):
+        if w:
+            addr = ""
+            for a in w:
+                if not addr:
+                    addr = a
+                else:
+                    addr = "%s,%s" % (addr, a)
+            self.loadEntry(frt, pag, p, data=addr)
+
     def setAddr(self, frt, pag, r, c, p, i, w):
         self.repprt[1][2] = w
 
@@ -4824,10 +4869,17 @@
             butt = opts["butt"]
         else:
             butt = None
-        if mode == "M" and typs:
-            typs.insert(0, ("", 0))
+        if mode == "M":
+            if "index" in opts:
+                selc = opts["index"]
+            else:
+                selc = 0
+            if typs:
+                typs.insert(0, ("", 0))
+        else:
+            selc = None
         sc = SChoice(self.mf, titl=titl, head=head, data=data, typs=typs,
-            mode=mode, retn=retn, butt=butt, scrn=self.mstFrame)
+            mode=mode, selc=selc, retn=retn, butt=butt, scrn=self.mstFrame)
         self.mf.updateStatus("")
         return sc
 
@@ -6543,10 +6595,14 @@
                 elif self.mode == "M":
                     self.selection = []
                     for sel in sc.selection:
+                        if self.selc:
+                            idx = self.selc
+                        else:
+                            idx = 0
                         if self.retn == "D":
-                            self.selection.append(sel[1])
+                            self.selection.append(sel[idx + 1])
                         elif self.retn == "I":
-                            self.selection.append(sel[0])
+                            self.selection.append(sel[idx])
 
 class SelectChoice:
     """
@@ -8578,7 +8634,7 @@
         if self.loc:
             whr.append(("pom_loc", "=", self.loc))
         whr.extend([
-            ("pom_date", "<=", self.curdt),
+            ("pom_date", "<=", mthendDate(self.curdt * 100)),
             ("pom_delno", "<>", "cancel"),
             ("pom_deldt", "=", 0),
             ("pot_cono=pom_cono",),
@@ -8595,7 +8651,7 @@
         whr = [
             ("si1_cono", "=", self.conum),
             ("si1_rtn", "=", "O"),
-            ("si1_date", "<=", self.curdt),
+            ("si1_date", "<=", mthendDate(self.curdt * 100)),
             ("si1_invno", "=", ""),
             ("si2_cono=si1_cono",),
             ("si2_rtn=si1_rtn",),
@@ -9720,12 +9776,13 @@
                 else:
                     lyr = self.sql.getRec(tables="genbal",
                         cols=["round(sum(glo_cyr), 2)"], where=[("glo_cono",
-                        "=", self.s_cono), ("glo_acno", "like", "%s%s" % ("%",
-                        acc)), ("glo_trdt", "=", self.s_lyr.work)], limit=1)[0]
+                        "=", self.s_cono), ("glo_acno::text", "like",
+                        "%s%s" % ("%", acc)), ("glo_trdt", "=",
+                        self.s_lyr.work)], limit=1)[0]
                 cyr = self.sql.getRec(tables="genbal",
                     cols=["round(sum(glo_cyr), 2)"], where=[("glo_cono", "=",
-                    self.s_cono), ("glo_acno", "like", "%s%s" % ("%", acc)),
-                    ("glo_trdt", "=", self.period[1][0])], limit=1)[0]
+                    self.s_cono), ("glo_acno::text", "like", "%s%s" % ("%",
+                    acc)), ("glo_trdt", "=", self.period[1][0])], limit=1)[0]
             else:
                 if not self.period[0]:
                     lyr = None
@@ -9746,13 +9803,14 @@
                 else:
                     lyr = self.sql.getRec(tables="genbal",
                         cols=["round(sum(glo_cyr), 2)"], where=[("glo_cono",
-                        "in", self.consol), ("glo_acno", "like", "%s%s" %
-                        ("%", acc)), ("glo_trdt", "=", self.s_lyr.work)],
+                        "in", self.consol), ("glo_acno::text", "like",
+                        "%s%s" % ("%", acc)), ("glo_trdt", "=",
+                        self.s_lyr.work)], limit=1)[0]
+                cyr = self.sql.getRec(tables="genbal",
+                    cols=["round(sum(glo_cyr), 2)"], where=[("glo_cono", "in",
+                        self.consol), ("glo_acno::text", "like", "%s%s" % ("%",
+                        acc)), ("glo_trdt", "=", self.period[1][0])],
                         limit=1)[0]
-                cyr = self.sql.getRec(tables="genbal",
-                    cols=["round(sum(glo_cyr), 2)"], where=[("glo_cono", "in",
-                    self.consol), ("glo_acno", "like", "%s%s" % ("%", acc)),
-                    ("glo_trdt", "=", self.period[1][0])], limit=1)[0]
             else:
                 if not self.period[0]:
                     lyr = None
@@ -9781,15 +9839,15 @@
                 acc = self.s_acno % (10 ** (7 - self.sysdp[1]))
                 lyr = self.sql.getRec(tables="gentrn",
                     cols=["round(sum(glt_tramt), 2)"], where=[("glt_cono", "=",
-                    self.s_cono), ("glt_acno", "like", "%s%s" % ("%", acc)),
-                    ("glt_curdt", "=", (curdt - 100))], limit=1)[0]
+                    self.s_cono), ("glt_acno::text", "like", "%s%s" % ("%",
+                    acc)), ("glt_curdt", "=", (curdt - 100))], limit=1)[0]
                 cyr = self.sql.getRec(tables="gentrn",
                     cols=["round(sum(glt_tramt), 2)"], where=[("glt_cono", "=",
-                    self.s_cono), ("glt_acno", "like", "%s%s" % ("%", acc)),
-                    ("glt_curdt", "=", curdt)], limit=1)[0]
+                        self.s_cono), ("glt_acno::text", "like", "%s%s" % ("%",
+                        acc)), ("glt_curdt", "=", curdt)], limit=1)[0]
                 bud = self.sql.getRec(tables="genbud", cols=["sum(glb_tramt)"],
-                    where=[("glb_cono", "=", self.s_cono), ("glb_acno", "like",
-                    "%s%s" % ("%", acc)), ("glb_curdt", "=", curdt)],
+                    where=[("glb_cono", "=", self.s_cono), ("glb_acno::text",
+                    "like", "%s%s" % ("%", acc)), ("glb_curdt", "=", curdt)],
                     limit=1)[0]
             else:
                 lyr = self.sql.getRec(tables="gentrn",
@@ -9808,15 +9866,15 @@
             acc = self.s_acno % (10 ** (7 - self.sysdp[1]))
             lyr = self.sql.getRec(tables="gentrn",
                 cols=["round(sum(glt_tramt), 2)"], where=[("glt_cono", "in",
-                self.consol), ("glt_acno", "like", "%s%s" % ("%", acc)),
+                self.consol), ("glt_acno::like", "like", "%s%s" % ("%", acc)),
                 ("glt_curdt", "=", (curdt - 100))], limit=1)[0]
             cyr = self.sql.getRec(tables="gentrn",
                 cols=["round(sum(glt_tramt), 2)"], where=[("glt_cono", "in",
-                self.consol), ("glt_acno", "like", "%s%s" % ("%", acc)),
+                self.consol), ("glt_acno::text", "like", "%s%s" % ("%", acc)),
                 ("glt_curdt", "=", curdt)], limit=1)[0]
             bud = self.sql.getRec(tables="genbud", cols=["sum(glb_tramt)"],
-                where=[("glb_cono", "in", self.consol), ("glb_acno", "=",
-                "%s%s" % ("%", acc)), ("glb_curdt", "like", curdt)],
+                where=[("glb_cono", "in", self.consol), ("glb_acno::text",
+                "like", "%s%s" % ("%", acc)), ("glb_curdt", "=", curdt)],
                 limit=1)[0]
         else:
             lyr = self.sql.getRec(tables="gentrn",
@@ -10876,7 +10934,322 @@
             elif self.dtype == "Q":
                 self.form.tptp["document_type"][1] = "%s QUOTATION" % typ
         self.form.bank_details(cmc, ctm, 0)
-        # terms
+        if "terms" in self.form.tptp:
+            acc = self.sql.getRec(tables="ctlmes", cols=["mss_detail"],
+                where=[("mss_system", "=", "CON"), ("mss_message", "=", 1)],
+                limit=1)
+            if acc:
+                self.form.tptp["terms"][1] = acc[0]
+            else:
+                del self.form.tptp["terms"]
+
+    def doHeader(self, page, tdc):
+        self.form.add_page()
+        for key in self.form.newkey:
+            line = self.form.newdic[key]
+            if not line[tdc.index("tpd_place")] == "A":
+                continue
+            nl = line[:]
+            if nl[tdc.index("tpd_detseq")] == "page_number_C00":
+                nl[tdc.index("tpd_text")] = str(page)
+            elif nl[tdc.index("tpd_type")] == "T" and \
+                        nl[tdc.index("tpd_ttyp")] == "H":
+                mrgcod = nl[tdc.index("tpd_mrgcod")]
+                if mrgcod and mrgcod == "deliver_to" and not self.deliver:
+                    continue
+                if mrgcod and self.form.tptp[mrgcod][0][1][0] == "S":
+                    txt = nl[tdc.index("tpd_text")]
+                    nl[tdc.index("tpd_text")] = "%s " % txt
+            elif nl[tdc.index("tpd_type")] == "C":
+                mrgcod = nl[tdc.index("tpd_mrgcod")]
+                if mrgcod == "deliver_to":
+                    if not self.deliver:
+                        continue
+                    else:
+                        nl[tdc.index("tpd_text")] = self.deliver
+                else:
+                    nl[tdc.index("tpd_text")] = self.doGetData(mrgcod)
+            if key == "document_type_C00":
+                self.form.doDrawDetail(nl, fmat=False)
+            else:
+                self.form.doDrawDetail(nl)
+        return 0
+
+    def doCfwd(self, page):
+        line = self.form.cfwd[:]
+        line[5] = "Continued on Page %i" % (page + 1)
+        self.form.doDrawDetail(line)
+        return page + 1
+
+    def doGetData(self, mrgcod):
+        if mrgcod and mrgcod in self.form.tptp and self.form.tptp[mrgcod][1]:
+            return self.form.tptp[mrgcod][1]
+        return ""
+
+class PrintBookingInvoice:
+    def __init__(self, mf, conum, dtype, docs, **args):
+        self.mf = mf
+        self.conum = conum
+        self.dtype = dtype
+        if type(docs) in (int, str):
+            self.docs = [[docs]]
+        else:
+            self.docs = docs
+        defaults = {
+            "prtnam": "Default",
+            "tname": "booking_invoice",
+            "email": "n",
+            "copy": "n"}
+        for nam in args:
+            defaults[nam] = args[nam]
+        for nam in defaults:
+            setattr(self, nam, defaults[nam])
+        if self.setVariables():
+            self.doProcess()
+
+    def setVariables(self):
+        self.sql = Sql(self.mf.dbm, ["ctlmst", "bkmmst", "bkmcon", "bkmrtt"],
+            prog=__name__)
+        if self.sql.error:
+            return False
+        if type(self.email) == str:
+            self.emadd = ""
+        else:
+            self.email, self.emadd = self.email
+        return True
+
+    def doProcess(self):
+        sp = SplashScreen(self.mf.body, "Generating Forms\n\n   Please Wait...")
+        mcc = self.sql.bkmmst_col
+        ccc = self.sql.bkmcon_col
+        ttc = self.sql.bkmrtt_col
+        self.form = DrawForm(self.mf.dbm, self.tname)
+        txt = self.form.sql.tpldet_col.index("tpd_text")
+        tdc = self.form.sql.tpldet_col
+        self.doLoadStatic()
+        self.form.doNewDetail()
+        for doc in self.docs:
+            self.docno = CCD(doc, "UI", 9.0)
+            inv = self.sql.getRec(tables="bkmtrn", cols=["bkt_number",
+                "bkt_date"], where=[("bkt_cono", "=", self.conum),
+                ("bkt_type", "=", 2), ("bkt_refno", "=", "%9s" % doc)],
+                group="bkt_number, bkt_date", limit=1)
+            bkno, ivdt = inv
+            mst = self.sql.getRec(tables="bkmmst", where=[("bkm_cono", "=",
+                self.conum), ("bkm_number", "=", bkno)], limit=1)
+            bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
+                where=[("bkt_cono", "=", self.conum), ("bkt_number", "=",
+                bkno), ("bkt_type", "<>", 1)], limit=1)
+            self.total_balance = CCD(bal[0], "SD", 13.2).work
+            self.cod = mst[self.sql.bkmmst_col.index("bkm_ccode")]
+            # bkmcon
+            con = self.sql.getRec(tables="bkmcon", where=[("bkc_cono", "=",
+                self.conum), ("bkc_ccode", "=", self.cod)], limit=1)
+            for fld in ccc:
+                if fld in self.form.tptp:
+                    d = "%s_C00" % fld
+                    self.form.newdic[d][txt] = con[ccc.index(fld)]
+            # Account details
+            if "contact_details" in self.form.tptp:
+                dat = "%s %s %s" % (
+                    con[ccc.index("bkc_title")],
+                    con[ccc.index("bkc_names")],
+                    con[ccc.index("bkc_sname")])
+                dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr1")])
+                dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr2")])
+                dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr3")])
+                dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_pcode")])
+                self.form.tptp["contact_details"][1] = dat
+            self.eml = con[ccc.index("bkc_email")]
+            self.form.document_date(ivdt)
+            for fld in mcc:
+                if fld in self.form.tptp:
+                    self.form.tptp[fld][1] = mst[mcc.index(fld)]
+            if "message" in self.form.tptp:
+                if mst[mcc.index("bkm_special")]:
+                    self.message = True
+                    self.form.tptp["message"][1] = mst[mcc.index("bkm_special")]
+                else:
+                    self.message = False
+            rtt = self.sql.getRec("bkmrtt", where=[("brt_cono", "=",
+                self.conum), ("brt_number", "=", bkno), ("brt_invno", "=",
+                doc)])
+            self.doBody(ttc, rtt, tdc)
+            self.total_movements = float(ASD(self.total_balance) - \
+                ASD(self.total_value))
+            self.doTotal(tdc)
+            self.doTail(tdc)
+            if self.email.lower() == "y" and not self.emadd:
+                self.doPrint(self.eml)
+                sp.refreshSplash()
+        if self.email.lower() == "n" or self.emadd:
+            self.doPrint(self.emadd)
+        sp.closeSplash()
+
+    def doBody(self, ttc, rtt, tdc):
+        page = 0
+        count = 0
+        self.total_taxable = 0
+        self.total_nontaxable = 0
+        self.total_tax = 0
+        self.total_value = 0
+        for item in rtt:
+            if not count:
+                page += 1
+                count = self.doHeader(str(page), tdc)
+            if count == self.form.maxlines:
+                page = self.doCfwd(page)
+                count = self.doHeader(page, tdc)
+            for cod in self.form.body:
+                if not cod == "line_value":
+                    exec "%s = CCD(item[ttc.index(cod)], "\
+                        "self.form.tptp[cod][0][1], "\
+                        "self.form.tptp[cod][0][2])" % cod
+            ### INVOICE LINES
+            brt_rbase = item[ttc.index("brt_rbase")]
+            incpri = round((brt_arate.work * 1), 2)
+            if brt_rbase == "A":
+                incamt = brt_quant.work * brt_bdays.work * brt_arate.work
+            elif brt_rbase == "C":
+                incamt = brt_bdays.work * brt_arate.work
+            else:
+                brt_bdays.work = brt_bdays.disp = ""
+                if brt_rbase == "B":
+                    incamt = brt_quant.work * brt_arate.work
+                else:
+                    incamt = brt_arate.work
+            vatrat = float(ASD(100.0) + ASD(item[ttc.index("brt_vrate")]))
+            excamt = round((incamt * 100.0 / vatrat), 2)
+            vatamt = float(ASD(incamt) - ASD(excamt))
+            if excamt == incamt:
+                self.total_nontaxable = float(ASD(self.total_nontaxable) + \
+                    ASD(excamt))
+            else:
+                self.total_taxable = float(ASD(self.total_taxable) + \
+                    ASD(excamt))
+            self.total_tax = float(ASD(self.total_tax) + ASD(vatamt))
+            self.total_value = float(ASD(self.total_value) + ASD(incamt))
+            line_value = CCD(incamt, "SD", 11.2)
+            if count == self.form.maxlines:
+                page = self.doCfwd(page)
+                count = self.doHeader(page, tdc)
+            include = self.form.body[:]
+            for code in self.form.body:
+                seq = "%s_C%02i" % (code, count)
+                if code == "rtt_desc":
+                    data = l
+                elif code in include:
+                    exec "data = %s" % code
+                    data = data.work
+                else:
+                    data = "BLANK"
+                self.form.newdic[seq][tdc.index("tpd_text")] = data
+                if code == "brt_bdays" and not data:
+                    self.form.doDrawDetail(self.form.newdic[seq], fmat=False)
+                else:
+                    self.form.doDrawDetail(self.form.newdic[seq])
+            count += 1
+        for x in xrange(count, self.form.maxlines):
+            for cod in self.form.body:
+                seq = "%s_C%02i" % (cod, x)
+                self.form.newdic[seq][tdc.index("tpd_text")] = "BLANK"
+                self.form.doDrawDetail(self.form.newdic[seq])
+
+    def doTotal(self, tdc):
+        for c in self.form.total:
+            line = None
+            if c in self.form.newdic:
+                line = self.form.newdic[c]
+            else:
+                t = "%s_T00" % c
+                if t in self.form.newdic:
+                    line = self.form.newdic[t]
+            if line:
+                self.form.doDrawDetail(line)
+            d = "%s_C00" % c
+            if d in self.form.newkey:
+                line = self.form.newdic[d]
+                mrgcod = line[tdc.index("tpd_mrgcod")]
+                exec "line[tdc.index('tpd_text')] = self.%s" % mrgcod
+                self.form.doDrawDetail(line)
+
+    def doTail(self, tdc):
+        for c in self.form.tail:
+            line = None
+            if c in self.form.newdic:
+                line = self.form.newdic[c]
+            else:
+                t = "%s_T00" % c
+                if t in self.form.newdic:
+                    line = self.form.newdic[t]
+            if line:
+                if line[tdc.index("tpd_mrgcod")] == "message":
+                    if not self.message:
+                        continue
+                self.form.doDrawDetail(line)
+            d = "%s_C00" % c
+            if d in self.form.newdic:
+                line = self.form.newdic[d]
+                mrgcod = line[tdc.index("tpd_mrgcod")]
+                line[tdc.index("tpd_text")] = self.doGetData(mrgcod)
+                self.form.doDrawDetail(line, fmat=False)
+
+    def doPrint(self, mail):
+        pfx = "InvCrn"
+        if self.dtype == "I":
+            head = "Invoice"
+        elif self.dtype == "C":
+            head = "Credit Note"
+        if self.email.lower() == "y" and not self.emadd:
+            pdfnam = getModName(self.mf.rcdic["wrkdir"], pfx,
+                "%s_%s" % (self.conum, self.docno.work), ext="pdf", wait=1)
+        else:
+            pdfnam = getModName(self.mf.rcdic["wrkdir"], pfx,
+                "%s_all" % self.conum, ext="pdf", wait=1)
+        if self.email.lower() == "y" and not self.emadd:
+            head = "%s %s" % (head, self.docno.work)
+        elif len(self.docs) == 1:
+            head = "%s %s" % (head, self.docno.work)
+        else:
+            head = "%s %s - %s" % (head, self.docs[0][0], self.docs[-1][0])
+        if self.prtnam == "view":
+            view = "V"
+        else:
+            view = "P"
+        self.form.output(pdfnam, "F")
+        doPrinter(mf=self.mf, conum=self.conum, rep=pdfnam, head=head,
+            view=view, prtnam=self.prtnam, mail=mail)
+        if self.email.lower() == "y":
+            self.form = DrawForm(self.mf.dbm, self.tname)
+            self.doLoadStatic()
+            self.form.doNewDetail()
+
+    def doLoadStatic(self):
+        # ctlmst
+        cmc = self.sql.ctlmst_col
+        ctm = self.sql.getRec(tables="ctlmst", where=[("ctm_cono", "=",
+            self.conum)], limit=1)
+        for fld in cmc:
+            dat = ctm[cmc.index(fld)]
+            if fld in self.form.tptp:
+                if fld == "ctm_logo":
+                    self.form.letterhead(cmc, ctm, fld, dat)
+                    continue
+                self.form.tptp[fld][1] = dat
+        if "letterhead" in self.form.tptp:
+            self.form.letterhead(cmc, ctm, "letterhead", None)
+        if "document_type" in self.form.tptp:
+            if self.copy == "y":
+                typ = "COPY"
+            else:
+                typ = ""
+            if ctm[cmc.index("ctm_taxno")]:
+                typ = "%s TAX" % typ
+            if self.dtype == "I":
+                self.form.tptp["document_type"][1] = "%s INVOICE" % typ
+            elif self.dtype == "C":
+                self.form.tptp["document_type"][1] = "%s CREDIT NOTE" % typ
+        self.form.bank_details(cmc, ctm, 0)
         if "terms" in self.form.tptp:
             acc = self.sql.getRec(tables="ctlmes", cols=["mss_detail"],
                 where=[("mss_system", "=", "CON"), ("mss_message", "=", 1)],
@@ -11192,6 +11565,11 @@
             self.doProcess()
 
     def setVariables(self):
+        gc = GetCtl(self.mf)
+        bwlctl = gc.getCtl("bwlctl", 1)
+        if not bwlctl:
+            return
+        self.nstart = bwlctl["ctb_nstart"]
         self.sql = Sql(self.mf.dbm, ["bwldrm", "bwldrt"], prog=__name__)
         if self.sql.error:
             return False
@@ -11240,7 +11618,7 @@
                 data.append([0, ""])
                 pos -= 1
             data.append([rec[3], rec[4]])
-            if rec[3] < 900:
+            if rec[3] < self.nstart:
                 mem += 1
             else:
                 vis += 1
@@ -11282,7 +11660,7 @@
                 for t in m[2:]:
                     if not t[0]:
                         continue
-                    if t[0] < 900:
+                    if t[0] < self.nstart:
                         mem += 1
                     else:
                         vis += 1
@@ -11384,7 +11762,7 @@
                             txt = "%s%s" % (grn, rnk)
                             self.fpdf.drawText(txt, x=x+32.5, y=yaxis,
                                 w=15, h=24, font=["Arial", "BI", 24],
-                                fill=1, border="TB", ln=0)
+                                fill=1, border="TLB", ln=0)
         if self.prtnam == "view":
             view = "V"
         else:
@@ -13144,9 +13522,9 @@
                 if itg[0]:
                     self.incoac = True
             # Check for Sales Invoicing
-            sql = Sql(self.mf.dbm, "slsiv1", errs=False, prog=__name__)
+            sql = Sql(self.mf.dbm, "bkmiv1", errs=False, prog=__name__)
             if not sql.error:
-                inv = sql.getRec(tables="slsiv1", cols=["count(*)"], limit=1)
+                inv = sql.getRec(tables="bkmiv1", cols=["count(*)"], limit=1)
                 if inv[0]:
                     self.slsinv = True
         # Load System Names and Check for Integration
@@ -14177,7 +14555,7 @@
                 mess="Missing 'impcol' and/or 'table' in List of Variables")
             return
         if "impfld" in args:
-            self.impfld = args["impfld"]
+            self.impfld = list(args["impfld"])
             self.index = len(self.impfld)
         else:
             self.index = 0
@@ -15020,7 +15398,6 @@
             self.tptp["document_date"][1] = date
 
     def bank_details(self, col, mst, seq=0):
-        tdc = self.sql.tpldet_col
         if "bank_details" in self.tptp:
             if mst[col.index("ctm_b_name")]:
                 dat = "Name:    %s" % mst[col.index("ctm_b_name")]
@@ -15030,12 +15407,12 @@
                 if not seq:
                     self.tptp["bank_details"][1] = dat
                 else:
+                    tdc = self.sql.tpldet_col
                     self.newdic["bank_details_C00"][tdc.index("tpd_text")] = dat
             elif not seq:
                 del self.tptp["bank_details"]
 
     def account_details(self, cod, col, mst, seq=0):
-        tdc = self.sql.tpldet_col
         if "account_details" in self.tptp:
             dat = mst[col.index("%s_name" % cod)]
             dat = "%1s\n%1s" % (dat, mst[col.index("%s_add1" % cod)])
@@ -15045,24 +15422,28 @@
             if not seq:
                 self.tptp["account_details"][1] = dat
             else:
+                tdc = self.sql.tpldet_col
                 self.newdic["account_details_C00"][tdc.index("tpd_text")] = dat
 
     def name_init(self, col, mst, seq=0):
-        tdc = self.sql.tpldet_col
         if "name_init" in self.tptp:
             dat = mst[col.index("mlm_names")].split()[0][0].upper()
             dat = "%s %s" % (dat, mst[col.index("mlm_surname")])
             if not seq:
                 self.tptp["name_init"][1] = dat
             else:
+                tdc = self.sql.tpldet_col
                 self.newdic["name_init"][tdc.index("tpd_text")] = dat
 
 class ToolTip(object):
-    def __init__(self, widget, text):
+    def __init__(self, widget, text, font=None):
         self.widget = widget
         self.text = text
+        if not font:
+            self.font = "TkTooltipFont"
+        else:
+            self.font = font
         self.tipwindow = None
-        self.id = None
         self.x = self.y = 0
         self.widget.bind("<Enter>", self.showTip)
         self.widget.bind("<FocusIn>", self.showTip)
@@ -15084,7 +15465,7 @@
         tw.wm_overrideredirect(1)
         tw.wm_geometry("+%d+%d" % (x, y))
         label = MyLabel(tw, text=self.text, justify="left", relief="solid",
-            borderwidth=2, font="TkTooltipFont", wraplength=500)
+            borderwidth=2, font=self.font, wraplength=500)
         label.pack(ipadx=1, ipady=2)
 
     def hideTip(self, event):
@@ -15094,7 +15475,7 @@
             tw.destroy()
 
 class AboutTartan:
-    def __init__(self, mf):
+    def __init__(self, mf, ver):
         self.mf = mf
         self.setVariables()
         self.about = MyFrame(self.mf.window, borderwidth=2, relief="ridge")
@@ -15112,7 +15493,7 @@
 
 %s 2004-%s Paul Malherbe
 
-""" % ("5.0.0", u"\u00A9", self.sysdtw / 10000)
+""" % (ver, u"\u00A9", self.sysdtw / 10000)
         label = MyText(self.about, font=("Helvetica", 14), width=65,
             height=14, takefocus=False)
         label.insert("insert", info)

=== modified file 'std/tartanFunctions.py'
--- std/tartanFunctions.py	2014-08-30 12:52:42 +0000
+++ std/tartanFunctions.py	2014-12-04 09:01:45 +0000
@@ -443,7 +443,7 @@
         nam.append(os.path.join(pth, "%s_%s_%s.%s" % (prg, key, tim, e)))
     return nam
 
-def doPrinter(mf=None, conum=None, rep=None, head=None, view=None, prtnam=None, fadd=None, mail=None, splash=True, skip=False, printm="y", emess=None):
+def doPrinter(mf=None, conum=None, rep=None, head=None, view=None, prtnam=None, fadd=None, mail=None, splash=True, skip=False, printm="y", emess=None, attach=None):
     """
     This module Views or Prints and/or Mails a Report
 
@@ -460,6 +460,7 @@
      skip   = Skip mail errors
      printm = Whether to print emailed documents
      emess  = A list or tuple contaning (Subject, Message)
+     attach = A list of attachments
      """
     import os, sys, time
     from TartanClasses import Dbase, SplashScreen, Sql
@@ -503,7 +504,10 @@
                     sp = SplashScreen(mf.body,
                         "E-Mailing the Report to:\n\n%s\n\nPlease Wait....." %
                         mail[0])
-                att = [rep]
+                if not attach:
+                    att = [rep]
+                else:
+                    att = [rep] + attach[:]
                 err = sendMail(smtp[0:6], fadd, mail, subj, mess, attach=att)
                 if err:
                     if skip:
@@ -544,11 +548,12 @@
             return
         if view.lower() == "v" or prtnam == "view":
             # Execute viewer command
-            mf.window.withdraw()
+            mf.window.iconify()
             exe, cmd = parsePrg(mf.rcdic["vwr"])
             cmd.append(rep)
             os.spawnv(os.P_WAIT, exe, tuple(cmd))
             mf.window.deiconify()
+            mf.window.lift()
         elif prtnam and prtnam.lower() != "none":
             if splash:
                 sp = SplashScreen(mf.body,
@@ -597,17 +602,18 @@
         showException(mf.window, mf.rcdic["wrkdir"], "Output Error")
         return
 
-def textFormat(text, width=30):
+def textFormat(text, width=30, blong=True):
     """
     Format a text block
 
     Arguments:
         `text`   -- the string to be reformatted
         `width`  -- the maximum width of formatted text
+        `blong`  -- break long words
     """
     if text:
         import textwrap
-        return textwrap.wrap(text, width=width)
+        return textwrap.wrap(text, width=width, break_long_words=blong)
     else:
         return [""]
 
@@ -912,9 +918,10 @@
 
 def dateDiff(date1, date2, ptype="years"):
     """
-    Function to return the differance between to dates.
+    Function to return the differance between two dates.
         date1 = Starting Date
         date2 = Ending Date
+        ptype = years, months or days
     """
     import datetime, time
 
@@ -1244,14 +1251,14 @@
         state = df.disableButtonsTags()
         df.setWidget(df.mstFrame, state="hide")
     opts = {"mf": mf}
-    if coy:
+    if coy is not None:
         opts["conum"] = coy[0]
         opts["conam"] = coy[1]
-    if period:
+    if period is not None:
         opts["period"] = period
-    if user:
+    if user is not None:
         opts["capnm"] = user
-    if args:
+    if args is not None:
         opts["args"] = args
     exec "from %s import %s as module" % (mod, mod)
     module(**opts)

=== modified file 'std/tartanWork.py'
--- std/tartanWork.py	2014-10-01 14:07:50 +0000
+++ std/tartanWork.py	2014-11-29 10:14:29 +0000
@@ -164,6 +164,8 @@
 #----------
 stdtpl = [
     "booking_form",
+    "booking_invoice",
+    "booking_statement",
     "comp_cards",
     "member_cards",
     "payslip",
@@ -190,22 +192,13 @@
             }},
     "B": {
         "tables": {
-            "BKM": ["bkmmst", "bkmcon"],
-            "INV": ["bkmmst", "bkmcon", "bkmrtt"]},
+            "BKM": ["bkmmst", "bkmcon"]},
         "codes": {
+            "company_name": [["", "NA", 30, "Company Name"], []],
             "booking_date": [["", "NA", 17, "Booking Date"], []],
             "booking_number": [["", "RW", 60, "Booking Number"], []],
             "booking_letter": [["", "RW", 80, "Booking Letter"], []],
-            "booking_details": [["", "RW", 80, "Booking Details"], []],
-            "contact_name": [["", "NA", 30, "Contact Name"], []],
-            "contact_details": [["", "RW", 30, "Contact Name & Address"], []],
-            "carried_forward": [["", "NA", 22, "Carried Forward"], []],
-            "eft_reference": [["", "RW", 60, "EFT Reference"], []],
-            "line_value": [["", "SD", 13.2, "Line Value"], []],
-            "total_taxable": [["", "SD", 13.2, "Total Taxable"], []],
-            "total_nontaxable": [["", "SD", 13.2, "Total Non-Taxable"], []],
-            "total_tax": [["", "SD", 13.2, "Total Tax"], []],
-            "total_value": [["", "SD", 13.2, "Total Document Value"], []],
+            "booking_details": [["", "RW", 80, "Booking Details"], []]
             }},
     "C": {
         "tables": {
@@ -224,9 +217,11 @@
             }},
     "I": {
         "tables": {
+            "BKM": ["bkmmst", "bkmcon", "bkmrtt"],
             "INV": ["drsmst", "slsiv1", "slsiv2"]},
         "codes": {
             "account_details": [["", "RW", 30, "Account Name & Address"], []],
+            "contact_details": [["", "RW", 30, "Contact Name & Address"], []],
             "deliver_to": [["", "RW", 30, "Delivery Address (All Lines)"], []],
             "line_value": [["", "SD", 13.2, "Line Value"], []],
             "carried_forward": [["", "NA", 22, "Carried Forward"], []],
@@ -234,6 +229,9 @@
             "total_nontaxable": [["", "SD", 13.2, "Total Non-Taxable"], []],
             "total_tax": [["", "SD", 13.2, "Total Tax"], []],
             "total_value": [["", "SD", 13.2, "Total Document Value"], []],
+            "total_movements": [["", "SD", 13.2, "Total Movements"], []],
+            "total_balance": [["", "SD", 13.2, "Total Account Balance"], []],
+            "total_value": [["", "SD", 13.2, "Total Document Value"], []],
             "terms": [["", "NA", 30, "Terms and Conditions (All Lines)"], []]
             }},
     "M": {
@@ -287,12 +285,14 @@
             }},
     "S": {
         "tables": {
+            "BKM": ["bkmmst", "bkmcon", "bkmtrn"],
             "DRS": ["drschn", "drsmst", "drstrn"],
             "MEM": ["memmst", "memtrn"],
             "RCA": ["rcaowm", "rcaowt", "rcaprm", "rcatnm", "rcatnt"],
             "RTL": ["rtlmst", "rtltrn", "rtlprm", "rtlcon"]},
         "codes": {
             "account_details": [["", "RW", 30, "Account Name & Address"], []],
+            "contact_details": [["", "RW", 30, "Contact Name & Address"], []],
             "type_code": [["", "NA", 3, "Transaction Type Code"], []],
             "line_paid": [["", "SD", 11.2, "Line Paid Amount"], []],
             "line_balance": [["", "SD", 11.2, "Line Balance"], []],

=== modified file 'str/st2010.py'
--- str/st2010.py	2014-08-06 15:44:15 +0000
+++ str/st2010.py	2014-12-04 14:58:53 +0000
@@ -712,8 +712,7 @@
             ("pot_code", "=", cod)])
         if self.acttyp == "A":
             self.amend = True
-        self.doReadLoadStr()
-        self.doChgExit()
+        self.doChgExit(loader=True)
 
     def doChgEnd(self):
         grp = self.change[0]
@@ -725,11 +724,12 @@
             self.ordno), ("pot_group", "=", grp), ("pot_code", "=", cod)])
         if self.acttyp == "A":
             self.amend = True
-        self.doReadLoadStr()
-        self.doChgExit()
+        self.doChgExit(loader=True)
 
-    def doChgExit(self):
+    def doChgExit(self, loader=False):
         self.cg.closeProcess()
+        if loader:
+            self.doReadLoadStr()
         self.opts["mf"].closeLoop()
 
     def doReprnt(self, widget=None):

=== modified file 'str/st4010.py'
--- str/st4010.py	2014-05-28 14:55:12 +0000
+++ str/st4010.py	2014-11-05 07:48:52 +0000
@@ -289,6 +289,7 @@
             self.opts["period"][0])))
         m_ob, m_mv, m_cb, y_ob, y_mv, y_cb, ac, lc, = bals.doStrBals()
         cb, oo, bo = bals.doStrOrds()
+        print cb.work, oo.work, bo.work
         this, hist = bals.doStrHist()
         rec = hist[0]
         rec.append(this[0])

=== modified file 'tab/tb1020.py'
--- tab/tb1020.py	2014-10-01 14:07:50 +0000
+++ tab/tb1020.py	2014-12-02 15:12:03 +0000
@@ -52,10 +52,12 @@
         if self.setVariables():
             if not self.part and self.oldver[0] and self.oldver[0] < 5:
                 self.doCvtVat()
-            self.doDelBatch()
+            if "ctlbat" in self.tab:
+                self.doDelBatch()
             self.doProcessTables()
             if not self.part and self.oldver[0] and self.oldver[0] < 5:
                 self.doWagCal()
+            self.doBowls()
             if not self.part and self.opts["cln"]:
                 self.doCleanDatabase()
             if not self.part and self.opts["ver"]:
@@ -151,7 +153,6 @@
             "wagcap": ["wcp_capdt", "wcp_seq"],
             "wagltf": ["wlt_capdt", "wlt_seq"],
             "wagtf1": ["wt1_capdt", "wt1_seq"]}
-        self.nstart = None
         return True
 
     def doCvtVat(self):
@@ -419,10 +420,14 @@
                         new = old[olddic[csv[2]][0]]
                     elif self.table == "asstrn" and csv[2] == "ast_capnm":
                         new = "Unknown"
+                    elif self.table == "bkmunm" and csv[2] == "bum_multi":
+                        new = "N"
                     elif self.table == "bwlctl" and csv[2] == "ctb_dbase":
                         new = "C"
                     elif self.table == "bwlctl" and csv[2] == "ctb_order":
                         new = old[olddic["ctb_rtype"][0]]
+                    elif self.table == "bwlflf" and csv[2] == "bff_gender":
+                        new = "B"
                     elif self.table == "bwlflf" and csv[2] == "bff_sets":
                         new = "N"
                     elif self.table == "bwlflm" and csv[2] == "bfm_self":
@@ -614,6 +619,29 @@
         if self.opts["mf"] and  self.opts["mf"].window:
             spl.closeSplash()
 
+    def doBowls(self):
+        if not self.dbm.checkTable("bwlskp"):
+            return
+        sql = Sql(self.dbm, ["bwlctl", "bwltab", "bwldrt", "bwlskp"],
+            prog=__name__)
+        scc = sql.bwlskp_col
+        skp = sql.getRec(tables="bwlskp", order="bcs_cono, bcs_surname")
+        for s in skp:
+            tab = sql.getRec(tables="bwltab", where=[("btb_cono", "=", s[0]),
+                ("btb_tab", "=", s[1])], limit=1)
+            if not tab:
+                coy = s[scc.index("bcs_cono")]
+                cod = s[scc.index("bcs_code")]
+                sur = s[scc.index("bcs_surname")]
+                nam = s[scc.index("bcs_names")]
+                gen = s[scc.index("bcs_gender")]
+                eml = s[scc.index("bcs_email")]
+                tel = s[scc.index("bcs_phone")]
+                data = [coy, cod, 0, sur, nam, gen, "", "", "", "", "", "",
+                    tel, eml, 0, 0, 0, 0, 0]
+                sql.insRec("bwltab", data=data)
+        self.dbm.commitDbase()
+
     def doCleanDatabase(self):
         txt = "Cleaning Database ... Please Wait"
         if self.opts["mf"] and  self.opts["mf"].window:
@@ -676,48 +704,6 @@
             self.opts["mf"].updateStatus("")
             if self.opts["bar"]:
                 pb.closeProgress()
-        if self.nstart:
-            if self.opts["mf"] and  self.opts["mf"].window:
-                self.opts["mf"].updateStatus("Generating Player's Codes")
-            else:
-                print "Generating Player's Codes"
-            tables = (
-                ("bwlent", "bce_cono", "bce_scod"),
-                ("bwlgme", "bcg_cono", "bcg_scod", "bcg_ocod"),
-                ("bwlskp", "bcs_cono", "bcs_code"))
-            tabs = []
-            for ot in tables:
-                tabs.append(ot[0])
-            sql = Sql(self.dbm, tabs, prog=__name__)
-            for ot in tables:
-                tt = "%s_temp" % ot[0]
-                sql.sqlRec("Create table %s as Select * from %s "\
-                    "where %s = %s" % (tt, ot[0], ot[1], 1))
-                sql.delRec(ot[0], where=[(ot[1], "=", 1)])
-            plrs = sql.sqlRec("Select * from bwlskp_temp order by "\
-                "bcs_surname, bcs_names")
-            key = {}
-            for plr in plrs:
-                old = plr[sql.bwlskp_col.index("bcs_code")]
-                if plr[sql.bwlskp_col.index("bcs_tab")]:
-                    new = plr[sql.bwlskp_col.index("bcs_tab")]
-                else:
-                    new = self.nstart
-                    self.nstart += 1
-                key[old] = new
-            for ot in tables:
-                tt = "%s_temp" % ot[0]
-                exec "cc = sql.%s_col" % ot[0]
-                recs = sql.sqlRec("Select * from %s" % tt)
-                for rec in recs:
-                    rec[cc.index(ot[2])] = key[rec[cc.index(ot[2])]]
-                    if ot[0] == "bwlgme":
-                        if rec[cc.index(ot[3])]:
-                            rec[cc.index(ot[3])] = key[rec[cc.index(ot[3])]]
-                    sql.insRec(ot[0], data=rec)
-            for ot in tables:
-                tt = "%s_temp" % ot[0]
-                sql.sqlRec("Drop table %s" % tt)
         if self.opts["mf"] and  self.opts["mf"].window:
             spl = SplashScreen(self.opts["mf"].body,
                 "Creating Standard Records\n\nPlease Wait")

=== modified file 'uty/bm1010.py'
--- uty/bm1010.py	2014-08-06 15:44:15 +0000
+++ uty/bm1010.py	2014-12-09 11:43:36 +0000
@@ -77,19 +77,35 @@
         mod = []
         for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
             mod.append(ctlmst["ctm_modules"][x:x+2])
+        if mod.count("BC"):
+            tab.append(("bwltab"))
+            bwlctl = gc.getCtl("bwlctl", self.opts["conum"])
+            if not bwlctl:
+                return
+            self.nstart = bwlctl["ctb_nstart"]
+        if mod.count("BK"):
+            tab.append("bkmcon")
         if mod.count("CR"):
             tab.append("crsmst")
         if mod.count("DR"):
             tab.extend(["drsact", "drstyp", "drsmst"])
         if mod.count("ML"):
             tab.extend(["memctc", "memmst", "memcat", "memkon"])
-        if mod.count("BC"):
-            tab.append(("bwlskp"))
         if mod.count("SC"):
-            tab.append(("scpskp"))
+            tab.append(("scpmem"))
         self.sql = Sql(self.opts["mf"].dbm, tables=tab, prog=__name__)
         if self.sql.error:
             return
+        if mod.count("BC"):
+            self.tab = self.sql.getRec(tables="bwltab", cols=["count(*)"],
+                where=[("btb_cono", "=", self.opts["conum"])], limit=1)
+        else:
+            self.tab = [0]
+        if mod.count("BK"):
+            self.bkm = self.sql.getRec(tables="bkmcon", cols=["count(*)"],
+                where=[("bkc_cono", "=", self.opts["conum"])], limit=1)
+        else:
+            self.bkm = [0]
         if mod.count("CR"):
             self.crs = self.sql.getRec(tables="crsmst", cols=["count(*)"],
                 where=[("crm_cono", "=", self.opts["conum"])], limit=1)
@@ -105,20 +121,16 @@
                 where=[("mlm_cono", "=", self.opts["conum"])], limit=1)
         else:
             self.mem = [0]
-        if mod.count("BC"):
-            self.skp = self.sql.getRec(tables="bwlskp", cols=["count(*)"],
-                where=[("bcs_cono", "=", self.opts["conum"])], limit=1)
-        else:
-            self.skp = [0]
         if mod.count("SC"):
-            self.dcs = self.sql.getRec(tables="scpskp", cols=["count(*)"],
+            self.scp = self.sql.getRec(tables="scpmem", cols=["count(*)"],
                 where=[("scs_cono", "=", self.opts["conum"])], limit=1)
         else:
-            self.dcs = [0]
+            self.scp = [0]
         self.mess = ""
         self.embed = []
         self.attach = []
         self.personal = "N"
+        self.namdet = "N"
         return True
 
     def mainProcess(self):
@@ -142,14 +154,16 @@
             "types": "fle",
             "multi": True}
         self.r2s = []
+        if self.bkm[0]:
+            self.r2s.append(("Bookings", "K"))
+        if self.tab[0] or self.scp[0]:
+            self.r2s.append(("Bowls", "B"))
+        if self.crs[0]:
+            self.r2s.append(("Creditors", "C"))
         if self.drs[0]:
             self.r2s.append(("Debtors", "D"))
-        if self.crs[0]:
-            self.r2s.append(("Creditors", "C"))
         if self.mem[0]:
             self.r2s.append(("Members", "M"))
-        if self.skp[0] or self.dcs[0]:
-            self.r2s.append(("Skips", "S"))
         self.r2s.append(("CSV File", "V"))
         if XLRD:
             self.r2s.append(("XLS File", "X"))
@@ -194,6 +208,7 @@
         self.dtyp = w
         idx = 0
         if self.dtyp == "S":
+            # Creditors and Debtors missing mobile field
             if self.drs[0]:
                 self.df.setWidget(self.df.topEntry[0][1][idx][0], state="hide")
                 idx += 1
@@ -201,8 +216,10 @@
                 self.df.setWidget(self.df.topEntry[0][1][idx][0], state="hide")
             if self.mem[0]:
                 self.df.topf[0][1][5] = "M"
-            elif self.skp[0]:
-                self.df.topf[0][1][5] = "S"
+            elif self.tab[0]:
+                self.df.topf[0][1][5] = "B"
+            elif self.bkm[0]:
+                self.df.topf[0][1][5] = "K"
             else:
                 self.df.topf[0][1][5] = "V"
         elif self.sms[0] == "Y":
@@ -216,7 +233,9 @@
     def doList(self, frt, pag, r, c, p, i, w):
         self.ulist = w
         self.personal = "Y"
-        if not self.ulist == "S":
+        if self.ulist == "K":
+            pass
+        else:
             self.doFilter()
             if self.fltexit:
                 return "rf"
@@ -273,6 +292,16 @@
                 fld.append((("T",0,3,0),"INA",3,"Type","Account Type",
                     "","N",self.doFltTyp,typ,None,None))
                 fld.append((("T",0,3,0),"ONA",30,""))
+        elif self.ulist == "B":
+            r1s = (("All", "A"),("Members","B"),("Guests","G"))
+            r2s = (("All", "A"),("Male","M"),("Female","F"))
+            r3s = (("Yes", "Y"), ("No", "N"))
+            r4s = (("First Name", "N"), ("First Initial", "I"))
+            fld = (
+                (("T",0,0,0),("IRB",r1s),0,"Category","",
+                    "A","Y",self.doFltCat,None,None,None),
+                (("T",0,1,0),("IRB",r2s),0,"Gender","",
+                    "A","Y",self.doFltGen,None,None,None))
         else:
             fle = {
                 "stype": "F",
@@ -333,6 +362,8 @@
             self.fltcod = []
             return
         self.fltcat = w
+        if self.ulist == "B":
+            return
         chk = self.sql.getRec(tables="memctc", where=[("mcc_cono", "=",
             self.opts["conum"]), ("mcc_type", "=", self.fltcat)], limit=1)
         if not chk:
@@ -669,7 +700,39 @@
             showError(self.opts["mf"].body, "Error",
                 "Please Check Username and/or Password")
             return
-        if self.ulist == "M":
+        if self.ulist == "B":
+            if self.tab[0]:
+                tab = ["bwltab"]
+                whr = [("btb_cono", "=", self.opts["conum"])]
+                if self.fltcat == "M":
+                    whr.append(("btb_tab", "<", self.nstart))
+                elif self.fltcat == "G":
+                    whr.append(("btb_tab", ">=", self.nstart))
+                if self.fltgen in ("M", "F"):
+                    whr.append(("btb_gender", "=", self.fltgen))
+                col = ["btb_surname", "btb_names", "btb_cell"]
+                odr = "btb_surname, btb_names"
+            else:
+                tab = ["scpmem"]
+                whr = [("scm_cono", "=", self.opts["conum"])]
+                col = ["scm_surname", "scm_names", "scm_phone"]
+                odr = "scm_surname, scm_names"
+            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+            accs = []
+            for g in get:
+                accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
+        elif self.ulist == "K":
+            tab = ["bkmcon"]
+            col = ["bkc_sname", "bkc_names", "bkc_celno"]
+            whr = [
+                ("bkc_cono", "=", self.opts["conum"]),
+                ("bkc_celno", "<>", "")]
+            odr = "bkm_sname, bkm_names"
+            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+            accs = []
+            for g in get:
+                accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
+        elif self.ulist == "M":
             tab = ["memmst", "memkon", "memctk"]
             col = ["mlm_surname", "mlm_names", "mlk_detail"]
             whr = [
@@ -679,6 +742,8 @@
                 ("mlk_memno=mlm_memno",),
                 ("mck_code=mlk_code",),
                 ("mck_type", "=", "M")]
+            if self.fltgen in ("M", "F"):
+                whr.append(("mlm_gender", "=", self.fltgen))
             if self.fltcat:
                 tab.append("memcat")
                 whr.append(("mlc_cono=mlm_cono",))
@@ -691,21 +756,6 @@
             accs = []
             for g in get:
                 accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
-        elif self.ulist == "S":
-            if self.skp[0]:
-                tab = ["bwlskp"]
-                whr = [("bcs_cono", "=", self.opts["conum"])]
-                col = ["bcs_surname", "bcs_names", "bcs_phone"]
-                odr = "bcs_surname, bcs_names"
-            else:
-                tab = ["scpskp"]
-                whr = [("scs_cono", "=", self.opts["conum"])]
-                col = ["scs_surname", "scs_names", "scs_phone"]
-                odr = "scs_surname, scs_names"
-            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
-            accs = []
-            for g in get:
-                accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
         elif self.ulist in ("V", "X"):
             accs = self.impdat
         if units < len(accs):
@@ -758,7 +808,52 @@
         return s
 
     def doSendEmail(self):
-        if self.ulist == "D":
+        if self.ulist == "B":
+            whr = [("bcs_cono", "=", self.opts["conum"])]
+            if self.fltcat == "M":
+                whr.append(("btb_tab", "<", self.nstart))
+            elif self.fltcat == "G":
+                whr.append(("btb_tab", ">=", self.nstart))
+            if self.fltgen in ("M", "F"):
+                whr.append(("btb_gender", "=", self.fltgen))
+            col = ["bcs_surname", "bcs_names", "bcs_email"]
+            odr = "bcs_surname, bcs_names"
+            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+            accs = []
+            for g in get:
+                accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
+        elif self.ulist == "K":
+            tab = ["bkmcon"]
+            col = ["bkc_title", "bkc_sname", "bkc_names", "bkc_email"]
+            whr = [
+                ("bkc_cono", "=", self.opts["conum"]),
+                ("bkc_email", "<>", "")]
+            odr = "bkc_sname, bkc_names"
+            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+            accs = []
+            for g in get:
+                if self.personal == "Y":
+                    tit = g[0]
+                    sur = g[1]
+                    nam = g[2].split()[0].title()
+                    if self.namdet == "I":
+                        nam = nam[0].upper()
+                    accs.append((g[3], "%s %s %s" % (tit, nam, sur)))
+                else:
+                    accs.append((g[3], ""))
+        elif self.ulist == "C":
+            whr = [("crm_cono", "=", self.opts["conum"])]
+            if self.fltto == "M":
+                col = ["crm_mgr_email", "crm_mgr"]
+                whr.append(("crm_mgr_email", "<>", ""))
+            elif self.fltto == "A":
+                col = ["crm_acc_email", "crm_acc"]
+                whr.append(("crm_acc_email", "<>", ""))
+            else:
+                col = ["crm_ord_email", "crm_ord"]
+                whr.append(("crm_ord_email", "<>", ""))
+            accs = self.sql.getRec(tables="crsmst", cols=col, where=whr)
+        elif self.ulist == "D":
             whr = [("drm_cono", "=", self.opts["conum"])]
             if self.fltto == "M":
                 col = ["drm_mgr_email", "drm_mgr"]
@@ -774,18 +869,6 @@
             if self.flttyp:
                 whr.append(("drm_bus_type", "=", self.flttyp))
             accs = self.sql.getRec(tables="drsmst", cols=col, where=whr)
-        elif self.ulist == "C":
-            whr = [("crm_cono", "=", self.opts["conum"])]
-            if self.fltto == "M":
-                col = ["crm_mgr_email", "crm_mgr"]
-                whr.append(("crm_mgr_email", "<>", ""))
-            elif self.fltto == "A":
-                col = ["crm_acc_email", "crm_acc"]
-                whr.append(("crm_acc_email", "<>", ""))
-            else:
-                col = ["crm_ord_email", "crm_ord"]
-                whr.append(("crm_ord_email", "<>", ""))
-            accs = self.sql.getRec(tables="crsmst", cols=col, where=whr)
         elif self.ulist == "M":
             tab = ["memmst", "memkon"]
             col = ["mlm_title", "mlm_surname", "mlm_names", "mlk_detail"]
@@ -818,14 +901,6 @@
                     accs.append((g[3], "%s %s %s" % (tit, nam, sur)))
                 else:
                     accs.append((g[3], ""))
-        elif self.ulist == "S":
-            whr = [("bcs_cono", "=", self.opts["conum"])]
-            col = ["bcs_surname", "bcs_names", "bcs_email"]
-            odr = "bcs_surname, bcs_names"
-            get = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
-            accs = []
-            for g in get:
-                accs.append((g[2], "%s %s" % (g[1].split()[0], g[0])))
         elif self.ulist in ("V", "X"):
             accs = self.impdat
         sent = []

=== modified file 'uty/pm1010.py'
--- uty/pm1010.py	2014-08-27 09:27:53 +0000
+++ uty/pm1010.py	2014-11-26 07:47:15 +0000
@@ -244,10 +244,17 @@
         self.opts["mf"].closeLoop()
 
 if __name__ == "__main__":
-    import getpass
+    import getopt, getpass
     from TartanClasses import MainFrame
     from tartanFunctions import loadRcFile
-    rcdic = loadRcFile("/home/paul/.secrets")
+    try:
+        opts, args = getopt.getopt(sys.argv[1:],"r:")
+    except:
+        print
+        print "Usage: -r rcfile"
+        print
+        sys.exit()
+    rcdic = loadRcFile(opts[0][1])
     mf = MainFrame(rcdic=rcdic)
     pm1010(**{"mf": mf, "capnm": getpass.getuser()})
 

