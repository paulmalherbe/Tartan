=== modified file '.bzrignore'
--- .bzrignore	2016-02-27 13:18:41 +0000
+++ .bzrignore	2016-04-27 13:26:57 +0000
@@ -78,3 +78,4 @@
 web
 mst/thm
 thm
+img/tcltk.png

=== modified file 'ass/ar3040.py'
--- ass/ar3040.py	2016-02-27 13:18:41 +0000
+++ ass/ar3040.py	2016-03-23 16:58:11 +0000
@@ -44,10 +44,11 @@
         self.eper = self.opts["period"][2][0] / 100
         self.head = ("%03u %-30s %s" % (self.opts["conum"],
             self.opts["conam"], "%s"))
-        self.colsh = ["Code", "Description", "Cost-Price", "Accum-Dep",
-            "Opening-Bal", "Purchases", "Improvements", "Write-Offs",
-            "Depreciation", "Sales", "Profit/Loss", "Closing-Bal"]
-        self.forms = [("Na", 7), ("NA", 30)] + [("SD", 13.2)] * 10
+        self.colsh = ["Code", "Description", "Purch-Date", "Cost-Price",
+            "Accum-Dep", "Opening-Bal", "Purchases", "Improvements",
+            "Write-Offs", "Depreciation", "Sales", "Profit/Loss",
+            "Closing-Bal"]
+        self.forms = [("Na", 7), ("NA", 30), ("d1", 10)] + [("SD", 13.2)] * 10
         self.stot = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
         self.gtot = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
         self.oldgrp = ""
@@ -157,6 +158,11 @@
             vals = self.getValues(dat)
             if not vals:
                 continue
+            pdte = self.sql.getRec(tables="asstrn", cols=["min(ast_date)"],
+                where=[("ast_cono", "=", self.opts["conum"]), ("ast_group",
+                "=", dat[0]), ("ast_code", "=", dat[1]), ("ast_mtyp", "=", 1)],
+                limit=1)
+            pdte = CCD(pdte[0], "d1", 10).work
             if self.oldgrp and self.oldgrp != dat[0]:
                 self.groupTotal()
                 self.expdatas.append(["BLANK"])
@@ -164,7 +170,7 @@
                 self.expdatas.append(["HEAD", ["", "Group %s %s" % (dat[0],
                     desc)]])
                 self.expdatas.append(["BLANK"])
-            line = ["BODY", [dat[1], dat[2]]]
+            line = ["BODY", [dat[1], dat[2], pdte]]
             for num, val in enumerate(vals):
                 line[1].append(val)
                 self.stot[num] = float(ASD(self.stot[num]) + ASD(val))
@@ -204,6 +210,11 @@
             grp = CCD(dat[0], "UA", 3)
             code = CCD(dat[1], "Na", 7)
             desc = CCD(dat[2], "NA", 30)
+            pdte = self.sql.getRec(tables="asstrn", cols=["min(ast_date)"],
+                where=[("ast_cono", "=", self.opts["conum"]), ("ast_group",
+                "=", grp.work), ("ast_code", "=", code.work), ("ast_mtyp",
+                "=", 1)], limit=1)
+            pdte = CCD(pdte[0], "d1", 10)
             vals = self.getValues(dat)
             if not vals:
                 continue
@@ -217,11 +228,11 @@
                 ldic["v%s" % num] = CCD(val, "SD", 13.2)
                 self.stot[num] = float(ASD(self.stot[num]) + ASD(val))
                 self.gtot[num] = float(ASD(self.gtot[num]) + ASD(val))
-            self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s %s %s" %
-                (code.disp, desc.disp, ldic["v0"].disp, ldic["v1"].disp,
-                ldic["v2"].disp, ldic["v3"].disp, ldic["v4"].disp,
-                ldic["v5"].disp, ldic["v6"].disp, ldic["v7"].disp,
-                ldic["v8"].disp, ldic["v9"].disp))
+            self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s %s %s %s" %
+                (code.disp, desc.disp, pdte.disp, ldic["v0"].disp,
+                ldic["v1"].disp, ldic["v2"].disp, ldic["v3"].disp,
+                ldic["v4"].disp, ldic["v5"].disp, ldic["v6"].disp,
+                ldic["v7"].disp, ldic["v8"].disp, ldic["v9"].disp))
             self.pglin += 1
             self.oldgrp = grp.work
         p.closeProgress()
@@ -289,11 +300,11 @@
         grpdesc = self.groupDesc(grp.work)
         self.fpdf.drawText("%-5s %3s %-30s" % ("Group", grp.disp, grpdesc))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-7s %-30s %13s %13s %13s %13s %13s %13s %13s "\
-            "%13s %13s %13s" % ("Code", "Description", "Cost-Price ",
-            "Accum-Dep ", "Opening-Bal ", "Purchases ", "Improvements ",
-            "  Write-Offs ", "Depreciation ", "Sales ", " Profit/Loss ",
-            " Closing-Bal "))
+        self.fpdf.drawText("%-7s %-30s %10s %13s %13s %13s %13s %13s %13s "\
+            "%13s %13s %13s %13s" % ("Code", "Description", "Purch-Date",
+            "Cost-Price ", "Accum-Dep ", "Opening-Bal ", "Purchases ",
+            "Improvements ", "  Write-Offs ", "Depreciation ", "Sales ",
+            " Profit/Loss ", " Closing-Bal "))
         self.fpdf.underLine(txt=self.head1)
         self.fpdf.setFont()
         self.pglin = 10
@@ -311,15 +322,15 @@
         if self.df.repprt[2] == "export":
             self.expdatas.append(["ULINES"])
             self.expdatas.append(["TOTAL",
-                ["", "Group %s Totals" % self.oldgrp] + self.stot])
+                ["", "Group %s Totals" % self.oldgrp, ""] + self.stot])
             self.stot = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
             return
         ldic = {}
         for num, val in enumerate(self.stot):
             ldic["v%s" % num] = CCD(val, "SD", 13.2)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-7s %-30s %13s %13s %13s %13s %13s %13s %13s "\
-            "%13s %13s %13s" % ("", "Group %s Totals" % self.oldgrp,
+        self.fpdf.drawText("%-7s %-30s %10s %13s %13s %13s %13s %13s %13s "\
+            "%13s %13s %13s %13s" % ("", "Group %s Totals" % self.oldgrp, "",
             ldic["v0"].disp, ldic["v1"].disp, ldic["v2"].disp, ldic["v3"].disp,
             ldic["v4"].disp, ldic["v5"].disp, ldic["v6"].disp, ldic["v7"].disp,
             ldic["v8"].disp, ldic["v9"].disp))
@@ -329,14 +340,15 @@
     def grandTotal(self):
         if self.df.repprt[2] == "export":
             self.expdatas.append(["ULINES"])
-            self.expdatas.append(["TOTAL", ["", "Grand Totals"] + self.gtot])
+            self.expdatas.append(["TOTAL",
+                ["", "Grand Totals", ""] + self.gtot])
             self.expdatas.append(["ULINED"])
             return
         ldic = {}
         for num, val in enumerate(self.gtot):
             ldic["v%s" % num] = CCD(val, "SD", 13.2)
-        self.fpdf.drawText("%-7s %-30s %13s %13s %13s %13s %13s %13s %13s "\
-            "%13s %13s %13s" % (" ", "Grand Totals", ldic["v0"].disp,
+        self.fpdf.drawText("%-7s %-30s %10s %13s %13s %13s %13s %13s %13s "\
+            "%13s %13s %13s %13s" % (" ", "Grand Totals", "", ldic["v0"].disp,
             ldic["v1"].disp, ldic["v2"].disp, ldic["v3"].disp, ldic["v4"].disp,
             ldic["v5"].disp, ldic["v6"].disp, ldic["v7"].disp, ldic["v8"].disp,
             ldic["v9"].disp))

=== modified file 'ass/arc210.py'
--- ass/arc210.py	2016-02-27 13:18:41 +0000
+++ ass/arc210.py	2016-03-22 14:43:57 +0000
@@ -67,10 +67,7 @@
             fld.append(
             (("C",0,0,1),"IUD",12.2,"Receiver-Rate","Receiver Rate",
                 "","N",self.doRecRte,None,None,("efld",)))
-        but = (
-            ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
-            ("Cancel",None,self.doCancel,0,("T",0,2),("T",0,1)),
-            ("Quit",None,self.doQuit,1,None,None))
+        but = (("Cancel",None,self.doCancel,0,("T",0,2),("T",0,1)),)
         tnd = ((self.doEnd,"n"), )
         txt = (self.doExit, )
         cnd = ((self.doEnd,"n"), )
@@ -160,21 +157,10 @@
             else:
                 self.df.focusField("C", 0, 1)
 
-    def doAccept(self, widget=None):
-        frt, pag, col, mes = self.df.doCheckFields()
-        if mes:
-            self.df.focusField(frt, pag, (col+1), err=mes)
-        else:
-            self.df.doEndFrame("T", 0, cnf="N")
-
     def doCancel(self, widget=None):
         self.opts["mf"].dbm.rollbackDbase()
         self.df.focusField("T", 0, 1)
 
-    def doQuit(self, widget=None):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
     def doExit(self, widget=None):
         if self.df.frt == "T":
             self.df.closeProcess()

=== modified file 'bkm/bk1010.py'
--- bkm/bk1010.py	2016-02-27 13:18:41 +0000
+++ bkm/bk1010.py	2016-04-30 07:30:36 +0000
@@ -179,7 +179,7 @@
             ("Search Bookings", self.doSch),
             ("Deposits List", (self.doRep, "D")),
             ("Arrivals List", (self.doRep, "L")),
-            ("Exit", self.doExit)]
+            ("Quit", self.doQuit)]
         cmds = [
             ("<Double-1>", self.doBkm),
             ("<Button-3>", self.doEnq)]
@@ -217,7 +217,7 @@
                 coy=(self.opts["conum"], self.opts["conam"]),
                 user=self.opts["capnm"], args=True)
 
-    def doExit(self, event=None):
+    def doQuit(self, event=None):
         self.quit = True
         self.opts["mf"].closeLoop()
 

=== modified file 'bkm/bk1020.py'
--- bkm/bk1020.py	2016-02-27 13:18:41 +0000
+++ bkm/bk1020.py	2016-05-05 10:45:01 +0000
@@ -191,20 +191,20 @@
                 "","N",None,None,None,None)]
         if "args" in self.opts:
             fld[1][3] += "(noesc)"
-        on = (("T",1,0),("T",1,2))
+        on = (("T",1,0), ("T",1,2))
         off = ("T",1,1)
         but = (
-            ("Edit",None,self.doEdit,0,on,off,
+            ("Edit",None,self.doEdit,0,("T",1,0),None,
                 "Edit the current booking"),
-            ("Transact",None,self.doTrans,0,on,off,
+            ("Transact",None,self.doTrans,0,("T",1,0),None,
                 "Create transactions for the current booking"),
-            ("Movements",None,self.doMoves,0,on,off,
+            ("Movements",None,self.doMoves,0,("T",1,0),None,
                 "Display all movements for the current booking"),
-            ("Notes",None,self.doNotes,0,on,off,
+            ("Notes",None,self.doNotes,0,("T",1,0),None,
                 "Create/Amend Notes for the current booking"),
             ("Accept",None,self.doAccept,0,on,off,
                 "Save/Print and Exit the current booking"),
-            ("Quit",None,self.doQuit,1,None,off,
+            ("Quit",None,self.doQuit,1,None,("T",1,1),
                 "Quit the current booking creation or amendment"))
         tnd = (None, (self.doEnd,"n"), (self.doEnd,"n"))
         txt = (None, self.doExit, None)
@@ -1109,6 +1109,7 @@
         return changed
 
     def doAccept(self):
+        self.df.setWidget(self.df.B4, "disabled")
         if not self.number and self.df.pag == 1:
             err = "Booking Not Yet Complete"
             self.df.focusField(self.df.frt, self.df.pag, self.df.col, err=err)
@@ -1685,29 +1686,30 @@
                     error = True
                     break
                 ln[tdc.index("tpd_text")] = "Dear %s\n\n%s" % (nam, body[0])
-                if self.state == "Q":
-                    emess = ["Booking Enquiry - %s" % self.number,
-                        "Dear %s\n\nAttached please find your booking "\
-                        "enquiry" % nam]
-                    if self.terms:
-                        emess[1] += " as well as a copy of our Terms "\
-                            "and Conditions."
-                    else:
-                        emess[1] += "."
-                elif self.state == "C":
-                    emess = ("Booking Enquiry - %s" % self.number,
-                        "Dear %s\n\nAttached please find your booking "\
-                        "confirmation." % nam)
-                elif self.state == "S":
-                    emess = ("Booking Settlement - %s" % self.number,
-                        "Dear %s\n\nAttached please find your confirmation "\
-                        "of settlement of your booking." % nam)
-                else:
-                    emess = ("Booking Cancellation - %s" % self.number,
-                        "Dear %s\n\nAttached please find the expiry of your "\
-                        "booking enquiry." % nam)
                 if self.pr.repeml[1] == "Y":
-                        self.pr.repeml[3] = emess
+                    if self.state == "Q":
+                        emess = ["Booking Enquiry - %s" % self.number,
+                            "Dear %s\n\nAttached please find your booking "\
+                            "enquiry" % nam]
+                        if self.terms:
+                            emess[1] += " as well as a copy of our Terms "\
+                                "and Conditions."
+                        else:
+                            emess[1] += "."
+                    elif self.state == "C":
+                        emess = ("Booking Enquiry - %s" % self.number,
+                            "Dear %s\n\nAttached please find your booking "\
+                            "confirmation." % nam)
+                    elif self.state == "S":
+                        emess = ("Booking Settlement - %s" % self.number,
+                            "Dear %s\n\nAttached please find your "\
+                            "confirmation of settlement of your booking." % nam)
+                    else:
+                        emess = ("Booking Cancellation - %s" % self.number,
+                            "Dear %s\n\nAttached please find the expiry of "\
+                            "your booking enquiry." % nam)
+                    if self.pr.repeml[3]:
+                        self.pr.repeml[3][0] = emess[0]
             if ln[tdc.index("tpd_detseq")] == 7:
                 if self.state in ("Q", "C"):
                     ln[tdc.index("tpd_text")] = "%-20s%60s" % \

=== modified file 'bkm/bk3010.py'
--- bkm/bk3010.py	2016-02-27 13:18:41 +0000
+++ bkm/bk3010.py	2016-05-14 18:56:28 +0000
@@ -85,9 +85,8 @@
         else:
             odr = "bkm_stddte, bkm_grpdte, bkm_ccode"
         recs = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
-        self.fpdf = MyFpdf(name=__name__, prog=__name__, head=80)
+        self.fpdf = MyFpdf(name=__name__, head=80, auto=True, foot=True)
         self.fpdf.header = self.pageHeading
-        self.fpdf.alias_nb_pages()
         self.fpdf.add_page()
         newrec = []
         for rec in recs:

=== modified file 'bkm/bk3020.py'
--- bkm/bk3020.py	2016-02-27 13:18:41 +0000
+++ bkm/bk3020.py	2016-04-18 09:19:03 +0000
@@ -152,11 +152,11 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()

=== modified file 'bkm/bk3030.py'
--- bkm/bk3030.py	2016-02-27 13:18:41 +0000
+++ bkm/bk3030.py	2016-05-14 18:56:43 +0000
@@ -191,9 +191,8 @@
             self.hdes = "Arrivals for Weekend %s to %s" % (start, end)
         else:
             self.hdes = "Arrivals for Period %s to %s" % (start, end)
-        self.fpdf = MyFpdf(name=__name__, prog=__name__, head=80)
+        self.fpdf = MyFpdf(name=__name__, head=80, auto=True, foot=True)
         self.fpdf.header = self.pageHeading
-        self.fpdf.alias_nb_pages()
         self.rtyp = "A"
         self.doArrival()
         if self.house == "Y":

=== modified file 'bkm/bk3080.py'
--- bkm/bk3080.py	2016-02-27 13:18:41 +0000
+++ bkm/bk3080.py	2016-05-02 10:49:55 +0000
@@ -98,9 +98,6 @@
             self.copy = "y"
         else:
             self.copy = "n"
-            self.df.topf[pag][6][5] = "V"
-            if len(self.df.topf[pag]) == 8:
-                self.df.topf[pag][8][5] = "N"
 
     def doType(self, frt, pag, r, c, p, i, w):
         self.dtyp = w

=== modified file 'bkm/bk3090.py'
--- bkm/bk3090.py	2016-02-27 13:18:41 +0000
+++ bkm/bk3090.py	2016-05-10 11:54:14 +0000
@@ -95,11 +95,13 @@
             num += 1
             lookup[mth] = num
         for r in rec:
-            if self.reptyp == "D":
+            if self.reptyp == "B":
                 if r[2] / 100 == r[3] / 100:
                     days = dateDiff(r[2], r[3], "days")
                     mth = (r[2] / 100) % 100
                     self.desc[r[0]][lookup[mth]] += (days * r[1])
+                    if r[0] == "X":
+                        continue
                     self.desc["T"][lookup[mth]] += (days * r[1])
                 else:
                     mnd = mthendDate(r[2])
@@ -110,15 +112,19 @@
                     mth = (r[3] / 100) % 100
                     days = dateDiff((((r[3]/100)*100)+1), r[3], "days")
                     self.desc[r[0]][lookup[mth]] += (days * r[1])
+                    if r[0] == "X":
+                        continue
                     self.desc["T"][lookup[mth]] += (days * r[1])
             else:
                 mth = (r[2] / 100) % 100
                 self.desc[r[0]][lookup[mth]] += r[1]
+                if r[0] == "X":
+                    continue
                 self.desc["T"][lookup[mth]] += r[1]
         achart = []
-        bchart = []
+        mchart = []
         for s in self.desc:
-            bchart.append([s] + self.desc[s])
+            mchart.append([s] + self.desc[s])
             if s in ("T", "X"):
                 continue
             achart.append([s] + self.desc[s])
@@ -128,7 +134,7 @@
             typ = "Value"
         CreateChart(self.opts["mf"], self.opts["conum"], self.opts["conam"],
             [self.sdate/100, self.edate/100], [[self.opts["conam"],
-            "Status Summary"], typ], achart, bchart)
+            "Status Summary"], typ], achart, mchart)
         self.opts["mf"].closeLoop()
 
     def doExit(self):

=== modified file 'bwl/bc1040.py'
--- bwl/bc1040.py	2016-02-27 13:18:41 +0000
+++ bwl/bc1040.py	2016-05-16 09:51:00 +0000
@@ -40,7 +40,11 @@
                 ("bct_code", "", 0, "Cod"),
                 ("bct_desc", "", 0, "Description", "Y")),
             "where": [("bct_cono", "=", self.opts["conum"])]}
-        r1s = (("Tournament", "T"), ("Knockout", "K"), ("Round Robin", "R"))
+        r1s = (
+            ("Tournament", "T"),
+            ("Knockout", "K"),
+            ("Round Robin", "R"),
+            ("Match", "X"))
         r2s = (("Yes", "Y"), ("No", "N"))
         fld = (
             (("T",0,0,0),"I@bct_code",0,"","",
@@ -75,7 +79,7 @@
                 "N","N",self.doSvS,None,None,None,None,
                 "Yes means that teams could play against each other, again, "\
                 "in ANY game. No means that teams could only play against "\
-                "each other, again, in the Final game."),
+                "each other, again, in the FINAL game."),
             (("T",0,13,0),("IRB",r2s),0,"Different Drawn Games Scoring","",
                 "N","N",self.doDiff,None,None,None,None,
                 "Yes means that Drawn Games have a Different Scoring Format "\
@@ -150,8 +154,11 @@
 
     def doEnds(self, frt, pag, r, c, p, i, w):
         self.ends = w
-        if self.cfmat in ("K", "R"):
-            defaults = ["N",0,"N","",0,0,"N","N"]
+        if self.cfmat in ("K", "R", "X"):
+            if self.cfmat in ("K", "R"):
+                defaults = ["N", 0, "N", "", 0, 0, "N", "N"]
+            else:
+                defaults = ["N", 0, "N", "", 0, self.games, "N", "N"]
             for num, dat in enumerate(defaults):
                 self.df.loadEntry("T", 0, p+num+1, data=dat)
             self.pdiff = "N"

=== modified file 'bwl/bc2020.py'
--- bwl/bc2020.py	2016-02-27 13:18:41 +0000
+++ bwl/bc2020.py	2016-05-14 19:41:14 +0000
@@ -542,7 +542,7 @@
         self.pr.closeProcess()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             "select_%s" % self.date, ext="pdf")
-        fpdf = MyFpdf(name=__name__, head=90)
+        fpdf = MyFpdf(name=__name__, head=90, foot=True)
         cw = fpdf.get_string_width("X")           # character width
         ld = 4.5                                  # line depth
         fm = {

=== modified file 'bwl/bc2040.py'
--- bwl/bc2040.py	2016-02-27 13:18:41 +0000
+++ bwl/bc2040.py	2016-05-14 19:41:14 +0000
@@ -13,7 +13,7 @@
     Copyright (C) 2004-2016 Paul Malherbe.
 """
 
-from TartanClasses import GetCtl, RepPrt, Sql, TartanDialog
+from TartanClasses import GetCtl, Sql, TartanDialog
 from tartanFunctions import askQuestion, getNextCode
 
 class bc2040:
@@ -70,13 +70,13 @@
                 ("btb_tab", "", 0, "Cod"),
                 ("btb_surname", "", 0, "Surame", "Y"),
                 ("btb_names", "", 0, "Names"),
+                ("bce_tcod", "", 0, "T"),
                 ("bce_paid", "", 0, "P")),
             "where": [
                 ("btb_cono", "=", self.opts["conum"]),
                 ("btb_tab=bce_scod",)],
             "whera": [("T", "bce_ccod", 0, 0)],
-            "order": "btb_surname",
-            "butt": [("Print", self.doPrint)]}
+            "order": "btb_surname"}
         fld = (
             (("T",0,0,0),"I@bcm_code",0,"Code","Competition Code",
                 "","Y",self.doCmpCod,com,None,("efld",)),
@@ -90,10 +90,8 @@
                 "","Y",self.doSkpCod,sk1,None,("efld",)),
             (("C",0,0,1),"ONA",30,"Name","",
                 "","N",None,None,None,("notblank",)),
-            (("C",0,0,2),"I@btb_tab",0,"Lead","",
-                "","n",self.doSkpCod,sk1,self.doDelSkp,("efld",)),
-            (("C",0,0,3),"ONA",30,"Name","",
-                "","N",None,None,None,("notblank",)),
+            (("C",0,0,2),"I@bce_tcod",0,"T","",
+                "H","n",self.doTeam,None,None,("in", ("H","V"))),
             (("C",0,0,4),"I@bce_paid",0,"","",
                 "N","N",self.doPaid,None,self.doDelSkp,("in", ("Y","N"))))
         but = (("Entered Players",sk2,None,0,("C",0,1),("T",0,1)),)
@@ -105,8 +103,8 @@
             eflds=fld, butt=but, tend=tnd, txit=txt, cend=cnd, cxit=cxt)
 
     def doCmpCod(self, frt, pag, r, c, p, i, w):
+        self.erase = False
         self.skips = []
-        self.parts = []
         if not w:
             self.ccod = getNextCode(self.sql, "bwlcmp", "bcm_code",
                 where=[("bcm_cono", "=", self.opts["conum"])], last=999)
@@ -126,19 +124,21 @@
                 where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
                 self.ccod), ("bcg_ocod", "<>", 0)], limit=1)
             if gme[0]:
-                return "This Competition Has Already Been Drawn"
+                ok = askQuestion(self.opts["mf"].body, "Error",
+                    """This Competition Has Already Been Drawn.
+
+Do You Want to Erase All Draws and Results?""", default="no")
+                if ok == "no":
+                    return "Invalid Competition"
+                self.erase = True
             self.newcmp = False
-            self.typ = self.sql.getRec(tables="bwltyp", where=[("bct_cono",
-                "=", self.opts["conum"]), ("bct_code", "=", chk[3])], limit=1)
             for num, fld in enumerate(chk[1:]):
                 self.df.loadEntry(frt, pag, p+num, data=fld)
-            ent = self.sql.getRec(tables="bwlent", cols=["bce_scod",
-                "bce_pcod"], where=[("bce_cono", "=", self.opts["conum"]),
+            ent = self.sql.getRec(tables="bwlent", cols=["bce_scod"],
+                where=[("bce_cono", "=", self.opts["conum"]),
                 ("bce_ccod", "=", self.ccod)])
             for e in ent:
                 self.skips.append(e[0])
-                if e[1]:
-                    self.parts.append(e[1])
 
     def doDelCmp(self, widget=None):
         if self.newcmp or self.skips:
@@ -156,6 +156,8 @@
             self.opts["conum"]), ("bct_code", "=", w)], limit=1)
         if not self.typ:
             return "Invalid Competition Type"
+        self.cfmat = self.typ[self.sql.bwltyp_col.index("bct_cfmat")]
+        self.tsize = self.typ[self.sql.bwltyp_col.index("bct_tsize")]
 
     def doSkpCod(self, frt, pag, r, c, p, i, w):
         if not w:
@@ -169,44 +171,31 @@
             self.df.loadEntry(frt, pag, p, data=cod)
         else:
             cod = w
-        if i == 0:
-            if cod in self.parts:
-                return "Invalid Skip, Already a Partner"
+        if not cod in self.skips:
             self.skips.append(cod)
-            self.scod = cod
-        else:
-            if cod in self.skips:
-                return "Invalid Partner, Already a Skip"
-            self.parts.append(cod)
-            self.pcod = cod
+        self.scod = cod
         chk = self.sql.getRec(tables="bwltab", cols=["btb_surname",
             "btb_names"], where=[("btb_cono", "=", self.opts["conum"]),
             ("btb_tab", "=", self.scod)], limit=1)
         if not chk:
             return "Invalid Player Code"
         self.df.loadEntry(frt, pag, p+1, data=self.getName(chk))
-        if i == 0:
-            ent = self.sql.getRec(tables="bwlent", cols=["bce_pcod",
-                "bce_paid"], where=[("bce_cono", "=", self.opts["conum"]),
-                ("bce_ccod", "=", self.ccod), ("bce_scod", "=", self.scod)],
-                limit=1)
-            if ent:
-                self.newent = False
-                if ent[0]:
-                    ptr = self.sql.getRec(tables="bwltab", cols=["btb_surname",
-                        "btb_names"], where=[("btb_cono", "=",
-                        self.opts["conum"]), ("btb_tab", "=", ent[0])],
-                        limit=1)
-                    self.df.loadEntry(frt, pag, p+2, data=ent[0])
-                    self.df.loadEntry(frt, pag, p+3, data=self.getName(ptr))
-                self.df.loadEntry(frt, pag, p+4, data=ent[1])
-            else:
-                self.newent = True
-            self.cfmat = self.typ[self.sql.bwltyp_col.index("bct_cfmat")]
-            self.tsize = self.typ[self.sql.bwltyp_col.index("bct_tsize")]
-            if not self.tsize == 2:
-                self.pcod = 0
-                return "sk3"
+        ent = self.sql.getRec(tables="bwlent", cols=["bce_tcod",
+            "bce_paid"], where=[("bce_cono", "=", self.opts["conum"]),
+            ("bce_ccod", "=", self.ccod), ("bce_scod", "=", self.scod)],
+            limit=1)
+        if ent:
+            self.newent = False
+            self.df.loadEntry(frt, pag, p+2, data=ent[0])
+            self.df.loadEntry(frt, pag, p+3, data=ent[1])
+        else:
+            self.newent = True
+        if not self.cfmat == "X":
+            self.tcod = ""
+            return "sk2"
+
+    def doTeam(self, frt, pag, r, c, p, i, w):
+        self.tcod = w
 
     def doNewCode(self):
         tit = ("New Player",)
@@ -284,6 +273,18 @@
             if self.newcmp:
                 self.sql.insRec("bwlcmp", data=data)
             else:
+                if self.erase:
+                    self.sql.delRec("bwlgme", where=[("bcg_cono", "=",
+                        self.opts["conum"]), ("bcg_ccod", "=", self.ccod)])
+                    if self.cfmat in ("T", "X"):
+                        recs = self.sql.getRec(tables="bwlent",
+                            cols=["bce_scod"], where=[("bce_cono",
+                            "=", self.opts["conum"]), ("bce_ccod",
+                            "=", self.ccod)], order="bce_scod")
+                        skips = []
+                        for rec in recs:
+                            skips.append(rec[0])
+                        self.doPopulate(skips)
                 self.sql.updRec("bwlcmp", data=data, where=[("bcm_cono", "=",
                     self.opts["conum"]), ("bcm_code", "=", self.ccod)])
             self.loadButton()
@@ -291,46 +292,39 @@
         else:
             if self.newent:
                 self.sql.insRec("bwlent", data=[self.opts["conum"], self.ccod,
-                    self.scod, self.pcod, self.paid])
-                if self.cfmat == "T":
-                    # Populate bwlgme records
-                    num = self.typ[self.sql.bwltyp_col.index("bct_games")]
-                    dgm = self.typ[self.sql.bwltyp_col.index("bct_drawn")]
-                    data = [self.opts["conum"], self.ccod, self.scod, 0, "", 0,
-                        0, "", 0, 0, 0, 0, 0, 0, 0, "", 0, 0]
-                    for x in xrange(0, dgm):
-                        data[3] = x + 1
-                        data[4] = "D"
-                        self.sql.insRec("bwlgme", data=data)
-                    for x in xrange(dgm, num):
-                        data[3] = x + 1
-                        data[4] = "S"
-                        self.sql.insRec("bwlgme", data=data)
+                    self.scod, self.tcod, self.paid])
+                if self.cfmat in ("T", "X"):
+                    self.doPopulate([self.scod])
             else:
-                self.sql.updRec("bwlent", cols=["bce_paid"], data=[self.paid],
-                    where=[("bce_cono", "=", self.opts["conum"]), ("bce_ccod",
-                    "=", self.ccod), ("bce_scod", "=", self.scod)])
+                self.sql.updRec("bwlent", cols=["bce_tcod", "bce_paid"],
+                    data=[self.tcod, self.paid], where=[("bce_cono", "=",
+                    self.opts["conum"]), ("bce_ccod", "=", self.ccod),
+                    ("bce_scod", "=", self.scod)])
             self.loadButton()
             self.df.advanceLine(0)
 
+    def doPopulate(self, scods):
+        # Populate bwlgme records
+        num = self.typ[self.sql.bwltyp_col.index("bct_games")]
+        dgm = self.typ[self.sql.bwltyp_col.index("bct_drawn")]
+        for scod in scods:
+            data = [self.opts["conum"], self.ccod, scod, 0, "",
+                0, 0, "", 0, 0, 0, 0, 0, 0, 0, "", 0, 0]
+            for x in xrange(0, dgm):
+                data[3] = x + 1
+                data[4] = "D"
+                self.sql.insRec("bwlgme", data=data)
+            for x in xrange(dgm, num):
+                data[3] = x + 1
+                data[4] = "S"
+                self.sql.insRec("bwlgme", data=data)
+
     def loadButton(self):
         rec = self.sql.getRec(tables="bwlent", cols=["count(*)"],
             where=[("bce_cono", "=", self.opts["conum"]), ("bce_ccod", "=",
             self.ccod)], limit=1)
         self.df.B0.setLabel("Entered Players (%s)" % int(rec[0]), underline=0)
 
-    def doPrint(self, widget=None):
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        hdr = ["Skips Entered for the %s" % self.cmpnam]
-        tab = ["bwlent", "bwltab"]
-        col = ["btb_tab", "btb_surname", "btb_names", "btb_cell",
-            ["btb_mail", "TX", 30, "Email-Address"], "bce_paid"]
-        whr = [("bce_ccod", "=", self.ccod), ("btb_tab=bce_scod",)]
-        odr = "btb_surname"
-        RepPrt(self.opts["mf"], name=__name__, heads=hdr, tables=tab, cols=col,
-            where=whr, order=odr, prtdia=(("Y","V"),("Y","N")))
-        self.df.setWidget(self.df.mstFrame, state="show")
-
     def doExit(self):
         if self.df.frt == "C":
             self.opts["mf"].dbm.commitDbase()

=== modified file 'bwl/bc2050.py'
--- bwl/bc2050.py	2016-02-27 13:18:41 +0000
+++ bwl/bc2050.py	2016-05-16 09:52:46 +0000
@@ -110,7 +110,7 @@
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            eflds=fld, tend=tnd, txit=txt, view=("Y","V"), mail=("Y","Y"))
+            eflds=fld, tend=tnd, txit=txt, view=("N","V"), mail=("Y","Y"))
         self.df.setWidget(self.df.topEntry[0][11][2][0], state="hide")
 
     def doCmpCod(self, frt, pag, r, c, p, i, w):
@@ -127,6 +127,7 @@
             self.opts["conum"]), ("bct_code", "=", self.ctyp)], limit=1)
         self.cfmat = bwltyp[self.sql.bwltyp_col.index("bct_cfmat")]
         self.tsize = bwltyp[self.sql.bwltyp_col.index("bct_tsize")]
+        self.drawn = bwltyp[self.sql.bwltyp_col.index("bct_drawn")]
         teams = self.sql.getRec(tables="bwlent", cols=["bce_scod"],
             where=[("bce_cono", "=", self.opts["conum"]), ("bce_ccod", "=",
             self.ccod)])
@@ -246,15 +247,13 @@
             self.date = chk[2]
             self.datd = CCD(self.date, "D1", 10).disp
             self.df.loadEntry(frt, pag, p+1, data=self.date)
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             return "sk5"
-        if w == 1 and (self.cfmat == "R" or \
-                (self.cfmat == "T" and self.gtyp == "D")):
+        if w == 1 and self.drawn > 1 and (self.cfmat == "R" or \
+                (self.cfmat in ("T", "X") and self.gtyp == "D")):
             ok = askQuestion(self.opts["mf"].body, "Drawn Games",
                 "Do You Want to Print All Drawn Games?", default="no")
             if ok == "yes":
                 self.drawall = True
-        self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
 
     def doGamDte(self, frt, pag, r, c, p, i, w):
         if w < self.today or w < self.sdat:
@@ -397,6 +396,46 @@
             return True
         if self.gtyp == "D":
             # Drawn Games
+            if self.cfmat == "X":
+                # Match
+                teams = {"H": {}, "V": {}}
+                ents = self.sql.getRec(tables="bwlent", where=[("bce_cono",
+                    "=", self.opts["conum"]), ("bce_ccod", "=", self.ccod)])
+                for skp in ents:
+                    scod = skp[self.sql.bwlent_col.index("bce_scod")]
+                    tcod = skp[self.sql.bwlent_col.index("bce_tcod")]
+                    teams[tcod][scod] = []
+                    opps = self.sql.getRec(tables="bwlgme", cols=["bcg_ocod"],
+                        where=[("bcg_cono", "=", self.opts["conum"]),
+                        ("bcg_ccod", "=", self.ccod), ("bcg_scod", "=", scod),
+                        ("bcg_ocod", "<>", 0)])
+                    for opp in opps:
+                        teams[tcod][scod].append(opp[0])
+                chk = (len(teams["H"]), len(teams["V"]))
+                if not chk[0] == chk[1]:
+                    showError(self.opts["mf"].body, "Mismatch",
+                        """There is an Uneven Number of Skips per Team:
+
+                Home:      %3s
+                Visitors:  %3s\n""" % chk)
+                    return
+                chk = True
+                while chk:
+                    pair = []
+                    home = teams["H"].keys()
+                    away = teams["V"].keys()
+                    random.shuffle(home)
+                    random.shuffle(away)
+                    for skp in home:
+                        for opp in away:
+                            if not opp in teams["H"][skp] and not opp in pair:
+                                pair.extend([skp, opp])
+                                break
+                    if len(pair) == len(ents):
+                        chk = False
+                self.skips = pair
+                return True
+            # Other
             chk = self.sql.getRec(tables="bwlgme", cols=["bcg_scod"],
                 where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
                 self.ccod), ("bcg_game", "=", self.game)], order="bcg_scod")
@@ -713,7 +752,7 @@
             head = (self.rnds * 19) + 19
             if head > 120:
                 head = 170
-            self.fpdf = MyFpdf(name=__name__, head=head)
+            self.fpdf = MyFpdf(name=__name__, head=head, foot=True)
             self.pageHeading(date=True)
         if not self.reprint:
             self.doSeeds()
@@ -1315,7 +1354,7 @@
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "=", self.game),
             ("btb_tab=bcg_scod",)]
-        self.fpdf = MyFpdf(name=__name__, head=65)
+        self.fpdf = MyFpdf(name=__name__, head=65, foot=True)
         self.pglin = 999
         lastg = None
         for g in grp:

=== modified file 'bwl/bc2070.py'
--- bwl/bc2070.py	2016-02-27 13:18:41 +0000
+++ bwl/bc2070.py	2016-05-14 19:41:14 +0000
@@ -261,7 +261,6 @@
         self.df.loadEntry(frt, pag, p + 7, data=chk[4])
         if self.ponly == "Y":
             self.mpts = self.totpts
-            self.s_for = self.s_agt = 0
             return "sk2"
 
     def doShots(self, frt, pag, r, c, p, i, w):
@@ -303,6 +302,7 @@
                 name = chk[0]
             self.df.loadEntry(frt, pag, p + 2, data=name)
             if self.ponly == "Y":
+                self.s_for = w
                 return "sk3"
             else:
                 return "sk2"
@@ -311,6 +311,8 @@
             self.df.loadEntry(frt, pag, p, data=self.p_agt)
         else:
             self.p_agt = w
+        if self.ponly == "Y":
+            self.s_agt = self.p_agt
         tot = float(ASD(self.p_for) + ASD(self.p_agt))
         if tot != self.mpts:
             return "Invalid Total Points (%s s/b %s)" % (tot, self.mpts)

=== modified file 'bwl/bc3020.py'
--- bwl/bc3020.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3020.py	2016-05-15 09:44:47 +0000
@@ -132,9 +132,8 @@
                 side[2][0], side[2][1], side[3][0], side[3][1]])
             dat.append(d)
             l = self.tab
-        self.fpdf = MyFpdf(prog=__name__)
-        self.fpdf.header = self.header
-        self.fpdf.alias_nb_pages()
+        self.fpdf = MyFpdf(auto=True, foot=True)
+        self.fpdf.header = self.pageHeading
         self.fpdf.add_page()
         self.fpdf.set_font("Courier","",9)
         cwth = self.fpdf.get_string_width("X")
@@ -226,7 +225,7 @@
             self.dic[self.tab].append(tab)
         return nam
 
-    def header(self):
+    def pageHeading(self):
         self.fpdf.set_font("Arial","B",15)
         if os.path.isfile(self.image):
             self.fpdf.image(self.image, 10, 10, 15, 11)

=== modified file 'bwl/bc3040.py'
--- bwl/bc3040.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3040.py	2016-05-14 19:41:14 +0000
@@ -89,7 +89,7 @@
         self.df.closeProcess()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             "declare_%s" % self.date, ext="pdf")
-        fpdf = MyFpdf(name=__name__, head=90)
+        fpdf = MyFpdf(name=__name__, head=90, foot=True)
         cw = fpdf.get_string_width("X")             # character width
         ld = 4.3                                    # line depth
         r1 = {

=== modified file 'bwl/bc3070.py'
--- bwl/bc3070.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3070.py	2016-05-15 09:47:25 +0000
@@ -64,7 +64,8 @@
 
     def doEnd(self):
         self.df.closeProcess()
-        col = ["btb_tab", "btb_surname", "btb_names", "btb_cell", "btb_mail"]
+        col = ["btb_tab", "btb_surname", "btb_names", "btb_cell",
+            "btb_mail", "bce_tcod"]
         whr = [
             ("bce_cono", "=", self.opts["conum"]),
             ("bce_ccod", "=", self.ccod),
@@ -73,9 +74,8 @@
         recs = self.sql.getRec(tables=["bwlent", "bwltab"], cols=col,
             where=whr, order="btb_surname")
         if recs:
-            self.fpdf = MyFpdf(prog=__name__)
-            self.fpdf.header = self.header
-            self.fpdf.alias_nb_pages()
+            self.fpdf = MyFpdf(auto=True, foot=True)
+            self.fpdf.header = self.doHead
             self.fpdf.add_page()
             self.fpdf.set_font("Courier","",9)
             cwth = self.fpdf.get_string_width("X")
@@ -87,7 +87,8 @@
                     nm += ", %s" % rec[2].split()[0].upper()
                 self.fpdf.drawText(txt=nm, w=cwth*31, h=5, ln=0)
                 self.fpdf.drawText(txt=rec[3], w=cwth*16, h=5, ln=0)
-                self.fpdf.drawText(txt=rec[4], w=cwth*41, h=5, ln=1)
+                self.fpdf.drawText(txt=rec[4], w=cwth*41, h=5, ln=0)
+                self.fpdf.drawText(txt=rec[5], w=cwth*2, h=5, ln=1)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
@@ -97,7 +98,7 @@
                 repeml=self.df.repeml)
         self.opts["mf"].closeLoop()
 
-    def header(self):
+    def doHead(self):
         if os.path.isfile(self.image):
             self.fpdf.image(self.image, 10, 10, 15, 11)
         self.fpdf.set_font("Arial","B",15)
@@ -105,8 +106,8 @@
         self.fpdf.cell(0,10,"Players Entered in the %s" % self.cnam,1,0,"C")
         self.fpdf.ln(20)
         self.fpdf.set_font("Courier","B",9)
-        self.fpdf.cell(0, 5, "%-6s %-30s %-15s %-40s" % \
-            ("Number", "Name", "Mobile", "Email"), "B")
+        self.fpdf.cell(0, 5, "%-6s %-30s %-15s %-40s %1s" % \
+            ("Number", "Name", "Mobile", "Email", "T"), "B")
         self.fpdf.ln(5)
 
     def doExit(self):

=== modified file 'bwl/bc3080.py'
--- bwl/bc3080.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3080.py	2016-05-16 09:53:19 +0000
@@ -123,17 +123,16 @@
             for col in self.sql.bwlpts_col[3:]:
                 ldic[ptyp][col] = r[self.sql.bwlpts_col.index(col)]
         if self.card:
-            self.fpdf = MyFpdf()
+            self.fpdf = MyFpdf(auto=True)
             self.fpdf.set_margins(55, 5, 55)
             self.fpdf.c_margin = self.fpdf.c_margin * 2
             self.fpdf.set_font("Arial","",8)
             h = 3.5
         else:
-            self.fpdf = MyFpdf(prog=__name__)
+            self.fpdf = MyFpdf(auto=True, foot=True)
             self.fpdf.set_font("Arial","",14)
             h = 6
-        self.fpdf.header = self.header
-        self.fpdf.alias_nb_pages()
+        self.fpdf.header = self.pageHeading
         cwth = self.fpdf.get_string_width("X")
         x1 = self.fpdf.l_margin + (cwth * 20)
         x2 = self.fpdf.l_margin + (cwth * 22)
@@ -145,8 +144,10 @@
                 txt = "Tournament"
             elif ldic["bct_cfmat"] == "K":
                 txt = "Knockout"
-            else:
+            elif ldic["bct_cfmat"] == "R":
                 txt = "Round Robin"
+            else:
+                txt = "Match"
             self.fpdf.drawText(txt=txt, x=x1, h=h, ctyp="M")
             self.fpdf.drawText(txt=self.sql.bwltyp_dic["bct_tsize"][4],
                 h=h, ln=0)
@@ -254,7 +255,7 @@
                 txt = "Therefore a Maximum of %s Points per Game." % pts
                 self.fpdf.drawText(txt=txt, x=x1, h=h, ctyp="M")
 
-    def header(self):
+    def pageHeading(self):
         if self.card:
             self.fpdf.set_fill_color(220)
             self.fpdf.set_font("Arial","B",12)

=== modified file 'bwl/bc3090.py'
--- bwl/bc3090.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3090.py	2016-05-14 19:41:14 +0000
@@ -127,7 +127,6 @@
                 self.opts["conum"]), ("bcg_ccod", "=", self.ccod), ("bcg_scod",
                 "=", skip[0])], order="bcg_group, bcg_game")
             for game in games:
-                gam = game[self.sql.bwlgme_col.index("bcg_game")]
                 grp = game[self.sql.bwlgme_col.index("bcg_group")]
                 opp = game[self.sql.bwlgme_col.index("bcg_ocod")]
                 if opp > 900000:
@@ -137,7 +136,7 @@
                     rnk = game[self.sql.bwlgme_col.index("bcg_rink")]
                 dat.extend([opp, rnk])
                 if opp:
-                    if gam != self.games and opp in ops:
+                    if opp in ops:
                         dup[0] = "X"
                     else:
                         dup[0] = "-"
@@ -151,7 +150,7 @@
             dat.insert(2, groups[grp])
             dat.append("%1s%1s" % tuple(dup))
             data.append(dat)
-        head = [(self.cdes, 24), "Bowls Draw Summary Sheet"]
+        head = [(self.cdes, 24), ("Bowls Draw Summary Sheet", 14)]
         cols = [
             ["a", "UI",  6, "Skp",  "y"],
             ["b", "NA", 29, "Name", "y"],

=== modified file 'bwl/bc3100.py'
--- bwl/bc3100.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3100.py	2016-05-14 19:41:14 +0000
@@ -13,7 +13,7 @@
     Copyright (C) 2004-2016 Paul Malherbe.
 """
 
-from TartanClasses import CCD, MyFpdf, TartanDialog, Sql
+from TartanClasses import ASD, CCD, MyFpdf, TartanDialog, Sql
 from tartanFunctions import doPrinter, copyList, getModName
 
 class bc3100:
@@ -69,6 +69,7 @@
         self.ctyp = chk[self.sql.bwlcmp_col.index("bcm_type")]
         chk = self.sql.getRec(tables="bwltyp", where=[("bct_cono", "=",
             self.opts["conum"]), ("bct_code", "=", self.ctyp)], limit=1)
+        self.cfmat = chk[self.sql.bwltyp_col.index("bct_cfmat")]
         self.grgame = chk[self.sql.bwltyp_col.index("bct_grgame")]
         game = self.sql.getRec(tables="bwlgme", cols=["bcg_game", "bcg_aflag",
             "sum(bcg_points)"], where=[("bcg_cono", "=", self.opts["conum"]),
@@ -160,13 +161,13 @@
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "=", self.game),
             ("btb_tab=bcg_scod",)]
-        self.fpdf = MyFpdf(name=__name__, head=65, prog=__name__)
+        self.fpdf = MyFpdf(name=__name__, head=65, foot=True)
         self.pglin = 999
         lastg = None
         for g in keys:
             whr = copyList(where)
             whr.append(("bcg_scod", "in", grps[g]))
-            col = ["btb_surname", "btb_names"]
+            col = ["bcg_scod", "btb_surname", "btb_names"]
             col.extend(["sum(bcg_shots_for) as sfor",
                 "sum(bcg_shots_agt) as sagt",
                 "sum(bcg_shots_for - bcg_shots_agt) as agg",
@@ -176,7 +177,9 @@
                 order="pts desc, agg desc, sagt asc")
             if not recs:
                 continue
-            for num, (snam, fnam, sfor, sagt, agg, pts) in enumerate(recs):
+            if self.cfmat == "X":
+                tms = {"H": [0, 0, 0, 0], "V": [0, 0, 0, 0]}
+            for num, (scod,snam,fnam,sfor,sagt,agg,pts) in enumerate(recs):
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading()
                 if not g == lastg:
@@ -195,7 +198,53 @@
                 e = CCD(agg, "SD", 7.1)
                 f = CCD(pts, "SD", 7.1)
                 self.printLine(a.disp, b.disp, c.disp, d.disp, e.disp, f.disp)
+                if self.cfmat == "X":
+                    tm = self.sql.getRec(tables="bwlent", cols=["bce_tcod"],
+                        where=[("bce_cono", "=", self.opts["conum"]),
+                        ("bce_ccod", "=", self.ccod), ("bce_scod", "=", scod)],
+                        limit=1)
+                    tms[tm[0]][0] = float(ASD(tms[tm[0]][0]) + ASD(c.work))
+                    tms[tm[0]][1] = float(ASD(tms[tm[0]][1]) + ASD(d.work))
+                    tms[tm[0]][2] = float(ASD(tms[tm[0]][2]) + ASD(e.work))
+                    tms[tm[0]][3] = float(ASD(tms[tm[0]][3]) + ASD(f.work))
                 self.pglin += 1
+        if self.cfmat == "X":
+            cwth = self.fpdf.cwth
+            self.fpdf.drawText()
+            self.fpdf.drawText("Game Summary", font=["courier", "B", 18])
+            self.fpdf.setFont(style="B")
+            self.fpdf.drawText()
+            self.fpdf.drawText("Home", w=cwth * 32, h=8, border="TLRB",
+                align="C", fill=1, ln=0)
+            self.fpdf.drawText("Visitors", w=cwth * 32, h=8, border="TLRB",
+                align="C", fill=1, ln=1)
+            x = self.fpdf.get_x()
+            y = self.fpdf.get_y()
+            for tm in ("H", "V"):
+                self.fpdf.drawText(" +For", x=x, y=y, w=cwth * 8, h=8,
+                    font="B", border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][0], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    font=[""], border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText(" -Agt", x=x, y=y, w=cwth * 8, h=8,
+                    font="B", border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][1], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    font=[""], border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText(" =Dif", x=x, y=y, w=cwth * 8, h=8,
+                    font="B", border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][2], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    font=[""], border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText("  Pts", x=x, y=y, w=cwth * 8, h=8,
+                    font="B", border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][3], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    font=[""], border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             "report", ext="pdf")
         self.fpdf.output(pdfnam, "F")

=== modified file 'bwl/bc3110.py'
--- bwl/bc3110.py	2016-02-27 13:18:41 +0000
+++ bwl/bc3110.py	2016-05-14 19:41:14 +0000
@@ -14,7 +14,7 @@
 """
 
 import os
-from TartanClasses import CCD, MyFpdf, TartanDialog, Sql
+from TartanClasses import ASD, CCD, MyFpdf, TartanDialog, Sql
 from tartanFunctions import askQuestion, copyList, doPrinter, getModName
 
 class bc3110:
@@ -191,20 +191,22 @@
             ("bcg_ccod", "=", self.ccod),
             ("bcg_game", "<=", self.lgame),
             ("btb_tab=bcg_scod",)]
-        self.fpdf = MyFpdf(name=__name__, head=65, prog=__name__)
+        self.fpdf = MyFpdf(name=__name__, head=65, foot=True)
         self.pglin = 999
         lastg = None
         for g in self.keys:
             whr = copyList(where)
             whr.append(("bcg_scod", "in", self.grps[g][0]))
-            col = ["btb_surname", "btb_names"]
+            col = ["bcg_scod", "btb_surname", "btb_names"]
             if self.lgame <= self.grgame:
-                col.extend(["sum(bcg_shots_for) as sfor",
+                col.extend([
+                    "sum(bcg_shots_for) as sfor",
                     "sum(bcg_shots_agt) as sagt",
                     "sum(bcg_shots_for - bcg_shots_agt) as agg",
                     "sum(bcg_points) as pts"])
             else:
-                col.extend(["sum(bcg_a_shots_for) as sfor",
+                col.extend([
+                    "sum(bcg_a_shots_for) as sfor",
                     "sum(bcg_a_shots_agt) as sagt",
                     "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
                     "sum(bcg_a_points) as pts"])
@@ -213,7 +215,9 @@
                 order="pts desc, agg desc, sagt asc")
             if not recs:
                 continue
-            for num, (snam, fnam, sfor, sagt, agg, pts) in enumerate(recs):
+            if self.cfmat == "X":
+                tms = {"H": [0, 0, 0, 0], "V": [0, 0, 0, 0]}
+            for num, (scod,snam,fnam,sfor,sagt,agg,pts) in enumerate(recs):
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading()
                 if not g == lastg:
@@ -232,7 +236,53 @@
                 e = CCD(agg, "SD", 7.1)
                 f = CCD(pts, "SD", 7.1)
                 self.printLine(a.disp, b.disp, c.disp, d.disp, e.disp, f.disp)
+                if self.cfmat == "X":
+                    tm = self.sql.getRec(tables="bwlent", cols=["bce_tcod"],
+                        where=[("bce_cono", "=", self.opts["conum"]),
+                        ("bce_ccod", "=", self.ccod), ("bce_scod", "=", scod)],
+                        limit=1)
+                    tms[tm[0]][0] = float(ASD(tms[tm[0]][0]) + ASD(c.work))
+                    tms[tm[0]][1] = float(ASD(tms[tm[0]][1]) + ASD(d.work))
+                    tms[tm[0]][2] = float(ASD(tms[tm[0]][2]) + ASD(e.work))
+                    tms[tm[0]][3] = float(ASD(tms[tm[0]][3]) + ASD(f.work))
                 self.pglin += 1
+        if self.cfmat == "X":
+            cwth = self.fpdf.cwth
+            self.fpdf.drawText()
+            self.fpdf.drawText("Match Summary", font=["courier", "B", 18])
+            self.fpdf.setFont(style="B")
+            self.fpdf.drawText()
+            self.fpdf.drawText("Home", w=cwth * 32, border="TLRB",
+                align="C", fill=1, ln=0)
+            self.fpdf.drawText("Visitors", w=cwth * 32, border="TLRB",
+                align="C", fill=1, ln=1)
+            x = self.fpdf.get_x()
+            y = self.fpdf.get_y()
+            for tm in ("H", "V"):
+                self.fpdf.drawText("+For", x=x, y=y, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][0], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText("-Agt", x=x, y=y, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][1], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText("=Dif", x=x, y=y, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][2], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
+                self.fpdf.drawText("Pts", x=x, y=y, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=1)
+                val = CCD(tms[tm][3], "SD", 7.1)
+                self.fpdf.drawText(val.disp, x=x, w=cwth * 8, h=8,
+                    border="TLRB", align="C", fill=0)
+                x += (cwth * 8)
         if self.lgame == self.games:
             # Enter Prizes
             for key in self.keys:

=== modified file 'crs/cr2020_rne.py'
--- crs/cr2020_rne.py	2016-02-27 13:18:41 +0000
+++ crs/cr2020_rne.py	2016-04-07 14:54:05 +0000
@@ -554,7 +554,7 @@
             for cod in self.form.body:
                 d = "%s_C%02i" % (cod, count)
                 if cod == "dep_pj_code":
-                    self.form.newdic[d][text] = "%-3s%05i" % (depno, pjno)
+                    self.form.newdic[d][text] = "%3s/%06i" % (depno, pjno)
                 elif cod == "document_type":
                     ttyp = tr[ctc.index("crt_type")]
                     self.form.newdic[d][text] = crtrtp[ttyp - 1][0]

=== modified file 'crs/cr3010.py'
--- crs/cr3010.py	2016-02-27 13:18:41 +0000
+++ crs/cr3010.py	2016-04-06 09:08:28 +0000
@@ -99,7 +99,7 @@
 
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%03u %-30s %54s %6s" %
+        self.head = ("%03u %-30s %44s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.btot = [0, 0]
@@ -134,14 +134,13 @@
                 acno = CCD(trn[tc.index("crt_acno")], "NA", 7)
                 trdt = CCD(trn[tc.index("crt_trdt")], "D1", 10)
                 ref1 = CCD(trn[tc.index("crt_ref1")], "Na", 9)
-                ref2 = CCD(trn[tc.index("crt_ref2")], "Na", 9)
                 desc = CCD(trn[tc.index("crt_desc")], "NA", 30)
                 tramt = CCD(trn[tc.index("crt_tramt")], "SD", 13.2)
                 taxamt = CCD(trn[tc.index("crt_taxamt")], "SD", 13.2)
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading()
-                self.fpdf.drawText("%s %s %s %s %s %s %s" % (acno.disp,
-                    trdt.disp, ref1.disp, ref2.disp, desc.disp, tramt.disp,
+                self.fpdf.drawText("%s %s %s %s %s %s" % (acno.disp,
+                    trdt.disp, ref1.disp, desc.disp, tramt.disp,
                     taxamt.disp))
                 self.btot[0] += 1
                 self.btot[1] = float(ASD(self.btot[1]) + ASD(tramt.work))
@@ -162,7 +161,7 @@
         self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-36s %53s %5s" %
+        self.fpdf.drawText("%-36s %43s %5s" %
             ("Creditors Ledger Batch Error Listing", "Page", self.pgnum))
         self.fpdf.drawText()
         self.fpdf.setFont()
@@ -180,8 +179,8 @@
             "Current Date:", self.curdt.disp,
             "Multi Allocations:", self.multi.disp))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-7s %-10s %-9s %-9s %-30s %-13s %-13s" %
-            ("Acc-Num", "   Date", "Reference", "Ref-Num-2", "Description",
+        self.fpdf.drawText("%-7s %-10s %-9s %-30s %-13s %-13s" %
+            ("Acc-Num", "   Date", "Reference", "Description",
             "  Trn-Amount", "  Tax-Amount"))
         self.fpdf.underLine(self.head)
         self.fpdf.setFont()

=== modified file 'crs/cr3020.py'
--- crs/cr3020.py	2016-02-27 13:18:41 +0000
+++ crs/cr3020.py	2016-04-18 10:06:53 +0000
@@ -153,11 +153,11 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()

=== modified file 'crs/cr3050.py'
--- crs/cr3050.py	2016-02-27 13:18:41 +0000
+++ crs/cr3050.py	2016-04-18 10:07:22 +0000
@@ -86,8 +86,8 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][7][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][7][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][7][4][0], state="hide")
             self.acc1 = ""
             self.fm = "First"
             self.acc2 = "zzzzzzz"
@@ -102,8 +102,8 @@
             self.df.loadEntry(frt, pag, p+5, data=self.zero)
             return "sk5"
         else:
-            self.df.setWidget(self.df.topEntry[0][7][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][7][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][7][4][0], state="show")
 
     def doAcc1(self, frt, pag, r, c, p, i, w):
         self.acc1 = w

=== modified file 'crs/cr3070_rne.py'
--- crs/cr3070_rne.py	2016-02-27 13:18:41 +0000
+++ crs/cr3070_rne.py	2016-04-07 15:18:24 +0000
@@ -136,7 +136,7 @@
             self.printBody()
 
     def printSetup(self):
-        self.head = ("%03u %-30s %59s %6s" % \
+        self.head = ("%03u %-30s %61s %6s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.prnt = "Y"
@@ -150,13 +150,13 @@
         self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-40s %-32s %-19s %-7s" % \
+        self.fpdf.drawText("%-40s %-34s %-19s %7s" % \
             (self.name.disp, "", "Acc-Num:", self.acno.disp))
-        self.fpdf.drawText("%-40s %-32s %-19s %-7s" % \
+        self.fpdf.drawText("%-40s %-34s %-19s %7s" % \
             (self.add1.disp, "", "Period", self.curdd))
-        self.fpdf.drawText("%-40s %-32s %-25s %-5s" % \
+        self.fpdf.drawText("%-40s %-34s %-21s %5s" % \
             (self.add2.disp, "", "Page:", self.pgnum))
-        self.fpdf.drawText("%-40s %-32s %-16s %-10s" % \
+        self.fpdf.drawText("%-40s %-34s %-16s %-10s" % \
             (self.add3.disp, "", "", ""))
         self.fpdf.drawText("%-40s" % (self.pcod.disp))
         self.fpdf.drawText()
@@ -167,7 +167,7 @@
             self.avdis.disp))
         self.fpdf.drawText()
         self.fpdf.drawText("%s %s %s %s %-3s %-13s %-13s %-13s %-13s %1s" % \
-            ("   Date   ", "Reference", "Ref-Num-2", "Dep/PjNo", "Typ",
+            ("   Date   ", "Reference", "Ref-Num-2", "Dep/PjNumb", "Typ",
             " Orig-Amount", "     Balance", " Paid-Amount", "  Bal-Amount",
             "T"))
         self.fpdf.underLine(txt=self.head)
@@ -193,16 +193,16 @@
             owebal = CCD(trn[self.ctc.index("balance")], "SD", 13.2)
             if not trn[self.ctc.index("rtf_depno")] is None:
                 depno = CCD(trn[self.ctc.index("rtf_depno")], "UI", 3)
-                pjno = CCD(trn[self.ctc.index("rtf_pjno")], "UI", 4)
+                pjno = CCD(trn[self.ctc.index("rtf_pjno")], "UI", 6)
             else:
                 depno = CCD(0, "UI", 3)
-                pjno = CCD(0, "UI", 4)
+                pjno = CCD(0, "UI", 6)
             if self.pglin > self.fpdf.lpp:
                 self.printHeader()
             self.totbal = float(ASD(self.totbal) + ASD(tramt.work))
             totbal = CCD(self.totbal, "SD", 13.2)
             typ = crtrtp[ttyp.work-1][0]
-            self.fpdf.drawText("%s %s %s %03i/%04i %s %s %s %s %s %s" % \
+            self.fpdf.drawText("%s %s %s %03i/%06i %s %s %s %s %s %s" % \
                 (trdt.disp, ref1.disp, ref2.disp, depno.work, pjno.work, typ,
                 tramt.disp, totbal.disp, payamt.disp, owebal.disp,
                 taxind.disp))

=== modified file 'crs/cr3320_rne.py'
--- crs/cr3320_rne.py	2016-02-27 13:18:41 +0000
+++ crs/cr3320_rne.py	2016-04-07 15:36:59 +0000
@@ -69,11 +69,11 @@
                 "Y","N",self.doPreview,None,None,None),
             (("T",0,3,0),"IUI",3,"Branch Code","",
                 "","N",self.doBranch,bch,None,("efld",)),
-            (("T",0,4,0),"IUI",4,"Start Number","",
+            (("T",0,4,0),"IUI",6,"Start Number","",
                 "","N",self.doStartN,None,None,("efld",)),
-            (("T",0,5,0),"IUI",4,"End Number","",
+            (("T",0,5,0),"IUI",6,"End Number","",
                 "","N",self.doEndN,None,None,("efld",)),
-            (("T",0,6,0),"ID1",10,"Start Date","",
+            (("T",0,6,0),"Id1",10,"Start Date","",
                 self.sysdtw,"N",self.doStartD,None,None,("efld",)),
             (("T",0,6,0),"ID1",10,"End Date","",
                 self.sysdtw,"N",self.doEndD,None,None,("efld",)))
@@ -248,7 +248,7 @@
             ref1 = CCD(dat[2], "Na", 9)
             rtyp = CCD(dat[3], "UI", 2)
             trtp = crtrtp[rtyp.work - 1][0]
-            self.pjnum = CCD(dat[4], "UI", 5)
+            self.pjnum = CCD(dat[4], "UI", 6)
             self.pjdat = CCD(dat[5], "d1", 10)
             acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
                 where=[("crm_cono", "=", self.opts["conum"]),
@@ -336,7 +336,7 @@
         else:
             typ = ""
             dat = ""
-        self.fpdf.drawText("%24s%29s%13s%6s%28s%33s" % ("Purchase Journal "\
+        self.fpdf.drawText("%24s%29s%13s%8s%26s%33s" % ("Purchase Journal "\
             "Listing", typ, "TAX INVOICE", self.pjno, "", dat))
         self.fpdf.drawText()
         self.fpdf.drawText("%49s%28s" % ("", "R N E HOLDINGS (PTY) LIMITED"))

=== modified file 'crs/cr3360_rne.py'
--- crs/cr3360_rne.py	2016-02-27 13:18:41 +0000
+++ crs/cr3360_rne.py	2016-04-07 14:53:56 +0000
@@ -259,7 +259,7 @@
             for cod in self.form.body:
                 d = "%s_C%02i" % (cod, count)
                 if cod == "dep_pj_code":
-                    self.form.newdic[d][text] = "%-2s%03i" % (depno, pjno)
+                    self.form.newdic[d][text] = "%3s/%06i" % (depno, pjno)
                 elif cod == "document_type":
                     ttyp = tr[ctc.index("crt_type")]
                     self.form.newdic[d][text] = crtrtp[ttyp - 1][0]

=== modified file 'crs/cr4010_rne.py'
--- crs/cr4010_rne.py	2016-02-27 13:18:41 +0000
+++ crs/cr4010_rne.py	2016-04-08 06:50:27 +0000
@@ -258,15 +258,16 @@
                 if rec[col.index("rtf_depno")] is None:
                     rec[col.index("rtf_depno")] = 0
                     rec[col.index("rtf_pjno")] = 0
-                    rec[col.index("rtf_disamt")] = 0
-                    rec[col.index("rtf_distax")] = 0
-                    rec[col.index("rtf_incamt")] = 0
-                    rec[col.index("rtf_advamt")] = 0
+                    #rec[col.index("rtf_disamt")] = 0
+                    #rec[col.index("rtf_distax")] = 0
+                    #rec[col.index("rtf_incamt")] = 0
+                    #rec[col.index("rtf_advamt")] = 0
                 dat = []
                 for nam in ["crt_trdt", "crt_curdt", "crt_batch",
                         "crt_type", "crt_ref1", "crt_ref2", "rtf_depno",
                         "rtf_pjno", "crt_tramt", "crt_taxamt", "paid",
-                        "balance", "rtf_disamt", "rtf_incamt", "rtf_advamt"]:
+                        "balance"]:
+                        #"balance", "rtf_disamt", "rtf_incamt", "rtf_advamt"]:
                     if not num:
                         if nam == "paid":
                             cols.append(("paid","Paid",13.2,"SD","N"))
@@ -368,8 +369,9 @@
                     for nam in ["crt_trdt", "crt_curdt", "crt_batch",
                             "crt_type", "crt_ref1", "crt_ref2", "rtf_depno",
                             "rtf_pjno", "crt_tramt", "crt_taxamt", "paid",
-                            "balance", "rtf_disamt", "rtf_incamt",
-                            "rtf_advamt"]:
+                            "balance"]:
+                            #"balance", "rtf_disamt", "rtf_incamt",
+                            #"rtf_advamt"]:
                         if not num:
                             if nam == "paid":
                                 cols.append(["paid", "SD", 13.2, "Paid"])

=== modified file 'csv/bkmrtt_fld.csv'
--- csv/bkmrtt_fld.csv	2015-08-25 15:02:35 +0000
+++ csv/bkmrtt_fld.csv	2016-05-10 10:43:07 +0000
@@ -14,7 +14,7 @@
 13,"brt_bdays","UI","3.0","Booked Days","Bkd"
 14,"brt_vrate","UD","5.2","V.A.T. Rate","VAT-R"
 15,"brt_invno","UI","9.0","Invoice Number","Invoice-N"
-16,"brt_invdt","UI","10.0","Invoice Date","Invoice-Dt"
+16,"brt_invdt","d1","10.0","Invoice Date","Invoice-Dt"
 17,"brt_crnno","UI","9.0","C/Note Number","CrNote-N"
 18,"brt_crndt","UI","10.0","C/Note Date","CrNote-Dt"
 19,"brt_capnm","TX","20.0","Capture Name","Capture-Name"

=== modified file 'csv/bwlent_fld.csv'
--- csv/bwlent_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/bwlent_fld.csv	2016-05-14 19:41:28 +0000
@@ -1,5 +1,5 @@
 0,"bce_cono","UI","3.0","Company Number","Coy"
 1,"bce_ccod","UI","3.0","Competition Code","CC"
 2,"bce_scod","UI","6.0","Skip Code","S-Code"
-3,"bce_pcod","UI","6.0","Partner Code","P-Code"
+3,"bce_tcod","UA","1.0","Team Code","T"
 4,"bce_paid","UA","1.0","Paid Flag","P"

=== modified file 'csv/bwlgme_fld.csv'
--- csv/bwlgme_fld.csv	2016-02-27 13:18:41 +0000
+++ csv/bwlgme_fld.csv	2016-05-14 19:41:28 +0000
@@ -9,10 +9,10 @@
 8,"bcg_group","UI","1.0","Group","G"
 9,"bcg_shots_for","UI","2.0","Shots For","SF"
 10,"bcg_shots_agt","UI","2.0","Shots Against","SA"
-11,"bcg_points","UD","4.1","Points","Pnts"
+11,"bcg_points","UD","5.1","Points","Pnts"
 12,"bcg_a_shots_for","UI","2.0","Shots For","SF"
 13,"bcg_a_shots_agt","UI","2.0","Shots Against","SA"
-14,"bcg_a_points","UD","4.1","Points","Pnts"
+14,"bcg_a_points","UD","5.1","Points","Pnts"
 15,"bcg_aflag","UA","1.0","Abandoned Flag","F"
 16,"bcg_seed","UI","2.0","Seed Number","SN"
 17,"bcg_pair","UI","2.0","Pair Number","PN"

=== modified file 'csv/crsrtf_fld.csv'
--- csv/crsrtf_fld.csv	2015-05-20 16:03:01 +0000
+++ csv/crsrtf_fld.csv	2016-04-07 16:09:16 +0000
@@ -3,7 +3,7 @@
 2,"rtf_type","UI","2.0","Transaction Type","TT"
 3,"rtf_ref1","Na","9.0","Reference Number","Reference"
 4,"rtf_depno","UI","3.0","Department Number","Dep"
-5,"rtf_pjno","UI","4.0","PJ Number","PJNum"
+5,"rtf_pjno","UI","6.0","PJ Number","PJNumb"
 6,"rtf_disamt","SD","13.2","Discount Amount","Dis-Amount"
 7,"rtf_distax","SD","13.2","Discount Tax","Dis-Tax"
 8,"rtf_incamt","SD","13.2","Incentive Amount","Inc-Amount"

=== added file 'csv/genqrb_fld.csv'
--- csv/genqrb_fld.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrb_fld.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,4 @@
+0,"gqb_bcod","UI","3.0","Branch Code","Bch"
+1,"gqb_name","NA","12.0","Branch Name","Branch-Name"
+2,"gqb_ccod","UA","1.0","Country Code","C"
+3,"gqb_gcod","UI","1.0","Group Code","G"

=== added file 'csv/genqrb_idx.csv'
--- csv/genqrb_idx.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrb_idx.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,1 @@
+"Trading Profit & Loss Branches",1,"U","gqb_bcod"

=== added file 'csv/genqrc_fld.csv'
--- csv/genqrc_fld.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrc_fld.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,2 @@
+0,"gqc_dcod","UI","3.0","Department Code","Dep"
+1,"gqc_name","NA","12.0","Department Name","Depart-Name"

=== added file 'csv/genqrc_idx.csv'
--- csv/genqrc_idx.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrc_idx.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,1 @@
+"Trading Profit and Loss",1,"U","gqc_dcod"

=== added file 'csv/genqrd_fld.csv'
--- csv/genqrd_fld.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrd_fld.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,3 @@
+0,"gqd_bcod","UI","3.0","Branch Code","Bch"
+1,"gqd_dcod","UI","3.0","Department Code","Dep"
+2,"gqd_cono","UI","3.0","Company Number","Coy"

=== added file 'csv/genqrd_idx.csv'
--- csv/genqrd_idx.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrd_idx.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,2 @@
+"Trading Profit and Loss",1,"U","gqd_bcod","gqd_dcod","gqd_cono"
+"",2,"U","gqd_cono"

=== added file 'csv/genqrt_fld.csv'
--- csv/genqrt_fld.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrt_fld.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,7 @@
+0,"gqt_cono","UI","3.0","Company Number","Coy"
+1,"gqt_curdt","D2","7.0","Current Period","Curr-Dt"
+2,"gqt_purch","SI","10.0","Additional Purchases","Purchases"
+3,"gqt_sale","SI","10.0","Additional Sales","Sales"
+4,"gqt_incent","SI","10.0","Additional Incentives","Incentives"
+5,"gqt_transit","SI","10.0","Invoices in Transit","Transit"
+6,"gqt_stock","SI","10.0","Closing Stock","Stock"

=== added file 'csv/genqrt_idx.csv'
--- csv/genqrt_idx.csv	1970-01-01 00:00:00 +0000
+++ csv/genqrt_idx.csv	2016-04-03 08:17:14 +0000
@@ -0,0 +1,1 @@
+"Trading Profit and Loss",1,"U","gqt_cono","gqt_curdt"

=== modified file 'csv/ibtmst_fld.csv'
--- csv/ibtmst_fld.csv	2016-02-27 13:18:41 +0000
+++ csv/ibtmst_fld.csv	2016-05-10 19:29:29 +0000
@@ -1,16 +1,11 @@
 0,"ibm_cono","UI","3.0","Company Number","Coy"
 1,"ibm_docno","UI","9.0","Document Number","Number"
-2,"ibm_date","UI","9.0","Document Date","Doc-Date"
-3,"ibm_branch","UI","3.0","Branch Code","Bch"
-4,"ibm_dnote","NA","10.0","Delivery Note","Del-Note"
-5,"ibm_ddate","D1","10.0","Delivery Date","Del-Date"
-6,"ibm_supp","NA","7.0","Supplier","Supp-Cd"
-7,"ibm_sinv","Na","9.0","Supplier Inv","S-Invoice"
-8,"ibm_sinc","Na","11.2","Supplier Inc","S-IncAmount"
-9,"ibm_stax","Na","11.2","Supplier Tax","S-TaxAmount"
-10,"ibm_tran","NA","7.0","Transport","Tran-Cd"
-11,"ibm_tinv","Na","9.0","Transport Inv","T-Invoice"
-12,"ibm_tinc","Na","11.2","Transport Inc","T-IncAmount"
-13,"ibm_ttax","Na","11.2","Transport Tax","T-TaxAmount"
-14,"ibm_tjnl","Na","9.0","Transfer Journal","Tj-Number"
-15,"ibm_tjdt","D1","10.0","Transfer Journal Date","TrfJnl-Dte"
+2,"ibm_date","D1","10.0","Document Date","Doc-Date"
+3,"ibm_ouref","NA","10.0","Our Reference","Our-Ref-No"
+4,"ibm_branch","UI","3.0","Branch Code","Bch"
+5,"ibm_dnote","NA","10.0","Delivery Note","Del-Note"
+6,"ibm_ddate","D1","10.0","Delivery Date","Del-Date"
+7,"ibm_supp","NA","7.0","Supplier-1","Supp-C1"
+8,"ibm_sup2","NA","7.0","Supplier-2","Supp-C2"
+9,"ibm_tran","NA","7.0","Transport","Tran-Cd"
+10,"ibm_cdte","d1","10.0","Credit Date","Credit-Dte"

=== modified file 'csv/ibttrn_fld.csv'
--- csv/ibttrn_fld.csv	2016-02-27 13:18:41 +0000
+++ csv/ibttrn_fld.csv	2016-04-23 10:36:12 +0000
@@ -6,8 +6,13 @@
 5,"ibt_price","UD","10.4","Unit-Price","Unit-Price"
 6,"ibt_quant","SD","11.2","Quantity","Trans-Quant"
 7,"ibt_value","SD","11.2","Value","Trans-Value"
-9,"ibt_pjno","UI","5.0","Purchases Journal","PjNum"
-10,"ibt_curdt","D2","7.0","Current Date","Curr-Dt"
-11,"ibt_capnm","TX","20.0","Capture Name","Capture-Name"
-12,"ibt_capdt","d1","10.0","Capture Date","Capture-Dt"
-13,"ibt_seq","US","10.0","Sequence","Sequence"
+8,"ibt_tjnl","Na","9.0","Transfer Journal","Tj-Number"
+9,"ibt_tjdt","D1","10.0","Transfer Journal Date","TrfJnl-Dte"
+10,"ibt_pjno","UI","5.0","Purchases Journal","PjNum"
+11,"ibt_cacc","NA","7.0","Crs Account Number","Crs-Acc"
+12,"ibt_ctyp","UI","2.0","Crs Document Type","CT"
+13,"ibt_cref","Na","9.0","Crs Reference","Crs-RefNo"
+14,"ibt_curdt","D2","7.0","Current Date","Curr-Dt"
+15,"ibt_capnm","TX","20.0","Capture Name","Capture-Name"
+16,"ibt_capdt","d1","10.0","Capture Date","Capture-Dt"
+17,"ibt_seq","US","10.0","Sequence","Sequence"

=== modified file 'csv/ibttrn_idx.csv'
--- csv/ibttrn_idx.csv	2016-02-27 13:18:41 +0000
+++ csv/ibttrn_idx.csv	2016-03-10 13:48:07 +0000
@@ -1,2 +1,1 @@
 "Inter Branch Transactions",1,"U","ibt_seq"
-"",2,"U","ibt_cono","ibt_docno","ibt_type","ibt_code"

=== modified file 'csv/rnesys.py'
--- csv/rnesys.py	2016-02-27 13:18:41 +0000
+++ csv/rnesys.py	2016-04-03 08:12:56 +0000
@@ -14,6 +14,7 @@
     # General Ledger
     "genbal", "genbud", "gendtm", "gendtt", "genint", "genjlm", "genjlt",
     "genmst", "genrcc", "genrct", "genrpc", "genrpt", "genstr", "gentrn",
+    "genqrb", "genqrc", "genqrd", "genqrt",
     # Inter Branch Transfers
     "ibtctl", "ibtcod", "ibtmst", "ibttrn",
     # Loans

=== modified file 'csv/tpldet_rne.dat'
--- csv/tpldet_rne.dat	2016-02-27 13:18:41 +0000
+++ csv/tpldet_rne.dat	2016-05-11 04:22:52 +0000
@@ -8,12 +8,12 @@
 branch_transfer|8.0|C|A|L|TelNo:|courier|10|#000000|Y|N|N|L||N|99.0|7|114.0|22.0|27.0|0.0|ctm_tel|courier|10|#000000|Y|N|N|L||N|114.0|15|146.0|22.0|27.0|1|1
 branch_transfer|9.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|#000000|Y|N|N|L||N|5.0|4|13.0|26.0|31.0|1|1
 branch_transfer|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|99.0|7|114.0|26.0|31.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|114.0|15|146.0|26.0|31.0|1|1
-branch_transfer|11.0|T|A||INVOICE|courier|12|#000000|Y|N|N|R||N|173.0|7|193.0|5.0|15.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
+branch_transfer|11.0|C|A|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|document_type|courier|15|#000000|Y|N|N|R||N|142.0|15|193.0|5.0|15.0|1|1
 branch_transfer|12.0|C|A|H|Charge To:|courier|10|#000000|Y|N|N|L|TLRB|Y|5.0|30|71.0|35.0|40.0|0.0|account_details|courier|10|#000000|N|N|N|L|TLRB|N|5.0|30|71.0|40.0|44.0|5|1
 branch_transfer|13.0|C|A|H|Deliver To:|courier|10|#000000|Y|N|N|L|TLRB|Y|95.0|30|161.0|35.0|40.0|0.0|deliver_to|courier|10|#000000|N|N|N|L|TLRB|N|95.0|30|161.0|40.0|44.0|5|1
 branch_transfer|14.0|C|A|H|Doc-Number|courier|10|#000000|Y|N|N|C|TLRB|Y|170.0|10|193.0|36.0|41.0|0.0|ibm_docno|courier|10|#000000|N|N|N|C|TLRB|N|170.0|10|193.0|41.0|45.0|1|1
-branch_transfer|15.0|C|A|H|Page No|courier|10|#000000|Y|N|N|C|TLRB|Y|170.0|10|193.0|45.0|50.0|0.0|page_number|courier|10|#000000|N|N|N|C|TLRB|N|170.0|10|193.0|50.0|54.0|1|1
-branch_transfer|16.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|170.0|10|193.0|54.0|59.0|0.0|ibm_date|courier|10|#000000|N|N|N|C|TLRB|N|170.0|10|193.0|59.0|63.0|1|1
+branch_transfer|15.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|170.0|10|193.0|45.0|50.0|0.0|document_date|courier|10|#000000|N|N|N|C|TLRB|N|170.0|10|193.0|50.0|54.0|1|1
+branch_transfer|16.0|C|A|H|Our-Refno|courier|10|#000000|Y|N|N|C|TLRB|Y|170.0|10|193.0|54.0|59.0|0.0|ibm_ouref|courier|10|#000000|N|N|N|C|TLRB|N|170.0|10|193.0|59.0|63.0|1|1
 branch_transfer|17.0|C|A|H|Del-Number|courier|10|#000000|Y|N|N|C|TLRB|Y|5.0|10|28.0|63.0|68.0|0.0|ibm_dnote|courier|10|#000000|N|N|N|C|TLRB|N|5.0|10|28.0|68.0|72.0|1|1
 branch_transfer|18.0|C|A|H|Del-Date|courier|10|#000000|Y|N|N|C|TLRB|Y|28.0|10|51.0|63.0|68.0|0.0|ibm_ddate|courier|10|#000000|N|N|N|C|TLRB|N|28.0|10|51.0|68.0|72.0|1|1
 branch_transfer|19.0|C|A|H|Transporter|courier|10|#000000|Y|N|N|C|TLRB|Y|51.0|27|110.0|63.0|68.0|0.0|transporter|courier|10|#000000|N|N|N|C|TLRB|N|51.0|27|110.0|68.0|72.0|1|1
@@ -25,37 +25,37 @@
 branch_transfer|25.0|C|B|H|Price|courier|10|#000000|Y|N|N|R|TLRB|Y|140.0|10|163.0|72.0|77.0|0.0|ibt_price|courier|10|#000000|N|N|N|R|R|N|140.0|10|163.0|77.0|81.0|1|20
 branch_transfer|26.0|C|B|H|Value|courier|10|#000000|Y|N|N|R|TLRB|Y|163.0|13|193.0|72.0|77.0|0.0|ibt_value|courier|10|#000000|N|N|N|R|R|N|163.0|13|193.0|77.0|81.0|1|20
 branch_transfer|27.0|C|C|L|Total Value|courier|10|#000000|Y|N|N|L|TLRB|Y|133.0|13|163.0|157.0|162.0|0.0|total_value|courier|10|#000000|Y|N|N|R|TLRB|N|163.0|13|193.0|157.0|162.0|1|1
-remittance_rnehol|1.0|I|A||||0|||||||15.0|0|130.0|15.0|35.0|0.0|ctm_logo||0|||||||0.0|0|0.0|0.0|0.0|0|0
-remittance_rnehol|2.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|Y|N|N|L||N|15.0|30|129.0|15.0|20.0|1|1
-remittance_rnehol|3.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|Y|N|N|L||N|15.0|30|78.0|21.0|25.0|1|1
-remittance_rnehol|4.0|C|A|L|RegNo:|courier|10|Y|N|N|L||N|85.0|7|100.0|21.0|25.0|0.0|ctm_regno|courier|10|Y|N|N|L||N|100.0|20|142.0|21.0|25.0|1|1
-remittance_rnehol|5.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add2|courier|10|Y|N|N|L||N|15.0|30|78.0|25.0|29.0|1|1
-remittance_rnehol|6.0|C|A|L|TaxNo:|courier|10|Y|N|N|L||N|85.0|7|100.0|25.0|29.0|0.0|ctm_taxno|courier|10|Y|N|N|L||N|100.0|20|142.0|25.0|29.0|1|1
-remittance_rnehol|7.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add3|courier|10|Y|N|N|L||N|15.0|30|78.0|29.0|33.0|1|1
-remittance_rnehol|8.0|C|A|L|TelNo:|courier|10|Y|N|N|L||N|85.0|7|100.0|29.0|33.0|0.0|ctm_tel|courier|10|Y|N|N|L||N|100.0|15|132.0|29.0|33.0|1|1
-remittance_rnehol|9.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|Y|N|N|L||N|15.0|4|23.0|33.0|37.0|1|1
-remittance_rnehol|10.0|C|A|L|FaxNo:|courier|10|Y|N|N|L||N|85.0|7|100.0|33.0|37.0|0.0|ctm_fax|courier|10|Y|N|N|L||N|100.0|15|132.0|33.0|37.0|1|1
-remittance_rnehol|11.0|T|A||REMITTANCE|courier|14|Y|N|N|R|TLRB|N|151.0|10|184.0|15.0|20.0|0.0|||0|||||||0.0|0|0.0|0.0|0.0|0|0
-remittance_rnehol|12.0|C|A|H|Account:|courier|10|Y|N|N|L|TLRB|Y|15.0|30|81.0|45.0|50.0|0.0|account_details|courier|10|N|N|N|L|TLRB|N|15.0|30|81.0|50.0|54.0|5|1
-remittance_rnehol|13.0|C|A|H|Acc-Num|courier|10|Y|N|N|C|TLRB|Y|154.0|13|184.0|43.0|48.0|0.0|crm_acno|courier|10|N|N|N|C|TLRB|N|154.0|13|184.0|48.0|52.0|1|1
-remittance_rnehol|14.0|C|A|H|Page|courier|10|Y|N|N|C|TLRB|Y|154.0|13|184.0|52.0|57.0|0.0|page_number|courier|10|N|N|N|C|TLRB|N|154.0|13|184.0|57.0|61.0|1|1
-remittance_rnehol|15.0|C|A|H|Date|courier|10|Y|N|N|C|TLRB|Y|154.0|13|184.0|61.0|66.0|0.0|document_date|courier|10|N|N|N|C|TLRB|N|154.0|13|184.0|66.0|70.0|1|1
-remittance_rnehol|16.0|C|B|H|Bch/PjNo|courier|10|Y|N|N|C|TLRB|Y|15.0|8|34.0|85.0|90.0|0.0|dep_pj_code|courier|10|N|N|N|C|LR|N|15.0|8|34.0|90.0|94.0|1|40
-remittance_rnehol|17.0|C|B|H|Typ|courier|10|Y|N|N|C|TLRB|Y|34.0|3|42.0|85.0|90.0|0.0|document_type|courier|10|N|N|N|L|R|N|34.0|3|42.0|90.0|94.0|1|40
-remittance_rnehol|18.0|C|B|H|Reference|courier|10|Y|N|N|C|TLRB|Y|42.0|9|63.0|85.0|90.0|0.0|crt_ref1|courier|10|N|N|N|L|R|N|42.0|9|63.0|90.0|94.0|1|40
-remittance_rnehol|19.0|C|B|H|Date|courier|10|Y|N|N|C|TLRB|Y|63.0|10|86.0|85.0|90.0|0.0|crt_trdt|courier|10|N|N|N|C|R|N|63.0|10|86.0|90.0|94.0|1|40
-remittance_rnehol|20.0|C|B|H|Amount|courier|10|Y|N|N|R|TLRB|Y|86.0|11|111.0|85.0|90.0|0.0|line_amount|courier|10|N|N|N|R|R|N|86.0|11|111.0|90.0|94.0|1|40
-remittance_rnehol|21.0|C|B|H|Dis-%|courier|10|Y|N|N|R|TLRB|Y|111.0|5|124.0|85.0|90.0|0.0|line_set-%|courier|10|N|N|N|R|R|N|111.0|5|124.0|90.0|94.0|1|40
-remittance_rnehol|22.0|C|B|H|Inc-%|courier|10|Y|N|N|C|TLRB|Y|124.0|5|137.0|85.0|90.0|0.0|line_inc-%|courier|10|N|N|N|R|R|N|124.0|5|137.0|90.0|94.0|1|40
-remittance_rnehol|23.0|C|B|H|Adv-%|courier|10|Y|N|N|C|TLRB|Y|137.0|5|150.0|85.0|90.0|0.0|line_adv-%|courier|10|N|N|N|R|R|N|137.0|5|150.0|90.0|94.0|1|40
-remittance_rnehol|24.0|C|B|H|Net Amount|courier|10|Y|N|N|R|TLRB|Y|150.0|15|184.0|85.0|90.0|0.0|line_paid|courier|10|N|N|N|R|R|N|150.0|15|184.0|90.0|94.0|1|40
-remittance_rnehol|25.0|C|C|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|carried_forward|courier|10|Y|N|N|C|TLRB|N|135.0|22|184.0|252.0|257.0|1|1
-remittance_rnehol|26.0|C|C|H|Total Amnt|courier|10|Y|N|N|R|TLRB|Y|15.0|15|49.0|252.0|257.0|0.0|total_amount|courier|10|Y|N|N|R|LRB|N|15.0|15|49.0|257.0|262.0|1|1
-remittance_rnehol|27.0|C|C|H|Total Disc|courier|10|Y|N|N|R|TLRB|Y|49.0|15|83.0|252.0|257.0|0.0|total_setdisc|courier|10|Y|N|N|R|RB|N|49.0|15|83.0|257.0|262.0|1|1
-remittance_rnehol|28.0|C|C|H|Total Inc|courier|10|Y|N|N|R|TLRB|Y|83.0|15|117.0|252.0|257.0|0.0|total_incdisc|courier|10|Y|N|N|R|RB|N|83.0|15|117.0|257.0|262.0|1|1
-remittance_rnehol|29.0|C|C|H|Total Adv|courier|10|Y|N|N|R|TLRB|Y|117.0|15|150.0|252.0|257.0|0.0|total_advdisc|courier|10|Y|N|N|R|RB|N|117.0|15|150.0|257.0|262.0|1|1
-remittance_rnehol|30.0|C|C|H|Total Payment|courier|10|Y|N|N|C|TLRB|Y|150.0|15|184.0|252.0|257.0|0.0|total_payment|courier|10|Y|N|N|R|RB|N|150.0|15|184.0|257.0|262.0|1|1
-remittance_rnehol|31.0|C|D|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|eft_message|helvetica|10|Y|Y|N|C||N|15.0|50|184.0|265.0|270.0|1|1
+remittance_rnehol|1.0|I|A||||0|#000000|||||||15.0|0|130.0|15.0|35.0|0.0|ctm_logo||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+remittance_rnehol|2.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|15.0|30|129.0|15.0|20.0|1|1
+remittance_rnehol|3.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|21.0|25.0|1|1
+remittance_rnehol|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|21.0|25.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|100.0|20|142.0|21.0|25.0|1|1
+remittance_rnehol|5.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add2|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|25.0|29.0|1|1
+remittance_rnehol|6.0|C|A|L|TaxNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|25.0|29.0|0.0|ctm_taxno|courier|10|#000000|Y|N|N|L||N|100.0|20|142.0|25.0|29.0|1|1
+remittance_rnehol|7.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add3|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|29.0|33.0|1|1
+remittance_rnehol|8.0|C|A|L|TelNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|29.0|33.0|0.0|ctm_tel|courier|10|#000000|Y|N|N|L||N|100.0|15|132.0|29.0|33.0|1|1
+remittance_rnehol|9.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_pcode|courier|10|#000000|Y|N|N|L||N|15.0|4|23.0|33.0|37.0|1|1
+remittance_rnehol|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|33.0|37.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|100.0|15|132.0|33.0|37.0|1|1
+remittance_rnehol|11.0|T|A||REMITTANCE|courier|14|#000000|Y|N|N|R|TLRB|N|155.0|10|188.0|15.0|20.0|0.0|||0||||||||0.0|0|0.0|0.0|0.0|0|0
+remittance_rnehol|12.0|C|A|H|Account:|courier|10|#000000|Y|N|N|L|TLRB|Y|15.0|30|81.0|45.0|50.0|0.0|account_details|courier|10|#000000|N|N|N|L|TLRB|N|15.0|30|81.0|50.0|54.0|5|1
+remittance_rnehol|13.0|C|A|H|Acc-Num|courier|10|#000000|Y|N|N|C|TLRB|Y|158.0|13|188.0|43.0|48.0|0.0|crm_acno|courier|10|#000000|N|N|N|C|TLRB|N|158.0|13|188.0|48.0|52.0|1|1
+remittance_rnehol|14.0|C|A|H|Page|courier|10|#000000|Y|N|N|C|TLRB|Y|158.0|13|188.0|52.0|57.0|0.0|page_number|courier|10|#000000|N|N|N|C|TLRB|N|158.0|13|188.0|57.0|61.0|1|1
+remittance_rnehol|15.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|158.0|13|188.0|61.0|66.0|0.0|document_date|courier|10|#000000|N|N|N|C|TLRB|N|158.0|13|188.0|66.0|70.0|1|1
+remittance_rnehol|16.0|C|B|H|Dep/PjNum|courier|10|#000000|Y|N|N|C|TLRB|Y|15.0|10|38.0|85.0|90.0|0.0|dep_pj_code|courier|10|#000000|N|N|N|C|LR|N|15.0|10|38.0|90.0|94.0|1|40
+remittance_rnehol|17.0|C|B|H|Typ|courier|10|#000000|Y|N|N|C|TLRB|Y|38.0|3|46.0|85.0|90.0|0.0|document_type|courier|10|#000000|N|N|N|L|R|N|38.0|3|46.0|90.0|94.0|1|40
+remittance_rnehol|18.0|C|B|H|Reference|courier|10|#000000|Y|N|N|C|TLRB|Y|46.0|9|67.0|85.0|90.0|0.0|crt_ref1|courier|10|#000000|N|N|N|L|R|N|46.0|9|67.0|90.0|94.0|1|40
+remittance_rnehol|19.0|C|B|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|67.0|10|90.0|85.0|90.0|0.0|crt_trdt|courier|10|#000000|N|N|N|C|R|N|67.0|10|90.0|90.0|94.0|1|40
+remittance_rnehol|20.0|C|B|H|Amount|courier|10|#000000|Y|N|N|R|TLRB|Y|90.0|11|115.0|85.0|90.0|0.0|line_amount|courier|10|#000000|N|N|N|R|R|N|90.0|11|115.0|90.0|94.0|1|40
+remittance_rnehol|21.0|C|B|H|Dis-%|courier|10|#000000|Y|N|N|R|TLRB|Y|115.0|5|128.0|85.0|90.0|0.0|line_set-%|courier|10|#000000|N|N|N|R|R|N|115.0|5|128.0|90.0|94.0|1|40
+remittance_rnehol|22.0|C|B|H|Inc-%|courier|10|#000000|Y|N|N|C|TLRB|Y|128.0|5|141.0|85.0|90.0|0.0|line_inc-%|courier|10|#000000|N|N|N|R|R|N|128.0|5|141.0|90.0|94.0|1|40
+remittance_rnehol|23.0|C|B|H|Adv-%|courier|10|#000000|Y|N|N|C|TLRB|Y|141.0|5|154.0|85.0|90.0|0.0|line_adv-%|courier|10|#000000|N|N|N|R|R|N|141.0|5|154.0|90.0|94.0|1|40
+remittance_rnehol|24.0|C|B|H|Net Amount|courier|10|#000000|Y|N|N|R|TLRB|Y|154.0|15|188.0|85.0|90.0|0.0|line_paid|courier|10|#000000|N|N|N|R|R|N|154.0|15|188.0|90.0|94.0|1|40
+remittance_rnehol|25.0|C|C|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|carried_forward|courier|10|#000000|Y|N|N|C|TLRB|N|135.0|24|188.0|252.0|257.0|1|1
+remittance_rnehol|26.0|C|C|H|Total Amnt|courier|10|#000000|Y|N|N|R|TLRB|Y|15.0|15|49.0|252.0|257.0|0.0|total_amount|courier|10|#000000|Y|N|N|R|LRB|N|15.0|15|49.0|257.0|262.0|1|1
+remittance_rnehol|27.0|C|C|H|Total Disc|courier|10|#000000|Y|N|N|R|TLRB|Y|49.0|15|83.0|252.0|257.0|0.0|total_setdisc|courier|10|#000000|Y|N|N|R|RB|N|49.0|15|83.0|257.0|262.0|1|1
+remittance_rnehol|28.0|C|C|H|Total Inc|courier|10|#000000|Y|N|N|R|TLRB|Y|83.0|15|117.0|252.0|257.0|0.0|total_incdisc|courier|10|#000000|Y|N|N|R|RB|N|83.0|15|117.0|257.0|262.0|1|1
+remittance_rnehol|29.0|C|C|H|Total Adv|courier|10|#000000|Y|N|N|R|TLRB|Y|117.0|15|150.0|252.0|257.0|0.0|total_advdisc|courier|10|#000000|Y|N|N|R|RB|N|117.0|15|150.0|257.0|262.0|1|1
+remittance_rnehol|30.0|C|C|H|Total Payment|courier|10|#000000|Y|N|N|C|TLRB|Y|150.0|17|188.0|252.0|257.0|0.0|total_payment|courier|10|#000000|Y|N|N|R|RB|N|150.0|17|188.0|257.0|262.0|1|1
+remittance_rnehol|31.0|C|D|N|||0||||||||0.0|0|0.0|0.0|0.0|0.0|eft_message|helvetica|10|#000000|Y|Y|N|C||N|15.0|50|188.0|265.0|270.0|1|1
 sales_document|1.0|I|A||||0|||||||30.0|0|160.0|7.0|34.0|0.0|ctm_logo||0|N||||||0.0|0|0.0|0.0|0.0|0|0
 sales_document|2.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|Y|N|N|L||N|30.0|30|144.0|7.0|12.0|1|1
 sales_document|3.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|Y|N|N|L||N|30.0|30|93.0|14.0|19.0|1|1

=== modified file 'csv/tplmst.dat'
--- csv/tplmst.dat	2015-10-03 07:36:56 +0000
+++ csv/tplmst.dat	2016-04-08 08:30:45 +0000
@@ -7,10 +7,10 @@
 purchase_order|Purchase Order|O|STR||A4|L
 remittance_advice|Remittance Advice|R|CRS||A4|P
 sales_document|Sales Document|I|INV||A4|L
-statement_loan|Statement (Loan)|S|LON|O|A4|P
-statement_member|Statement (Member)|S|MEM|O|A4|P
+statement_loan|Statement (Loan)|S|LON|N|A4|P
+statement_member|Statement (Member)|S|MEM|N|A4|P
 statement_normal|Statement (Normal)|S|DRS|N|A4|P
 statement_other|Statement (Other)|S|DRS|O|A4|P
 statement_owner|Statement (Owner)|S|RCA|O|A4|P
-statement_rental|Statement (Rental)|S|RTL|O|A4|P
+statement_rental|Statement (Rental)|S|RTL|N|A4|P
 statement_tenant|Statement (Tenant)|S|RCA|T|A4|P

=== modified file 'csv/tplmst_rne.dat'
--- csv/tplmst_rne.dat	2016-02-27 13:18:41 +0000
+++ csv/tplmst_rne.dat	2016-04-08 08:31:15 +0000
@@ -1,7 +1,7 @@
 branch_transfer|Branch Transfer|I|IBT||A4|P
 remittance_rnehol|Remittance Advice (RNE)|R|CRS||A4|P
 sales_document|Sales Document|I|INV||A4|L
-statement_loan|Statement (Loan)|S|LON|O|A4|P
+statement_loan|Statement (Loan)|S|LON|N|A4|P
 statement_normal|Statement (Normal)|S|DRS|N|A4|P
 statement_other|Statement (Other)|S|DRS|O|A4|P
-statement_rental|Statement (Rental)|S|RTL|O|A4|P
+statement_rental|Statement (Rental)|S|RTL|N|A4|P

=== modified file 'doc/BC.rst'
--- doc/BC.rst	2016-02-27 13:18:41 +0000
+++ doc/BC.rst	2016-05-10 05:32:34 +0000
@@ -88,7 +88,7 @@
 
 + **Type Code** - zero for the next number else an existing number. To see existing types press the F1 key.
 + **Description** - The competition description.
-+ **Competition Format** - The type of competition i.e. Tournament, Knockout or Round Robin.
++ **Competition Format** - The type of competition i.e. Tournament, Knockout, Round Robin or Teams i.e. Home versus Visitors.
 + **Team Size** - The number of players in a team.
 + **Number of Games** - The total number of games comprising the competition.
 + **Number of Ends per Game** - The number of ends to be completed in a game.
@@ -252,7 +252,7 @@
 Enter the Skip's Codes
 
 + **Skip** - The skip's code as created in `Tab's Maintenance`_ or you can enter a zero to enter a new player as per `Tab's Maintenance`_.
-+ **Lead** - The lead's code, in the case of pairs, as created in `Tab's Maintenance`_ or you can enter a zero to enter a new player as per `Tab's Maintenance`_.
++ **Team** - The team's code i.e. H or V if the competition type is Teams.
 + **P** - Whether or not the skip has paid, Y or N.
 
 Entries Listing
@@ -282,6 +282,10 @@
 + **All Cards** - If cards were selected to be printed, whether to print all cards or only selected ones.
 + **Template Name** - The template to use for the cards.
 
+.. raw:: pdf
+
+    PageBreak
+
 Draw Summary
 ++++++++++++
 Use this routine to print a summary of all draws to date.

=== modified file 'doc/Downloads.rst'
--- doc/Downloads.rst	2016-03-01 14:42:33 +0000
+++ doc/Downloads.rst	2016-05-21 12:42:20 +0000
@@ -11,23 +11,23 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.2.1 and was released on the 1st March, 2016.
+The latest version of Tartan is 5.2.2 and was released on the 21st May, 2016.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Documentation: http://www.tartan.co.za/cgi-bin/simple_web.py/Documentation
-.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.2.1.tar.gz
+.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.2.2.tar.gz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.14.tar.gz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tar.gz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tar.gz
-.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.2.1.exe
+.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.2.2.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.14.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
 .. _Tartan-2-win: ftp://tartan.co.za/Tartan_2.5.29.exe
-.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.2.1.tar.gz
-.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.2.1.exe
-.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.2.1.tar.gz
-.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.2.1.exe
+.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.2.2.tar.gz
+.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.2.2.exe
+.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.2.2.tar.gz
+.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.2.2.exe
 
 |linux| Linux
 =============

=== added file 'doc/GL_rne.rst'
--- doc/GL_rne.rst	1970-01-01 00:00:00 +0000
+++ doc/GL_rne.rst	2016-04-04 10:18:43 +0000
@@ -0,0 +1,584 @@
+General Ledger
+--------------
+File Maintenance (GL)
+.....................
+Masterfile Records (GL)
++++++++++++++++++++++++
+This routine is used to create or amend general ledger account records. For a new company you can **automatically populate** the company with standard accounts and reports by selecting the `Populate` button. You can also import a chart of accounts by selecting the `Import` button in which case the file must be in `csv` or `xls` format and must contain all the fields as listed below.
+
++ **Acc-Num** - The account number of the record. This is a numeric field and can have up to 7 digits. There is nothing special about this number it is only used to access the record.
++ **Account Type** - Select the applicable account type for the record.
++ **Description** - The account's description up to 30 characters in length.
++ **Allow Postings** - Whether or not direct postings are allowed to this account. Normally direct postings are not allowed to control accounts of subsidiary ledgers, e.g. Debtor's as they should be generated in the subsidiary ledger.
++ **Tax Default** - The V.A.T. code normally associated with postings to this account.
+
+Once all accounts have been created, you should print a list of them by selecting `Chart of Accounts (GL)`_ from the reporting menu, and check that all accounts have been created correctly.
+
+Control Accounts (GL)
++++++++++++++++++++++
+This routine is used to create control accounts for the company. Control accounts are accounts that the system needs to know about in order to create double sided entries. You must create at least one bank as well as the retained income control records but preferably most of the others as well.
+
+If you elected to **automatically populate** while creating masterfile records this would already have been done for you.
+
++ **Code** - Enter a valid control code e.g. **bank_1**. If you press F1 you  will be given a list of available codes which you can select from.
++ **G/L Acc-Num** - Enter the applicable general ledger account number for this code.
++ **Bank Account** - If the code is a bank account then you can enter the bank's account number here. This is required for importing bank statements.
++ **Import Format** - If you are going to import bank statements you must select the format you will be downloading or else `None` for no imports. The preferred format for internet banking is the OFX, or Open Financial eXchange, format.
++ **Date Format** - If you entered an import format, select the applicable date format. The date format for OFX is CCYYMMDD.
+
+Inter Company Records (GL)
+++++++++++++++++++++++++++
+This routine only applies to systems which have multiple companies. This allows one to capture transactions in one company directly into another company's accounts e.g. capture a payment made by company one for a telephone account for company two. For the purposes of simplicity lets assume that we are presently in company 1's ledger and want to integrate company 2.
+
++ **Coy-Num** - The other company's number i.e. 2
++ **Acc-Num-1** - Company 2's inter company loan account number in company 1.
++ **Acc-Num-2** - Company 1's inter company loan account number in company 2.
+
+Standard Journals (GL)
+++++++++++++++++++++++
+Use this routine to create, amend and delete standard journals.
+
++ **Number** - This is the journals reference number.
++ **Description** - This is the description of the journal.
++ **Frequency** - This is the frequency with which this journal is raised:
+    + **M** - Monthly
+    + **3** - Quarterly
+    + **6** - Biannually
+    + **Y** - Annually
++ **Starting Period** - The first period this journal is to be raised, (CCYYMM)
++ **Ending Period** - The last period this journal is to be raised, (CCYYMM)
+
+Now all the journal lines must be entered as follows:
+
++ **Seq** - The line number.
++ **Acc-Num** - The general ledger account number.
++ **V** - The VAT code.
++ **Value** - The value of the transaction. Enter credits as minus values.
+
+Please note that you will not be able to end this routine until the debits equal the credits.
+
+Report Generator (GL)
++++++++++++++++++++++
+Use this routine to create, amend and delete `Financial Statements (GL)`_ report formats.
+
++ **Company** - The company number or a 0 to create a general report for all companies.
++ **Report** - The report number. After this point certain options are available.
+    + **Re-Sequence** - This re-sequences the whole report starting from 1
+    + **Copy** - This allows you to copy an existing report
+        + **Company Number** - The company number of the existing report
+        + **Report Number** - The number of the existing report
+    + **Print** - This allows you to print the report layout
++ **Type** - The type of report to create:
+    + **B** - Balance Sheet
+    + **P** - Profit and Loss
+    + **O** - Any Other type of report
++ **Heading** - The report heading.
++ **Sequence**
+    + **Seq-Num** - The report sequence number. To insert lines use decimals.
+    + **Sequence Type** - The sequence type as follows.
++ **Heading (H)**
+    + **Description** - The heading detail.
+    + **Highlight** - Whether to print the heading in bold characters.
+    + **New Page** - Whether to print the heading on a new page.
+    + **Ignore Account Type** - In the case of B and P report types, when the account type changes the heading will automatically also change. To ignore this action select this option.
++ **Ledger (L)**
+    + **From Account** - The first account in a range of accounts.
+    + **To Account** - The last account in a range or 0 for only the first account.
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Include Opening Balance** - Whether to include the opening balance.
+    + **Accumulate Month Values** - Whether to accumulate the month values. This only applies to (M)onthly report types.
+    + **Print Values**
+        + **Yes** - Print
+        + **No** - Do not print
+        + **Debit** - Only print if the value is positive
+        + **Credit** - Only print of the value is negative
+    + **Normal Sign**
+        + **Positive** - The value for this account is normally positive
+        + **Negative** - The value for this account is normally negative
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the totals
+        + **Subtract** - Subtract the value from the totals
+        + **Ignore** - Do not add nor subtract the value
+    + **Ignore Account Type** - In the case of B and P report types, when the account type changes the heading will automatically also change. To ignore this action select this option.
+    + **Store Amount** - Whether you want to store the value for later
+    + **Storage Number** - The number to use when storing the value
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the storage
+        + **Subtract** - Subtract the value from the storage
+        + **Ignore** - Do not add nor subtract the value
++ **Group (G)** - This is used to group a number of accounts together
+    + **Group Number** - The group number
+    + **Description** - The group description
+    + **From Account** - The first account in a range of accounts.
+    + **To Account** - The last account in a range or 0 for only the first account.
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Include Opening Balance** - Whether to include the opening balance.
+    + **Accumulate Month Values** - Whether to accumulate the month values. This only applies to (M)onthly report types.
+    + **Print Values**
+        + **Yes** - Print
+        + **No** - Do not print
+        + **Debit** - Only print if the value is positive
+        + **Credit** - Only print of the value is negative
+    + **Normal Sign**
+        + **Positive** - The value for this account is normally positive
+        + **Negative** - The value for this account is normally negative
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the totals
+        + **Subtract** - Subtract the value from the totals
+        + **Ignore** - Do not add nor subtract the value
+    + **Ignore Account Type** - In the case of B and P report types, when the account type changes the heading will automatically also change. To ignore this action select this option.
+    + **Store Amount** - Whether you want to store the value for later
+    + **Storage Number** - The number to use when storing the value
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the totals
+        + **Subtract** - Subtract the value from the totals
+        + **Ignore** - Do not add nor subtract the value
+    + **Chart Label**
++ **Stored (S)**
+    + **Description** - The description of the stored value
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Print Values**
+        + **Yes** - Print
+        + **No** - Do not print
+        + **Debit** - Only print if the value is positive
+        + **Credit** - Only print of the value is negative
+    + **Normal Sign**
+        + **Positive** - The value for this account is normally positive
+        + **Negative** - The value for this account is normally negative
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the totals
+        + **Subtract** - Subtract the value from the totals
+        + **Ignore** - Do not add nor subtract the value
+    + **Clear Stored Value** - Whether to zero the stored amount
+    + **Storage Number** - The stored value's number
+    + **Percentage of Stored Value** - The percentage of the stored value to print
++ **Total (T)** - All values are automatically added into or subtracted from totals numbered from 1 to 9.
+    + **Description** - To description of the total or blank
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Total Level** - The total number to print
+    + **Print Values**
+        + **Yes** - Print
+        + **No** - Do not print
+        + **Debit** - Only print if the value is positive
+        + **Credit** - Only print of the value is negative
+    + **Normal Sign**
+        + **Positive** - The value for this account is normally positive
+        + **Negative** - The value for this account is normally negative
+    + **Clear Total** - Whether to zero the total
+    + **Store Amount** - Whether you want to store the value for later
+    + **Storage Number** - The number to use when storing the value
+    + **Add, Subtract or Ignore**
+        + **Add** - Add the value in the totals
+        + **Subtract** - Subtract the value from the totals
+        + **Ignore** - Do not add nor subtract the value
+    + **Chart Label**
++ **Uline (U)**
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Underline Type**
+        + **Single** - Single line
+        + **Double** - Double line
+        + **Blank** - Blank line
++ **Calc (C)** - Not Yet Implemented:
++ **Percent (P)** - This is a percentage of one stored amount against another stored amount.
+    + **Description** - The description of the percentage
+    + **Highlight** - Whether to print the line in bold characters.
+    + **Storage Number** - The first stored amount
+    + **Storage Number** - The second stored amount
+
+Detail Records (GL)
++++++++++++++++++++
+Use this routine to create, amend and delete detail records used by `Financial Statements (GL)`_ report formats.
+
++ **Code** - A sequential number for the detail record.
++ **Description** - A description of the detail.
+
+For each month in the financial year enter the following:
+
++ **Period** - A financial period i.e. CCYYMM
++ **Value** - A value for the period.
+
+Stream Records (GL)
++++++++++++++++++++
+Use this routine to create, amend and delete stream records used by `Financial Statements (GL)`_ report formats.
+
++ **Stream Number** - A sequential number for the stream record.
++ **Description** - A description of the stream.
+
+For each report in the stream enter the following:
+
++ **Seq** - A sequence number starting at 0.
++ **T** - The report type, S(mall), L(arge), M(onthly) or C(ustom).
++ **CN** - If the report type is a C then this is the custom report number.
++ **C** - Consolidation code, Y or N.
++ **Rep** - Report number.
++ **G** - General report, Y or N.
++ **V** - Report contents, V(alues), B(udgets), C(ombined) or D(etail).
++ **Cod** - For contents type D, enter the applicable detail code.
++ **Z** - Ignore zeros, Y or N.
++ **O** - Print the options line on report, Y or N.
++ **N** - Print account numbers on the report, Y or N.
++ **Printer Name** - The printer name to print on or None.
++ **E-Mail Address** - An email address to send the report to or leave blank.
+
+Bank Import Control (GL)
+++++++++++++++++++++++++
+Use this routine to create, amend and delete bank import control records. These records are used when importing bank statements to automatically create transactions for recurring entries e.g. charges, fees, interest, stop orders etc.
+
++ **Bank Account** - The G/L account number for the bank.
++ **Memo Code** - This is a 5 digit sequential number of the record. Entering a zero will automatically allocated the next number.
++ **Memo Desc Contains** - This together with the next two fields are used to correctly identify the transaction using the description appearing on the bank statement.
++ **Transaction Type** - Payment or Deposit.
++ **Allocation Company** - The company number to be debited or credited.
++ **Allocation Account** - The account number to be debited or credited.
++ **Chn** - The chain store code if the account number is the debtor's control account.
++ **Acc-Num** - If the account number is the creditor's or debtor's account enter the relevant creditor's or debtor's account number.
++ **Ageing Code** - If the account number is the creditor's or debtor's account select how to age the amount.
++ **Vat Code** - Enter the applicable V.A.T. code.
+
+Data Capture (GL)
+.................
+Opening Balances (GL)
++++++++++++++++++++++
+Use this routine to capture initial opening balances. You can also import these balances by selecting the `Import File` button in which case the file must be in `csv` or `xls` format and must contain the account number and balance fields.
+
+* **Acc-Num** - The account number.
+* **Balance** - The opening balance.
+
+Budgets (GL)
+++++++++++++
+Use this routine to capture monthly budgets for a specific financial period. You can also import budgets by selecting the `Import File` button in which case the file must be in `csv` or `xls` format and must contain all the fields as detailed in the prompt when you hover your cursor over the button. There is also an `Auto Populate` button which will create budgets based on the previous year's actual plus or minus a standard rate.
+
+* **Acc-Num** - The account number.
+* **F** - `M` to enter a monthly budget or `A` to enter an annual budget amount.
+* **Period** - If `M` was selected then enter the period i.e. YYYYMM.
+* **Budget** - The budget value.
+
+*Auto Populate*
+
+If the auto populate button is used the following screen will appear:
+
++ **Use Previous Year's** - Actual or Budgets.
++ **Standard Rate (+-)** - The rate to be used to increase or decrease the previous year's amounts.
++ **Rounding to Nearest** - Select the rounding requirement.
+
+You are now able to enter exclusions to the above parameters as follows:
+
++ **Acc-Num** - The generals ledger account number.
++ **Rate** - The rate to apply to this account.
+
+On exiting the the screen with the <Esc> key the budgets will be populated.
+
+Sales, Payments, Petty Cash, Purchases and Receipts (GL)
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+These data capture routines are similar in operation and therefore I will handle them together. Please note that if subsidiary books are integrated i.e. creditors and debtors, purchases and sales will not be available and an error message will be displayed if you attempt to access them.
+
+As with most data capture routines you will first have to enter the `Batch Details`_ after which the following screens and fields apply:
+
++ **Transaction**
+    + **T** - The transaction type (Petty Cash Only), (P)ayment or (R)eceipt.
+    + **Reference** - The document's reference number.
+    + **Date** - The date of the document.
+    + **Amount** - The total inclusive value of the document.
+    + **Details** - The description of the document.
++ **Allocation**
+    + **Coy** - The company number in multi company installations.
+    + **Acc-Num** - The general ledger account number to debit or credit.
+    + **Alloc-Amt** - The inclusive amount to be allocated to this account.
+    + **V** - The applicable V.A.T. code to apply to this allocation.
+    + **VAT-Amount** - The V.A.T. amount, which can be overridden.
+    + **Details** - The description of the allocation.
++ **ASS** - This only applies if the `Acc-Num` is one of the asset control accounts.
+    + **Grp** - The asset's group code.
+    + **Cod-Num** - The asset's code.
+    + **M** - The transaction type i.e. New purchase, improvement, write off, depreciation or sale of asset.
+    + **Amount** - The amount of the allocation.
+    + **Details** - The description of the allocation.
++ **BKM** - This only applies if the `Acc-Num` is the booking control account.
+    + **Bkm-Num** - The booking number.
+    + **Amount** - The amount of the allocation.
++ **CRS** - This only applies if the `Acc-Num` is the creditor's control account and the transaction type is payments or receipts.
+    + **Acc-Num** - The creditor's account number.
+    + **Ref-No2** - A further reference number if applicable.
+    + **Discount** - A discount amount.
+    + **Amount** - The amount to be allocated to this account.
++ **DRS** - This only applies if the `Acc-Num` is the debtor's control account and the transaction type is payments or receipts.
+    + **Chn** - The chain store code, if chain stores apply.
+    + **Acc-Num** - The debtor's account number.
+    + **Ref-No2** - A further reference number if applicable.
+    + **Discount** - A discount amount.
+    + **Amount** - The amount to be allocated to this account.
++ **LON** - This only applies if the `Acc-Num` is the staff loans control account.
+    + **Acc-Num** - The account number.
+    + **Ln** - The loan number.
+    + **Description** - The description of the loan, new loans only.
+    + **Amount** - The amount of the loan.
+    + **Rate-%** - The new interest rate to apply to the loan.
+    + **Mth** - The interest rate to apply to the loan.
+    + **Repayment** - The new amount to be repaid monthly.
++ **MEM** = This only applies if the `Acc-Num` is the members control account.
+    + **Mem-Num** - The member's number.
+    + **Discount** - A discount amount.
+    + **Amount** - The amount to be allocated to this member.
++ **SLN** - This only applies if the `Acc-Num` is the staff loans control account.
+    + **EmpNo** - The employee number.
+    + **Ln** - The loan number.
+    + **Amount** - The amount of the loan.
+    + **Cde** - The new deduction code to use to repay the loan.
+    + **Intr-%** - The new interest rate to apply to the loan.
+    + **Ded-Amt** - The new amount to be deducted from earnings to repay the loan.
+
+If you have allocated the transaction to a creditor's, debtor's or member's account you might be required to age the amount as described in `Ageing Transactions`_ above.
+
+Manual Journal Entries (GL)
++++++++++++++++++++++++++++
+Use this routine to capture manual journal entries. You can also import journals by selecting the `Import File` button in which case the file must be in `csv` or `xls` format and must contain all the fields as detailed in the prompt when you hover your cursor over the button.
+
+As with most data capture routines you will first have to enter the `Batch Details`_ after which the following fields apply:
+
++ **Ref-Num** - The journal number.
++ **Date** - The date of the journal.
++ **Coy** - The company number in multi company installations.
++ **Acc-Num** - The general ledger account number to debit or credit.
++ **Amount** - The inclusive amount of the journal.
++ **V** - The applicable V.A.T. code to apply to this journal.
++ **VAT-Amt** - The V.A.T. amount, which can be overridden.
++ **Details** - The description of the journal.
+
+The *List All* button will show you all the postings captured, including those which have scrolled off the screen, for checking purposes.
+
+Please note that you will not be able to exit this routine until the debits equal the credits. Credits are entered as minus amounts.
+
+Standard Journal Entries (GL)
++++++++++++++++++++++++++++++
+Use this routine to raise standard journal entries as created using `Standard Journals (GL)`_.
+
+As with most data capture routines you will first have to enter the `Batch Details`_ after which the following fields apply:
+
++ **Frequency** - Select the frequency of the journals to be raised.
++ **All Journals** - Select whether to raise all journals for the selected frequency.
++ **All Periods** - Select whether to raise journals for all periods from the start of the current financial period up to and including the batch header period.
+
+Bank Statements (GL)
+++++++++++++++++++++
+Use this routine to capture bank statements. This is to facilitate reconciling the bank accounts with the bank statements. This routine can also used to capture receipts, payments and journal entries affecting the bank account e.g. all entries on the bank statement not yet entered into the bank account can be processed during this routine.
+
+As with most data capture routines you will first have to enter the `Batch Details`_.  The following buttons will then be available:
+
++ **Exit** - This exits out of the capture routine as per using the <Escape> key.
++ **Import Bank File** - This routine is used to import a bank statement file as described under `Control Accounts (GL)`_.
+
+    Once you have selected the file to import the system will automatically flag all transactions which already exist on your database.
+
+    If there are more than one transaction satisfying the comparison criteria these transactions will be displayed and you will have to select the transaction to be flagged. Should none of the transactions be the correct one, click the `Quit` button to skip allocating it.
+
+    While importing, if a duplicate record is detected, i.e. a possible duplication of the import file, a message will be displayed giving you the choice of importing it or not.
+
+    At the end of the import process a screen will be displayed showing all unallocated transactions. You must now capture these transactions as per the next option i.e. `Process Bank Data`.
+
++ **Process Bank Data** - This routine is to continue an import which was suspended for whatever reason. This is also the procedure for capturing unallocated transactions from the previous option i.e. `Import Bank File`. A screen showing all the unallocated transactions will display.
+
+  Select a transaction to process by clicking on it or moving the cursor to it and hitting the `Enter` key.  Continue from the `Details` field in the following section.
+
++ **Manual Entries** - Use this procedure to enter the bank statement manually. If there are unallocated records from a previous import then this will be highlighted and you will first have to allocated these using the `Process Bank Data` routine, before continuing.
+
+    + **T** - Enter the transaction type i.e. (P)ayment or (R)eceipt.
+    + **Ref-Num** - Enter the reference number. If the transaction already exists on your database it will be flagged as either paid or received i.e. will not appear on the bank reconciliation statement. If the transaction does not already exist you can capture it by entering the following fields:
+
+    + **Date** - Enter the transaction date.
+    + **Amount** - Enter the transaction amount.
+    + **Details** - The details for this transaction.
+
+    You will then be asked to confirm your entry and if you do so you will be able to allocate the transaction as in `Sales, Payments, Petty Cash, Purchases and Receipts (GL)`_ above.
+
+Reporting (GL)
+..............
+Batch Error Listing (GL)
+++++++++++++++++++++++++
+Use this routine to print any unbalanced batches.
+
++ **Type** - The transaction type or 0 for all.
++ **Batch-Number** - The batch number or blank for all.
+
+Transaction Audit Trail (GL)
+++++++++++++++++++++++++++++
+Use this routine to print lists of transactions either by financial period or date of capture.
+
++ **Period Type** - Financial or Capture.
++ **Starting Period** - The first financial period to include in the report.
++ **Ending Period** - The last financial period to include in the report.
++ **Starting Date** - The from date to include in the report.
++ **Ending Date** - The to date to include in the report.
++ **Type** - The transaction type or 0 for all.
++ **Batch-Number** - The batch number or blank for all.
++ **Totals Only** - Yes or No.
++ **Include Other Companies** - Whether or not to include other companies. If yes, you will be prompted at a later stage to select which other companies to include.
+
+Account Statements (GL)
++++++++++++++++++++++++
+Use this routine to produce statements for individual ledger accounts.
+
+* **Whole File** - `Yes` for all accounts, `Range` for a range of accounts or `Singles` to select individual accounts.
+* **From Account** - If range was selected enter the starting account number.
+* **To Account** - If range was selected enter the ending account number.
+* **Starting Period** - The starting financial period in the financial year.
+* **Ending Period** - The ending financial period in the financial year.
+* **Separate Pages** - Select whether or not to print each account on a new page.
+
+Trial Balance (GL)
+++++++++++++++++++
+Use this routine to produce a trial balance.
+
+* **Opening Balances Only** - Select whether or not to only print opening balances.
+* **Include Opening Balances** - Select whether or not to include opening balances.
+* **Starting Period** - The starting financial period in the financial year.
+* **Ending Period** - The ending financial period in the financial year.
+* **Ignore Zero Balances** - Select whether or not to ignore zero balances.
+
+Financial Statements (GL)
++++++++++++++++++++++++++
+Use this routine to produce financial statements using the information as set up with `Report Generator (GL)`_.
+
+* **Ending Period** - The last period, in the financial year, to take into account.
+* **Stream Number** - To print the reports as enumerated in a stream record as created using `Stream Records (GL)`_.
+* **Report Type** - Select the relevant report type.
+* **Consolidate Companies** - Select whether or not to print a consolidated report. This is only applicable in a multi company installation.
+* **Report Number** - The relevant report number as created using `Report Generator (GL)`_.
+* **General Report** - Select whether or not the report is a general report.
+* **Contents** - Select which values to use in the report.
+* **Detail Code** - If `Detail` was selected above, enter the detail code as created using `Detail Records (GL)`_.
+* **Ignore Zeros** - Select whether or not to ignore lines with zero balances.
+* **Print Options** - Select whether or not to include the selected options on the report heading.
+* **Account Numbers** - Select whether or not to include the account numbers in the report.
+
+Chart of Accounts (GL)
+++++++++++++++++++++++
+Use this routine to produce a chart of accounts.
+
+* **Sort Order** - Select the order by which the report must be sorted.
+
+Notes Listing (GL)
+++++++++++++++++++
+Use this routine to print any notes on the general ledger accounts.
+
++ **Action Flag** - Normal or Urgent.
++ **From Capture Date** - The starting creation date.
++ **To Capture Date** - The ending creation date.
++ **From Action Date** - The starting action date.
++ **To Action Date** - The ending action date.
+
+Bank Reconciliation (GL)
+++++++++++++++++++++++++
+Use this routine to produce a bank reconciliation statement.
+
+* **Bank Account** - The bank account number.
+* **Accounting Period** - The relevant period in the financial year.
+
+Imported Bank Statements (GL)
++++++++++++++++++++++++++++++
+Use this routine to produce a report of imported bank statements.
+
++ **Bank Account** - Bank account number.
++ **From Date** - The starting date.
++ **To Date** - The ending date.
++ **Unallocated Only** - Whether to only print entries which have not yet been allocated.
+
+Consolidated Trial Balance (GL)
++++++++++++++++++++++++++++++++
+Use this routine to produce a consolidated trial balance of groups of companies.
+
++ **Financial Period** - The relevant financial period.
++ **Ending Period** - The last period to include in the report.
++ **Group** - The group code of the companies.
++ **Description** - The description of the group.
+
+Multi-Company Reports (GL)
+++++++++++++++++++++++++++
+Use this routine to produce financial statements for multiple companies.
+
++ **Financial Period** - The relevant financial period.
++ **Ending Period** - The last period to include in the report.
++ **Trial Balance** - Select whether to produce trial balances.
++ **Financials** - Select whether to produce financial statements.
++ **Report Type** - Select the financial statement report type.
++ **Report Number** - Select the financial statement report number.
++ **Contents** - Select the financial statement contents type.
++ **Ignore Zeros** - Select whether to include accounts with zero balances.
+
+Quick Trading Results (GL)
+++++++++++++++++++++++++++
+Use this routine to produce quick trading results reporting.
+
++ **Financial Period** - The financial period to report on.
++ **Ending Period** - The last period to include in the report.
+
+The following Buttons are now available:
+
++ **Import** - Use this button to import values, by company, for additional purchases, sales, incentives, invoices in transit and closing stock.
++ **Manual** - Use this button to  manually edit branches and departments.
+    + **Branch Details**
+        + **Branch Code** - The branch code to create/amend.
+        + **Branch Name** - The name of the branch.
+        + **Country Code** - The country where the branch operates.
+        + **Group Code** - The group the branch is part of.
+    + **Department Details**
+        + **Dep** - The department code.
+        + **Coy** - The company code.
+        + **Purchases** - The additional purchases value.
+        + **Sales** - The additional sales value.
+        + **Incentives** - The additional incentives value.
+        + **Transit** - The invoices in transit value.
+        + **Stock** - The closing stock value.
+    + **Edit** - Use this button to edit department values.
++ **Print** - Use this button to generate and print the reports.
+    + **Totals Only** - Select whether to only print totals.
+    + **All Branches** - Select whether to print selected branches only.
+    + **Department Totals** - Select whether to print department totals.
+    + **Graphs** - Select whether to print graphs for the selections.
++ **Exit** - Use this button to exit the financial period.
+
+Toolbox (GL)
+............
+Change Account Numbers (GL)
++++++++++++++++++++++++++++
+Use this routine to change account numbers within a company.
+
+* **Old Number** - The current account number to change.
+* **New Number** - The new account number. It must not already exist.
+
+Copy Masterfile Records (GL)
+++++++++++++++++++++++++++++
+Use this routine to copy accounts from another company.
+
+* **Copy From Company** - The company number from which to copy.
+* **Include ...** - Select what additional data is to be copied.
+
+Integrated Controls Report (GL)
++++++++++++++++++++++++++++++++
+Use this routine to produce a report showing the balance status of integrated systems and their respective control accounts.
+
+* **Cut Off Period** - The relevant period in the financial year.
+
+Intercompany Accounts Report (GL)
++++++++++++++++++++++++++++++++++
+Use this routine to produce a report showing the balance status of intercompany accounts in a multi company installation.
+
+Initialise Bank Reconciliation (GL)
++++++++++++++++++++++++++++++++++++
+Use this routine to initialise the bank reconciliation.
+
+* **Bank Account** - The bank account number.
+* **Last Period** - The last reconciled period.
+* **Clear History** - Select whether or not to mark all transactions up to the `Last Period` as being cleared through the bank.
+
+Now capture all the outstanding transactions as at the `Last Period`.
+
++ **T** - Enter the transaction type i.e. (P)ayment or (R)eceipt.
++ **Ref-Num** - Enter the transaction reference number.
+
+Merge Accounts Into a Control (GL)
+++++++++++++++++++++++++++++++++++
+Use this routine to transfer all transactions of selected accounts into a control account and then delete the accounts e.g. Transfer individual loan accounts into a loan's control account.
+
+Interrogation (GL)
+..................
+This routine is for querying individual general ledger accounts.

=== modified file 'doc/IB.rst'
--- doc/IB.rst	2016-02-27 13:18:41 +0000
+++ doc/IB.rst	2016-04-04 19:18:01 +0000
@@ -20,10 +20,12 @@
 
 For each delivery enter the following:
 
++ **Our Reference** - The local reference number e.g. Order Number.
 + **Branch** - The branch number to be invoiced.
 + **D/Note** - The delivery note number.
 + **D/Date** - The delivery date.
-+ **Supplier** - The supplier's account number.
++ **Supplier-1** - The first supplier's account number.
++ **Supplier-2** - The second supplier's account number, if applicable.
 + **Transporter** - The transporter's account number.
 
 For each product enter the following:
@@ -34,6 +36,16 @@
 + **Quantity** - The quantity delivered.
 + **Value** - The line value.
 
+Buttons:
+
++ **Accept** - Use this button to finalise the invoice.
++ **Edit** - Use this button to edit an existing invoice or the current invoice.
++ **Cancel** - Use this button to cancel the current invoice or any editing.
+
+.. raw:: pdf
+
+    PageBreak
+
 Creditor's Invoices (IB)
 ++++++++++++++++++++++++
 Use this routine to capture supplier's and transporter's invoices.
@@ -42,20 +54,14 @@
 
 For each invoice in the purchase journal enter the following:
 
++ **T** - The creditor's product type, S (Supplier) or T (Transporter).
 + **Acc-Num** - The creditor's account number.
++ **D** - The creditor's document type, I (Invoices) or C (Credit Notes).
 + **Reference** - The document number.
-+ **Ref-Date** - The document number.
-+ **Amount** - The total inclusive value of the document.
-+ **V** - The tax code.
-+ **V.A.T.** - The tax amount.
 
 For each inter branch invoice relating to the creditor's invoice enter the following:
 
 + **I.B.T-Inv** - The inter branch invoice number.
-+ **Product-Cd** - The product code.
-+ **Quantity** - The product quantity.
-+ **Price** - The product price.
-+ **Value** - The product exclusive value.
 
 Reporting (IB)
 ..............
@@ -73,10 +79,12 @@
 Use this routine to print lists of inter branch invoices by branch.
 
 + **Reprints** - Select whether to reprint previously printed journals.
-+ **Preview Only** - Select whether to print preview journals.
-+ **Branch Code** - The branch to reprint else 0 for all branches.
-+ **Start Number** - The first journal to reprint.
-+ **End Number** - The last journal to reprint.
+    + **Yes**
+        + **Branch Code** - The branch to reprint else 0 for all branches.
+        + **Start Number** - The first journal to reprint.
+        + **End Number** - The last journal to reprint.
+    + **No**
+        + **Preview Only** - Select whether to only *preview* journals.
 
 Sales Report (IB)
 +++++++++++++++++

=== modified file 'doc/MB.rst'
--- doc/MB.rst	2016-03-01 14:42:33 +0000
+++ doc/MB.rst	2016-05-21 12:42:20 +0000
@@ -2,7 +2,7 @@
  TARTAN SYSTEMS - Bowling Clubs
 ================================
 
-:Version:   5.2.1
+:Version:   5.2.2
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -63,7 +63,7 @@
 ------
 Update File Formats
 ...................
-Everytime you perfor an upgrade of Tartan you will have to run this routine as well. This routine will automatically update all table formats in the database.
+Every time you perform an upgrade of Tartan you will have to run this routine as well. This routine will automatically update all table formats in the database.
 
 Backup Database
 ...............
@@ -133,14 +133,16 @@
 
     + **Theme** - The theme to be used. The default theme is `Default`.
 
-|
-
 After you exit from the configuration routine elect to Exit and Save Tartan. You must then restart Tartan and if you have not yet created your database you will be prompted to do so.
 
 Quit
 ....
 Select this to exit Tartan.
 
+.. raw:: pdf
+
+    PageBreak
+
 Control
 -------
 System Record
@@ -166,362 +168,3 @@
 While most of the fields are self explanatory the following are of note:
 
 + **E-Mail Address** - Your default email address.
-
-Bowling Clubs
--------------
-File Maintenance
-................
-Control Record (BC)
-+++++++++++++++++++
-Use this routine to create the bowls control record.
-
-+ **M/L Integration** - Select whether or not the bowls system is integrated with the Member's system.
-+ **Same Numbers** - If integrated with the member's system is the tab number the same as the member number.
-+ **Male Start Seq** - The number range for male bowler's tab numbers.
-+ **Female Start Seq** - The number range for female bowler's tab numbers.
-+ **Non-member Start Seq** - The number range for non-member's player codes. This number must be greater than the male and female numbers.
-+ **Draw Base** - By pre-allocated Position, Rating or a Combination of both.
-+ **Rating Order** - Whether the rating system is ascending or descending, like golf handicaps.
-+ **Replace Fours** - When doing a trips tabs-in draw use pairs instead of fours for eight players.
-+ **Weeks Between Draws** - The minimum number of weeks that team members should not be in the same team again. They could however be drawn to play against them.
-+ **Rate - Member** - The member's rate.
-+ **Rate - Visitor** - The visitor's rate.
-+ **Greens** - The available green codes e.g. AB
-
-Club's Records
-++++++++++++++
-Use this routine to add, amend and delete clubs.
-
-+ **Club Code** - The applicable club's code. A zero code will automatically select the next available code.
-+ **Club Name** - The name of the club.
-
-Tabs Maintenance
-++++++++++++++++
-Use this routine to create, delete or amend tab records.
-
-+ **Tab Number** - The number of the tab or zero for the next available number depending on the gender of the member.
-+ **Membership Number** - If the Member system is integrated enter the member's membership number and the details will be obtained from there.
-+ **Surname** - The person's surname.
-+ **Names** - The person's names.
-+ **Gender** - The person's gender.
-+ **Address Line 1** - The person's address line 1.
-+ **Address Line 2** - The person's address line 2.
-+ **Address Line 3** - The person's address line 3.
-+ **Postal Code** - The person's postal code.
-+ **Home Number** - The person's home phone number.
-+ **Work Number** - The person's work phone number.
-+ **Cell Number** - The person's mobile phone number.
-+ **Email Address** - The person's email address.
-+ **Position - Primary** - The position the person should normally play.
-+ **Rating - Primary** - The person's rating as graded by the selectors.
-+ **Position - Mixed** - The position the person should play in mixed bowls.
-+ **Rating - Mixed** - The person's rating in mixed bowls.
-+ **Association Number** - The person's number with the bowling association.
-
-In addition there are the following buttons.
-
-+ **Import** - Use this button to import, only tab ratings for existing tabs or all tab details for existing and new members, from an excel (xls) or comma separated (csv) file.
-+ **Print** - Use this button to print a listing of member's details.
-
-League Formats
-++++++++++++++
-Use this routine to create league format records e.g. Flag or Muter.
-
-+ **Format Code** - The applicable format code. A zero code will automatically select the next available code.
-+ **Description** - The description of the format.
-+ **Assessment Forms** - Allow printing of assessment forms.
-+ **Number of Forms** - Print assessment form per team or individual.
-+ **Assess Self** - Whether the player must assess himself.
-+ **Rating Out Of** - What the maximum assessment rating could be.
-+ **Sets Format** - Whether sets are to be played.
-+ **Logo** - The logo image file of the sponsor, if applicable.
-
-Side's Maintenance
-++++++++++++++++++
-Use this routine to create or amend side records. These are sides as entered in the league e.g. `WPCC A` or `WPCC B`.
-
-+ **Format Code** - The applicable league format code as created using `League Formats`_.
-+ **Side Code** - The applicable side code. A zero code will automatically select the next available code.
-+ **Description** - The description of the side e.g. `WPCC A`
-+ **League** - Select whether this side is playing in the `Main` or `Friendly` league.
-+ **Division** - The division that the side is playing in e.g. `PR`, `1A` etc.
-+ **Number of Teams** - The number of teams in the side.
-+ **Active Flag** - Whether or not this side is still active. If a team gets relegated or promoted it must be made inactive and a new side must be created. An inactive side can be made active again in the future if it once again becomes applicable.
-
-Player's Maintenance
-++++++++++++++++++++
-Use this routine to create, delete or amend competition player's records. Most of the fields are self explanatory with the exception of:
-
-+ **Code** - The player's number or zero for the next available number.
-+ **Tab Number** - The tab number if the player is a member of the club.
-+ **Club Code** - The player's club code or zero for the next available number in which case you must enter the name of the club.
-
-Competition Types
-+++++++++++++++++
-Use this routine to create competition type records as follows:
-
-+ **Type Code** - zero for the next number else an existing number. To see existing types press the F1 key.
-+ **Description** - The competition description.
-+ **Competition Format** - The type of competition i.e. Tournament, Knockout or Round Robin.
-+ **Team Size** - The number of players in a team.
-+ **Number of Games** - The total number of games comprising the competition.
-+ **Number of Ends per Game** - The number of ends to be completed in a game.
-+ **Groups by Position** - Whether or not the teams must be split into different groups. If grouping is not going to occur continue with `Skins` below.
-+ **Group After Game** - Select the game after which the grouping is to take place.
-+ **Adjust Scores** - Whether or not the scores are to be adjusted.
-+ **Expunge Games** - Which games, if any, must be expunged i.e. cleared. The games must be comma separated e.g. 1,2
-+ **Retain Percentage** - What percentage of the shots of the games, not expunged, must be retained when split into groups.
-+ **Number of Drawn Games** - The number of games which are randomly drawn. Enter 99 for a Round Robin.
-+ **Strict S v S** - Whether the competition is strictly strength versus strength i.e. teams could play each other again before the last game.
-+ **Skins** - Whether or not to have skins.
-+ **Number of Ends per Skin** - If skins were selected then enter the number of games per skin.
-+ **Points Only** - Only points are to be captured i.e. no shots.
-+ **Points per End** - Number of points per end won.
-+ **Points per Skin** - If skins were selected then enter the number of points allocated per skin.
-+ **Points per Game** - Number of points for the game.
-+ **Bonus Points** - Whether to allocated a bonus point.
-+ **Win by More Than** - If bonus points are allocated enter the number of points which the winning margin must be more than.
-+ **Lose by Less Than** - If bonus points are allocated enter the number of points which the losing margin must be less than.
-
-Tabs Draw
-.........
-New Draw
-++++++++
-Use this routine to make a New Draw.
-
-+ **Date** - The date of the draw.
-+ **Time** - The time of the draw.
-+ **Mixed Gender** - Whether or not the draw is mixed.
-+ **Mixed Rating** - Whether or not to use the alternative ratings.
-+ **Draw By** - If available select whether to base the draw on Positions, Ratings or a Combination of both.
-+ **Rates - Member** - The price charges per member.
-+ **Rates - Visitor** - The price charges per visitor.
-
-Once the above fields have been entered capture all tabs as follows:
-
-+ **Tab Number** - The player's tab number. Enter zero for a visitor. A number will be allocated to the visitor which can then be written on his tab e.g. 901.
-+ **Surname** - The player's surname. Only for visitors.
-+ **Names** - The player's names. Only for visitors.
-+ **Gender** - The player's gender. Only for visitors.
-+ **Position** - The player's position. Only for visitors.
-+ **Rating** - The player's rating. Only for visitors.
-+ **Paid** - Whether or not the player has paid.
-
-The following *Buttons* are available:
-
-+ **Arranged** - Use this button to enter arranged matches.
-+ **Entered** - Use this button to display all entered players.
-+ **Modify** - Use this button to change the player's position/ratings.
-+ **Draw** - Use this button to make the draw once all tabs have been entered. You will have to enter the following:
-
-    + **Team Size** - The preferred number of players per team.
-    + **Replace Fours** - Whether or not to replace fours with pairs. This only applies when the team size is three.
-    + **Greens** - The greens to be used. This is in the format A,B or A,B234 showing green code and rinks. If the rinks are not entered they will default to 6. If there are more rinks available than needed, end rinks will be removed.
-+ **Print** - Use this button to print a draw.
-
-    + **Cash Takings Sheet** - Print a cash takings sheet.
-    + **Tabs Draw Listing** - Print a tabs draw list in tab number.
-    + **Tabs Draw Board** - Print an emulation of a tabs draw board.
-    + **Include Empty Rinks** - Whether to include or exclude empty rinks when printing a tabs draw board.
-+ **Edit Draw** - Use this button to manually change a draw.
-+ **Exit** - Use this button to exit the program. If the draw has not yet been done you will be prompted to confirm exiting.
-
-Reprint Draw
-++++++++++++
-Use this routine to reprint a previous draw.
-
-+ **Date** - The date of the draw.
-+ **Time** - The time of the draw.
-
-League Selections
-.................
-Capture Selections
-++++++++++++++++++
-Use this routine to capture team selections as follows:
-
-+ **Format Code** - The applicable league format code as created using `League Formats`_.
-+ **Type** - Select the type of match, Fixture or Practice.
-+ **Match Date** - YYYYMMDD.
-+ **Side Code** - The applicable side code. If no sides have as yet been entered enter a zero and create a side code as follows:
-    + **Side Description** - The description on the side.
-    + **League (M/F)** - Main or Friendly league.
-    + **Side Division** - The division of the side. PR for the premier side and 1A, 1B, 2A etc
-    + **Number of Teams** - The number of teams in the side.
-+ **Opposition Code** - The applicable opposition side code. If the opponent's record has not yet been captured enter a zero and create the opposition's side code as follows:
-    + **Club Code** - Enter an existing club code or zero for a new club.
-    + **Club Name** - Enter the club's name if it is a new club.
-    + **Side Name** - Enter the opposition side's name e.g. WPCC A or WPCC B
-+ **Venue (H/A/Name)** - Enter where the match is being played, at (H)ome, (A)way or another location.
-+ **Meeting Time** - Enter the time the side must meet on the day of the match.
-+ **At (H/A/Name)** - Enter where the side must meet, at (H)ome, (A)way or another location.
-+ **Captain Code** - The tab code of the captain.
-+ **Enter the teams as follows**:
-    + **Skp** - The tab code of the skip.
-    + **Plr** - The tab code of the next team member.
-+ When all sides have been entered press the `Esc` key twice to exit. You will then be asked whether or not you would like to View or Print the Selections. If Yes continue as follows:
-    + **Output** - Select the type of output.
-    + **E-Mail Report** - Select whether to email the forms.
-    + **E-Mail Address** - The email address(es), comma separated, to email the forms to.
-
-Assessment Forms
-++++++++++++++++
-Use this routine to print assessment forms as follows:
-
-+ **Format Code** - The applicable league format code.
-+ **Type** - Select the type of match, Fixture or Practice.
-+ **Match Date** - Enter the match date to print.
-
-Declaration Forms
-+++++++++++++++++
-Use this routine to print declaration forms as follows:
-
-+ **Format Code** - The applicable league format code.
-+ **Match Date** - Enter the match date to print.
-
-Capture Assessments
-+++++++++++++++++++
-Use this routine to capture completed assessment forms as follows:
-
-+ **Format Code** - The applicable league format code.
-+ **Type** - Select the type of match, Fixture or Practice.
-+ **Match Date** -  Enter the match date to capture.
-+ **Number of Forms** - The number of forms per team.
-+ For each completed form enter the following.
-    * **Skp** - The skip's tab code.
-    * **Plr** - If capturing 4 forms per team enter the player's tab code.
-    * **SF** - The number of shots the team scored.
-    * **SA** - The number of shots the opposition scored.
-    * **4** - The skip's rating.
-    * **3** - The third's rating.
-    * **2** - The second's rating.
-    * **1** - The lead's rating.
-    * **Remarks** - Any remarks.
-
-Match Assessment Report
-+++++++++++++++++++++++
-Use this routine to print a match assessment reports as follows:
-
-+ **Format Code** - The applicable league format code.
-+ **Type** - Select the type of match, Fixture or Practice.
-+ **Match Date** - Enter the match date to print.
-
-Assessment Summary
-++++++++++++++++++
-Use this routine to print an assessment summary as follows:
-
-+ **Format Code** - The applicable league format code.
-+ **Type** - Select the type of match, Fixture or Practice.
-+ **First Round Date** - Enter the date that the first round of the season was played.
-
-Club Competitions
-.................
-Capture Entries
-+++++++++++++++
-Use this routine to capture entries in a competition as follows:
-
-+ **Competition Code** - The relevant competition number or zero for the next available number.
-+ **Competition Name** - The name of the competition.
-+ **Date** - The starting date of the competition.
-+ **Type** - The competition type as created in `Competition Types`_.
-
-Enter the Skip's Codes
-
-+ **Skp** - The skip's code as created in `Player's Maintenance`_ or you can enter a zero to enter a new player as per `Player's Maintenance`_.
-+ **Ptr** - The partner's code, in the case of pairs, as created in `Player's Maintenance`_ or you can enter a zero to enter a new player as per `Player's Maintenance`_.
-+ **P** - Whether or not the skip has paid, Y or N.
-
-Print Match Cards
-+++++++++++++++++
-Use this routine to create a draw and to print match cards as follows:
-
-+ **Competition Code** - The relevant competition code.
-+ **Game Number** - The relevant game number.
-+ **Game Date** - The date of the game.
-+ **Number of Groups** - The number of groups, if applicable, to split the players into.
-+ **Greens** - The greens to be used, comma separated e.g. A,B,C
-+ **Group per Green** - Whether to allocate greens to groups. This only applies to the final game.
-+ **Print Cards** - Whether or not to print score cards.
-+ **All Cards** - If cards were selected to be printed, whether to print all cards or only a select few.
-+ **Template Name** - The template to use for the cards.
-+ **Output** - Whether to view the reports or simply print them.
-+ **Printer Name** - The printer to use for printing.
-
-Print Cards Summary
-+++++++++++++++++++
-Use this routine to print a summary of all draws to date.
-
-Change Match Cards
-++++++++++++++++++
-Use this routine to change individual match cards. After changing the cards you must reprint them as per `Print Match Cards`_. Please note that to only reprint certain cards you must select `All Cards No`.
-
-+ **Competition Code** - The relevant competition code.
-+ **Game Number** - The relevant game number.
-+ **Greens** - The available greens comma separated e.g. A,B,C
-    + **SKC** - The skip's code.
-    + **OPP** - The opposition's code.
-    + **GR** - The rink number e.g. A1
-
-Capture Results
-+++++++++++++++
-Use this routine to capture completed matches as follows:
-
-+ **Competition Code** - The relevant competition code.
-+ **Game Number** - The relevant game number.
-+ **Ends Completed** - The number of ends completed. Enter a zero to abandon a game.
-    + **SKC** - The skip's code.
-    + **SF** - Shots scored by the skip's side.
-    + **Pnts** - Points scored by the skip's side.
-    + **OPP** - The opposition's code.
-    + **SA** - Shots scored by the opposing side.
-    + **Pnts** - Points scored by the opposing side.
-
-Print Game Results
-++++++++++++++++++
-Use this routine to print game results as follows:
-
-+ **Competition Code** - The relevant competition code.
-+ **Game Number** - The relevant game number.
-
-Print Match Results
-+++++++++++++++++++
-Use this routine to print the match results as follows:
-
-+ **Competition Code** - The relevant competition code.
-+ **Last Game** - The last game to take into account.
-+ **Session Prizes by Group** - Whether session prizes are to be awarded by group or overall.
-
-Prizes by Group or the Match if not Grouped
-
-+ **Number Prizes** - The number of prizes being awarded.
-+ **EFT Forms** - Whether to print EFT Forms in which case you will be required to enter the total value of each prize.
-
-Contact Request Forms
-+++++++++++++++++++++
-Use this routine to print forms with player's missing contact details.
-
-Toolbox
-.......
-Change Tab Numbers
-++++++++++++++++++
-Use this routine to change Tab numbers.
-
-+ **Old Tab** - The old tab number
-+ **New Tab** - The new tab number
-
-The **Generate** button is used to automatically renumber tabs in surname and names sequence.
-
-Change Player's Codes
-+++++++++++++++++++++
-Use this routine to change player's codes.
-
-+ **Old Code** - The old code
-+ **New Code** - The new code
-
-The **Generate** button is used to automatically generate new codes in surname and names order.
-
-Clear League History
-++++++++++++++++++++
-Use this routine to erase all previous selection data as well as selectively erasing player and opponent details. Please ensure that you have a **backup** before selecting this routine as there is no going back.
-
-+ **Clear Players** - Select whether or not to also erase all player's details.
-+ **Clear Opponents** - Select whether or not to also erase all opponent's details.

=== modified file 'doc/MD.rst'
--- doc/MD.rst	2016-03-01 14:42:33 +0000
+++ doc/MD.rst	2016-05-21 12:42:20 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.2.1
+:Version:   5.2.2
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -55,13 +55,16 @@
 Ensure that the following dependencies are installed on your system:
 
 + python >= 2.7.5 and < 3.0.0
+
+Windows also requires pywin32 >= build 216 downloaded from:
+
+    https://sourceforge.net/projects/pywin32/files/pywin32/
+
+The following dependencies must be installed using pip:
+
 + pillow >= 2.3.0
 + fpdf >= 1.7.0
 
-Windows also requires the following:
-
-+ pywin32 >= build 216
-
 Additionally, the following dependencies should also be installed using pip:
 
 + odfpy
@@ -74,7 +77,6 @@
 
 And, depending on your database needs, one of:
 
-+ SQLite - The module is already in python
 + Postgresql - psycopg2
 + MySQL - mysqlclient
 + Firebird - fdb

=== modified file 'doc/SC.rst'
--- doc/SC.rst	2016-02-27 13:18:41 +0000
+++ doc/SC.rst	2016-05-10 05:49:16 +0000
@@ -133,8 +133,6 @@
 
     + **Theme** - The theme to be used. The default theme is `Default`.
 
-|
-
 After you exit from the configuration routine elect to Exit and Save Tartan. You must then restart Tartan and if you have not yet created your database you will be prompted to do so.
 
 Quit

=== modified file 'doc/UD.rst'
--- doc/UD.rst	2015-06-17 15:23:42 +0000
+++ doc/UD.rst	2016-05-10 05:24:05 +0000
@@ -1,5 +1,26 @@
 Utilities
 ---------
+Telephone Directory
+...................
+Use this routine to manage a telephone directory.
+
+All the fields are self explanatory with the exception of the following:
+
++ **Directory Groups** - These are 3 letter group codes. If the code does not exist you will have to also enter the group description. This code can also be used in the bulk mailing module.
+
++ **Directory Entries** - These are the individual directory entries. All the fields are self explanatory with the exception of the 'Contact Groups' which is a comma separated list of directory groups.
+
++ **Buttons**
+    + **Back** - Select this button to display the previous directory entry.
+    + **Forward** - Select this button to display the next directory entry.
+    + **Import** - Select this button to import all contacts from other sources e.g. Creditors, Debtors, Members, Bookings etc.
+    + **Notes** - Select this button to maintain notes relating to this entry.
+    + **Print** - Select this button to print all entries or the current entry.
+    + **Apply** - Select this button to apply current addition or change.
+    + **Contacts** - Select this button to maintain contacts of the current entry.
+    + **Cancel** - Select this button to cancel any current additions or changes.
+    + **Quit** - Select this button to quit the application.
+
 Bulk Mail Utility
 .................
 Use this routine to send bulk MAIL or bulk SMSes. In order to use the MAIL facility you must enter a valid SMTP server in the `System Control Record`. In order to use the SMS facility you must register with www.smsportal.co.za and then enter your username and password in the `System Control Record` using `System Record Maintenance`_.
@@ -196,26 +217,3 @@
     + **Y2 Co-Ordinate** - The bottom position of the imported data in mm.
     + **Number of Lines** - The number of lines the imported data can contain e.g. a name and address could be 5 lines.
     + **Repeats** - The number of time to repeat the imported data e.g. the number of lines in the body of a statement could be 30.
-
-.. raw:: pdf
-
-    PageBreak
-
-Telephone Directory
-...................
-Use this routine to manage a telephone directory.
-
-All the fields are self explanatory with the exception of the following:
-
-+ **Contact Group** - This is a 3 letter group code. If the code does not exist you will have to also enter the group description. This code is used in the bulk mailing module.
-
-+ **Buttons**
-    + **Back** - Select this button to display the previous directory entry.
-    + **Forward** - Select this button to display the next directory entry.
-    + **Import** - Select this button to import all contacts from other sources e.g. Creditors, Debtors, Members, Bookings etc.
-    + **Notes** - Select this button to maintain notes relating to this entry.
-    + **Print** - Select this button to print all entries or the current entry.
-    + **Apply** - Select this button to apply current addition or change.
-    + **Contacts** - Select this button to maintain contacts of the current entry.
-    + **Cancel** - Select this button to cancel any current additions or changes.
-    + **Quit** - Select this button to quit the application.

=== modified file 'drs/dr2010.py'
--- drs/dr2010.py	2016-02-27 13:18:41 +0000
+++ drs/dr2010.py	2016-05-16 08:27:20 +0000
@@ -406,9 +406,9 @@
             if self.dis:
                 val = float(ASD(0) - ASD(self.dis))
                 data = (self.opts["conum"], self.dis_all, self.curdt,
-                    self.trndat, self.glt, self.ref1, self.bh.batno, val, 0.00,
-                    self.trndet, "N", "", recon, self.opts["capnm"],
-                    self.sysdtw, 0)
+                    self.trndat, self.glt, self.ref1, self.bh.batno,
+                    val, 0.00, self.trndet, "N", "", recon,
+                    self.opts["capnm"], self.sysdtw, 0)
                 self.sql.insRec("gentrn", data=data)
 
     def doAgeNormal(self, widget=None):

=== modified file 'drs/dr2030.py'
--- drs/dr2030.py	2016-02-27 13:18:41 +0000
+++ drs/dr2030.py	2016-04-06 09:12:51 +0000
@@ -86,7 +86,7 @@
                 "M","N",self.doFreq,None,None,None),
             (("T",0,1,0),("IRB",r2s),1,"All Charges","",
                 "N","N",self.doAll,None,None,None),
-            (("T",0,2,0),"INA",9,"2nd Reference","",
+            (("T",0,2,0),"INa",9,"2nd Reference","",
                 "","N",self.doRef2,None,None,None),
             (("T",0,3,0),("IRB",r2s),1,"Invoices","",
                 "N","N",self.doInv,None,None,None))

=== modified file 'drs/dr3010.py'
--- drs/dr3010.py	2016-02-27 13:18:41 +0000
+++ drs/dr3010.py	2016-04-06 09:06:31 +0000
@@ -99,7 +99,7 @@
 
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%03u %-30s %58s %6s" %
+        self.head = ("%03u %-30s %48s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.btot = [0, 0]
@@ -135,15 +135,14 @@
                 acno = CCD(trn[tc.index("drt_acno")], "NA", 7)
                 trdt = CCD(trn[tc.index("drt_trdt")], "D1", 10)
                 ref1 = CCD(trn[tc.index("drt_ref1")], "Na", 9)
-                ref2 = CCD(trn[tc.index("drt_ref2")], "Na", 9)
                 desc = CCD(trn[tc.index("drt_desc")], "NA", 30)
                 tramt = CCD(trn[tc.index("drt_tramt")], "SD", 13.2)
                 taxamt = CCD(trn[tc.index("drt_taxamt")], "SD", 13.2)
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading()
-                self.fpdf.drawText("%s %s %s %s %s %s %s %s" % (chn.disp,
-                    acno.disp, trdt.disp, ref1.disp, ref2.disp, desc.disp,
-                    tramt.disp, taxamt.disp))
+                self.fpdf.drawText("%s %s %s %s %s %s %s" % (chn.disp,
+                    acno.disp, trdt.disp, ref1.disp, desc.disp, tramt.disp,
+                    taxamt.disp))
                 self.btot[0] += 1
                 self.btot[1] = float(ASD(self.btot[1]) + ASD(tramt.work))
                 self.pglin += 1
@@ -163,7 +162,7 @@
         self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-34s %59s %5s" %
+        self.fpdf.drawText("%-34s %49s %5s" %
             ("Debtors Ledger Batch Error Listing", "Page", self.pgnum))
         self.fpdf.drawText()
         self.fpdf.setFont()
@@ -181,9 +180,9 @@
             "Current Date:", self.curdt.disp,
             "Multi Allocations:", self.multi.disp))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-3s %-7s %-10s %-9s %-9s %-30s %-13s %-13s" %
-            ("Chn", "Acc-Num", "   Date", "Reference", "Ref-Num-2",
-            "Description", "  Trn-Amount", "  Tax-Amount"))
+        self.fpdf.drawText("%-3s %-7s %-10s %-9s %-30s %-13s %-13s" %
+            ("Chn", "Acc-Num", "   Date", "Reference", "Description",
+            "  Trn-Amount", "  Tax-Amount"))
         self.fpdf.underLine(self.head)
         self.fpdf.setFont()
         self.pglin += 4

=== modified file 'drs/dr3020.py'
--- drs/dr3020.py	2016-02-27 13:18:41 +0000
+++ drs/dr3020.py	2016-04-18 10:07:52 +0000
@@ -154,11 +154,11 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()

=== modified file 'drs/dr3050.py'
--- drs/dr3050.py	2016-02-27 13:18:41 +0000
+++ drs/dr3050.py	2016-04-18 10:08:09 +0000
@@ -90,8 +90,8 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][7][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][7][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][7][4][0], state="hide")
             self.drsact = "All"
             self.df.loadEntry(frt, pag, p+1, data=self.drsact)
             self.drstyp = "All"
@@ -104,8 +104,8 @@
             self.df.loadEntry(frt, pag, p+5, data=self.zero)
             return "sk5"
         else:
-            self.df.setWidget(self.df.topEntry[0][7][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][7][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][7][4][0], state="show")
 
     def doDrsAct(self, frt, pag, r, c, p, i, w):
         if w:

=== modified file 'drs/dr4010.py'
--- drs/dr4010.py	2016-02-27 13:18:41 +0000
+++ drs/dr4010.py	2016-04-06 10:38:03 +0000
@@ -319,7 +319,7 @@
                     dat[col.index("drt_batch")],
                     dat[col.index("drt_type")],
                     dat[col.index("drt_ref1")],
-                    dat[col.index("drt_ref2")],
+                    self.getRef2(col, dat),
                     dat[col.index("drt_tramt")],
                     dat[col.index("paid")],
                     dat[col.index("balance")],
@@ -336,7 +336,7 @@
                 ("drt_batch", "Batch", 7, "Na", "N"),
                 ("drt_type", "Typ", 3, ("XX", drtrtp), "N"),
                 ("drt_ref1", "Reference", 9, "Na", "Y"),
-                ("drt_ref2", "Ref-Num-2", 9, "Na", "Y"),
+                ("drt_ref2", "Ref-Number-Two", 14, "Na", "Y"),
                 ("drt_tramt", "    Amount", 13.2, "SD", "N"),
                 ("alloc", " Allocated", 13.2, "SD", "N"),
                 ("balan", "   Balance", 13.2, "SD", "N"),
@@ -382,6 +382,27 @@
             self.df.enableButtonsTags(state=state)
         self.doTrans1()
 
+    def getRef2(self, col, dat):
+        dtyp = dat[col.index("drt_type")]
+        ref1 = dat[col.index("drt_ref1")]
+        ref2 = dat[col.index("drt_ref2")]
+        if dtyp not in (1, 2):
+            return ref2
+        try:
+            doc = int(ref1)
+        except:
+            return ref2
+        if dtyp == 1:
+            styp = "I"
+        else:
+            styp = "C"
+        sls = self.sql.getRec(tables="slsiv1", cols=["si1_our_ord",
+            "si1_cus_ord"], where=[("si1_cono", "=", self.opts["conum"]),
+            ("si1_rtn", "=", styp), ("si1_docno", "=", doc)], limit=1)
+        if sls and sls[1].strip()[:9] == ref2.strip():
+            return sls[1]
+        return ref2
+
     def doNotes(self, widget=None):
         state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
@@ -443,14 +464,19 @@
                     for nam in ["drt_ref1", "drt_ref2", "drt_trdt", "drt_type",
                             "drt_tramt", "paid", "balance", "drt_desc"]:
                         if not num:
-                            if nam == "paid":
+                            if nam == "drt_ref2":
+                                cols.append(["a", "Na", 14, "Ref-Number-Two"])
+                            elif nam == "paid":
                                 cols.append(["paid", "SD", 13.2, "Paid"])
                             elif nam == "balance":
                                 cols.append(["balance", "SD", 13.2, "Balance"])
                             else:
                                 cols.append([nam, dic[nam][2], dic[nam][3],
                                 dic[nam][5]])
-                        dat.append(rec[col.index(nam)])
+                        if nam == "drt_ref2":
+                            dat.append(self.getRef2(col, rec))
+                        else:
+                            dat.append(rec[col.index(nam)])
                     data.append(dat)
                 gtots = ["drt_tramt", "paid", "balance"]
                 if repprt:

=== modified file 'gen/gl1010.py'
--- gen/gl1010.py	2016-02-27 13:18:41 +0000
+++ gen/gl1010.py	2016-04-30 08:21:25 +0000
@@ -99,11 +99,11 @@
                 "Generate a Chart of Accounts with Accompanying Control "\
                 "Records and Financial Statement Report. This Only Applies "\
                 "to Unpopulated (NEW) Ledgers."),
-            ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
-            ("Cancel",None,self.doCancel,0,("T",0,2),("T",0,0)),
-            ("Quit",None,self.doExit,1,None,None))
+            ("Accept",None,self.doAccept,0,("T",0,2),(("T",0,0),("T",0,1))),
+            ("Cancel",None,self.doCancel,0,("T",0,2),(("T",0,0),("T",0,1))),
+            ("Quit",None,self.doQuit,1,None,None,"",1,4))
         tnd = ((self.doEnd,"y"), )
-        txt = (self.doExit, )
+        txt = (self.doQuit, )
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld, butt=but,
             tend=tnd, txit=txt)
         if self.newgen:
@@ -278,7 +278,7 @@
                 eflds=fld, tend=((self.doIgEnd,"y"),), txit=(self.doIgExit,))
             self.opts["mf"].startLoop()
             if self.igexit:
-                self.doExit()
+                self.doQuit()
                 return
         sp = SplashScreen(self.opts["mf"].body,
             "Populating Records\n\nPlease Wait ...")
@@ -407,7 +407,7 @@
         self.ig.closeProcess()
         self.opts["mf"].closeLoop()
 
-    def doExit(self, widget=None):
+    def doQuit(self, widget=None):
         self.df.closeProcess()
         self.opts["mf"].closeLoop()
 

=== modified file 'gen/gl2030.py'
--- gen/gl2030.py	2016-02-27 13:18:41 +0000
+++ gen/gl2030.py	2016-05-05 06:41:18 +0000
@@ -180,9 +180,8 @@
                 [self.incoac.append(coy[0]) for coy in itg]
             else:
                 self.incoac = False
-        if not self.incoac:
-            if self.doChkLoadCtls():
-                return
+        if not self.incoac and self.doChkLoadCtls():
+            return
         return True
 
     def batchHeader(self):
@@ -409,7 +408,7 @@
                     [["C",self.asspag,0,4],"ISD",13.2,"Amount","",
                         "","N",self.doAssAmt,None,None,("efld",)],
                     [["C",self.asspag,0,5],"INA",30,"Details","Details",
-                        "","N",self.doTrnDet,None,None,("efld",)]])
+                        "","N",self.doAssDet,None,None,("efld",)]])
             elif tag == "BK":
                 self.bkmpag = self.tagp[tag]
                 fld.extend([
@@ -467,7 +466,6 @@
                     [["C",self.lonpag,0,7],"IUI",3,"Mth","Period in Months",
                         "","N",self.doLonMth,None,None,("efld",)],
                     [["C",self.lonpag,0,8],"OUD",12.2,"Repayment"]])
-
             elif tag == "ML":
                 self.mempag = self.tagp[tag]
                 fld.extend([
@@ -1543,252 +1541,6 @@
                 self.sysdtw, 0)
             self.sql.insRec("ctlvtf", data=data)
 
-    def doCrsAcc(self, frt, pag, r, c, p, i, w):
-        self.othacno = w
-        acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
-            where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
-            self.othacno)], limit=1)
-        if not acc:
-            ok = askQuestion(screen=self.opts["mf"].body, head="New Creditor",
-                mess="Account does not exist, Create?")
-            if ok == "no":
-                return "rf"
-            self.doNewCrs()
-            acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
-                where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
-                self.othacno)], limit=1)
-            if not acc:
-                return "rf"
-        self.df.loadEntry(frt, pag, p+1, data=acc[0])
-        self.allref = self.trnref
-
-    def doCrsRef(self, frt, pag, r, c, p, i, w):
-        self.othref = w
-
-    def doCrsDis(self, frt, pag, r, c, p, i, w):
-        self.othdis = w
-
-    def doCrsAmt(self, frt, pag, r, c, p, i, w):
-        self.othamt = w
-        if not self.othamt:
-            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
-
-    def doNewCrs(self, widget=None):
-        callModule(self.opts["mf"], self.df, "cr1010", coy=(self.allcoy,
-            self.allnam), period=None, user=self.opts["capnm"],
-            args=self.othacno)
-
-    def doDrsChn(self, frt, pag, r, c, p, i, w):
-        self.chain = w
-
-    def doDrsAcc(self, frt, pag, r, c, p, i, w):
-        self.othacno = w
-        acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
-            where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
-            self.chain), ("drm_acno", "=", self.othacno)], limit=1)
-        if not acc:
-            ok = askQuestion(screen=self.opts["mf"].body, head="New Debtor",
-                mess="Account does not exist, Create?")
-            if ok == "no":
-                return "rf"
-            self.doNewDrs()
-            acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
-                where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
-                self.chain), ("drm_acno", "=", self.othacno)], limit=1)
-            if not acc:
-                return "rf"
-        self.df.loadEntry(frt, pag, p+1, data=acc[0])
-        self.allref = self.trnref
-
-    def doDrsRef(self, frt, pag, r, c, p, i, w):
-        self.othref = w
-
-    def doDrsDis(self, frt, pag, r, c, p, i, w):
-        self.othdis = w
-
-    def doDrsAmt(self, frt, pag, r, c, p, i, w):
-        self.othamt = w
-        if not self.othamt:
-            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
-
-    def doNewDrs(self, widget=None):
-        callModule(self.opts["mf"], self.df, "dr1010", coy=(self.allcoy,
-            self.allnam), period=None, user=self.opts["capnm"],
-            args=(self.chain, self.othacno))
-
-    def doMemAcc(self, frt, pag, r, c, p, i, w):
-        self.othacno = w
-        acc = self.sql.getRec(tables="memmst", cols=["mlm_surname",
-            "mlm_names"], where=[("mlm_cono", "=", self.allcoy),
-            ("mlm_memno", "=", self.othacno)], limit=1)
-        if not acc:
-            return "Invalid Member Number"
-        self.name = "%s, %s" % (acc[0], acc[1])
-        self.df.loadEntry(frt, pag, p+1, data=self.name)
-        self.allref = self.trnref
-
-    def doMemDis(self, frt, pag, r, c, p, i, w):
-        self.othdis = w
-
-    def doMemAmt(self, frt, pag, r, c, p, i, w):
-        self.othamt = w
-        if not self.othamt:
-            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
-
-    def endCrsDrsMem(self):
-        if (self.others == "crs" and self.glrtn == 2) or \
-                (self.others == "drs" and self.glrtn == 6) or \
-                (self.others == "mem" and self.glrtn == 6):
-            self.tramt = float(ASD(0.0) - ASD(self.othamt))
-            self.dsamt = float(ASD(0.0) - ASD(self.othdis))
-        else:
-            self.tramt = self.othamt
-            self.dsamt = self.othdis
-        # Age Transaction
-        state = self.df.disableButtonsTags(tags=False)
-        self.opts["mf"].updateStatus("Choose an Ageing Option")
-        if len(self.but) == 5:
-            self.beg = 0
-        elif len(self.but) == 8:
-            self.beg = 4
-        for b in xrange(self.beg, (self.beg + 4)):
-            exec "self.df.setWidget(self.df.B%d, 'normal')" % b
-        exec "self.df.setWidget(self.df.B%d, 'focus')" % self.beg
-        self.opts["mf"].startLoop()
-        self.df.enableButtonsTags(state=state)
-        if self.agecan:
-            self.doCancel()
-            return
-        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
-        if self.others == "crs":
-            # Creditors Ledger Transaction
-            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
-                self.bh.batno, self.trndat, self.othref, self.tramt,
-                self.vatamt, 0, self.curdt, 0, "Y", 0, self.alldet,
-                self.vatcod, "", self.opts["capnm"], self.sysdtw, 0]
-            self.sql.insRec("crstrn", data=data, unique="crt_ref1")
-            if self.dsamt:
-                # Creditors Ledger Transaction
-                data[2] = 6
-                data[7] = self.dsamt
-                data[8] = 0
-                self.sql.insRec("crstrn", data=data, unique="crt_ref1")
-                # General Ledger Discount Received
-                data = (self.allcoy, self.ctlctl["dis_rec"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
-                    0, self.alldet, "", "", 0, self.opts["capnm"],
-                    self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-                # General Ledger Creditors Control
-                dis = float(ASD(0.0) - ASD(self.dsamt))
-                data = (self.allcoy, self.ctlctl["crs_ctl"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
-                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-            if self.othtot != self.allamt:
-                bal = float(ASD(self.allamt) - ASD(self.othtot))
-                self.df.loadEntry("T", self.crspag, 0, data=bal)
-                self.df.advanceLine(self.tagp["CR"])
-            else:
-                self.opts["mf"].closeLoop()
-        elif self.others == "drs":
-            # Debtors Ledger Transaction
-            data = [self.allcoy, self.chain, self.othacno, self.othrtn,
-                self.allref, self.bh.batno, self.trndat, self.othref,
-                self.tramt, self.vatamt, self.curdt, self.alldet,
-                self.vatcod, "", self.opts["capnm"], self.sysdtw, 0]
-            self.sql.insRec("drstrn", data=data, unique="drt_ref1")
-            if self.dsamt:
-                # Debtors Ledger Transaction
-                data[3] = 6
-                data[8] = self.dsamt
-                data[9] = 0
-                self.sql.insRec("drstrn", data=data, unique="drt_ref1")
-                # General Ledger Debtors Control
-                data = (self.allcoy, self.ctlctl["drs_ctl"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
-                    0, self.alldet, "", "", 0, self.opts["capnm"],
-                    self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-                # General Ledger Discount Allowed
-                dis = float(ASD(0.0) - ASD(self.dsamt))
-                data = (self.allcoy, self.ctlctl["dis_all"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
-                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-            if self.othtot != self.allamt:
-                bal = float(ASD(self.allamt) - ASD(self.othtot))
-                self.df.loadEntry("T", self.drspag, 0, data=bal)
-                self.df.advanceLine(self.tagp["DR"])
-            else:
-                self.opts["mf"].closeLoop()
-        elif self.others == "mem":
-            # Members Ledger Transaction
-            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
-                self.bh.batno, self.trndat, self.tramt, self.vatamt,
-                self.curdt, "", 0, self.alldet, self.vatcod, "",
-                self.opts["capnm"], self.sysdtw, 0]
-            self.sql.insRec("memtrn", data=data, unique="mlt_refno")
-            if self.dsamt:
-                # Members Ledger Transaction
-                data[2] = 6
-                data[6] = self.dsamt
-                data[7] = 0
-                self.sql.insRec("memtrn", data=data, unique="mlt_refno")
-                # General Ledger Members Control
-                data = (self.allcoy, self.ctlctl["mem_ctl"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
-                    0, self.alldet, "", "", 0, self.opts["capnm"],
-                    self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-                # General Ledger Discount Allowed
-                dis = float(ASD(0.0) - ASD(self.dsamt))
-                data = (self.allcoy, self.ctlctl["dis_all"], self.curdt,
-                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
-                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
-                self.sql.insRec("gentrn", data=data)
-            if self.othtot != self.allamt:
-                bal = float(ASD(self.allamt) - ASD(self.othtot))
-                self.df.loadEntry("T", self.mempag, 0, data=bal)
-                self.df.advanceLine(self.tagp["ML"])
-            else:
-                self.opts["mf"].closeLoop()
-
-    def doAgeNormal(self, widget=None):
-        self.doAgeing("N")
-
-    def doAgeHistory(self, widget=None):
-        self.doAgeing("H")
-
-    def doAgeAuto(self, widget=None):
-        self.doAgeing("O")
-
-    def doAgeCurrent(self, widget=None):
-        self.doAgeing("C")
-
-    def doAgeing(self, atype):
-        # Disable All Ageing Buttons
-        for b in xrange(self.beg, (self.beg + 4)):
-            exec "self.df.setWidget(self.df.B%d, 'disabled')" % b
-        self.opts["mf"].updateStatus("Select Transaction to Allocate Against")
-        if self.others == "crs":
-            age = AgeAll(self.opts["mf"], system="crs", agetyp=atype,
-                agekey=[self.allcoy, self.othacno, self.othrtn, self.allref,
-                self.curdt, self.tramt, self.dsamt])
-        elif self.others == "drs":
-            age = AgeAll(self.opts["mf"], system="drs", agetyp=atype,
-                agekey=[self.allcoy, self.chain, self.othacno, self.othrtn,
-                self.allref, self.curdt, self.tramt, self.dsamt])
-        elif self.others == "mem":
-            age = AgeAll(self.opts["mf"], system="mem", agetyp=atype,
-                agekey=[self.allcoy, self.othacno, self.othrtn, self.allref,
-                self.curdt, self.tramt, self.dsamt])
-        self.agecan = age.cancel
-        self.opts["mf"].closeLoop()
-
     def doAssGrp(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="assgrp", where=[("asg_cono", "=",
             self.allcoy), ("asg_group", "=", w)], limit=1)
@@ -1863,12 +1615,16 @@
             self.othamt = float(
                 ASD(self.allamt) - ASD(self.vatamt) - ASD(self.othtot))
             self.othvat = float(ASD(self.vatamt) - ASD(self.vattot))
+        elif self.vatamt:
+            self.othvat = round(((self.othamt / self.allamt) * self.vatamt), 2)
         else:
-            self.othamt = float(ASD(self.allamt) - ASD(self.vatamt))
-            self.othvat = round(((self.othamt / self.othvat) * self.vatamt), 2)
+            self.othvat = 0
         self.df.loadEntry(frt, pag, p, data=self.othamt)
         self.df.loadEntry(frt, pag, p+1, data=self.trndet)
 
+    def doAssDet(self, frt, pag, r, c, p, i, w):
+        self.trndet = w
+
     def endAss(self):
         if self.glrtn == 2:
             self.othrtn = 1
@@ -1979,9 +1735,7 @@
         if not self.othamt:
             self.othamt = float(
                 ASD(self.allamt) - ASD(self.vatamt) - ASD(self.othtot))
-        else:
-            self.othamt = float(ASD(self.allamt) - ASD(self.vatamt))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
 
     def endBkm(self):
         if self.glrtn == 6:
@@ -2018,6 +1772,81 @@
         else:
             self.opts["mf"].closeLoop()
 
+    def doCrsAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
+            where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
+            self.othacno)], limit=1)
+        if not acc:
+            ok = askQuestion(screen=self.opts["mf"].body, head="New Creditor",
+                mess="Account does not exist, Create?")
+            if ok == "no":
+                return "rf"
+            self.doNewCrs()
+            acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
+                where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
+                self.othacno)], limit=1)
+            if not acc:
+                return "rf"
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.allref = self.trnref
+
+    def doCrsRef(self, frt, pag, r, c, p, i, w):
+        self.othref = w
+
+    def doCrsDis(self, frt, pag, r, c, p, i, w):
+        self.othdis = w
+
+    def doCrsAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def doNewCrs(self, widget=None):
+        callModule(self.opts["mf"], self.df, "cr1010", coy=(self.allcoy,
+            self.allnam), period=None, user=self.opts["capnm"],
+            args=self.othacno)
+
+    def doDrsChn(self, frt, pag, r, c, p, i, w):
+        self.chain = w
+
+    def doDrsAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
+            where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
+            self.chain), ("drm_acno", "=", self.othacno)], limit=1)
+        if not acc:
+            ok = askQuestion(screen=self.opts["mf"].body, head="New Debtor",
+                mess="Account does not exist, Create?")
+            if ok == "no":
+                return "rf"
+            self.doNewDrs()
+            acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
+                where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
+                self.chain), ("drm_acno", "=", self.othacno)], limit=1)
+            if not acc:
+                return "rf"
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.allref = self.trnref
+
+    def doDrsRef(self, frt, pag, r, c, p, i, w):
+        self.othref = w
+
+    def doDrsDis(self, frt, pag, r, c, p, i, w):
+        self.othdis = w
+
+    def doDrsAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def doNewDrs(self, widget=None):
+        callModule(self.opts["mf"], self.df, "dr1010", coy=(self.allcoy,
+            self.allnam), period=None, user=self.opts["capnm"],
+            args=(self.chain, self.othacno))
+
     def doLonAcc(self, frt, pag, r, c, p, i, w):
         newacc = False
         if not w and self.glrtn == 2:
@@ -2080,9 +1909,7 @@
         if not self.othamt:
             self.othamt = float(
                 ASD(self.allamt) - ASD(self.vatamt) - ASD(self.othtot))
-        else:
-            self.othamt = float(ASD(self.allamt) - ASD(self.vatamt))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
         if self.glrtn == 6 or not self.newlon:
             self.df.loadEntry(frt, pag, p+1, data=0)
             self.df.loadEntry(frt, pag, p+2, data=0)
@@ -2134,6 +1961,26 @@
         else:
             self.opts["mf"].closeLoop()
 
+    def doMemAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="memmst", cols=["mlm_surname",
+            "mlm_names"], where=[("mlm_cono", "=", self.allcoy),
+            ("mlm_memno", "=", self.othacno)], limit=1)
+        if not acc:
+            return "Invalid Member Number"
+        self.name = "%s, %s" % (acc[0], acc[1])
+        self.df.loadEntry(frt, pag, p+1, data=self.name)
+        self.allref = self.trnref
+
+    def doMemDis(self, frt, pag, r, c, p, i, w):
+        self.othdis = w
+
+    def doMemAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
     def doSlnEmp(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="wagmst", cols=["wgm_sname", "wgm_fname"],
             where=[("wgm_cono", "=", self.allcoy), ("wgm_empno", "=", w)],
@@ -2180,9 +2027,7 @@
         if not self.othamt:
             self.othamt = float(
                 ASD(self.allamt) - ASD(self.vatamt) - ASD(self.othtot))
-        else:
-            self.othamt = float(ASD(self.allamt) - ASD(self.vatamt))
-        self.df.loadEntry(frt, pag, p, data=self.othamt)
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
         if self.glrtn == 6:
             return "nd"
         if not self.newsln:
@@ -2249,6 +2094,157 @@
         else:
             self.opts["mf"].closeLoop()
 
+    def endCrsDrsMem(self):
+        if (self.others == "crs" and self.glrtn == 2) or \
+                (self.others == "drs" and self.glrtn == 6) or \
+                (self.others == "mem" and self.glrtn == 6):
+            self.tramt = float(ASD(0.0) - ASD(self.othamt))
+            self.dsamt = float(ASD(0.0) - ASD(self.othdis))
+        else:
+            self.tramt = self.othamt
+            self.dsamt = self.othdis
+        # Age Transaction
+        state = self.df.disableButtonsTags(tags=False)
+        self.opts["mf"].updateStatus("Choose an Ageing Option")
+        if len(self.but) == 5:
+            self.beg = 0
+        elif len(self.but) == 8:
+            self.beg = 4
+        for b in xrange(self.beg, (self.beg + 4)):
+            exec "self.df.setWidget(self.df.B%d, 'normal')" % b
+        exec "self.df.setWidget(self.df.B%d, 'focus')" % self.beg
+        self.opts["mf"].startLoop()
+        self.df.enableButtonsTags(state=state)
+        if self.agecan:
+            self.doCancel()
+            return
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.others == "crs":
+            # Creditors Ledger Transaction
+            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.bh.batno, self.trndat, self.othref, self.tramt,
+                self.vatamt, 0, self.curdt, 0, "Y", 0, self.alldet,
+                self.vatcod, "", self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("crstrn", data=data, unique="crt_ref1")
+            if self.dsamt:
+                # Creditors Ledger Transaction
+                data[2] = 6
+                data[7] = self.dsamt
+                data[8] = 0
+                self.sql.insRec("crstrn", data=data, unique="crt_ref1")
+                # General Ledger Discount Received
+                data = (self.allcoy, self.ctlctl["dis_rec"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
+                    0, self.alldet, "", "", 0, self.opts["capnm"],
+                    self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+                # General Ledger Creditors Control
+                dis = float(ASD(0.0) - ASD(self.dsamt))
+                data = (self.allcoy, self.ctlctl["crs_ctl"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
+                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+            if self.othtot != self.allamt:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.crspag, 0, data=bal)
+                self.df.advanceLine(self.tagp["CR"])
+            else:
+                self.opts["mf"].closeLoop()
+        elif self.others == "drs":
+            # Debtors Ledger Transaction
+            data = [self.allcoy, self.chain, self.othacno, self.othrtn,
+                self.allref, self.bh.batno, self.trndat, self.othref,
+                self.tramt, self.vatamt, self.curdt, self.alldet,
+                self.vatcod, "", self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("drstrn", data=data, unique="drt_ref1")
+            if self.dsamt:
+                # Debtors Ledger Transaction
+                data[3] = 6
+                data[8] = self.dsamt
+                data[9] = 0
+                self.sql.insRec("drstrn", data=data, unique="drt_ref1")
+                # General Ledger Debtors Control
+                data = (self.allcoy, self.ctlctl["drs_ctl"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
+                    0, self.alldet, "", "", 0, self.opts["capnm"],
+                    self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+                # General Ledger Discount Allowed
+                dis = float(ASD(0.0) - ASD(self.dsamt))
+                data = (self.allcoy, self.ctlctl["dis_all"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
+                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+            if self.othtot != self.allamt:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.drspag, 0, data=bal)
+                self.df.advanceLine(self.tagp["DR"])
+            else:
+                self.opts["mf"].closeLoop()
+        elif self.others == "mem":
+            # Members Ledger Transaction
+            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.bh.batno, self.trndat, self.tramt, self.vatamt,
+                self.curdt, "", 0, self.alldet, self.vatcod, "",
+                self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("memtrn", data=data, unique="mlt_refno")
+            if self.dsamt:
+                # Members Ledger Transaction
+                data[2] = 6
+                data[6] = self.dsamt
+                data[7] = 0
+                self.sql.insRec("memtrn", data=data, unique="mlt_refno")
+                # General Ledger Members Control
+                data = (self.allcoy, self.ctlctl["mem_ctl"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, self.dsamt,
+                    0, self.alldet, "", "", 0, self.opts["capnm"],
+                    self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+                # General Ledger Discount Allowed
+                dis = float(ASD(0.0) - ASD(self.dsamt))
+                data = (self.allcoy, self.ctlctl["dis_all"], self.curdt,
+                    self.trndat, 4, self.allref, self.bh.batno, dis, 0,
+                    self.trndet, "", "", 0, self.opts["capnm"], self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+            if self.othtot != self.allamt:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.mempag, 0, data=bal)
+                self.df.advanceLine(self.tagp["ML"])
+            else:
+                self.opts["mf"].closeLoop()
+
+    def doAgeNormal(self, widget=None):
+        self.doAgeing("N")
+
+    def doAgeHistory(self, widget=None):
+        self.doAgeing("H")
+
+    def doAgeAuto(self, widget=None):
+        self.doAgeing("O")
+
+    def doAgeCurrent(self, widget=None):
+        self.doAgeing("C")
+
+    def doAgeing(self, atype):
+        # Disable All Ageing Buttons
+        for b in xrange(self.beg, (self.beg + 4)):
+            exec "self.df.setWidget(self.df.B%d, 'disabled')" % b
+        self.opts["mf"].updateStatus("Select Transaction to Allocate Against")
+        if self.others == "crs":
+            age = AgeAll(self.opts["mf"], system="crs", agetyp=atype,
+                agekey=[self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.curdt, self.tramt, self.dsamt])
+        elif self.others == "drs":
+            age = AgeAll(self.opts["mf"], system="drs", agetyp=atype,
+                agekey=[self.allcoy, self.chain, self.othacno, self.othrtn,
+                self.allref, self.curdt, self.tramt, self.dsamt])
+        elif self.others == "mem":
+            age = AgeAll(self.opts["mf"], system="mem", agetyp=atype,
+                agekey=[self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.curdt, self.tramt, self.dsamt])
+        self.agecan = age.cancel
+        self.opts["mf"].closeLoop()
+
     def updateBatch(self, rev=False):
         if rev:
             self.bh.batqty = self.bh.batqty - 1

=== modified file 'gen/gl2040.py'
--- gen/gl2040.py	2016-02-27 13:18:41 +0000
+++ gen/gl2040.py	2016-05-16 09:08:10 +0000
@@ -14,25 +14,18 @@
 """
 
 import time
-from TartanClasses import ASD, Batches, CCD, FileImport, GetCtl, ProgressBar
-from TartanClasses import PwdConfirm, SplashScreen, Sql, TartanDialog
-from tartanFunctions import askQuestion, chkGenAcc, getSingleRecords
-from tartanFunctions import getVatRate, mthendDate, showError
-from tartanWork import gltrtp
+from TartanClasses import ASD, Batches, CCD, FileImport, GetCtl
+from TartanClasses import ProgressBar, PwdConfirm, SplashScreen, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import askQuestion, callModule, chkGenAcc, getNextCode
+from tartanFunctions import getVatRate, showError
+from tartanWork import armvtp, gltrtp
 
 class gl2040:
     def __init__(self, **opts):
         self.opts = opts
-        if self.opts["rtn"] == 1:
-            self.jtyp = "manual"
-        else:
-            self.jtyp = "standard"
-        self.opts["rtn"] = 4
         if self.setVariables():
-            if self.jtyp == "manual":
-                self.manualHeader()
-            else:
-                self.standardHeader()
+            self.doProcess()
             self.opts["mf"].startLoop()
 
     def setVariables(self):
@@ -41,9 +34,89 @@
         ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
         if not ctlmst:
             return
+        self.allcoy = self.opts["conum"]
+        self.allnam = self.opts["conam"]
+        # Get Enabled Modules
+        tab = ["ctlctl", "ctlmst", "ctlvmf", "ctlvrf", "ctlvtf", "genint",
+            "genmst", "gentrn"]
+        mod = []
+        for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
+            mod.append(ctlmst["ctm_modules"][x:x+2])
+        # Load Control Accounts
+        self.tags = [("Transaction", None, None, None, False)]
+        self.tagp = {}
+        page = 1
+        if mod.count("AR"):
+            ctl = self.gc.getCtl("assctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["cta_glint"] == "Y":
+                tab.extend(["assgrp", "assmst", "asstrn"])
+                self.tags.append(("ASS", None, None, None, False))
+                page += 1
+                self.tagp["AR"] = page
+        if mod.count("BK"):
+            ctl = self.gc.getCtl("bkmctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["cbk_glint"] == "Y":
+                tab.extend(["bkmcon", "bkmmst", "bkmtrn"])
+                self.tags.append(("BKM", None, None, None, False))
+                page += 1
+                self.tagp["BK"] = page
+        if mod.count("CR"):
+            ctl = self.gc.getCtl("crsctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["ctc_glint"] == "Y":
+                tab.extend(["crsmst", "crstrn"])
+                self.tags.append(("CRS", None, None, None, False))
+                page += 1
+                self.tagp["CR"] = page
+        if mod.count("DR"):
+            ctl = self.gc.getCtl("drsctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["ctd_glint"] == "Y":
+                tab.extend(["drsmst", "drstrn"])
+                self.tags.append(("DRS", None, None, None, False))
+                page += 1
+                self.tagp["DR"] = page
+        if mod.count("LN"):
+            ctl = self.gc.getCtl("lonctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["cln_glint"] == "Y":
+                tab.extend(["lonmf1", "lonmf2", "lonrte", "lontrn"])
+                self.tags.append(("LON", None, None, None, False))
+                page += 1
+                self.tagp["LN"] = page
+                self.lon_cr = 0
+                self.lon_dr = 0
+        if mod.count("ML"):
+            ctl = self.gc.getCtl("memctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["mcm_glint"] == "Y":
+                tab.extend(["memmst", "memtrn"])
+                self.tags.append(("MEM", None, None, None, False))
+                page += 1
+                self.tagp["ML"] = page
+        if mod.count("SL"):
+            ctl = self.gc.getCtl("wagctl", self.opts["conum"])
+            if not ctl:
+                return
+            if ctl["ctw_glint"] == "Y":
+                tab.extend(["wagmst", "waglmf", "wagltf"])
+                self.tags.append(("SLN", None, None, None, False))
+                page += 1
+                self.tagp["SL"] = page
+                self.sln_rt = 0
+        # Check if Control Accounts Exist
+        self.ctlctl = self.gc.getCtl("ctlctl", self.opts["conum"])
+        if not self.ctlctl:
+            return
         # Create SQL Object
-        tab = ["ctlctl", "ctlmst", "ctlvmf", "ctlvrf", "ctlvtf", "genint",
-            "genjlm", "genjlt", "genmst", "gentrn", "assgrp", "rtlprm"]
         self.sql = Sql(self.opts["mf"].dbm, tab, prog=__name__)
         if self.sql.error:
             return
@@ -59,21 +132,16 @@
                 [self.incoac.append(coy[0]) for coy in itg]
             else:
                 self.incoac = False
-        if not self.incoac:
-            self.allcoy = self.opts["conum"]
-            chk = self.doChkLoadCtls()
-            if chk:
+        if not self.incoac and self.doChkLoadCtls():
                 return
-        if self.jtyp == "standard":
-            multi = "Y"
-        else:
-            multi = None
+        # Batch Header
         self.bh = Batches(self.opts["mf"], self.opts["conum"],
             self.opts["conam"], self.opts["period"], "GEN",
-            self.opts["rtn"], multi=multi)
+            self.opts["rtn"], multi=None)
         self.bh.doBatchHeader()
         if not self.bh.batno:
             return
+        # Other
         t = time.localtime()
         self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
         self.s_per = self.opts["period"][1][0] / 100
@@ -81,10 +149,7 @@
         self.importing = False
         return True
 
-    def manualHeader(self):
-        self.crspag = 2
-        self.drspag = 3
-        self.asspag = 4
+    def doProcess(self):
         tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
             "General Ledger " + gltrtp[self.opts["rtn"] - 1][1] + \
             " Data Capture (%s)" % __name__)
@@ -114,64 +179,306 @@
             "cols": (
                 ("glm_acno", "", 0, "Acc-Num"),
                 ("glm_desc", "", 0, "Description", "Y")),
-            "whera": [["C", "glm_cono", 2, 0]]}
+            "whera": [["C", "glm_cono", 2, 1]]}
+        if "AR" in self.tagp:
+            asg = {
+                "stype": "R",
+                "tables": ("assgrp",),
+                "cols": (
+                    ("asg_group", "", 0, "Grp"),
+                    ("asg_desc", "", 0, "Description", "Y")),
+                "whera": [("C", "asg_cono", 2, 1)]}
+            asm = {
+                "stype": "R",
+                "tables": ("assmst",),
+                "cols": (
+                    ("asm_code", "", 0, "Cod-Num"),
+                    ("asm_desc", "", 0, "Description", "Y")),
+                "whera": [
+                    ("C", "asm_cono", 2, 1),
+                    ("C", "asm_group", 0, self.tagp["AR"])]}
+            data = []
+            for x in xrange(1, len(armvtp)+1):
+                if x == 4:
+                    continue
+                data.append([x, armvtp[x-1][1]])
+            mov = {
+                "stype": "C",
+                "titl": "Valid Types",
+                "head": ("C", "Description"),
+                "data": data}
+        if "BK" in self.tagp:
+            bkm = {
+                "stype": "R",
+                "tables": ("bkmmst", "bkmcon"),
+                "cols": (
+                    ("bkm_number", "", 0, "Bkm-No"),
+                    ("bkc_sname", "", 0, "Surname", "Y"),
+                    ("bkc_names", "", 0, "Names")),
+                "where": [
+                    ("bkc_cono=bkm_cono",),
+                    ("bkc_ccode=bkm_ccode",)],
+                "whera": [("C", "bkm_cono", 2, 1)]}
+        if "CR" in self.tagp:
+            crm = {
+                "stype": "R",
+                "tables": ("crsmst",),
+                "cols": (
+                    ("crm_acno", "", 0, "Acc-Num"),
+                    ("crm_name", "", 0, "Name", "Y")),
+                "whera": [("C", "crm_cono", 2, 1)]}
+        if "DR" in self.tagp:
+            chn = {
+                "stype": "R",
+                "tables": ("drschn",),
+                "cols": (
+                    ("chm_chain", "", 0, "Num"),
+                    ("chm_name", "", 0, "Name", "Y")),
+                "whera": [("C", "chm_cono", 2, 1)]}
+            drm = {
+                "stype": "R",
+                "tables": ("drsmst",),
+                "cols": (
+                    ("drm_acno", "", 0, "Acc-Num"),
+                    ("drm_name", "", 0, "Name", "Y"),
+                    ("drm_add1", "", 0, "Address Line 1")),
+                "whera": [
+                    ("C", "drm_cono", 2, 1),
+                    ("C", "drm_chain", 0, self.tagp["DR"])]}
+        if "LN" in self.tagp:
+            lm1 = {
+                "stype": "R",
+                "tables": ("lonmf1",),
+                "cols": (
+                    ("lm1_acno", "", 0, "Acc-Num"),
+                    ("lm1_name", "", 0, "Name", "Y")),
+                "whera": [("C", "lm1_cono", 2, 1)]}
+            lm2 = {
+                "stype": "R",
+                "tables": ("lonmf2",),
+                "cols": (
+                    ("lm2_loan", "", 0, "Ln"),
+                    ("lm2_desc", "", 0, "Description", "Y")),
+                "whera": [
+                    ("C", "lm2_cono", 2, 1),
+                    ("C", "lm2_acno", 0, self.tagp["LN"])]}
+        if "ML" in self.tagp:
+            mlm = {
+                "stype": "R",
+                "tables": ("memmst",),
+                "cols": (
+                    ("mlm_memno", "", 0, "Mem-No"),
+                    ("mlm_surname", "", 0, "Surname", "Y"),
+                    ("mlm_names", "", 0, "Names")),
+                "whera": [("C", "mlm_cono", 2, 1)]}
+        if "SL" in self.tagp:
+            wgm = {
+                "stype": "R",
+                "tables": ("wagmst",),
+                "cols": (
+                    ("wgm_empno", "", 0, "EmpNo"),
+                    ("wgm_sname", "", 0, "Surname", "Y"),
+                    ("wgm_fname", "", 0, "Names")),
+                "whera": [("C", "wgm_cono", 2, 1)]}
+            lmf = {
+                "stype": "R",
+                "tables": ("waglmf",),
+                "cols": (
+                    ("wlm_loan", "", 0, "Ln"),
+                    ("wlm_desc", "", 0, "Description", "Y")),
+                "whera": [
+                    ("C", "wlm_cono", 2, 1),
+                    ("C", "wlm_empno", 0, self.tagp["SL"])]}
+            ced = {
+                "stype": "R",
+                "tables": ("wagedc",),
+                "cols": (
+                    ("ced_type", "", 0, "T"),
+                    ("ced_code", "", 0, "Cde"),
+                    ("ced_desc", "", 0, "Description", "Y")),
+                "where": [("ced_type", "=", "D")],
+                "whera": [("C", "ced_cono", 2, 1)],
+                "index": 1}
         vat = {
             "stype": "R",
             "tables": ("ctlvmf",),
             "cols": (
                 ("vtm_code", "", 0, "C"),
                 ("vtm_desc", "", 0, "Description", "Y")),
-            "whera": [["C", "vtm_cono", 2, 0]]}
+            "whera": [["C", "vtm_cono", 2, 1]]}
         self.fld = [
             (("T",0,0,0),"OUI",9,"Batch %s Quantity" % self.bh.batno),
             (("T",0,0,0),"OSD",13.2,"Value"),
-            (("C",0,0,0),"INa",9,"Ref-Num","Reference Number",
+            (("C",1,0,0),"INa",9,"Ref-Num","Reference Number",
                 "i","N",self.doTrnRef,None,None,("notblank",)),
-            (("C",0,0,1),"ID1",10,"Date","Transaction Date",
+            (("C",1,0,1),"ID1",10,"Date","Transaction Date",
                 "r","N",self.doTrnDat,None,None,("efld",)),
-            [("C",0,0,2),"IUI",3,"Coy","Company Number",
+            [("C",1,0,2),"IUI",3,"Coy","Company Number",
                 self.opts["conum"],"N",self.doCoyNum,coy,None,("notzero",)],
-            (("C",0,0,3),"IUI",7,"Acc-Num","Account Number",
+            (("C",1,0,3),"IUI",7,"Acc-Num","Account Number",
                 "","N",self.doAccNum,glm,None,None),
-            (("C",0,0,4),"ONA",20,"Description"),
-            (("C",0,0,5),"ISD",13.2,"Amount","Transaction Amount",
+            (("C",1,0,4),"ONA",20,"Description"),
+            (("C",1,0,5),"ISD",13.2,"Amount","Transaction Amount",
                 "","N",self.doTrnAmt,None,None,None),
-            (("C",0,0,6),"IUA",1,"V","V.A.T. Code",
-                "","N",self.doVatCod,vat,None,("notblank",)),
-            (("C",0,0,7),"ISD",13.2,"VAT-Amt","V.A.T. Amount",
+            (("C",1,0,6),"IUA",1,"V","V.A.T. Code",
+                "N","N",self.doVatCod,vat,None,("notblank",)),
+            (("C",1,0,7),"ISD",13.2,"VAT-Amt","V.A.T. Amount",
                 "","N",self.doVatAmt,None,None,("efld",)),
-            (("C",0,0,8),"INA",(20,30),"Details","",
+            (("C",1,0,8),"INA",(20,30),"Details","Details",
                 "r","N",self.doTrnDet,None,None,("notblank",))]
+        tags = self.tagp.keys()
+        tags.sort()
+        for tag in tags:
+            if tag == "AR":
+                self.asspag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.asspag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.asspag,0,0],"IUA",3,"Grp","Asset Group",
+                        "r","N",self.doAssGrp,asg,None,("notblank",)],
+                    [["C",self.asspag,0,1],"INa",7,"Cod-Num","Asset Code",
+                        "r","N",self.doAssCod,asm,None,("notblank",)],
+                    [["C",self.asspag,0,2],"ONA",30,"Description"],
+                    [["C",self.asspag,0,3],"IUI",1,"M","Movement Type",
+                        "r","N",self.doAssMov,mov,None,("in",(1,2,5))],
+                    [["C",self.asspag,0,4],"ISD",13.2,"Amount","",
+                        "","N",self.doAssAmt,None,None,("efld",)],
+                    [["C",self.asspag,0,5],"INA",30,"Details","Details",
+                        "","N",self.doAssDet,None,None,("efld",)]])
+            elif tag == "BK":
+                self.bkmpag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.bkmpag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.bkmpag,0,0],"IUI",6,"Bkm-Num","Booking Number",
+                        "","N",self.doBkmNum,bkm,None,("notzero",)],
+                    [["C",self.bkmpag,0,1],"ONA",70,"Name"],
+                    [["C",self.bkmpag,0,2],"ISD",13.2,"Amount","",
+                        "","N",self.doBkmAmt,None,None,("efld",)]])
+            elif tag == "CR":
+                self.crspag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.crspag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.crspag,0,0],"INA",7,"Acc-Num","Account Number",
+                        "","N",self.doCrsAcc,crm,None,("notblank",)],
+                    [["C",self.crspag,0,1],"ONA",30,"Name"],
+                    [["C",self.crspag,0,2],"INa",9,"Ref-Num-2","",
+                        "i","N",self.doCrsRef,None,None,None],
+                    [["C",self.crspag,0,3],"ISD",13.2,"Amount","",
+                        "","N",self.doCrsAmt,None,None,("efld",)]])
+            elif tag == "DR":
+                self.drspag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.drspag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.drspag,0,0],"IUI",3,"Chn","Chain Store Code",
+                        "","N",self.doDrsChn,chn,None,("efld",)],
+                    [["C",self.drspag,0,1],"INA",7,"Acc-Num","Account Number",
+                        "","N",self.doDrsAcc,drm,None,("notblank",)],
+                    [["C",self.drspag,0,2],"ONA",30,"Name"],
+                    [["C",self.drspag,0,3],"INa",9,"Ref-Num-2","",
+                        "i","N",self.doDrsRef,None,None,None],
+                    [["C",self.drspag,0,4],"ISD",13.2,"Amount","",
+                        "","N",self.doDrsAmt,None,None,("efld",)]])
+            elif tag == "LN":
+                self.lonpag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.lonpag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.lonpag,0,0],"IUA",7,"Acc-Num","Account Number",
+                        "","N",self.doLonAcc,lm1,None,None],
+                    [["C",self.lonpag,0,1],"ONA",20,"Name"],
+                    [["C",self.lonpag,0,2],"IUI",2,"Ln","Loan Number",
+                        "","N",self.doLonNum,lm2,None,("efld",)],
+                    [["C",self.lonpag,0,3],"INA",30,"Description","",
+                        "","N",self.doLonDes,None,None,("notblank",)],
+                    [["C",self.lonpag,0,4],"ISD",13.2,"Amount","",
+                        "","N",self.doLonAmt,None,None,("efld",)],
+                    [["C",self.lonpag,0,5],"IUD",6.2,"DRte-%","Debit Rate",
+                        self.lon_dr,"N",self.doLonDri,None,None,("efld",)],
+                    [["C",self.lonpag,0,6],"IUD",6.2,"CRte-%","Credit Rate",
+                        self.lon_cr,"N",self.doLonCri,None,None,("efld",)],
+                    [["C",self.lonpag,0,7],"IUI",3,"Mth","Period in Months",
+                        "","N",self.doLonMth,None,None,("efld",)],
+                    [["C",self.lonpag,0,8],"OUD",12.2,"Repayment"]])
+            elif tag == "ML":
+                self.mempag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.mempag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.mempag,0,0],"IUI",6,"Mem-No","Member Number",
+                        "","N",self.doMemAcc,mlm,None,("notblank",)],
+                    [["C",self.mempag,0,1],"ONA",30,"Name"],
+                    [["C",self.mempag,0,2],"ISD",13.2,"Amount","",
+                        "","N",self.doMemAmt,None,None,("efld",)]])
+            elif tag == "SL":
+                self.slnpag = self.tagp[tag]
+                self.fld.extend([
+                    [["T",self.slnpag,0,0],"OSD",13.2,"Unallocated Balance"],
+                    [["C",self.slnpag,0,0],"IUI",5,"EmpNo","Employee Number",
+                        "","N",self.doSlnEmp,wgm,None,None],
+                    [["C",self.slnpag,0,1],"ONA",20,"Name"],
+                    [["C",self.slnpag,0,2],"IUI",2,"Ln","Loan Number",
+                        "","N",self.doSlnNum,lmf,None,("notzero",)],
+                    [["C",self.slnpag,0,3],"INA",20,"Description","",
+                        "","N",self.doSlnDes,None,None,("notblank",)],
+                    [["C",self.slnpag,0,4],"ISD",13.2,"Amount","",
+                        "","N",self.doSlnAmt,None,None,("efld",)],
+                    [["C",self.slnpag,0,5],"IUI",3,"Cde","Deduction Code",
+                        "","N",self.doSlnCod,ced,None,("efld",)],
+                    [["C",self.slnpag,0,6],"ONA",20,"Description"],
+                    [["C",self.slnpag,0,7],"IUD",6.2,"Rate-%","Interest Rate",
+                        self.sln_rt,"N",self.doSlnInt,None,None,("efld",)],
+                    [["C",self.slnpag,0,8],"IUD",13.2,"Ded-Amt","Deduction",
+                        "","N",self.doSlnDed,None,None,("efld",)]])
         if not self.incoac:
             self.fld[4][1] = "OUI"
             self.allcoy = self.opts["conum"]
-        row = (20,)
-        but = (
-            ("_Import File",None,self.doImport,0,("C",0,1),("C",0,2),
+        but = [
+            ("_Import File",None,self.doImport,0,("C",1,1),("C",1,2),
             "Import a CSV or XLS File with the Correct Format i.e. Reference "\
             "Number, Transaction Date, Company Number, Account Number, "\
             "Transaction Amount, V.A.T. Code, V.A.T. Amount, Details. "\
             "If there is a VAT Code with no VAT Amount, it will be "\
             "Calculated."),
-            ("View Entries",lst,None,0,("C",0,1),("C",0,2)),
-            ("End Batch",None,self.exitPage,0,("C",0,1),("C",0,2)),
-            ("Abort Current",None,self.doAbort,1,None,None))
-        cnd = ((self.endPage,"y"),)
-        cxt = (self.exitPage,)
-        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=self.fld,
-            butt=but, rows=row, cend=cnd, cxit=cxt)
+            ("View Entries",lst,None,0,("C",1,1),("C",1,2)),
+            ("End Batch",None,self.exitPage,0,("C",1,1),("C",1,2)),
+            ("Abort Batch",None,self.doAbort,1,None,None)]
+        cnd = [None, (self.endPage,"y")]
+        cxt = [None, self.exitPage]
+        for tag in tags:
+            if tag == "AR":
+                cnd.append((self.endAss, "y"))
+                cxt.append(None)
+            elif tag == "BK":
+                cnd.append((self.endBkm, "y"))
+                cxt.append(None)
+            elif tag == "CR":
+                cnd.append((self.endCrsDrsMem, "y"))
+                cxt.append(None)
+            elif tag == "DR":
+                cnd.append((self.endCrsDrsMem, "y"))
+                cxt.append(None)
+            elif tag == "LN":
+                cnd.append((self.endLon, "y"))
+                cxt.append(None)
+            elif tag == "ML":
+                cnd.append((self.endCrsDrsMem, "y"))
+                cxt.append(None)
+            elif tag == "SL":
+                cnd.append((self.endSln, "y"))
+                cxt.append(None)
+        self.df = TartanDialog(self.opts["mf"], title=tit, tags=self.tags,
+            eflds=self.fld, butt=but, cend=cnd, cxit=cxt)
         self.df.loadEntry("T", 0, 0, data=self.bh.batqty)
         self.df.loadEntry("T", 0, 1, data=self.bh.batval)
-        self.df.focusField("C", 0, 1)
+        self.df.focusField("C", 1, 1)
 
     def doImport(self, widget=None):
+        self.df.closeProcess()
         self.importing = True
-        self.df.closeProcess()
         impcol = []
         pos = 0
         for num, fld in enumerate(self.fld[2:]):
             if num == 4:
                 continue
+            if num > 8:
+                break
             if type(fld[2]) in (tuple, list):
                 size = fld[2][1]
             else:
@@ -277,17 +584,13 @@
         else:
             sp = SplashScreen(self.opts["mf"].body,
                 "Updating Records ... Please Wait")
-            for ref, dte, self.allcoy, acc, val, cod, vat, des in trans:
-                self.trnref = ref
-                self.trndat = dte
+            for self.trnref, self.trndat, self.allcoy, self.acno, \
+                    self.trnamt, self.vatcod, vat, self.trndet in trans:
                 if self.bh.multi == "N":
                     self.curdt = self.bh.curdt
                 else:
                     self.curdt = self.trndat / 100
                 self.doChkLoadCtls()
-                self.acno = acc
-                self.trnamt = val
-                self.vatcod = cod
                 if self.vatcod and not vat:
                     vrte = getVatRate(self.sql, self.opts["conum"],
                         self.vatcod, self.trndat)
@@ -296,7 +599,7 @@
                     self.vatamt = round((self.trnamt * vrte / (vrte + 100)), 2)
                 else:
                     self.vatamt = vat
-                self.trndet = des
+                self.allamt = float(ASD(self.trnamt) - ASD(self.vatamt))
                 self.updateTables()
                 self.updateBatch()
             self.bh.doBatchTotal(imp=True)
@@ -308,16 +611,6 @@
         if self.impint == "N":
             self.batind = "N"
 
-    def doAbort(self, widget=None):
-        ok = askQuestion(self.opts["mf"].body, head="Abort",
-            mess="Are You Certain You Want to Cancel These Batch Postings?")
-        if ok == "yes":
-            self.opts["mf"].dbm.rollbackDbase()
-            self.df.closeProcess()
-            self.opts["mf"].closeLoop()
-        else:
-            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-
     def doTrnRef(self, frt, pag, r, c, p, i, w):
         self.trnref = w
 
@@ -343,7 +636,7 @@
 
     def doChkLoadCtls(self):
         # Check for Intercompany Records
-        if not self.allcoy == self.opts["conum"]:
+        if self.allcoy != self.opts["conum"]:
             acc = self.sql.getRec(tables="genint", where=[("cti_cono", "=",
                 self.allcoy), ("cti_inco", "=", self.opts["conum"])], limit=1)
             if not acc:
@@ -356,47 +649,164 @@
         self.taxdf = ctlmst["ctm_taxdf"]
         if not self.taxdf:
             self.taxdf = "N"
-        # Check and Load VAT Control
+        # Check for Integrated Systems
+        mod = []
+        for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
+            mod.append(ctlmst["ctm_modules"][x:x+2])
+        # Load Ass Integration
+        if mod.count("AR"):
+            ctl = self.gc.getCtl("assctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.ass_gl = ctl["cta_glint"]
+        else:
+            self.ass_gl = "N"
+        # Load Bkm Integration
+        if mod.count("BK"):
+            ctl = self.gc.getCtl("bkmctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.bkm_gl = ctl["cbk_glint"]
+        else:
+            self.bkm_gl = "N"
+        # Load Crs Integration
+        if mod.count("CR"):
+            ctl = self.gc.getCtl("crsctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.crs_gl = ctl["ctc_glint"]
+        else:
+            self.crs_gl = "N"
+        # Load Drs Integration and Chain Store Flag
+        if mod.count("DR"):
+            ctl = self.gc.getCtl("drsctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.drs_gl = ctl["ctd_glint"]
+            self.drs_ch = ctl["ctd_chain"]
+        else:
+            self.drs_gl = "N"
+            self.drs_ch = "N"
+        # Load Lon Integration
+        if mod.count("LN"):
+            ctl = self.gc.getCtl("lonctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.lon_gl = ctl["cln_glint"]
+            self.lon_dr = ctl["cln_drte"]
+            self.lon_cr = ctl["cln_crte"]
+        else:
+            self.lon_gl = "N"
+        # Load Mem Integration
+        if mod.count("ML"):
+            ctl = self.gc.getCtl("memctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.mem_gl = ctl["mcm_glint"]
+        else:
+            self.mem_gl = "N"
+        # Load Sln Integration
+        if mod.count("SL"):
+            ctl = self.gc.getCtl("wagctl", self.allcoy)
+            if not ctl:
+                return "rf"
+            self.sln_gl = ctl["ctw_glint"]
+            self.sln_rt = ctl["ctw_i_rate"]
+        else:
+            self.sln_gl = "N"
+        # Check for Control Records e.g. VAT, Crs and Drs
         self.ctlctl = self.gc.getCtl("ctlctl", self.allcoy)
         if not self.ctlctl:
             return "rf"
         ctls = ["vat_ctl"]
+        if self.ass_gl == "Y":
+            ctls.append("ass_sls")
+        if self.bkm_gl == "Y":
+            ctls.append("bkm_ctl")
+        if self.crs_gl == "Y":
+            ctls.append("crs_ctl")
+        if self.drs_gl == "Y":
+            ctls.append("drs_ctl")
+        if self.lon_gl == "Y":
+            ctls.extend(["lon_ctl", "int_pay", "int_rec"])
+        if self.mem_gl == "Y":
+            ctls.append("mem_ctl")
+        if self.sln_gl == "Y":
+            ctls.extend(["wag_slc", "wag_sli"])
         if self.gc.chkRec(self.allcoy, self.ctlctl, ctls):
             return "rf"
         self.convat = self.ctlctl["vat_ctl"]
-        # Set Batch Indicator
+        # Get for Asset Accounts
+        if self.ass_gl == "Y":
+            self.assctl = []
+            ass = self.sql.getRec(tables="assgrp", cols=["asg_assacc"],
+                where=[("asg_cono", "=", self.allcoy)])
+            for a in ass:
+                self.assctl.append(a[0])
+        # Batch Indicator
         if self.allcoy == self.opts["conum"]:
             self.batind = "N"
         else:
             self.batind = ""
 
     def doAccNum(self, frt, pag, r, c, p, i, w):
-        chk = chkGenAcc(self.opts["mf"], self.allcoy, w)
+        self.others = False
+        self.othtot = 0
+        if self.ass_gl == "Y" and w in self.assctl:
+            self.others = "ass"
+        elif self.bkm_gl == "Y" and w == self.ctlctl["bkm_ctl"]:
+            self.others = "bkm"
+        elif self.crs_gl == "Y" and w == self.ctlctl["crs_ctl"]:
+            self.others = "crs"
+        elif self.drs_gl == "Y" and w == self.ctlctl["drs_ctl"]:
+            self.others = "drs"
+        elif self.lon_gl == "Y" and w == self.ctlctl["lon_ctl"]:
+            self.others = "lon"
+        elif self.mem_gl == "Y" and w == self.ctlctl["mem_ctl"]:
+            self.others = "mem"
+        elif self.sln_gl == "Y" and w == self.ctlctl["wag_slc"]:
+            self.others = "sln"
+        if self.others:
+            ctl = False
+        else:
+            ctl = True
+        chk = chkGenAcc(self.opts["mf"], self.allcoy, w, ctl=ctl)
         if type(chk) is str:
             return chk
         self.acno = w
-        self.vattot = 0
-        if not chk[2]:
+        self.df.loadEntry(frt, pag, p+1, chk[0])
+        if self.others:
+            if self.others in ("bkm", "sln"):
+                self.othrtn = 5
+            else:
+                self.othrtn = 3
+            self.vatcod = "N"
+        elif not chk[2]:
             if chk[3] == "P":
-                self.taxgl = self.taxdf
+                self.vatcod = self.taxdf
             else:
-                self.taxgl = "N"
+                self.vatcod = "N"
         else:
-            self.taxgl = chk[2]
-        self.df.loadEntry("C", 0, p+1, data=chk[0])
+            self.vatcod = chk[2]
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):
         self.trnamt = w
-        self.df.loadEntry("C", 0, p+1, self.taxgl)
+        self.df.loadEntry("C", 1, p+1, self.vatcod)
+        if self.others:
+            self.vatamt = 0
+            self.allamt = self.trnamt
+            self.df.loadEntry("C", 1, p+2, self.vatamt)
+            return "sk2"
 
     def doVatCod(self, frt, pag, r, c, p, i, w):
         vrte = getVatRate(self.sql, self.opts["conum"], w, self.trndat)
         if vrte is None:
             return "Invalid V.A.T. Code"
         self.vatcod = w
-        self.vatamt = str(round((self.trnamt * vrte / (vrte + 100)), 2))
-        self.df.loadEntry("C", 0, p+1, data=self.vatamt)
+        self.vatamt = round((self.trnamt * vrte / (vrte + 100)), 2)
+        self.df.loadEntry("C", 1, p+1, data=self.vatamt)
         if not self.vatamt:
+            self.allamt = self.trnamt
             return "sk1"
 
     def doVatAmt(self, frt, pag, r, c, p, i, w):
@@ -406,139 +816,606 @@
             self.vatamt = float(ASD(0) - ASD(w))
         else:
             self.vatamt = w
+        self.allamt = float(ASD(self.trnamt) - ASD(self.vatamt))
         self.df.loadEntry(frt, pag, p, data=self.vatamt)
 
     def doTrnDet(self, frt, pag, r, c, p, i, w):
         self.trndet = w
 
-    def standardHeader(self):
-        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-            "General Ledger " + gltrtp[self.opts["rtn"] - 1][1] + \
-            " Data Capture (%s)" % __name__)
-        r1s = (
-            ("Monthly", "M"),
-            ("Quarterly", "3"),
-            ("Bi-Annually", "6"),
-            ("Annually", "Y"))
-        r2s = (("Yes", "Y"), ("No", "N"))
-        fld = (
-            (("T",0,0,0),("IRB",r1s),0,"Frequency","Frequency (M/3/6/Y)",
-                "M","N",self.doFreq,None,None,None),
-            (("T",0,1,0),("IRB",r2s),9,"All Journals","",
-                "N","N",self.doAllJnl,None,None,None),
-            (("T",0,2,0),("IRB",r2s),1,"All Periods","",
-                "N","N",self.doAllPer,None,None,None))
-        tnd = ((self.endPage,"y"),)
-        txt = (self.exitPage,)
-        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
-            tend=tnd, txit=txt)
-
-    def doFreq(self, frt, pag, r, c, p, i, w):
-        self.freq = w
-        self.wher = [("gjm_cono", "=", self.opts["conum"]), ("gjm_freq", "=",
-            self.freq), ("gjm_start","<=",self.bh.curdt), ("gjm_end", ">=",
-            self.bh.curdt), ("gjm_last", "<", self.bh.curdt)]
-        data = self.sql.getRec(tables="genjlm", cols=["gjm_num", "gjm_desc"],
-            where=self.wher)
-        if not data:
-            return "No Valid Standard Journals"
-        if self.freq == "M":
-            self.mths = 1
-        elif self.freq == "3":
-            self.mths = 3
-        elif self.freq == "6":
-            self.mths = 6
-        else:
-            self.mths = 12
-
-    def doAllJnl(self, frt, pag, r, c, p, i, w):
-        self.alljnl = w
-
-    def doAllPer(self, frt, pag, r, c, p, i, w):
-        self.allper = w
-
     def endPage(self):
-        if self.jtyp == "manual":
-            self.updateTables()
-            self.updateBatch()
-            self.cancel = False
-            self.agecan = False
-            self.df.advanceLine(0)
-        else:
-            self.df.closeProcess()
-            if self.alljnl == "N":
-                recs = getSingleRecords(self.opts["mf"], "genjlm", ("gjm_num",
-                    "gjm_desc"), where=self.wher)
-            else:
-                recs = self.sql.getRec(tables="genjlm", where=self.wher)
-            if recs:
-                for gjm in recs:
-                    self.batind = "N"
-                    self.trnref = gjm[self.sql.genjlm_col.index("gjm_num")]
-                    self.trndet = gjm[self.sql.genjlm_col.index("gjm_desc")]
-                    start = gjm[self.sql.genjlm_col.index("gjm_start")]
-                    last = gjm[self.sql.genjlm_col.index("gjm_last")]
-                    dates = []
-                    while not start > self.bh.curdt:
-                        if start < self.s_per or start <= last:
-                            pass
-                        elif self.allper == "N" and start == self.bh.curdt:
-                            dates.append(start)
-                        elif self.allper == "Y" and not start > self.bh.curdt:
-                            dates.append(start)
-                        start = self.nextPeriod(start)
-                    for self.curdt in dates:
-                        self.trndat = mthendDate((self.curdt * 100))
-                        data = self.sql.getRec(tables="genjlt",
-                            cols=["gjt_acno", "gjt_amnt", "gjt_vatc"],
-                            where=[("gjt_cono", "=", self.opts["conum"]),
-                                ("gjt_num", "=", self.trnref),
-                                ("gjt_amnt", "<>", 0)])
-                        if not data:
-                            continue
-                        for tran in data:
-                            self.acno = tran[0]
-                            self.trnamt = tran[1]
-                            self.vatcod = tran[2]
-                            vrte = getVatRate(self.sql, self.opts["conum"],
-                                self.vatcod, self.trndat)
-                            if vrte is None:
-                                vrte = 0.0
-                            self.vatamt = round(
-                                (self.trnamt * vrte / (vrte + 100)), 2)
-                            self.updateTables()
-                            self.updateBatch()
-                        self.sql.updRec("genjlm", cols=["gjm_last"],
-                            data=[self.curdt], where=[("gjm_cono", "=",
-                            self.opts["conum"]), ("gjm_num", "=", self.trnref),
-                            ("gjm_freq", "=", self.freq)])
-            self.closeBatch()
-            self.opts["mf"].closeLoop()
-
-    def nextPeriod(self, period):
-        yy = period / 100
-        mm = (period % 100) + self.mths
-        if mm > 12:
-            yy += 1
-            mm -= 12
-        return (yy * 100) + mm
+        self.updateTables()
+        self.updateBatch()
+        if self.others == "ass":
+            self.df.selPage("ASS")
+            self.allvat = self.vatamt
+            self.df.loadEntry("T", self.asspag, 0, data=self.allamt)
+            self.df.focusField("C", self.asspag, 1)
+        elif self.others == "bkm":
+            self.df.selPage("BKM")
+            self.df.loadEntry("T", self.bkmpag, 0, data=self.allamt)
+            self.df.focusField("C", self.bkmpag, 1)
+        elif self.others == "crs":
+            self.df.selPage("CRS")
+            self.df.loadEntry("T", self.crspag, 0, data=self.allamt)
+            self.df.focusField("C", self.crspag, 1)
+        elif self.others == "drs":
+            if self.drs_ch == "N":
+                self.df.colf[self.drspag][0][1] = "OUI"
+                self.chain = 0
+            else:
+                self.df.colf[self.drspag][0][1] = "IUI"
+            self.df.selPage("DRS")
+            self.df.loadEntry("T", self.drspag, 0, data=self.allamt)
+            self.df.focusField("C", self.drspag, 1)
+        elif self.others == "lon":
+            self.df.selPage("LON")
+            self.df.loadEntry("T", self.lonpag, 0, data=self.allamt)
+            self.df.focusField("C", self.lonpag, 1)
+        elif self.others == "mem":
+            self.df.selPage("MEM")
+            self.df.loadEntry("T", self.mempag, 0, data=self.allamt)
+            self.df.focusField("C", self.mempag, 1)
+        elif self.others == "sln":
+            self.df.selPage("SLN")
+            self.df.loadEntry("T", self.slnpag, 0, data=self.allamt)
+            self.df.focusField("C", self.slnpag, 1)
+        else:
+            self.df.advanceLine(1)
+
+    def doAssGrp(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="assgrp", where=[("asg_cono", "=",
+            self.allcoy), ("asg_group", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Asset Group (1)"
+        self.assgrp = w
+        self.depcod = acc[self.sql.assgrp_col.index("asg_depcod")]
+        self.assacc = acc[self.sql.assgrp_col.index("asg_assacc")]
+        self.depacc = acc[self.sql.assgrp_col.index("asg_depacc")]
+        self.expacc = acc[self.sql.assgrp_col.index("asg_expacc")]
+        if self.assacc != self.acno:
+            return "Invalid Asset Group (2)"
+
+    def doAssCod(self, frt, pag, r, c, p, i, w):
+        self.asscod = w
+        self.assbuy = 0
+        self.asssel = 0
+        cols = ["asm_desc"]
+        whr = [("asm_cono", "=", self.allcoy), ("asm_group", "=", self.assgrp),
+            ("asm_code", "=", w)]
+        acc = self.sql.getRec(tables="assmst", where=whr, cols=cols, limit=1)
+        if not acc:
+            ok = askQuestion(screen=self.opts["mf"].body, head="New Asset",
+                mess="Asset does not exist, Create?")
+            if ok == "no":
+                return "rf"
+            self.doNewAss()
+            acc = self.sql.getRec(tables="assmst", where=whr, cols=cols,
+                limit=1)
+            if not acc:
+                return "rf"
+            self.newass = True
+        else:
+            self.newass = False
+        pur = self.sql.getRec(tables="asstrn", cols=["ast_date"],
+            where=[("ast_cono", "=", self.allcoy), ("ast_group", "=",
+            self.assgrp), ("ast_code", "=", w)], limit=1)
+        if pur:
+            self.assbuy = pur[0]
+        sel = self.sql.getRec(tables="asstrn", cols=["ast_date"],
+            where=[("ast_cono", "=", self.allcoy), ("ast_group", "=",
+            self.assgrp), ("ast_code", "=", w), ("ast_mtyp", "=", 5)],
+            limit=1)
+        if sel:
+            self.asssel = sel[0]
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        if self.newass:
+            self.othmov = 1
+            self.df.loadEntry(frt, pag, p+2, data=self.othmov)
+            return "sk2"
+
+    def doAssMov(self, frt, pag, r, c, p, i, w):
+        if type(w) == list:
+            w = w[0] + 1
+        # Do some tests to see if not new again or already sold etc.
+        if w == 1 and self.assbuy:
+            return "Asset Already Purchased"
+        if w in (2, 5) and self.asssel:
+            return "Asset Already Sold"
+        if w in (2, 3, 5) and not self.assbuy:
+            return "Asset Not Yet Purchased"
+        self.df.loadEntry(frt, pag, p, data=w)
+        self.othmov = w
+
+    def doAssAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+        self.df.loadEntry(frt, pag, p, data=self.othamt)
+        self.df.loadEntry(frt, pag, p+1, data=self.trndet)
+
+    def doAssDet(self, frt, pag, r, c, p, i, w):
+        self.trndet = w
+
+    def endAss(self):
+        # Asset Register Transaction
+        data = [self.allcoy, self.assgrp, self.asscod, self.othrtn,
+            self.trnref, self.bh.batno, self.trndat, self.othmov,
+            self.othamt, self.othamt, 0, self.curdt, self.trndet,
+            "", "", self.opts["capnm"], self.sysdtw, 0]
+        self.sql.insRec("asstrn", data=data)
+        if self.othmov == 5:
+            # Sale of Asset
+            # Raise Depreciation
+            callModule(self.opts["mf"], None, "ar2030",
+                coy=(self.allcoy, self.allnam), period=self.opts["period"],
+                user=self.opts["capnm"], args=(self.curdt, self.assgrp,
+                self.asscod))
+            # Generate Sale
+            amt = self.sql.getRec(tables="asstrn", cols=["sum(ast_amt1)"],
+                where=[("ast_cono", "=", self.allcoy), ("ast_group", "=",
+                self.assgrp), ("ast_code", "=", self.asscod)], limit=1)
+            if amt[0]:
+                data = [self.opts["conum"], self.ctlctl["ass_sls"], self.curdt,
+                    self.trndat, self.opts["rtn"], self.trnref, self.bh.batno,
+                    amt[0], 0, self.trndet, "N", "", 0, self.opts["capnm"],
+                    self.sysdtw, 0]
+                self.sql.insRec("gentrn", data=data)
+                data[1] = self.acno
+                data[7] = float(ASD(0) - ASD(amt[0]))
+                self.sql.insRec("gentrn", data=data)
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.othtot == self.allamt:
+            self.endOther()
+        else:
+            bal = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry("T", self.asspag, 0, data=bal)
+            self.df.advanceLine(self.tagp["AR"])
+
+    def doNewAss(self):
+        tit = ("Create New Asset", )
+        dep = {
+            "stype": "R",
+            "tables": ("assdep",),
+            "cols": (
+                ("asd_code", "", 0, "Cod"),
+                ("asd_desc", "", 0, "Description", "Y")),
+            "where": [("asd_cono", "=", self.allcoy)]}
+        self.fld = (
+            (("T",0,0,0),"INA",30,"Description","",
+                "","N",None,None,None,("notblank",)),
+            (("T",0,1,0),"INa",3,"Dep Code","Depreciation Code",
+                self.depcod,"N",self.doNewADep,dep,None,("notblank",)),
+            (("T",0,1,0),"ONA",27,""))
+        tnd = ((self.doNewAEnd,"N"), )
+        txt = (self.doNewAXit, )
+        state = self.df.disableButtonsTags()
+        self.na = TartanDialog(self.opts["mf"], tops=True, title=tit,
+            eflds=self.fld, tend=tnd, txit=txt)
+        self.opts["mf"].startLoop()
+        self.df.enableButtonsTags(state=state)
+
+    def doNewADep(self, frt, pag, r, c, p, i, w):
+        chk = self.sql.getRec(tables="assdep", cols=["asd_desc"],
+            where=[("asd_cono", "=", self.allcoy), ("asd_code", "=", w)],
+            limit=1)
+        if not chk:
+            return "Invalid Depreciation Code"
+        self.na.loadEntry(frt, pag, p+1, data=chk[0])
+
+    def doNewAEnd(self):
+        dat = [self.allcoy, self.assgrp, self.asscod]
+        dat.append(self.na.t_work[0][0][0])
+        dat.append(self.na.t_work[0][0][1])
+        self.sql.insRec("assmst", data=dat)
+        self.doNewAXit()
+
+    def doNewAXit(self):
+        self.na.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doBkmNum(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables=["bkmmst", "bkmcon"], cols=["bkm_value",
+            "bkc_sname", "bkc_names"], where=[("bkm_cono", "=", self.allcoy),
+            ("bkm_number", "=", w), ("bkc_cono=bkm_cono",),
+            ("bkc_ccode=bkm_ccode",)], limit=1)
+        if not acc:
+            return "Invalid Booking Number (1)"
+        self.bkmnum = w
+        self.bkmval = acc[0]
+        if acc[2]:
+            name = "%s, %s" % (acc[1], acc[2].split()[0])
+        else:
+            name = acc[1]
+        self.df.loadEntry(frt, pag, p+1, data=name)
+
+    def doBkmAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def endBkm(self):
+        # Bookings Ledger Transaction
+        data = [self.allcoy, self.bkmnum, self.othrtn, self.trnref,
+            self.bh.batno, self.trndat, self.othamt, 0, self.curdt,
+            self.trndet, "", "", self.opts["capnm"], self.sysdtw, 0]
+        self.sql.insRec("bkmtrn", data=data)
+        # Check and Update Status
+        trn = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
+            where=[("bkt_cono", "=", self.allcoy), ("bkt_number", "=",
+            self.bkmnum), ("bkt_type", "<>", 1)], limit=1)
+        if not trn[0]:
+            bal = CCD(0, "SD", 13.2).work
+        else:
+            bal = CCD(trn[0], "SD", 13.2).work
+        if not bal or bal == float(ASD(0) - ASD(self.bkmval)):
+            state = "S"
+        elif bal == self.bkmval:
+            state = "Q"
+        else:
+            state = "C"
+        self.sql.updRec("bkmmst", cols=["bkm_state"], data=[state],
+            where=[("bkm_cono", "=", self.allcoy), ("bkm_number", "=",
+            self.bkmnum)])
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.othtot == self.allamt:
+            self.endOther()
+        else:
+            bal = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry("T", self.bkmpag, 0, data=bal)
+            self.df.advanceLine(self.tagp["BK"])
+
+    def doCrsAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
+            where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
+            self.othacno)], limit=1)
+        if not acc:
+            ok = askQuestion(screen=self.opts["mf"].body, head="New Creditor",
+                mess="Account does not exist, Create?")
+            if ok == "no":
+                return "rf"
+            self.doNewCrs()
+            acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
+                where=[("crm_cono", "=", self.allcoy), ("crm_acno", "=",
+                self.othacno)], limit=1)
+            if not acc:
+                return "rf"
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.allref = self.trnref
+
+    def doCrsRef(self, frt, pag, r, c, p, i, w):
+        self.othref = w
+
+    def doCrsAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def doNewCrs(self, widget=None):
+        callModule(self.opts["mf"], self.df, "cr1010", coy=(self.allcoy,
+            self.allnam), period=None, user=self.opts["capnm"],
+            args=self.othacno)
+
+    def doDrsChn(self, frt, pag, r, c, p, i, w):
+        self.chain = w
+
+    def doDrsAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
+            where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
+            self.chain), ("drm_acno", "=", self.othacno)], limit=1)
+        if not acc:
+            ok = askQuestion(screen=self.opts["mf"].body, head="New Debtor",
+                mess="Account does not exist, Create?")
+            if ok == "no":
+                return "rf"
+            self.doNewDrs()
+            acc = self.sql.getRec(tables="drsmst", cols=["drm_name"],
+                where=[("drm_cono", "=", self.allcoy), ("drm_chain", "=",
+                self.chain), ("drm_acno", "=", self.othacno)], limit=1)
+            if not acc:
+                return "rf"
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.allref = self.trnref
+
+    def doDrsRef(self, frt, pag, r, c, p, i, w):
+        self.othref = w
+
+    def doDrsAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def doNewDrs(self, widget=None):
+        callModule(self.opts["mf"], self.df, "dr1010", coy=(self.allcoy,
+            self.allnam), period=None, user=self.opts["capnm"],
+            args=(self.chain, self.othacno))
+
+    def doLonAcc(self, frt, pag, r, c, p, i, w):
+        newacc = False
+        if not w:
+            yn = askQuestion(self.opts["mf"].body, "New Account",
+                "Is This a New Account?", default="no")
+            if yn == "no":
+                return "Invalid Account Number"
+            newacc = True
+            w = callModule(self.opts["mf"], self.df, "ln1010",
+                coy=(self.allcoy, self.allnam), user=self.opts["capnm"],
+                args="auto", ret="acno")
+            self.df.loadEntry(frt, pag, p, data=w)
+        acc = self.sql.getRec(tables="lonmf1", cols=["lm1_name"],
+            where=[("lm1_cono", "=", self.allcoy),
+            ("lm1_acno", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Account Number"
+        self.lonacc = w
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        if newacc:
+            self.lonnum = 1
+            self.newlon = True
+            self.df.loadEntry(frt, pag, p+2, data=self.lonnum)
+            return "sk2"
+
+    def doLonNum(self, frt, pag, r, c, p, i, w):
+        self.newlon = False
+        if not w:
+            ok = askQuestion(self.opts["mf"].body, head="New Loan",
+                mess="Is This a New Loan?", default="no")
+            if ok == "yes":
+                self.newlon = True
+                self.lonnum = getNextCode(self.sql, "lonmf2", "lm2_loan",
+                    where=[("lm2_cono", "=", self.allcoy), ("lm2_acno",
+                    "=", self.lonacc)], start=1, last=9999999)
+                self.df.loadEntry(frt, pag, p, data=self.lonnum)
+            else:
+                return "Invalid Loan Number"
+        else:
+            self.lonmf2 = self.sql.getRec(tables="lonmf2", where=[("lm2_cono",
+                "=", self.allcoy), ("lm2_acno", "=", self.lonacc),
+                ("lm2_loan", "=", w)], limit=1)
+            if not self.lonmf2:
+                return "Invalid Loan Number"
+            self.lonnum = w
+            self.londes = self.lonmf2[self.sql.lonmf2_col.index("lm2_desc")]
+            self.londat = self.lonmf2[self.sql.lonmf2_col.index("lm2_start")]
+            self.lonmth = self.lonmf2[self.sql.lonmf2_col.index("lm2_pmths")]
+            self.lonpay = self.lonmf2[self.sql.lonmf2_col.index("lm2_repay")]
+            if self.lonmth:
+                return "Invalid Entry, Fixed Loan"
+            self.df.loadEntry(frt, pag, p+1, data=self.londes)
+            return "sk1"
+
+    def doLonDes(self, frt, pag, r, c, p, i, w):
+        self.londes = w
+
+    def doLonAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+        if not self.newlon:
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            self.df.loadEntry(frt, pag, p+2, data=0)
+            return "nd"
+
+    def doLonDri(self, frt, pag, r, c, p, i, w):
+        self.newdri = w
+
+    def doLonCri(self, frt, pag, r, c, p, i, w):
+        self.newcri = w
+
+    def doLonMth(self, frt, pag, r, c, p, i, w):
+        self.lonmth = w
+        if self.lonmth:
+            rte = (self.newdri / 1200.0)
+            self.lonpay = round(((self.othamt * rte) * ((1 + rte) ** w)) /
+                (((1 + rte) ** w) - 1), 2)
+        else:
+            self.lonpay = 0
+        self.df.loadEntry(frt, pag, p+1, data=self.lonpay)
+
+    def endLon(self):
+        if self.newlon:
+            # Loans Rate
+            self.sql.insRec("lonrte", data=[self.allcoy, self.lonacc,
+                self.lonnum, self.trndat, self.newdri, self.newcri])
+            # Loans Ledger Masterfile
+            self.sql.insRec("lonmf2", data=[self.allcoy, self.lonacc,
+                self.lonnum, self.londes, self.trndat, self.lonmth,
+                self.lonpay])
+        # Loans Ledger Transaction
+        data = [self.allcoy, self.lonacc, self.lonnum, self.bh.batno,
+            self.othrtn, self.trndat, self.trnref, self.othamt, self.curdt,
+            self.trndet, "", self.opts["capnm"], self.sysdtw, 0]
+        self.sql.insRec("lontrn", data=data)
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.othtot == self.allamt:
+            self.endOther()
+        else:
+            bal = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry("T", self.lonpag, 0, data=bal)
+            self.df.advanceLine(self.tagp["LN"])
+
+    def doMemAcc(self, frt, pag, r, c, p, i, w):
+        self.othacno = w
+        acc = self.sql.getRec(tables="memmst", cols=["mlm_surname",
+            "mlm_names"], where=[("mlm_cono", "=", self.allcoy),
+            ("mlm_memno", "=", self.othacno)], limit=1)
+        if not acc:
+            return "Invalid Member Number"
+        self.name = "%s, %s" % (acc[0], acc[1])
+        self.df.loadEntry(frt, pag, p+1, data=self.name)
+        self.allref = self.trnref
+
+    def doMemAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+
+    def doSlnEmp(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="wagmst", cols=["wgm_sname", "wgm_fname"],
+            where=[("wgm_cono", "=", self.allcoy), ("wgm_empno", "=", w)],
+            limit=1)
+        if not acc:
+            return "Invalid Employee Number"
+        self.empnum = w
+        empnam = "%s, %s" % (acc[0], acc[1].split()[0])
+        self.df.loadEntry(frt, pag, p+1, data=empnam)
+
+    def doSlnNum(self, frt, pag, r, c, p, i, w):
+        if not w:
+            ok = askQuestion(self.opts["mf"].body, head="New Loan",
+                mess="Is This a New Loan?", default="no")
+            if ok == "yes":
+                self.newsln = True
+                self.slnnum = getNextCode(self.sql, "waglmf", "wlm_loan",
+                    where=[("wlm_cono", "=", self.allcoy), ("wlm_empno",
+                    "=", self.empnum)], start=1, last=99999)
+                self.df.loadEntry(frt, pag, p, data=self.slnnum)
+        else:
+            acc = self.sql.getRec(tables="waglmf", where=[("wlm_cono",
+                "=", self.allcoy), ("wlm_empno", "=", self.empnum),
+                ("wlm_loan", "=", self.slnnum)], limit=1)
+            if not acc:
+                return "Loan Does Not Exist"
+            self.slnnum = w
+            self.newsln = False
+            self.slndes = acc[self.sql.waglmf_col.index("wlm_desc")]
+            self.slncod = acc[self.sql.waglmf_col.index("wlm_code")]
+            self.slnrte = acc[self.sql.waglmf_col.index("wlm_rate")]
+            self.slndat = acc[self.sql.waglmf_col.index("wlm_start")]
+            self.slnded = acc[self.sql.waglmf_col.index("wlm_repay")]
+            self.df.loadEntry(frt, pag, p+1, data=self.slndes)
+            return "sk1"
+
+    def doSlnDes(self, frt, pag, r, c, p, i, w):
+        self.slndes = w
+
+    def doSlnAmt(self, frt, pag, r, c, p, i, w):
+        self.othamt = w
+        if not self.othamt:
+            self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry(frt, pag, p, data=self.othamt)
+        if not self.newsln:
+            self.df.loadEntry(frt, pag, p+1, data=self.slncod)
+
+    def doSlnCod(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="wagedc", cols=["ced_desc"],
+            where=[("ced_cono", "=", self.allcoy), ("ced_type",
+            "=", "D"), ("ced_code", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Code"
+        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        self.slncod = w
+        if not self.newsln:
+            self.newrte = 0
+            self.slnded = 0
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            self.df.loadEntry(frt, pag, p+2, data=0)
+            return "nd"
+        self.df.loadEntry(frt, pag, p+2, data=self.slnrte)
+
+    def doSlnInt(self, frt, pag, r, c, p, i, w):
+        self.newrte = w
+        if not self.newsln:
+            self.df.loadEntry(frt, pag, p+2, data=self.slnded)
+
+    def doSlnDed(self, frt, pag, r, c, p, i, w):
+        self.slnded = w
+
+    def endSln(self):
+        if self.newsln:
+            # Staff Loans Ledger Masterfile
+            cap = self.othamt
+            self.sql.insRec("waglmf", data=[self.allcoy, self.empnum,
+                self.slnnum, self.slndes, self.slncod, self.newrte,
+                self.trndat, self.slnded])
+        else:
+            # Staff Loans Ledger Masterfile
+            cap = self.othamt
+            self.sql.updRec("waglmf", cols=["wlm_int_per"], data=[self.newrte],
+                where=[("wlm_cono", "=", self.allcoy), ("wlm_empno", "=",
+                self.empnum), ("wlm_loan", "=", self.slnnum)])
+        # Staff Loans Ledger Transaction
+        data = [self.allcoy, self.empnum, self.slnnum, self.bh.batno,
+            self.othrtn, self.trndat, self.trnref, self.othamt, cap,
+            self.slnded, self.newrte, self.curdt, self.trndet, "",
+            self.opts["capnm"], self.sysdtw, 0]
+        self.sql.insRec("wagltf", data=data)
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.othtot == self.allamt:
+            self.endOther()
+        else:
+            bal = float(ASD(self.allamt) - ASD(self.othtot))
+            self.df.loadEntry("T", self.slnpag, 0, data=bal)
+            self.df.advanceLine(self.tagp["SL"])
+
+    def endCrsDrsMem(self):
+        self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
+        if self.others == "crs":
+            # Creditors Ledger Transaction
+            amt = float(ASD(0) - ASD(self.othamt))
+            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.bh.batno, self.trndat, self.othref, amt, 0, 0,
+                self.curdt, 0, "Y", 0, self.trndet, "", "",
+                self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("crstrn", data=data, unique="crt_ref1")
+            if self.othtot == self.allamt:
+                self.endOther()
+            else:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.crspag, 0, data=bal)
+                self.df.advanceLine(self.tagp["CR"])
+        elif self.others == "drs":
+            # Debtors Ledger Transaction
+            data = [self.allcoy, self.chain, self.othacno, self.othrtn,
+                self.allref, self.bh.batno, self.trndat, self.othref,
+                self.othamt, 0, self.curdt, self.trndet, "", "",
+                self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("drstrn", data=data, unique="drt_ref1")
+            if self.othtot == self.allamt:
+                self.endOther()
+            else:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.drspag, 0, data=bal)
+                self.df.advanceLine(self.tagp["DR"])
+        elif self.others == "mem":
+            # Members Ledger Transaction
+            data = [self.allcoy, self.othacno, self.othrtn, self.allref,
+                self.bh.batno, self.trndat, self.othamt, 0, self.curdt,
+                "", 0, self.trndet, "", "", self.opts["capnm"], self.sysdtw, 0]
+            self.sql.insRec("memtrn", data=data, unique="mlt_refno")
+            if self.othtot == self.allamt:
+                self.endOther()
+            else:
+                bal = float(ASD(self.allamt) - ASD(self.othtot))
+                self.df.loadEntry("T", self.mempag, 0, data=bal)
+                self.df.advanceLine(self.tagp["ML"])
+
+    def endOther(self):
+        self.df.clearFrame("C", self.mempag)
+        self.df.selPage("Transaction")
+        self.df.advanceLine(1)
 
     def updateTables(self):
         if not self.allcoy == self.opts["conum"]:
-            inter = "y"
+            inter = True
             ac1 = self.sql.getRec(tables="genint", cols=["cti_acno"],
-                where=[("cti_cono", "=", self.opts["conum"]), ("cti_inco", "=",
-                self.allcoy)], limit=1)[0]
+                where=[("cti_cono", "=", self.opts["conum"]),
+                ("cti_inco", "=", self.allcoy)], limit=1)[0]
             ac2 = self.sql.getRec(tables="genint", cols=["cti_acno"],
-                where=[("cti_cono", "=", self.allcoy), ("cti_inco", "=",
-                self.opts["conum"])], limit=1)[0]
+                where=[("cti_cono", "=", self.allcoy),
+                ("cti_inco", "=", self.opts["conum"])], limit=1)[0]
         else:
-            inter = "n"
-        amt = float(ASD(self.trnamt) - ASD(self.vatamt))
+            inter = False
         data = (self.allcoy, self.acno, self.curdt, self.trndat,
-            self.opts["rtn"], self.trnref, self.bh.batno, amt, self.vatamt,
-            self.trndet, self.vatcod, self.batind, 0, self.opts["capnm"],
-            self.sysdtw, 0)
+            self.opts["rtn"], self.trnref, self.bh.batno, self.allamt,
+            self.vatamt, self.trndet, self.vatcod, self.batind, 0,
+            self.opts["capnm"], self.sysdtw, 0)
         self.sql.insRec("gentrn", data=data)
         if self.vatcod:
             if self.vatamt:
@@ -547,16 +1424,16 @@
                     0.00, self.trndet, self.vatcod, self.batind, 0,
                     self.opts["capnm"], self.sysdtw, 0)
                 self.sql.insRec("gentrn", data=data)
-            if amt < 0:
+            if self.allamt < 0:
                 vtyp = "O"
             else:
                 vtyp = "I"
             data = (self.allcoy, self.vatcod, vtyp, self.curdt, "G",
                 self.opts["rtn"], self.bh.batno, self.trnref, self.trndat,
-                self.acno, self.trndet, amt, self.vatamt, 0,
+                self.acno, self.trndet, self.allamt, self.vatamt, 0,
                 self.opts["capnm"], self.sysdtw, 0)
             self.sql.insRec("ctlvtf", data=data)
-        if inter == "y":
+        if inter:
             data = (self.opts["conum"], ac1, self.curdt, self.trndat,
                 self.opts["rtn"], self.trnref, self.bh.batno, self.trnamt,
                 0.00, self.trndet, self.vatcod, "N", 0, self.opts["capnm"],
@@ -576,39 +1453,35 @@
         else:
             self.bh.batqty = self.bh.batqty + 1
             self.bh.batval = float(ASD(self.bh.batval) + ASD(self.trnamt))
-        if self.jtyp == "manual" and not self.importing:
+        if not self.importing:
             self.df.loadEntry("T", 0, 0, data=self.bh.batqty)
             self.df.loadEntry("T", 0, 1, data=self.bh.batval)
 
     def exitPage(self, widget=None):
-        if self.jtyp == "standard":
+        err = False
+        if self.bh.batval:
+            cf = PwdConfirm(self.opts["mf"], conum=self.allcoy,
+                system="GEN", code="JnlBal")
+            if not cf.pwd or cf.flag == "no":
+                err = "Debits Do Not Equal Credits"
+        if err:
+            self.opts["mf"].updateStatus(err)
+            showError(self.opts["mf"].body, "Total Error", err)
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+        else:
             self.df.closeProcess()
-            self.opts["mf"].closeLoop()
-        else:
-            err = False
-            if self.bh.batval:
-                cf = PwdConfirm(self.opts["mf"], conum=self.allcoy,
-                    system="GEN", code="JnlBal")
-                if not cf.pwd or cf.flag == "no":
-                    err = "Debits Do Not Equal Credits"
-            if err:
-                self.opts["mf"].updateStatus(err)
-                showError(self.opts["mf"].body, "Total Error", err)
-                self.df.focusField(self.df.frt, self.df.pag, self.df.col)
-            else:
-                self.df.closeProcess()
-                self.closeBatch()
-                self.opts["mf"].closeLoop()
-
-    def closeBatch(self):
-        if self.jtyp == "manual":
             self.bh.doBatchTotal()
+            self.opts["mf"].closeLoop()
+
+    def doAbort(self, widget=None):
+        ok = askQuestion(self.opts["mf"].body, head="Abort",
+            mess="Are You Certain You Want to Cancel These Batch Postings?")
+        if ok == "yes":
+            self.abort = True
+            self.opts["mf"].dbm.rollbackDbase()
+            self.df.closeProcess()
+            self.opts["mf"].closeLoop()
         else:
-            self.sql.updRec("gentrn", cols=["glt_batind"], data=["Y"],
-                where=[("glt_cono", "=", self.opts["conum"]), ("glt_type", "=",
-                self.opts["rtn"]), ("glt_batch", "=", self.bh.batno),
-                ("glt_curdt", "between", self.s_per, self.e_per),
-                ("glt_batind", "=", "N")])
-            self.opts["mf"].dbm.commitDbase()
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'gen/gl2050.py'
--- gen/gl2050.py	1970-01-01 00:00:00 +0000
+++ gen/gl2050.py	2016-05-04 08:44:40 +0000
@@ -0,0 +1,210 @@
+#! /usr/bin/python
+
+"""
+SYNOPSIS
+    General Ledger Standard Journals.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2016 Paul Malherbe.
+"""
+
+import time
+from TartanClasses import ASD, Batches, GetCtl, Sql, TartanDialog
+from tartanFunctions import getSingleRecords, getVatRate, mthendDate
+from tartanWork import gltrtp
+
+class gl2050:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.doProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        # Check for Company Record
+        self.gc = GetCtl(self.opts["mf"])
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        # Check and Load VAT Control
+        self.ctlctl = self.gc.getCtl("ctlctl", self.opts["conum"])
+        if not self.ctlctl:
+            return
+        if self.gc.chkRec(self.opts["conum"], self.ctlctl, ["vat_ctl"]):
+            return
+        self.convat = self.ctlctl["vat_ctl"]
+        # Set Batch Indicator
+        self.batind = "N"
+        # Create SQL Object
+        tab = ["ctlctl", "ctlmst", "ctlvmf", "ctlvrf", "ctlvtf", "genint",
+            "genjlm", "genjlt", "genmst", "gentrn", "assgrp", "rtlprm"]
+        self.sql = Sql(self.opts["mf"].dbm, tab, prog=__name__)
+        if self.sql.error:
+            return
+        self.bh = Batches(self.opts["mf"], self.opts["conum"],
+            self.opts["conam"], self.opts["period"], "GEN",
+            self.opts["rtn"], multi="Y")
+        self.bh.doBatchHeader()
+        if not self.bh.batno:
+            return
+        t = time.localtime()
+        self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
+        self.s_per = self.opts["period"][1][0] / 100
+        self.e_per = self.opts["period"][1][0] / 100
+        return True
+
+    def doProcess(self):
+        tit = "General Ledger " + gltrtp[self.opts["rtn"] - 1][1] + \
+            " Data Capture (%s)" % __name__
+        r1s = (
+            ("Monthly", "M"),
+            ("Quarterly", "3"),
+            ("Bi-Annually", "6"),
+            ("Annually", "Y"))
+        r2s = (("Yes", "Y"), ("No", "N"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Frequency","",
+                "M","N",self.doFreq,None,None,None),
+            (("T",0,1,0),("IRB",r2s),9,"All Journals","",
+                "N","N",self.doAllJnl,None,None,None),
+            (("T",0,2,0),("IRB",r2s),1,"All Periods","",
+                "N","N",self.doAllPer,None,None,None))
+        tnd = ((self.doEnd,"y"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
+            tend=tnd, txit=txt)
+
+    def doFreq(self, frt, pag, r, c, p, i, w):
+        self.freq = w
+        self.wher = [("gjm_cono", "=", self.opts["conum"]), ("gjm_freq", "=",
+            self.freq), ("gjm_start","<=",self.bh.curdt), ("gjm_end", ">=",
+            self.bh.curdt), ("gjm_last", "<", self.bh.curdt)]
+        data = self.sql.getRec(tables="genjlm", cols=["gjm_num", "gjm_desc"],
+            where=self.wher)
+        if not data:
+            return "No Valid Standard Journals"
+        if self.freq == "M":
+            self.mths = 1
+        elif self.freq == "3":
+            self.mths = 3
+        elif self.freq == "6":
+            self.mths = 6
+        else:
+            self.mths = 12
+
+    def doAllJnl(self, frt, pag, r, c, p, i, w):
+        self.alljnl = w
+
+    def doAllPer(self, frt, pag, r, c, p, i, w):
+        self.allper = w
+
+    def doEnd(self):
+        self.df.closeProcess()
+        if self.alljnl == "N":
+            recs = getSingleRecords(self.opts["mf"], "genjlm", ("gjm_num",
+                "gjm_desc"), where=self.wher)
+        else:
+            recs = self.sql.getRec(tables="genjlm", where=self.wher)
+        if not recs:
+            self.opts["mf"].closeLoop()
+            return
+        for gjm in recs:
+            self.trnref = gjm[self.sql.genjlm_col.index("gjm_num")]
+            self.trndet = gjm[self.sql.genjlm_col.index("gjm_desc")]
+            start = gjm[self.sql.genjlm_col.index("gjm_start")]
+            last = gjm[self.sql.genjlm_col.index("gjm_last")]
+            dates = []
+            while not start > self.bh.curdt:
+                if start < self.s_per or start <= last:
+                    pass
+                elif self.allper == "N" and start == self.bh.curdt:
+                    dates.append(start)
+                elif self.allper == "Y" and not start > self.bh.curdt:
+                    dates.append(start)
+                start = self.nextPeriod(start)
+            for self.curdt in dates:
+                self.trndat = mthendDate((self.curdt * 100))
+                data = self.sql.getRec(tables="genjlt",
+                    cols=["gjt_acno", "gjt_amnt", "gjt_vatc"],
+                    where=[("gjt_cono", "=", self.opts["conum"]),
+                        ("gjt_num", "=", self.trnref),
+                        ("gjt_amnt", "<>", 0)])
+                if not data:
+                    continue
+                for tran in data:
+                    self.acno = tran[0]
+                    self.trnamt = tran[1]
+                    self.vatcod = tran[2]
+                    vrte = getVatRate(self.sql, self.opts["conum"],
+                        self.vatcod, self.trndat)
+                    if vrte is None:
+                        vrte = 0.0
+                    self.vatamt = round(
+                        (self.trnamt * vrte / (vrte + 100)), 2)
+                    self.updateTables()
+                    self.updateBatch()
+                self.sql.updRec("genjlm", cols=["gjm_last"],
+                    data=[self.curdt], where=[("gjm_cono", "=",
+                    self.opts["conum"]), ("gjm_num", "=", self.trnref),
+                    ("gjm_freq", "=", self.freq)])
+        self.closeBatch()
+        self.opts["mf"].closeLoop()
+
+    def nextPeriod(self, period):
+        yy = period / 100
+        mm = (period % 100) + self.mths
+        if mm > 12:
+            yy += 1
+            mm -= 12
+        return (yy * 100) + mm
+
+    def updateTables(self):
+        amt = float(ASD(self.trnamt) - ASD(self.vatamt))
+        data = (self.opts["conum"], self.acno, self.curdt, self.trndat,
+            self.opts["rtn"], self.trnref, self.bh.batno, amt, self.vatamt,
+            self.trndet, self.vatcod, self.batind, 0, self.opts["capnm"],
+            self.sysdtw, 0)
+        self.sql.insRec("gentrn", data=data)
+        if self.vatcod:
+            if self.vatamt:
+                data = (self.opts["conum"], self.convat, self.curdt,
+                    self.trndat, self.opts["rtn"], self.trnref, self.bh.batno,
+                    self.vatamt, 0.00, self.trndet, self.vatcod, self.batind,
+                    0, self.opts["capnm"], self.sysdtw, 0)
+                self.sql.insRec("gentrn", data=data)
+            if amt < 0:
+                vtyp = "O"
+            else:
+                vtyp = "I"
+            data = (self.opts["conum"], self.vatcod, vtyp, self.curdt, "G",
+                self.opts["rtn"], self.bh.batno, self.trnref, self.trndat,
+                self.acno, self.trndet, amt, self.vatamt, 0,
+                self.opts["capnm"], self.sysdtw, 0)
+            self.sql.insRec("ctlvtf", data=data)
+
+    def updateBatch(self, rev=False):
+        if rev:
+            self.bh.batqty = self.bh.batqty - 1
+            self.bh.batval = float(ASD(self.bh.batval) - ASD(self.trnamt))
+        else:
+            self.bh.batqty = self.bh.batqty + 1
+            self.bh.batval = float(ASD(self.bh.batval) + ASD(self.trnamt))
+
+    def doExit(self, widget=None):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def closeBatch(self):
+        self.sql.updRec("gentrn", cols=["glt_batind"], data=["Y"],
+            where=[("glt_cono", "=", self.opts["conum"]), ("glt_type", "=",
+            self.opts["rtn"]), ("glt_batch", "=", self.bh.batno),
+            ("glt_curdt", "between", self.s_per, self.e_per),
+            ("glt_batind", "=", "N")])
+        self.opts["mf"].dbm.commitDbase()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'gen/gl3020.py'
--- gen/gl3020.py	2016-02-27 13:18:41 +0000
+++ gen/gl3020.py	2016-04-18 09:17:32 +0000
@@ -164,18 +164,18 @@
         self.totsonly = w
         if self.totsonly == "Y":
             if self.multi == "Y":
-                self.df.setWidget(self.df.topEntry[0][9][2][0], state="hide")
                 self.df.setWidget(self.df.topEntry[0][9][3][0], state="hide")
+                self.df.setWidget(self.df.topEntry[0][9][4][0], state="hide")
             else:
-                self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
                 self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+                self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
             if self.multi == "Y":
-                self.df.setWidget(self.df.topEntry[0][9][2][0], state="show")
                 self.df.setWidget(self.df.topEntry[0][9][3][0], state="show")
+                self.df.setWidget(self.df.topEntry[0][9][4][0], state="show")
             else:
-                self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
                 self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+                self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doCoy(self, frt, pag, r, c, p, i, w):
         self.other = w

=== modified file 'gen/gl3050.py'
--- gen/gl3050.py	2016-02-27 13:18:41 +0000
+++ gen/gl3050.py	2016-03-24 09:53:37 +0000
@@ -434,8 +434,8 @@
     def doCoyCmd(self, frt, pag, r, c, p, i, w):
         c = ""
         for co in w:
-            if int(co):
-                c = c + str(int(co)) + ","
+            if int(co[0]):
+                c = c + str(int(co[0])) + ","
         if len(c) > 1:
             c = c[:-1]
         self.cc.loadEntry(frt, pag, p, data=c)

=== added file 'gen/gl3120_rne.py'
--- gen/gl3120_rne.py	1970-01-01 00:00:00 +0000
+++ gen/gl3120_rne.py	2016-05-15 10:24:39 +0000
@@ -0,0 +1,924 @@
+"""
+SYNOPSIS
+    Preliminary Trading Profit and Loss Account.
+
+    This file is part of Tartan Financial Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2015 Paul Malherbe.
+"""
+
+from TartanClasses import CCD, FileImport, MyFpdf, SplashScreen, Sql
+from TartanClasses import TartanDialog, rgb
+from tartanFunctions import askQuestion, copyList, doPrinter, getModName
+from tartanFunctions import getNextCode, getPeriods, getSingleRecords
+from tartanFunctions import showError, simpleLineChart
+
+class gl3120:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "ctlynd", "ctlgrp",
+            "genqrb", "genqrc", "genqrd", "genqrt", "gentrn"], prog=__name__)
+        if self.sql.error:
+            return
+        p = self.sql.getRec(tables="ctlynd", cols=["max(cye_period)"],
+            where=[("cye_cono", "=", 1)])
+        self.finper = int(p[0][0])
+        return True
+
+    def mainProcess(self):
+        tit = "Preliminary Trading P&L Account"
+        fin = {
+            "stype": "R",
+            "tables": ("ctlynd",),
+            "cols": (
+                ("cye_period", "", 0, "Prd"),
+                ("cye_start", "", 0, "Start"),
+                ("cye_end", "", 0, "End")),
+            "where": [("cye_cono=1",)]}
+        bch = {
+            "stype": "R",
+            "tables": ("genqrb",),
+            "cols": (
+                ("gqb_bcod", "", 0, "Cod"),
+                ("gqb_name", "", 0, "Name")),
+            "order": "gqb_bcod"}
+        self.grps = [
+            (1, "Autocote"),
+            (2, "RNE"),
+            (3, "SPAR"),
+            (4, "Spargs")]
+        grp = {
+            "stype": "C",
+            "head": ("Cod", "Name"),
+            "typs": (("UI",3), ("NA",30)),
+            "data": self.grps}
+        dep = {
+            "stype": "R",
+            "tables": ("genqrc",),
+            "cols": (
+                ("gqc_dcod", "", 0, "Dep"),
+                ("gqc_name", "", 0, "Depart-Name")),
+            "order": "gqc_dcod"}
+        ctm = {
+            "stype": "R",
+            "tables": ("ctlmst",),
+            "cols": (
+                ("ctm_cono", "", 0, "Com"),
+                ("ctm_name", "", 0, "Name", "Y")),
+            "where": [
+                ("ctm_cono not in (select gqd_cono from genqrd)",)],
+            "order": "ctm_cono"}
+        tag = (("Details", None, ("T",0,1), None),)
+        r1s = (("South Africa", "S"), ("Transkei", "T"))
+        fld = (
+            (("T",0,0,0),"IUI",3,"Financial Period","",
+                self.finper,"Y",self.doFPer,fin,None,("efld",)),
+            (("T",0,1,0),"ID2",7,"Ending Period","",
+                0,"N",self.doEPer,None,None,("efld",)),
+            (("T",1,0,0),"IUI",3,"Group Code","",
+                "","Y",self.doCode,bch,None,("efld",)),
+            (("T",1,1,0),"INA",12,"Group Name", "",
+                "","N",self.doName,None,self.doDelete,("notblank",)),
+            (("T",1,2,0),("IRB",r1s),0,"Country Code", "",
+                "S","N",self.doCountry,None,None,None),
+            (("T",1,3,0),"IUI",1,"Group Code", "",
+                "","N",self.doGroup,grp,None,("notzero",)),
+            (("T",1,3,0),"ONA",30,""),
+            (("C",1,0,0),"IUI",3,"Dep","",
+                "","Y",self.doDepno,dep,None,("efld",)),
+            (("C",1,0,1),"INA",12,"Depart-Name", "",
+                "","N",self.doDepnm,None,None,("notblank",)),
+            (("C",1,0,2),"IUI",3,"Coy","",
+                "","N",self.doCono,ctm,None,("efld",)),
+            (("C",1,0,3),"ONA",30,"Company Name"),
+            (("C",1,0,4),"ISI",10,"Purchases","Additional Purchases",
+                0,"N",self.doPurch,None,None,("efld",)),
+            (("C",1,0,5),"ISI",10,"Sales","Additional Sales",
+                0,"N",self.doSale,None,None,("efld",)),
+            (("C",1,0,6),"ISI",10,"Incentives","Additional Incentives",
+                0,"N",self.doIncent,None,None,("efld",)),
+            (("C",1,0,7),"ISI",10,"Transit","Invoices in Transit",
+                0,"N",self.doTransit,None,None,("efld",)),
+            (("C",1,0,8),"ISI",10,"Stock","Closing Stock",
+                0,"N",self.doStock,None,None,("efld",)))
+        but = (
+            ("Import",None,self.doImport,0,("T",0,0),None,
+                "Import Values for Additionals like Closing Stock. The "\
+                "file must consist of at least the following 6 columns: "\
+                "Company Number, Purchases, Sales, Incentives, Invoices "\
+                "in Transit and Closing Stock"),
+            ("Manual",None,self.doManual,0,("T",0,0),None,
+                "Enter Additional Values Manually by Branch"),
+            ("Print",None,self.doPrint,0,("T",0,0),None),
+            ("Exit",None,self.doExit,0,("T",0,0),None),
+            ("Edit",None,self.doEdit,0,("C",1,1),None,None,1,4))
+        tnd = ((self.doEnd,"y"), (self.doEnd, "n"))
+        txt = (self.doExit, self.doExit)
+        cnd = (None, (self.doEnd,"y"))
+        cxt = (None, self.doExit)
+        self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
+            tags=tag, eflds=fld, butt=but, tend=tnd, txit=txt, cend=cnd,
+            cxit=cxt)
+
+    def doFPer(self, frt, pag, r, c, p, i, w):
+        f = getPeriods(self.opts["mf"], 1, w, check=True)
+        if f == (None, None, None):
+            return "Invalid Financial Period"
+        self.cper = w
+        self.sper = f[0].work / 100
+        self.eper = f[1].work / 100
+        self.df.loadEntry(frt, pag, p+1, data=self.eper)
+
+    def doEPer(self, frt, pag, r, c, p, i, w):
+        if w < self.sper or w > self.eper:
+            return "Period Not In Financial Period"
+        self.eper = w
+        self.eperd = CCD(self.eper, "D2", 7).disp
+
+    def doManual(self):
+        self.df.focusField("T", 1, 1)
+
+    def doCode(self, frt, pag, r, c, p, i, w):
+        if not w:
+            self.bcod = getNextCode(self.sql, "genqrb", "gqb_bcod", last=899)
+            self.df.loadEntry(frt, pag, p, data=self.bcod)
+        else:
+            self.bcod = w
+        acc = self.sql.getRec(tables="genqrb", where=[("gqb_bcod", "=", w)],
+            limit=1)
+        if not acc:
+            ok = askQuestion(self.opts["mf"].body, "New Branch",
+                "Is This a New Branch?", default="no")
+            if ok == "no":
+                return "Invalid Branch Code"
+            self.newbch = True
+        else:
+            self.newbch = False
+            self.df.loadEntry(frt, pag, p+1, data=acc[1])
+            self.df.loadEntry(frt, pag, p+2, data=acc[2])
+            self.df.loadEntry(frt, pag, p+3, data=acc[3])
+            name = None
+            for d in self.grps:
+                if acc[3] == d[0]:
+                    name = d[1]
+                    self.df.loadEntry(frt, pag, p+4, data=name)
+                    break
+
+    def doName(self, frt, pag, r, c, p, i, w):
+        self.bnam = w
+
+    def doCountry(self, frt, pag, r, c, p, i, w):
+        self.country = w
+
+    def doGroup(self, frt, pag, r, c, p, i, w):
+        name = None
+        for d in self.grps:
+            if w == d[0]:
+                name = d[1]
+                self.df.loadEntry(frt, pag, p+1, data=name)
+                break
+        if not name:
+            return "Invalid Group"
+        self.group = w
+
+    def doDepno(self, frt, pag, r, c, p, i, w):
+        dep = self.sql.getRec(tables="genqrc", where=[("gqc_dcod", "=", w)],
+            limit=1)
+        if not dep:
+            ok = askQuestion(self.opts["mf"].body, "Department",
+                "Is This a New Department?", default="no")
+            if ok == "yes":
+                self.newdep = True
+            else:
+                return "Invalid Department"
+        else:
+            self.newdep = False
+            self.df.loadEntry(frt, pag, p+1, data=dep[1])
+        self.dcod = w
+
+    def doDepnm(self, frt, pag, r, c, p, i, w):
+        self.dnam = w
+
+    def doCono(self, frt, pag, r, c, p, i, w):
+        coy = self.sql.getRec(tables="ctlmst", where=[("ctm_cono", "=", w)],
+            limit=1)
+        if not coy:
+            return "Invalid Company"
+        chk = self.sql.getRec(tables="genqrd", where=[("gqd_cono", "=", w)],
+            limit=1)
+        if chk:
+            return "ff%s|Company Already In Use, Use Edit|True" % (c - 2)
+        self.cono = w
+        return "sk1"
+
+    def doPurch(self, frt, pag, r, c, p, i, w):
+        self.purch = w
+
+    def doSale(self, frt, pag, r, c, p, i, w):
+        self.sale = w
+
+    def doIncent(self, frt, pag, r, c, p, i, w):
+        self.incent = w
+
+    def doTransit(self, frt, pag, r, c, p, i, w):
+        self.transit = w
+
+    def doStock(self, frt, pag, r, c, p, i, w):
+        self.stock = w
+
+    def doDelete(self):
+        if self.newbch:
+            return
+        self.sql.delRec("genqrb", where=[("gqb_bcod", "=", self.bcod)])
+        self.sql.delRec("genqrd", where=[("gqd_bcod", "=", self.bcod)])
+        self.opts["mf"].dbm.commitDbase()
+        return ("T", 1, 1)
+
+    def doEnd(self):
+        if self.df.pag == 0:
+            pass
+        elif self.df.frt == "T":
+            if self.newbch:
+                self.sql.insRec("genqrb", data=[self.bcod, self.bnam,
+                    self.country, self.group])
+            else:
+                self.sql.updRec("genqrb", cols=["gqb_name", "gqb_ccod",
+                    "gqb_gcod"], data=[self.bnam, self.country, self.group],
+                    where=[("gqb_bcod", "=", self.bcod)])
+            self.loadCoys()
+        elif self.df.frt == "C":
+            if self.newdep:
+                self.sql.insRec("genqrc", data=[self.dcod, self.dnam])
+            else:
+                self.sql.updRec("genqrc", cols=["gqc_name"], data=[self.dnam],
+                    where=[("gqc_dcod", "=", self.dcod)])
+            self.sql.insRec("genqrd", data=[self.bcod, self.dcod, self.cono])
+            chk = self.sql.getRec(tables="genqrt", where=[("gqt_cono", "=",
+                self.cono), ("gqt_curdt", "=", self.eper)])
+            if chk:
+                self.sql.updRec("genqrt", cols=["gqt_purch", "gqt_sale",
+                    "gqt_incent", "gqt_transit", "gqt_stock"],
+                    data=[self.purch, self.sale, self.incent, self.transit,
+                    self.stock], where=[("gqt_cono", "=", self.cono),
+                    ("gqt_curdt", "=", self.eper)])
+            else:
+                self.sql.insRec("genqrt", data=[self.cono, self.eper,
+                    self.purch, self.sale, self.incent, self.transit,
+                    self.stock])
+            self.df.advanceLine(1)
+
+    def doImport(self):
+        self.df.disableButtonsTags(tags=False)
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        fi = FileImport(self.opts["mf"], imptab="genqrt", impskp=["gqt_curdt"])
+        err = None
+        for num, line in enumerate(fi.impdat):
+            self.sql.delRec("genqrt", where=[("gqt_cono", "=", line[0]),
+                ("gqt_curdt", "=", self.eper)])
+            line.insert(1, self.eper)
+            self.sql.insRec("genqrt", data=line)
+        if err:
+            err = "Line %s: %s" % ((num + 1), err)
+            showError(self.opts["mf"].body, "Import Error", """%s
+
+Please Correct your Import File and then Try Again.""" % err)
+            self.opts["mf"].dbm.rollbackDbase()
+        else:
+            self.opts["mf"].dbm.commitDbase()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.enableButtons()
+
+    def doEdit(self):
+        self.edit = True
+        data = []
+        for line in self.df.c_work[1]:
+            if line[0]:
+                data.append(line)
+        if data:
+            titl = "Document Product Lines"
+            head = ("Dep", "Department", "Coy", "Company", "Purchases",
+                "Sales", "Incentives","Transit","Stock")
+            lin = {
+                "stype": "C",
+                "titl": titl,
+                "head": head,
+                "typs": [
+                    ("UI",3), ("NA",30), ("UI",3), ("NA",30), ("SI",10),
+                    ("SI",10), ("SI",10), ("SI",10), ("SI",10)],
+                "data": data}
+            self.df.disableButtonsTags(tags=False)
+            self.opts["mf"].updateStatus("Select a Product to Edit")
+            chg = self.df.selChoice(lin)
+            if chg and chg.selection:
+                self.chg = chg.selection
+                self.doEditChanges()
+            self.enableButtons()
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+
+    def doEditChanges(self):
+        tit = ("Change Entry",)
+        fld = (
+            (("T",0,0,0),"ONA",3,"Department"),
+            (("T",0,0,0),"ONA",30,""),
+            (("T",0,1,0),"ONA",3,"Company"),
+            (("T",0,1,0),"ONA",30,""),
+            (("T",0,2,0),"ISI",10,"Additional Purchases","",
+                0,"N",self.doPurch,None,None,("efld",)),
+            (("T",0,3,0),"ISI",10,"Additional Sales","",
+                0,"N",self.doSale,None,None,("efld",)),
+            (("T",0,4,0),"ISI",10,"Additional Incentives","",
+                0,"N",self.doIncent,None,None,("efld",)),
+            (("T",0,5,0),"ISI",10,"Invoices in Transit","",
+                0,"N",self.doTransit,None,None,("efld",)),
+            (("T",0,6,0),"ISI",10,"Closing Stock","",
+                0,"N",self.doStock,None,None,("efld",)))
+        but = [["Delete",None,self.doChgDel,1,None,None]]
+        self.cg = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, butt=but, tend=((self.doChgEnd,"n"),),
+            txit=(self.doChgExit,))
+        for x in range(9):
+            self.cg.loadEntry("T", 0, x, data=self.chg[x])
+        self.cg.focusField("T", 0, 3, clr=False)
+        self.opts["mf"].startLoop()
+
+    def doChgDel(self):
+        self.sql.delRec("genqrd", where=[("gqd_bcod", "=", self.bcod),
+            ("gqd_dcod", "=", self.chg[0]), ("gqd_cono", "=", self.chg[2])])
+        self.loadCoys()
+
+    def doChgEnd(self):
+        self.cg.closeProcess()
+        coy = self.cg.t_work[0][0][2]
+        pur = self.cg.t_work[0][0][4]
+        sls = self.cg.t_work[0][0][5]
+        inc = self.cg.t_work[0][0][6]
+        trn = self.cg.t_work[0][0][7]
+        stk = self.cg.t_work[0][0][8]
+        self.sql.delRec("genqrt", where=[("gqt_cono", "=", coy),
+            ("gqt_curdt", "=", self.eper)])
+        self.sql.insRec("genqrt", data=[coy,self.eper,pur,sls,inc,trn,stk])
+        self.loadCoys()
+        self.opts["mf"].closeLoop()
+
+    def doChgExit(self):
+        self.cg.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def loadCoys(self):
+        self.df.clearFrame("C", 1)
+        deps = self.sql.getRec(tables="genqrd", where=[("gqd_bcod",
+            "=", self.bcod)], order="gqd_dcod")
+        pos = 0
+        for dep in deps:
+            self.df.loadEntry("C", 1, pos, dep[1])
+            nam = self.sql.getRec(tables="genqrc", where=[("gqc_dcod",
+                "=", dep[1])], limit=1)
+            self.df.loadEntry("C", 1, pos+1, data=nam[1])
+            self.df.loadEntry("C", 1, pos+2, dep[2])
+            coy = self.sql.getRec(tables="ctlmst", cols=["ctm_name"],
+                where=[("ctm_cono", "=", dep[2])], limit=1)
+            self.df.loadEntry("C", 1, pos+3, data=coy[0])
+            rec = self.sql.getRec(tables="genqrt", where=[("gqt_cono",
+                "=", dep[2]), ("gqt_curdt", "=", self.eper)], limit=1)
+            for num, val in enumerate(rec[2:]):
+                self.df.loadEntry("C", 1, pos+4+num, data=val, zero=True)
+            pos += 9
+        self.df.focusField("C", 1, pos + 1)
+
+    def doPrint(self):
+        self.df.disableButtonsTags(tags=False)
+        tit = ("Print Reports",)
+        r1s = (("Yes", "Y"), ("No", "N"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Totals Only","",
+                "Y","Y",self.doPrtTot,None,None,None),
+            (("T",0,1,0),("IRB",r1s),0,"All Branches","",
+                "Y","Y",self.doAllBch,None,None,None),
+            (("T",0,2,0),("IRB",r1s),0,"Department Totals","",
+                "Y","Y",self.doPrtDep,None,None,None),
+            (("T",0,3,0),("IRB",r1s),0,"All Departments","",
+                "Y","Y",self.doAllDep,None,None,None))
+        self.pr = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, tend=((self.doPrtEnd,"n"),), txit=(self.doPrtExit,),
+            view=("N","V"), mail=("Y","N"))
+        self.opts["mf"].startLoop()
+        self.enableButtons()
+
+    def enableButtons(self):
+        self.df.setWidget(self.df.B0, "normal")
+        self.df.setWidget(self.df.B1, "normal")
+        self.df.setWidget(self.df.B2, "normal")
+        self.df.setWidget(self.df.B3, "normal")
+
+    def doPrtTot(self, frt, pag, r, c, p, i, w):
+        self.totonly = w
+
+    def doAllBch(self, frt, pag, r, c, p, i, w):
+        miss = []
+        self.bchs = []
+        if w == "Y":
+            self.bchs = self.sql.getRec(tables="genqrb", order="gqb_bcod")
+            if not self.bchs:
+                return "No Branches Available"
+        else:
+            self.bchs = getSingleRecords(self.opts["mf"],
+                "genqrb", ("gqb_bcod", "gqb_name"), order="gqb_bcod")
+            if not self.bchs:
+                return "No Branches Selected"
+        for bch in self.bchs:
+            coys = self.sql.getRec(tables="genqrd", cols=["gqd_cono"],
+                where=[("gqd_bcod", "=", bch[0])])
+            for coy in coys:
+                chk = self.sql.getRec(tables="genqrt", cols=["gqt_stock"],
+                    where=[("gqt_cono", "=", coy[0]), ("gqt_curdt",
+                    "=", self.eper)], limit=1)
+                if not chk and not coy[0] in miss:
+                    miss.append(coy[0])
+        if miss:
+            txt = ""
+            miss.sort()
+            for coy in miss:
+                if not txt:
+                    txt = "Missing Value Records for the following "\
+                        "Companies:\n\n%s" % coy
+                else:
+                    txt = "%s, %s" % (txt, coy)
+            txt += "\n\nUse Historical if Possible?"
+            ok = askQuestion(self.opts["mf"].body, "Missing Values", txt)
+            if ok == "no":
+                return "Invalid Answer"
+        if len(self.bchs) == 1:
+            self.prtdep = "N"
+            self.deps = []
+            self.pr.loadEntry(frt, pag, p+1, data="N")
+            return "sk2"
+
+    def doPrtDep(self, frt, pag, r, c, p, i, w):
+        self.prtdep = w
+        if self.prtdep == "N":
+            self.deps = []
+            return "sk1"
+
+    def doAllDep(self, frt, pag, r, c, p, i, w):
+        self.deps = []
+        if w == "Y":
+            self.deps = self.sql.getRec(tables="genqrc",
+                where=[("gqc_dcod", "<>", 0)], order="gqc_dcod")
+            if not self.deps:
+                return "No Departments Available"
+        else:
+            self.deps = getSingleRecords(self.opts["mf"],
+                "genqrc", ("gqc_dcod", "gqc_name"), order="gqc_dcod")
+            if not self.deps:
+                return "No Departments Selected"
+
+    def doPrtEnd(self):
+        self.pr.closeProcess()
+        sp = SplashScreen(self.opts["mf"].body,
+            "Generating Reports\n\nPlease Wait ...")
+        self.fpdf = MyFpdf(name=__name__, font=("Courier","",12),
+            auto=True, foot=True)
+        self.fpdf.header = self.doHead
+        self.fpdf.set_fill_color(220)
+        self.gt = {900: {}, 999: {}}
+        self.br = [["T", self.eper / 100], ["T", (self.eper / 100) - 1]]
+        self.bg = [["T", self.eper / 100], ["T", (self.eper / 100) - 1]]
+        self.dp = [["T", self.eper / 100], ["T", (self.eper / 100) - 1]]
+        self.dg = [["T", self.eper / 100], ["T", (self.eper / 100) - 1]]
+        self.codes = {
+            "P": [[201101], {900: 0, 999: 0}],
+            "S": [[101098, 101099, 101100, 101101, 101103, 101104,
+                    301110, 9905769], {900: 0, 999: 0}],
+            "I": [[101108], {900: 0, 999: 0}],
+            "A": [[303003], {900: 0, 999: 0}],
+            "R": [[403130], {900: 0, 999: 0}],
+            "O": [[201100], {900: 0, 999: 0}],
+            "T": [[0], {900: 0, 999: 0}],
+            "C": [[0], {900: 0, 999: 0}]}
+        for bch in self.bchs:
+            self.bcod, self.bnam, self.ccod, self.gcod = bch
+            coys = self.sql.getRec(tables=["genqrd", "ctlmst"],
+                cols=["gqd_dcod", "ctm_cono", "ctm_name"],
+                where=[("gqd_bcod", "=", self.bcod),
+                ("ctm_cono=gqd_cono",)], order="gqd_dcod")
+            for coy in coys:
+                dep, self.conum, self.conam = coy
+                if self.doPrintCoy(dep):
+                    sp.closeSplash()
+                    self.opts["mf"].closeLoop()
+                    return
+            # Branch Total
+            self.conum = 900
+            self.conam = "%s (Branch Total)" % bch[1]
+            self.doPrintCoy()
+            self.gt[900] = {}
+            for cod in ("P", "S", "I", "A", "R", "O", "T", "C"):
+                self.codes[cod][1][900] = 0
+        # Department Total
+        if self.prtdep == "Y":
+            for dep in self.deps:
+                self.conum = 900 + dep[0]
+                if self.conum in self.gt:
+                    self.conam = "%s (Department Total)" % dep[1]
+                    self.doPrintCoy()
+        # Grand Totals
+        if len(self.bchs) > 1:
+            self.conum = 999
+            self.conam = "All Stores Total"
+            self.doPrintCoy()
+            # Charts
+            self.conum = 0
+            self.conam = ""
+            self.fpdf.add_page()
+            head = "Branches Gross Profit for Period End %s" % self.eperd
+            xcol = []
+            for b in self.bchs:
+                xcol.append(b[1])
+            vals = []
+            ycol = []
+            for b in self.br:
+                ycol.append(b[1])
+                vals.append(b[2:])
+            simpleLineChart(self.fpdf, head, xcol, vals, ycol=ycol, labs=False)
+            self.fpdf.add_page()
+            head = "Branches G/P Percentages for Period End %s" % self.eperd
+            vals = []
+            ycol = []
+            for b in self.bg:
+                ycol.append(b[1])
+                vals.append(b[2:])
+            simpleLineChart(self.fpdf, head, xcol, vals, ycol=ycol, labs=False)
+            if self.prtdep == "Y" and len(self.deps) > 1:
+                self.fpdf.add_page()
+                head = "Department Gross Profit for Period End %s" % \
+                    self.eperd
+                xcol = []
+                for d in self.deps:
+                    xcol.append(d[1])
+                vals = []
+                ycol = []
+                for d in self.dp:
+                    ycol.append(d[1])
+                    vals.append(d[2:])
+                simpleLineChart(self.fpdf, head, xcol, vals, ycol=ycol,
+                    labs=False)
+                self.fpdf.add_page()
+                head = "Department G/P Percentages for Period End %s" % \
+                    self.eperd
+                vals = []
+                ycol = []
+                for d in self.dg:
+                    ycol.append(d[1])
+                    vals.append(d[2:])
+                simpleLineChart(self.fpdf, head, xcol, vals, ycol=ycol,
+                    labs=False)
+        sp.closeSplash()
+        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+            "all", ext="pdf")
+        self.fpdf.output(pdfnam, "F")
+        doPrinter(self.opts["mf"], pdfnam=pdfnam, repprt=self.pr.repprt,
+            repeml=self.pr.repeml)
+        self.opts["mf"].closeLoop()
+
+    def doPrtExit(self):
+        self.pr.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doHead(self):
+        self.fpdf.setFont("Courier", "B", 12, default=True)
+        if self.conum:
+            self.fpdf.drawText("%03i %-30s                Period End: %s" %
+                (self.conum, self.conam, self.eperd))
+            self.fpdf.drawText()
+        self.fpdf.drawText(txt="Trading Profit and Loss Account", align="C")
+        self.fpdf.drawText()
+
+    def doPrintCoy(self, dep=0):
+        if self.conum < 900:
+            qrt = self.sql.getRec(tables="genqrt",
+                where=[("gqt_cono", "=", self.conum),
+                ("gqt_curdt", "=", self.eper)], limit=1)
+            if not qrt:
+                sp = self.sper + 100
+                ep = self.eper + 100
+                cl = self.sql.getRec(tables="gentrn", cols=["sum(glt_tramt)"],
+                    where=[("glt_cono", "=", self.conum), ("glt_acno", "=",
+                    201100), ("glt_curdt", "between", sp, ep)], limit=1)
+                if cl[0] is None:
+                    cl = [0]
+                qrt = [self.conum, self.eper, 0, 0, 0, 0, cl[0]]
+            self.codes["P"][1][self.conum] = qrt[2]
+            self.codes["S"][1][self.conum] = qrt[3]
+            self.codes["I"][1][self.conum] = qrt[4]
+            self.codes["T"][1][self.conum] = qrt[5]
+            self.codes["C"][1][self.conum] = qrt[6]
+            self.codes["P"][1][900] += qrt[2]
+            self.codes["S"][1][900] += qrt[3]
+            self.codes["I"][1][900] += qrt[4]
+            self.codes["T"][1][900] += qrt[5]
+            self.codes["C"][1][900] += qrt[6]
+            if dep:
+                dep += 900
+                if not dep in self.gt:
+                    self.gt[dep] = {}
+                    for cod in ("P", "S", "I", "A", "R", "O", "T", "C"):
+                        self.codes[cod][1][dep] = 0
+                self.codes["P"][1][dep] += qrt[2]
+                self.codes["S"][1][dep] += qrt[3]
+                self.codes["I"][1][dep] += qrt[4]
+                self.codes["T"][1][dep] += qrt[5]
+                self.codes["C"][1][dep] += qrt[6]
+                self.codes["P"][1][999] += qrt[2]
+                self.codes["S"][1][999] += qrt[3]
+                self.codes["I"][1][999] += qrt[4]
+                self.codes["T"][1][999] += qrt[5]
+                self.codes["C"][1][999] += qrt[6]
+            for code in self.codes:
+                if not self.conum in self.codes[code][1]:
+                    self.codes[code][1][self.conum] = 0
+                accs = copyList(self.codes[code][0])
+                if accs:
+                    for acc in accs:
+                        whr = [
+                            ("glt_cono", "=", self.conum),
+                            ("glt_acno", "=", acc)]
+                        whr.append(
+                            ("glt_curdt", "between", self.sper, self.eper))
+                        if code == "R":
+                            whr.append(("glt_tramt", "<", 0))
+                        amt = self.sql.getRec(tables="gentrn",
+                            cols=["sum(glt_tramt)"], where=whr, limit=1)
+                        if amt[0]:
+                            if amt[0] < 0:
+                                amt = 0 - amt[0]
+                            else:
+                                amt = amt[0]
+                            self.codes[code][1][self.conum] += int(amt)
+                            self.codes[code][1][900] += int(amt)
+                            if dep:
+                                self.codes[code][1][dep] += int(amt)
+                                self.codes[code][1][999] += int(amt)
+            gp = [0 - (
+                self.codes["P"][1][self.conum] -
+                self.codes["S"][1][self.conum] +
+                self.codes["T"][1][self.conum] -
+                self.codes["I"][1][self.conum] +
+                self.codes["O"][1][self.conum] -
+                self.codes["A"][1][self.conum] -
+                self.codes["R"][1][self.conum] -
+                self.codes["C"][1][self.conum]),
+                self.codes["S"][1][self.conum]]
+            if not self.conum in self.gt:
+                self.gt[self.conum] = {}
+            self.gt[self.conum][self.eper] = [gp[0], gp[1]]
+            if not self.eper in self.gt[900]:
+                self.gt[900][self.eper] = [gp[0], gp[1]]
+            else:
+                self.gt[900][self.eper][0] += gp[0]
+                self.gt[900][self.eper][1] += gp[1]
+            if dep:
+                if not self.eper in self.gt[dep]:
+                    self.gt[dep][self.eper] = [gp[0], gp[1]]
+                else:
+                    self.gt[dep][self.eper][0] += gp[0]
+                    self.gt[dep][self.eper][1] += gp[1]
+                if not self.eper in self.gt[999]:
+                    self.gt[999][self.eper] = [gp[0], gp[1]]
+                else:
+                    self.gt[999][self.eper][0] += gp[0]
+                    self.gt[999][self.eper][1] += gp[1]
+        if self.conum < 900 and self.totonly == "Y":
+            pass
+        else:
+            self.printBranch()
+        pers = self.sql.getRec(tables="ctlynd", where=[("cye_cono", "=",
+            self.conum), ("cye_period", "<", self.cper)],
+            order="cye_period desc")
+        for per in pers:
+            if self.conum < 900:
+                chk = self.doGrossProfit(per, dep)
+                if not chk:
+                    continue
+        if self.conum < 900 and self.totonly == "Y":
+            pass
+        else:
+            self.doPrintGross()
+        if self.conum < 900 or self.conum == 999:
+            return
+        gp1, sl1 = self.gt[self.conum][self.eper]
+        if sl1:
+            gg1 = round(gp1 * 100.0 / sl1, 2)
+        else:
+            gg1 = 0
+        nper = self.eper - 100
+        if nper in self.gt[self.conum]:
+            gp2, sl2 = self.gt[self.conum][nper]
+            if sl2:
+                gg2 = round(gp2 * 100.0 / sl2, 2)
+            else:
+                gg2 = 0
+        else:
+            gp2, sl2 = (0, 0)
+            gg2 = 0
+        if self.conum == 900:
+            self.br[0].append(gp1)
+            self.bg[0].append(gg1)
+            self.br[1].append(gp2)
+            self.bg[1].append(gg2)
+        elif self.prtdep == "Y" and self.conum > 900:
+            self.dp[0].append(gp1)
+            self.dg[0].append(gg1)
+            self.dp[1].append(gp2)
+            self.dg[1].append(gg2)
+
+    def printBranch(self):
+        self.fpdf.add_page()
+        cwth = self.fpdf.get_string_width("X")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Purchases", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["P"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=0, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Sales", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["S"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=1, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Invoices", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["T"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=0, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Incentive", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["I"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=1, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Opening Stock", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["O"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=0, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Advertising", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["A"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=1, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="", ln=0, border="TLRB", font=["B"], fill=1)
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt="", ln=0, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Spar Rebate", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["R"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=1, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Gross Profit", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.gt[self.conum][self.eper][0], "CI", 10).disp
+        self.fpdf.set_text_color(*rgb("#ff0000"))
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=0, border="TLRB")
+        self.fpdf.set_text_color(*rgb("#0000000"))
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Closing Stock", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = CCD(self.codes["C"][1][self.conum], "CI", 10).disp
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt=amt, ln=1, border="TLRB")
+        self.fpdf.drawText(w=(20 * cwth), h=5,
+            txt="Percentage", ln=0, border="TLRB", font=["B"], fill=1)
+        amt = round(self.gt[self.conum][self.eper][0] * 100.0 /
+            self.gt[self.conum][self.eper][1], 2)
+        self.fpdf.set_text_color(*rgb("#ff0000"))
+        self.fpdf.drawText(w=(15 * cwth), h=5, align="R",
+            txt="%10.2f%s" % (amt, "%"), ln=0, border="TLRB")
+        self.fpdf.set_text_color(*rgb("#0000000"))
+        self.fpdf.drawText()
+
+    def doGrossProfit(self, per, dep):
+        work = {}
+        for code in self.codes:
+            work[code] = 0
+            if self.codes[code][0]:
+                if code == "C":
+                    sp = (per[2] / 100) + 100
+                    ep = (per[3] / 100) + 100
+                    accs = [201100]
+                else:
+                    sp = per[2] / 100
+                    ep = per[3] / 100
+                    accs = copyList(self.codes[code][0])
+                for acc in accs:
+                    whr = [
+                        ("glt_cono", "=", self.conum),
+                        ("glt_acno", "=", acc)]
+                    whr.append(("glt_curdt", "between", sp, ep))
+                    if code == "R":
+                        whr.append(("glt_tramt", "<", 0))
+                    amt = self.sql.getRec(tables="gentrn",
+                        cols=["sum(glt_tramt)"], where=whr, limit=1)
+                    if amt[0]:
+                        work[code] += int(amt[0])
+        curdt = per[3] / 100
+        self.gt[self.conum][curdt] = [0, 0]
+        if not curdt in self.gt[900]:
+            self.gt[900][curdt] = [0, 0]
+        if dep:
+            if not curdt in self.gt[dep]:
+                self.gt[dep][curdt] = [0, 0]
+            if not curdt in self.gt[999]:
+                self.gt[999][curdt] = [0, 0]
+        for code in work:
+            if code == "S":
+                self.gt[self.conum][curdt][1] += (0 - work[code])
+                self.gt[900][curdt][1] += (0 - work[code])
+                if dep:
+                    self.gt[dep][curdt][1] += (0 - work[code])
+                    self.gt[999][curdt][1] += (0 - work[code])
+            if code == "C":
+                work[code] = 0 - work[code]
+            self.gt[self.conum][curdt][0] += (0 - work[code])
+            self.gt[900][curdt][0] += (0 - work[code])
+            if dep:
+                self.gt[dep][curdt][0] += (0 - work[code])
+                self.gt[999][curdt][0] += (0 - work[code])
+        return True
+
+    def doPrintGross(self):
+        # Heading
+        cwth = self.fpdf.get_string_width("X")
+        pers = self.gt[self.conum].keys()
+        pers.sort()
+        if len(pers) > 5:
+            pers = pers[-5:]
+        self.fpdf.drawText()
+        self.fpdf.drawText("Gross Profit Percentages for Periods %s to %s" %
+            (CCD(pers[0], "D2", 7).disp, CCD(pers[-1], "D2", 7).disp),
+            align="C")
+        self.fpdf.drawText()
+        # Text
+        rpers = copyList(pers)
+        rpers.sort(reverse=True)
+        for per in rpers:
+            if self.gt[self.conum][per][1]:
+                gp = round(self.gt[self.conum][per][0] * 100.0 /
+                    self.gt[self.conum][per][1], 2)
+                if per == self.eper:
+                    fill = 1
+                else:
+                    fill = 0
+                self.fpdf.drawText(w=(70 * cwth), h=5, align="C",
+                    txt="Gross Profit %6.2f%s %s" % (gp, "%",
+                    CCD(per, "D2", 7).disp), border="TLRB", fill=fill)
+        self.fpdf.drawText()
+        # Graph
+        xcol = []
+        vals = [[]]
+        for per in pers:
+            if self.gt[self.conum][per][1]:
+                xcol.append("%s" % (per / 100))
+                gp = round(self.gt[self.conum][per][0] * 100.0 /
+                    self.gt[self.conum][per][1], 2)
+                vals[0].append(gp)
+        simpleLineChart(self.fpdf, xcol=xcol, vals=vals)
+
+    def doExit(self):
+        if self.df.pag == 0:
+            self.df.closeProcess()
+            self.opts["mf"].closeLoop()
+        elif self.df.frt == "T":
+            self.df.setWidget(self.df.getWidget("T", 1, 0), "disabled")
+            self.df.mstFrame.focus_set()
+            self.enableButtons()
+            self.df.frt = None
+        elif self.df.frt == "C":
+            ok = askQuestion(self.opts["mf"].body, "Exit",
+                "Do You Want To Save All Entries?", default="yes")
+            if ok == "yes":
+                self.opts["mf"].dbm.commitDbase()
+            else:
+                self.opts["mf"].dbm.rollbackDbase()
+            self.df.clearFrame("T", 1)
+            self.df.clearFrame("C", 1)
+            self.df.focusField("T", 1, 1)
+        else:
+            self.df.focusField("T", 0, 1)
+
+if __name__ == "__main__":
+    from TartanClasses import Dbase, MainFrame
+    from tartanFunctions import loadRcFile
+    mf = MainFrame(rcdic=loadRcFile("/home/paul/rcf/tartanrc_rnehol"))
+    mf.dbm = Dbase(rcdic=mf.rcdic)
+    mf.dbm.openDbase()
+    rpt = gl3120(**{"mf": mf})
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'gen/gl6010.py'
--- gen/gl6010.py	2016-02-27 13:18:41 +0000
+++ gen/gl6010.py	2016-05-19 12:57:38 +0000
@@ -14,7 +14,7 @@
 """
 
 from TartanClasses import CCD, FileImport, ProgressBar, Sql, TartanDialog
-from tartanFunctions import copyList
+from tartanFunctions import askQuestion, copyList
 
 class gl6010:
     def __init__(self, **opts):
@@ -151,12 +151,17 @@
         if self.doimp:
             p1 = ProgressBar(self.opts["mf"].body, typ="",
                 mxs=len(self.tables))
+            genrpt = "no"
+        else:
+            genrpt = askQuestion(self.opts["mf"].body, head="Report Generator",
+                mess="Apply this Change to the Report Generator as well?",
+                default="no")
         for num, tab in enumerate(self.tables):
+            if tab[0] == "genrpt" and genrpt == "no":
+                continue
             if self.doimp:
                 p1.txtlab.configure(text="Changing %s Table" % tab[0])
                 p1.displayProgress(num)
-            #print tab[0], self.sql.getRec(tables=tab[0], \
-            #        cols=["count(*)"])[0][0],
             new = []
             if self.doimp:
                 p2 = ProgressBar(self.opts["mf"].body, inn=p1, typ="",
@@ -200,8 +205,6 @@
                 p2.closeProgress()
             if new:
                 self.sql.insRec(tab[0], data=new)
-            #print self.sql.getRec(tables=tab[0], \
-            #        cols=["count(*)"])[0][0]
         if self.doimp:
             p1.closeProgress()
             self.opts["mf"].dbm.commitDbase(ask=True)

=== modified file 'gen/gl6030.py'
--- gen/gl6030.py	2016-02-27 13:18:41 +0000
+++ gen/gl6030.py	2016-05-05 08:58:54 +0000
@@ -198,13 +198,12 @@
             else:
                 b = CCD(0, "SD", 14.2)
             self.gcr_bal = float(ASD(self.gcr_bal) + ASD(b.work))
-            self.gcr_bal = float(ASD(0) - ASD(self.gcr_bal))
             bal = self.sql.getRec(tables="crstrn",
                 cols=["round(sum(crt_tramt), 2)"], where=[("crt_cono", "=",
                 self.opts["conum"]), ("crt_curdt", "<=", self.opts["period"])],
                 limit=1)
             if bal and bal[0]:
-                self.crs_bal = bal[0]
+                self.crs_bal = float(ASD(0) - ASD(bal[0]))
             else:
                 self.crs_bal = 0.00
         else:

=== modified file 'ibt/ib2010.py'
--- ibt/ib2010.py	2016-02-27 13:18:41 +0000
+++ ibt/ib2010.py	2016-05-10 19:32:21 +0000
@@ -14,8 +14,8 @@
 """
 
 import time
-from TartanClasses import GetCtl, PrintTransfer, Sql, TartanDialog
-from tartanFunctions import askQuestion, getNextCode
+from TartanClasses import ASD, GetCtl, PrintTransfer, Sql, TartanDialog
+from tartanFunctions import askQuestion, copyList, getNextCode
 
 class ib2010:
     def __init__(self, **opts):
@@ -40,6 +40,7 @@
             return
         self.stpl = ibtctl["cbt_tplnam"]
         self.ccoy = ibtctl["cbt_crscoy"]
+        self.edit = False
         return True
 
     def getPrinters(self):
@@ -78,6 +79,7 @@
         self.trdd = self.pr.t_disp[0][0][1]
         self.curdt = self.trdt / 100
         self.batch = "S%s" % self.curdt
+        self.credit = False
 
     def doDelNote(self, frt, pag, r, c, p, i, w):
         self.dnote = w
@@ -121,19 +123,24 @@
                 ("ibc_cono", "=", self.opts["conum"])],
             "order": "ibc_code"}
         fld = (
-            (("T",0,0,0),"IUI",3,"Branch","",
-                "","Y",self.doBranch,ctm,None,None),
-            (("T",0,0,0),"ONA",30,""),
-            (("T",0,1,0),"INa",10,"D/Note","",
+            (("T",0,0,0),"INA",10,"Our Reference","",
+                "","Y",self.doOurRef,None,None,("notblank",)),
+            (("T",0,1,0),"IUI",3,"Branch","",
+                "","N",self.doBranch,ctm,None,("notzero",)),
+            (("T",0,1,0),"ONA",30,""),
+            (("T",0,2,0),"INa",10,"D/Note","",
                 "","N",self.doDNote,None,None,("notblank",)),
-            (("T",0,1,0),"ID1",10," D/Date","",
+            (("T",0,2,0),"ID1",10," D/Date","",
                 "","N",self.doDDate,None,None,("efld",)),
-            (("T",0,2,0),"INA",7,"Supplier","",
+            (("T",0,3,0),"INA",7,"Supplier-1","",
                 "","N",self.doSupp,crm,None,("notblank",)),
-            (("T",0,2,0),"ONA",30,""),
-            (("T",0,3,0),"INA",7,"Transporter","",
+            (("T",0,3,0),"ONA",30,""),
+            (("T",0,4,0),"INA",7,"Supplier-2","",
+                "","N",self.doSupp,crm,None,("efld",)),
+            (("T",0,4,0),"ONA",30,""),
+            (("T",0,5,0),"INA",7,"Transporter","",
                 "","N",self.doTrpt,crm,None,("notblank",)),
-            (("T",0,3,0),"ONA",30,""),
+            (("T",0,5,0),"ONA",30,""),
             (("C",0,0,0),"IUA",10,"Product-Cd","",
                 "","Y",self.doCode,cod,None,("notblank",)),
             (("C",0,0,1),"INA",30,"Description","",
@@ -144,14 +151,22 @@
                 "","N",self.doQuant,None,None,("notzero",)),
             (("C",0,0,4),"OSD",11.2,"Value"))
         but = (
-            ("Accept",None,self.doAccept,0,("C",0,1),None),
-            ("Cancel",None,self.doCancel,0,("C",0,1),None),
-            ("Edit",None,self.doEdit,0,("C",0,1),None))
+            ("Credit",None,self.doCredit,0,("T",0,1),None,
+                "Credit an Existing Invoice"),
+            ("Accept",None,self.doAccept,0,("C",0,1),None,
+                "Accept the Current Invoice"),
+            ("Edit",None,self.doEdit,0,("C",0,1),None,
+                "Edit the Current Invoice"),
+            ("Cancel",None,self.doCancel,0,("C",0,1),None,
+                "Cancel the Current Invoice"))
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
-            tend=((self.doEnd, "y"),), txit=(self.doExit,),
-            cend=((self.doEnd, "y"),), cxit=(None,),
+            tend=[[self.doEnd, "y"]], txit=(self.doExit,),
+            cend=[[self.doEnd, "y"]], cxit=(None,),
             butt=but, rows=(10,))
 
+    def doOurRef(self, frt, pag, r, c, p, i, w):
+        self.ouref = w
+
     def doBranch(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="ctlmst", cols=["ctm_name"],
             where=[("ctm_cono", "=", w)], limit=1)
@@ -167,13 +182,19 @@
         self.ddate = w
 
     def doSupp(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
-            where=[("crm_cono", "=", self.ccoy), ("crm_acno", "=", w)],
-            limit=1)
-        if not acc:
-            return "Invalid Supplier Code"
-        self.dsupp = w
-        self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        if w:
+            acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
+                where=[("crm_cono", "=", self.ccoy), ("crm_acno", "=", w)],
+                limit=1)
+            if not acc:
+                return "Invalid Supplier Code"
+            self.df.loadEntry(frt, pag, p+1, data=acc[0])
+        else:
+            self.df.loadEntry(frt, pag, p+1, data="")
+        if p == 5:
+            self.dsup1 = w
+        else:
+            self.dsup2 = w
 
     def doTrpt(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="crsmst", cols=["crm_name"],
@@ -186,9 +207,15 @@
 
     def doCode(self, frt, pag, r, c, p, i, w):
         self.code = w
-        acc = self.sql.getRec(tables="ibtcod", cols=["ibc_desc", "ibc_price"],
-            where=[("ibc_cono", "=", self.opts["conum"]), ("ibc_code", "=", w)],
-            limit=1)
+        if not self.edit:
+            chk = self.sql.getRec(tables="ibttrn", where=[("ibt_cono", "=",
+                self.opts["conum"]), ("ibt_docno", "=", self.docno),
+                ("ibt_type", "=", 1), ("ibt_code", "=", self.code)])
+            if chk:
+                return "This Code Already Exists on This Invoice"
+        acc = self.sql.getRec(tables="ibtcod", cols=["ibc_desc",
+            "ibc_price"], where=[("ibc_cono", "=", self.opts["conum"]),
+            ("ibc_code", "=", self.code)], limit=1)
         if not acc:
             ok = askQuestion(self.opts["mf"].body, "New Code",
                 "This Code Does Not exist, Is it a New Code", default="no")
@@ -214,14 +241,159 @@
         self.value = round(self.quant * self.price, 2)
         self.df.loadEntry(frt, pag, p+1, data=self.value)
 
+    def doAccept(self):
+        if self.edit or self.credit or not self.df.col == 1:
+            self.opts["mf"].dbm.commitDbase()
+            self.df.setWidget(self.df.mstFrame, state="hide")
+            if self.credit:
+                dtyp = "C"
+            else:
+                dtyp = "I"
+            PrintTransfer(self.opts["mf"], self.opts["conum"],
+                self.opts["conam"], dtyp, self.docno, crcoy=self.ccoy,
+                tname=self.tname, repprt=self.pr.repprt)
+            self.df.setWidget(self.df.mstFrame, state="show")
+            self.edit = False
+            self.credit = False
+            self.df.focusField("T", 0, 1)
+        else:
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+
+    def doCredit(self):
+        state = self.df.disableButtonsTags()
+        tit = "Credit Sales Invoice"
+        ibm = {
+            "stype": "R",
+            "tables": ("ibtmst", "ctlmst"),
+            "cols": [
+                ("ibm_docno", "",  0, "Doc-Num"),
+                ("ibm_date", "",  0, "Date"),
+                ("ibm_branch",  "", 0, "Bch"),
+                ("ctm_name",  "", 0, "Name", "Y")],
+            "where": [
+                ("ibm_cono", "=", self.opts["conum"]),
+                ("ibm_cdte", "=", 0),
+                ("ctm_cono=ibm_branch",)],
+            "order": "ibm_docno"}
+        fld = (
+            (("T",0,0,0),"IUI",9,"Invoice Number","",
+                0,"Y",self.doCreditDoc,ibm,None,None),)
+        self.ed = TartanDialog(self.opts["mf"], tops=True, title=tit, eflds=fld,
+            tend=((self.doCreditEnd,"y"),), txit=(self.doCreditExit,))
+        self.opts["mf"].startLoop()
+        self.df.enableButtonsTags(state=state)
+        if not self.docno:
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+            return
+        mc = self.sql.ibtmst_col
+        self.df.loadEntry("T",0,0,self.mst[mc.index("ibm_ouref")])
+        self.df.loadEntry("T",0,1,self.mst[mc.index("ibm_branch")])
+        self.df.loadEntry("T",0,3,self.mst[mc.index("ibm_dnote")])
+        self.df.loadEntry("T",0,4,self.mst[mc.index("ibm_ddate")])
+        self.df.loadEntry("T",0,5,self.mst[mc.index("ibm_supp")])
+        self.df.loadEntry("T",0,7,self.mst[mc.index("ibm_sup2")])
+        self.df.loadEntry("T",0,9,self.mst[mc.index("ibm_tran")])
+        trns = self.sql.getRec(tables="ibttrn", where=[("ibt_cono",
+            "=", self.opts["conum"]), ("ibt_docno", "=", self.docno),
+            ("ibt_type", "=", 1)], order="ibt_seq")
+        tc = self.sql.ibttrn_col
+        for n, t in enumerate(trns):
+            p = n * 5
+            self.df.loadEntry("C",0,p,t[tc.index("ibt_code")])
+            self.df.loadEntry("C",0,p+1,t[tc.index("ibt_desc")])
+            self.df.loadEntry("C",0,p+2,t[tc.index("ibt_price")])
+            self.df.loadEntry("C",0,p+3,t[tc.index("ibt_quant")])
+            self.df.loadEntry("C",0,p+4,t[tc.index("ibt_value")])
+        # Confirm Credit
+        ok = askQuestion(self.opts["mf"].body, "Credit",
+            "Please Confirm\nPassing a Credit\nfor this Invoice")
+        if ok == "no":
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+            return
+        self.sql.updRec("ibtmst", cols=["ibm_cdte"], data=[self.trdt],
+            where=[("ibm_cono", "=", self.opts["conum"]),
+            ("ibm_docno", "=", self.docno)])
+        for trn in trns:
+            trn[tc.index("ibt_type")] = 2
+            q = float(ASD(0) - ASD(trn[tc.index("ibt_quant")]))
+            trn[tc.index("ibt_quant")] = q
+            v = float(ASD(0) - ASD(trn[tc.index("ibt_value")]))
+            trn[tc.index("ibt_value")] = v
+            trn[tc.index("ibt_tjnl")] = ""
+            trn[tc.index("ibt_tjdt")] = 0
+            trn[tc.index("ibt_curdt")] = self.curdt
+            trn[tc.index("ibt_capnm")] = self.opts["capnm"]
+            trn[tc.index("ibt_capdt")] = self.sysdtw
+            self.sql.insRec("ibttrn", data=trn)
+        self.credit = True
+        self.doAccept()
+
+    def doCreditDoc(self, frt, pag, r, c, p, i, w):
+        self.mst = self.sql.getRec(tables="ibtmst", where=[("ibm_cono",
+            "=", self.opts["conum"]), ("ibm_docno", "=", w)], limit=1)
+        if not self.mst:
+            return "Invalid Invoice Number"
+        elif self.mst[self.sql.ibtmst_col.index("ibm_cdte")]:
+            return "This Invoice is Cancelled"
+        chk = self.sql.getRec(tables="ibttrn", where=[("ibt_cono",
+            "=", self.opts["conum"]), ("ibt_docno", "=", w),
+            ("ibt_type", ">", 2)])
+        if chk:
+            return "This Invoice is Already Allocated"
+        self.docno = w
+
+    def doCreditTyp(self, frt, pag, r, c, p, i, w):
+        self.action = w
+
+    def doCreditEnd(self):
+        self.ed.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doCreditExit(self):
+        self.docno = None
+        self.ed.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doEdit(self):
+        if self.df.col == 1:
+            return
+        self.edit = True
+        # Display document items and allow editing of qty and price
+        data = []
+        for dat in self.df.c_work[0]:
+            if dat[0]:
+                data.append(dat)
+        if data:
+            titl = "Document Product Lines"
+            head = ("Product-Cd", "Description", "Price", "Quantity", "Value")
+            lin = {
+                "stype": "C",
+                "titl": titl,
+                "head": head,
+                "data": data,
+                "typs": [
+                    ("UA", 10),
+                    ("NA", 30),
+                    ("UD", 12.4),
+                    ("SD", 11.2),
+                    ("SD", 11.2)]}
+            state = self.df.disableButtonsTags()
+            self.opts["mf"].updateStatus("Select a Product to Edit")
+            chg = self.df.selChoice(lin)
+            if chg and chg.selection:
+                self.data = chg.selection
+                self.doChange()
+            self.df.enableButtonsTags(state=state)
+        self.df.focusField("C", 0, self.df.col)
+
     def doEnd(self):
         if self.df.frt == "T":
             self.docno = getNextCode(self.sql, "ibtmst", "ibm_docno",
                 where=[("ibm_cono", "=", self.opts["conum"])], start=3001,
                 last=999999999)
-            data = [self.opts["conum"], self.docno, self.trdt, self.bcod,
-                self.dnote, self.ddate, self.dsupp, "", 0, 0, self.dtrpt,
-                "", 0, 0, "", 0]
+            data = [self.opts["conum"], self.docno, self.trdt, self.ouref,
+                self.bcod, self.dnote, self.ddate, self.dsup1, self.dsup2,
+                self.dtrpt, ""]
             self.sql.insRec("ibtmst", data=data)
             self.df.focusField("C", 0, 1)
         else:
@@ -233,32 +405,86 @@
                     where=[("ibc_cono", "=", self.opts["conum"]), ("ibc_code",
                     "=", self.code)])
             data = [self.opts["conum"], self.docno, 1, self.code, self.desc,
-                self.price, self.quant, self.value, 0, self.curdt,
-                self.opts["capnm"], self.sysdtw, 0]
+                self.price, self.quant, self.value, "", 0, 0, "", 0, "",
+                self.curdt, self.opts["capnm"], self.sysdtw, 0]
             self.sql.insRec("ibttrn", data=data)
             self.df.advanceLine(0)
 
-    def doAccept(self):
-        if self.df.col == 1:
-            self.doCancel()
-            return
-        self.opts["mf"].dbm.commitDbase()
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        PrintTransfer(self.opts["mf"], self.opts["conum"],
-            self.opts["conam"], self.docno, crcoy=self.ccoy,
-            tname=self.tname, repprt=self.pr.repprt)
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.focusField("T", 0, 1)
+    def doChange(self):
+        tit = ("Change Item",)
+        fld = (
+            (("T",0,0,0),"OUA",10,"Code"),
+            (("T",0,1,0),"ONA",30,"Description"),
+            (("T",0,2,0),"IUD",12.4,"Price","",
+                "","N",self.doChgPrc,None,None,("notzero",)),
+            (("T",0,3,0),"ISD",11.2,"Quantity","",
+                "","N",self.doChgQty,None,None,("notzero",)),
+            (("T",0,4,0),"OSD",11.2,"Value"))
+        but = [["Delete", None, self.doChgDel, 1, None, None]]
+        self.cg = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, butt=but, tend=((self.doChgEnd,"n"),),
+            txit=(self.doChgExit,), focus=False)
+        self.cg.loadEntry("T", 0, 0, data=self.data[0])
+        self.cg.loadEntry("T", 0, 1, data=self.data[1])
+        self.cg.loadEntry("T", 0, 2, data=self.data[2])
+        self.cg.loadEntry("T", 0, 3, data=self.data[3])
+        self.cg.loadEntry("T", 0, 4, data=self.data[4])
+        self.cg.focusField("T", 0, 3, clr=False)
+        self.opts["mf"].startLoop()
+
+    def doChgDel(self, widget=None):
+        self.loadData("D")
+
+    def doChgPrc(self, frt, pag, r, c, p, i, w):
+        self.data[2] = w
+
+    def doChgQty(self, frt, pag, r, c, p, i, w):
+        self.data[3] = w
+        self.data[4] = round(self.data[3] * self.data[2], 2)
+
+    def doChgEnd(self):
+        self.loadData("A")
+
+    def loadData(self, ctyp):
+        self.cg.closeProcess()
+        data = copyList(self.df.c_work[0])
+        self.df.clearFrame("C", 0)
+        row = 0
+        for dat in data:
+            if dat[0]:
+                if dat[0] == self.data[0]:
+                    whr = [
+                        ("ibt_cono", "=", self.opts["conum"]),
+                        ("ibt_docno", "=", self.docno),
+                        ("ibt_type", "=", 1),
+                        ("ibt_code", "=", dat[0])]
+                    if ctyp == "D":
+                        self.sql.delRec("ibttrn", where=whr)
+                        continue
+                    dat = self.data
+                    self.sql.updRec("ibttrn", cols=["ibt_price", "ibt_quant",
+                        "ibt_value"], data=dat[2:5], where=whr)
+                for seq, fld in enumerate(dat):
+                    p = (row * 5) + seq
+                    self.df.loadEntry("C", 0, p, data=fld)
+                row += 1
+        self.df.focusField("C", 0, (row * 5) + 1)
+        self.opts["mf"].closeLoop()
+
+    def doChgExit(self):
+        self.cg.closeProcess()
+        self.opts["mf"].closeLoop()
 
     def doCancel(self):
+        self.edit = False
         self.opts["mf"].dbm.rollbackDbase()
         self.df.focusField("T", 0, 1)
 
-    def doEdit(self):
-        pass
-
     def doExit(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
+        if self.edit:
+            self.doCancel()
+        else:
+            self.df.closeProcess()
+            self.opts["mf"].closeLoop()
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'ibt/ib2020.py'
--- ibt/ib2020.py	2016-02-27 13:18:41 +0000
+++ ibt/ib2020.py	2016-05-10 19:33:12 +0000
@@ -15,7 +15,7 @@
 
 import time
 from TartanClasses import ASD, CCD, GetCtl, Sql, TartanDialog
-from tartanFunctions import askQuestion, getVatRate
+from tartanFunctions import askQuestion, copyList
 
 class ib2020:
     def __init__(self, **opts):
@@ -31,8 +31,8 @@
             return
         t = time.localtime()
         self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.sql = Sql(self.opts["mf"].dbm, ["ibtmst", "ibttrn", "crsmst",
-            "crsrtf"], prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ibtcod", "ibtmst",
+            "ibttrn", "crsmst", "crsrtf"], prog=__name__)
         if self.sql.error:
             return
         self.ccoy = ibtctl["cbt_crscoy"]
@@ -49,50 +49,48 @@
             "where": [
                 ("rtf_cono", "=", self.ccoy),
                 ("rtf_type", "=", 1),
-                ("rtf_depno", "=", self.opts["conum"])],
+                ("rtf_depno", "=", self.opts["conum"]),
+                ("rtf_pjno", "<>", 0)],
             "group": "rtf_pjno, rtf_prtdte",
-            "order": "rtf_prtdte desc"}
+            "order": "rtf_prtdte desc, rtf_pjno desc"}
         crm = {
             "stype": "R",
-            "tables": ("crsmst", "ibtmst"),
+            "tables": ("crsrtf", "crsmst"),
             "cols": [
-                ("crm_acno",  "", 0, "Acc-Num"),
+                ("rtf_acno",  "", 0, "Acc-Num"),
                 ("crm_name",  "", 0, "Name", "Y")],
             "where": [
-                ("crm_cono", "=", self.ccoy),
-                ("ibm_cono", "=", self.opts["conum"]),
-                ("crm_acno=ibm_supp or crm_acno=ibm_tran",)],
-            "group": "crm_acno, crm_name",
-            "order": "crm_acno",
+                ("rtf_cono", "=", self.ccoy),
+                ("rtf_depno", "=", self.opts["conum"]),
+                ("crm_cono=rtf_cono",),
+                ("crm_acno=rtf_acno",)],
+            "whera": [("T", "rtf_pjno", 0, 0)],
+            "group": "rtf_acno, crm_name",
+            "order": "rtf_acno",
             "autoc": False}
-        ref = {
+        self.ref = {
             "stype": "R",
-            "tables": ("crsrtf", "crstrn"),
+            "tables": ("crstrn", "crsrtf"),
             "cols": [
-                ("rtf_ref1",  "", 0, "Reference"),
-                ("crt_trdt",  "", 0, "Date", "Y")],
-            "where": [
-                ("rtf_cono", "=", self.ccoy),
-                ("crt_cono=rtf_cono",),
-                ("crt_acno=rtf_acno",),
-                ("crt_ref1=rtf_ref1",)],
-            "whera": [
-                ("T", "rtf_pjno", 0, 0),
-                ("C", "rtf_acno", 0, 1)],
-            "order": "rtf_ref1",
-            "autoc": False}
+                ("crt_trdt",  "", 0, "Date", "Y"),
+                ("crt_ref1",  "", 0, "Reference")],
+            "where": [],
+            "order": "crt_trdt, crt_ref1",
+            "autoc": False,
+            "index": 1}
         self.ibt = {
             "stype": "R",
-            "tables": ("ibtmst",),
+            "tables": ("ibtmst", "ibttrn"),
             "cols": (
                 ("ibm_docno", "", 0, "I.B.T-Num"),
                 ("ibm_date", "", 0, "Trans-Date"),
-                ("ibm_branch", "", 0, "Bch", "F"),
-                ("ibm_dnote", "", 0, "Deliv-Note", "F"),
-                ("ibm_supp", "", 0, "Supplir", "F"),
-                ("ibm_tran", "", 0, "Transpr", "F")),
+                ("ibm_ouref", "", 0, "Our-Ref-No"),
+                ("ibm_branch", "", 0, "Bch"),
+                ("ibm_dnote", "", 0, "Deliv-Note", "Y"),
+                ("ibt_quant", "", 0, "Quantity")),
             "where": [],
-            "autoc": False}
+            "group": "ibt_docno",
+            "order": "ibm_docno"}
         cod = {
             "stype": "R",
             "tables": ("ibttrn",),
@@ -102,38 +100,46 @@
             "where": [
                 ("ibt_cono", "=", self.opts["conum"]),
                 ("ibt_type", "=", 1)],
-            "whera": [("C", "ibt_docno", 0, 2)],
+            "group": "ibt_code",
             "order": "ibt_code"}
         tag = (
             ("Invoice", None, None, None, False),
-            ("IBT", None, None, None, False))
+            ("Products", None, None, None, False),
+            ("Allocation", None, None, None, False))
         fld = (
             (("T",0,0,0),"IUI",5,"Purchase Journal","",
                 "","Y",self.doPjno,pjn,None,("notzero",)),
-            (("C",1,0,0),"IUA",7,"Acc-Num","",
-                "","Y",self.doAcno,crm,None,("notblank",)),
-            (("C",1,0,1),"ONA",30,"Name"),
-            (("C",1,0,2),"INa",9,"Reference","",
-                "","N",self.doRefno,ref,None,("notblank",)),
-            (("C",1,0,3),"OD1",10,"Ref-Date"),
-            (("C",1,0,4),"OSD",11.2,"Amount"),
-            (("C",1,0,5),"OUA",1,"V"),
-            (("C",1,0,6),"OSD",11.2,"V.A.T"),
-            (("C",2,0,0),"IUI",9,"I.B.T-Inv","",
+            (("C",1,0,0),"IUA",1,"T","Supplier Type (S or T)",
+                "S","Y",self.doSTyp,None,None,("in",("S","T"))),
+            (("C",1,0,1),"IUA",7,"Acc-Num","",
+                "","N",self.doCAcc,crm,None,("notblank",)),
+            (("C",1,0,2),"ONA",30,"Name"),
+            (("C",1,0,3),"IUA",1,"D","Document Type",
+                "I","N",self.doCTyp,None,None,("in",("I", "C"))),
+            (("C",1,0,4),"INa",9,"Reference","",
+                "","N",self.doCRef,self.ref,None,("notblank",)),
+            (("C",1,0,5),"OD1",10,"Ref-Date"),
+            (("C",1,0,6),"OSD",11.2,"Amount"),
+            (("C",1,0,7),"OUA",1,"V"),
+            (("C",1,0,8),"OSD",11.2,"V.A.T"),
+            (("C",2,0,0),"IUA",10,"Product-Cd","",
+                "","N",self.doCCod,cod,None,("notblank",)),
+            (("C",2,0,1),"ONA",30,"Description"),
+            (("C",2,0,2),"ISD",11.2,"Quantity","",
+                "","N",self.doCQty,None,None,("notzero",)),
+            (("C",2,0,3),"IUD",12.4,"Price","",
+                "","N",self.doCPrice,None,None,("notzero",)),
+            (("C",2,0,4),"ISD",11.2,"Value","",
+                0,"N",self.doCValue,None,None,None),
+            (("C",3,0,0),"IUI",9,"I.B.T-Inv","",
                 "","N",self.doIbt,self.ibt,None,("notblank",)),
-            (("C",2,0,1),"IUA",10,"Product-Cd","",
-                "","N",self.doCode,cod,None,("notblank",)),
-            (("C",2,0,2),"ONA",30,"Description"),
-            (("C",2,0,3),"ISD",11.2,"Quantity","",
-                "","N",self.doQuant,None,None,("notzero",)),
-            (("C",2,0,4),"IUD",12.4,"Price","",
-                "","N",self.doPrice,None,None,("notzero",)),
-            (("C",2,0,5),"ISD",11.2,"Value","",
-                0,"N",self.doValue,None,None,("notzero",)))
+            (("C",3,0,1),"OUA",10,"Product-Cd"),
+            (("C",3,0,2),"ONA",30,"Description"),
+            (("C",3,0,3),"OSD",11.2,"Quantity"))
         tnd = ((self.doEnd, "y"), None, None)
         txt = (self.doExit, None, None)
-        cnd = (None, (self.doEnd, "y"), (self.doEnd, "y"))
-        cxt = (None, self.doExit, self.doExit)
+        cnd = (None, (self.doEnd, "y"), (self.doEnd, "y"), (self.doEnd, "y"))
+        cxt = (None, self.doExit, self.doExit, self.doExit)
         but = (("Cancel",None,self.doCancel,0,("C",2,1),("C",1,1)),)
         self.df = TartanDialog(self.opts["mf"], title=tit, tags=tag,
             eflds=fld, tend=tnd, txit=txt, cend=cnd, cxit=cxt, butt=but)
@@ -146,160 +152,209 @@
             return "Invalid Purchase Journal"
         self.pjno = w
 
-    def doAcno(self, frt, pag, r, c, p, i, w):
-        col = ["crm_name", "ibm_supp", "ibm_tran"]
+    def doSTyp(self, frt, pag, r, c, p, i, w):
+        self.styp = w
+        if self.styp == "S":
+            self.ityp = 3
+        else:
+            self.ityp = 4
+
+    def doCAcc(self, frt, pag, r, c, p, i, w):
+        col = ["crm_name"]
         whr = [
             ("crm_cono", "=", self.ccoy),
-            ("crm_acno", "=", w),
-            ("ibm_cono", "=", self.opts["conum"]),
-            ("crm_acno=ibm_supp or crm_acno=ibm_tran",)]
-        acc = self.sql.getRec(tables=["crsmst", "ibtmst"], cols=col,
-            where=whr, limit=1)
+            ("crm_acno", "=", w)]
+        acc = self.sql.getRec(tables="crsmst", cols=col, where=whr, limit=1)
         if not acc:
             return "Invalid Account Number"
-        self.acno = w
-        self.ibt["where"] = [("ibm_cono", "=", self.opts["conum"])]
-        if w == acc[1]:
-            self.ibttyp = 2
-            self.ibt["where"].extend([
-                ("ibm_supp", "=", self.acno),
-                ("ibm_sinv", "=", "")])
-        elif w == acc[2]:
-            self.ibttyp = 3
-            self.ibt["where"].extend([
-                ("ibm_tran", "=", self.acno),
-                ("ibm_tinv", "=", "")])
+        self.cacc = w
         self.df.loadEntry(frt, pag, p+1, data=acc[0])
-
-    def doRefno(self, frt, pag, r, c, p, i, w):
-        col = ["crt_trdt", "crt_curdt", "crt_tramt", "crt_taxind",
-            "crt_taxamt"]
+        col = ["ibm_supp", "ibm_sup2", "ibm_tran"]
+        whr = [("ibm_cono", "=", self.opts["conum"])]
+        if self.styp == "S":
+            col = ["ibm_supp", "ibm_sup2"]
+            whr.append(("ibm_supp", "=", self.cacc, "or",
+                "ibm_sup2", "=", self.cacc))
+        else:
+            col = ["ibm_tran"]
+            whr.append(("ibm_tran", "=", self.cacc))
+        whr.append(("ibm_cdte", "=", 0))
+        acc = self.sql.getRec(tables="ibtmst", cols=col, where=whr, limit=1)
+        if not acc:
+            if self.styp == "S":
+                return "Supplier Not in IBT"
+            else:
+                return "Transporter Not in IBT"
+
+    def doCTyp(self, frt, pag, r, c, p, i, w):
+        if w == "I":
+            self.ctyp = 1
+        else:
+            self.ctyp = 4
+        self.ref["where"] = [
+            ("crt_cono", "=", self.ccoy),
+            ("crt_acno", "=", self.cacc),
+            ("crt_type", "=", self.ctyp),
+            ("rtf_cono=crt_cono",),
+            ("rtf_acno=crt_acno",),
+            ("rtf_ref1=crt_ref1",),
+            ("rtf_depno", "=", self.opts["conum"]),
+            ("rtf_pjno", "=", self.pjno)]
+
+    def doCRef(self, frt, pag, r, c, p, i, w):
+        col = ["crt_trdt", "crt_curdt", "crt_tramt", "crt_taxind", "crt_taxamt"]
         acc = self.sql.getRec(tables=["crstrn", "crsrtf"], cols=col,
-            where=[("rtf_cono", "=", self.ccoy), ("rtf_acno", "=",
-            self.acno), ("rtf_type", "=", 1), ("rtf_ref1", "=", w),
-            ("rtf_depno", "=", self.opts["conum"]), ("rtf_pjno", "=",
-            self.pjno), ("crt_cono=rtf_cono",), ("crt_acno=rtf_acno",),
+            where=[("rtf_cono", "=", self.ccoy), ("rtf_acno", "=", self.cacc),
+            ("rtf_type", "=", self.ctyp), ("rtf_ref1", "=", w), ("rtf_depno",
+            "=", self.opts["conum"]), ("rtf_pjno", "=", self.pjno),
+            ("crt_cono=rtf_cono",), ("crt_acno=rtf_acno",),
             ("crt_ref1=rtf_ref1",)], limit=1)
         if not acc:
             return "Invalid Reference Number"
-        if self.ibttyp == 2:
-            chk = self.sql.getRec(tables="ibtmst", where=[("ibm_cono",
-                "=", self.opts["conum"]), ("ibm_supp", "=", self.acno),
-                ("ibm_sinv", "=", w)], limit=1)
-        else:
-            chk = self.sql.getRec(tables="ibtmst", where=[("ibm_cono",
-                "=", self.opts["conum"]), ("ibm_tran", "=", self.acno),
-                ("ibm_tinv", "=", w)], limit=1)
+        chk = self.sql.getRec(tables="ibttrn", where=[("ibt_cono", "=",
+            self.opts["conum"]), ("ibt_cacc", "=", self.cacc),
+            ("ibt_ctyp", "=", self.ctyp), ("ibt_cref", "=", w)])
         if chk:
-            return "Already Captured"
-        self.refno = w
-        self.trdt, self.curdt, self.tramt, self.taxind, self.taxamt = acc
-        self.df.loadEntry(frt, pag, p+1, data=self.trdt)
-        self.df.loadEntry(frt, pag, p+2, data=self.tramt)
-        self.df.loadEntry(frt, pag, p+3, data=self.taxind)
-        self.df.loadEntry(frt, pag, p+4, data=self.taxamt)
-        self.excamt = float(ASD(self.tramt) - ASD(self.taxamt))
-
-    def doDate(self, frt, pag, r, c, p, i, w):
-        self.trdt = w
-
-    def doTrnAmt(self, frt, pag, r, c, p, i, w):
-        self.tramt = w
-
-    def doVatCode(self, frt, pag, r, c, p, i, w):
-        vrte = getVatRate(self.sql, self.opts["conum"], w, self.trdt)
-        if vrte is None:
-            return "Invalid V.A.T Code"
-        self.taxind = w
-        self.taxamt = round((self.tramt * vrte / (vrte + 100)), 2)
-        self.df.loadEntry(frt, pag, p+1, self.taxamt)
-        if not self.taxamt:
-            self.excamt = self.tramt
-            return "sk1"
-
-    def doVatAmt(self, frt, pag, r, c, p, i, w):
-        self.taxamt = w
-        self.excamt = float(ASD(self.tramt) - ASD(self.taxamt))
+            return "Document Already Entered"
+        self.cref = w
+        self.cdte, self.ccur, self.camt, self.cind, self.ctax = acc
+        self.df.loadEntry(frt, pag, p+1, data=self.cdte)
+        self.df.loadEntry(frt, pag, p+2, data=self.camt)
+        self.df.loadEntry(frt, pag, p+3, data=self.cind)
+        self.df.loadEntry(frt, pag, p+4, data=self.ctax)
+        self.cval = float(ASD(self.camt) - ASD(self.ctax))
+        self.aval = 0
+
+    def doCCod(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="ibtcod", where=[("ibc_cono",
+            "=", self.opts["conum"]), ("ibc_code", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Code"
+        self.code = w
+        self.desc = acc[self.sql.ibtcod_col.index("ibc_desc")]
+        self.ibt["where"] = [("ibm_cono", "=", self.opts["conum"])]
+        if self.styp == "S":
+            self.ibt["where"].append(("(", "ibm_supp", "=", self.cacc,
+                "or", "ibm_sup2", "=", self.cacc, ")"))
+        else:
+            self.ibt["where"].append(("ibm_tran", "=", self.cacc))
+        self.ibt["where"].append(("ibm_cdte", "=", 0))
+        self.ibt["where"].append(("ibt_cono=ibm_cono",))
+        self.ibt["where"].append(("ibt_docno=ibm_docno",))
+        self.ibt["where"].append(("ibt_type", "=", 1))
+        self.ibt["where"].append(("ibt_code", "=", self.code))
+        self.df.loadEntry(frt, pag, p+1, data=self.desc)
+
+    def doCQty(self, frt, pag, r, c, p, i, w):
+        self.cqty = w
+
+    def doCPrice(self, frt, pag, r, c, p, i, w):
+        self.cpri = w
+        self.cexc = round(self.cqty * self.cpri, 2)
+        self.df.loadEntry(frt, pag, p+1, data=self.cexc)
+        if self.cexc > self.cval:
+            return "Value Exceeds Invoice Value"
+
+    def doCValue(self, frt, pag, r, c, p, i, w):
+        self.cexc = w
+        if self.cexc > self.cval:
+            return "Value Exceeds Invoice Value"
 
     def doIbt(self, frt, pag, r, c, p, i, w):
         whr = [
             ("ibm_cono", "=", self.opts["conum"]),
             ("ibm_docno", "=", w)]
-        if self.ibttyp == 2:
-            whr.extend([
-                ("ibm_supp", "=", self.acno),
-                ("ibm_sinv", "=", "")])
-        else:
-            whr.extend([
-                ("ibm_tran", "=", self.acno),
-                ("ibm_tinv", "=", "")])
         acc = self.sql.getRec(tables="ibtmst", where=whr, limit=1)
-        if not acc:
-            return "Invalid IBT Number"
-        self.ibtnum = w
-
-    def doCode(self, frt, pag, r, c, p, i, w):
-        acc = self.sql.getRec(tables="ibttrn", where=[("ibt_cono",
-            "=", self.opts["conum"]), ("ibt_docno", "=", self.ibtnum),
-            ("ibt_type", "=", 1), ("ibt_code", "=", w)], limit=1)
-        if not acc:
-            return "Invalid Code"
-        self.code = w
-        self.desc = acc[self.sql.ibttrn_col.index("ibt_desc")]
-        self.oprc = acc[self.sql.ibttrn_col.index("ibt_price")]
-        self.oqty = acc[self.sql.ibttrn_col.index("ibt_quant")]
-        self.oval = acc[self.sql.ibttrn_col.index("ibt_value")]
-        self.df.loadEntry(frt, pag, p+1, data=self.desc)
-        self.df.loadEntry(frt, pag, p+2, data=self.oqty)
-
-    def doQuant(self, frt, pag, r, c, p, i, w):
-        if not w == self.oqty:
-            ok = askQuestion(self.opts["mf"].body, "Quantity Error",
-                "The Quantity Does Not Equal the IBT Quantity - %s" %
-                CCD(self.oqty, "SD", 11.2).disp)
-            if ok == "no":
-                return "Invalid Quantity"
-        self.quant = w
-
-    def doPrice(self, frt, pag, r, c, p, i, w):
-        self.price = w
-        self.value = round(self.quant * self.price, 2)
-        self.df.loadEntry(frt, pag, p+1, data=self.value)
-
-    def doValue(self, frt, pag, r, c, p, i, w):
-        self.value = w
+        if acc[self.sql.ibtmst_col.index("ibm_cdte")]:
+            return "IBT Document is Cancelled"
+        if self.styp == "S":
+            if self.cacc == acc[self.sql.ibtmst_col.index("ibm_supp")]:
+                pass
+            elif self.cacc == acc[self.sql.ibtmst_col.index("ibm_sup2")]:
+                pass
+            else:
+                return "Supplier Not in IBT"
+        elif self.cacc == acc[self.sql.ibtmst_col.index("ibm_tran")]:
+            pass
+        else:
+            return "Transporter Not in IBT"
+        trn = self.sql.getRec(tables="ibttrn", cols=["ibt_quant"],
+            where=[("ibt_cono", "=", self.opts["conum"]),
+            ("ibt_docno", "=", w), ("ibt_type", "=", 1),
+            ("ibt_code", "=", self.code)], limit=1)
+        if not trn:
+            return "Product Not in IBT"
+        self.inum = w
+        self.iqty = trn[0]
+        amt = CCD(round(self.iqty * self.cpri, 2), "SD", 11.2)
+        if amt.err:
+            return "Invalid Quantity/Price, Please Cancel"
+        self.ival = amt.work
+        self.df.loadEntry(frt, pag, p+1, data=self.code)
+        self.df.loadEntry(frt, pag, p+2, data=self.desc)
+        self.df.loadEntry(frt, pag, p+3, data=self.iqty)
 
     def doEnd(self):
         if self.df.pag == 0:
+            # End of Top Page 0
             self.df.selPage("Invoice")
             self.df.focusField("C", 1, 1)
         elif self.df.pag == 1:
-            self.df.selPage("IBT")
-            self.df.focusField("C", 2, 1)
+            # End of Col Page 1
+            if self.ctyp == 4:
+                # Credit Note
+                chk = self.sql.getRec(tables="ibtmst", where=[("ibm_cono",
+                    "=", self.opts["conum"]), ("ibm_docno", "=", 999999999)],
+                    limit=1)
+                if not chk:
+                    self.sql.insRec("ibtmst", data=[self.opts["conum"],
+                        999999999, self.sysdtw, "", 150, "", self.sysdtw,
+                        "", "", "", "", self.sysdtw])
+                self.sql.insRec("ibttrn", data=[self.opts["conum"], 999999999,
+                    self.ityp, "", "", self.cval, 1, self.cval, "", 0,
+                    self.pjno, self.cacc, self.ctyp, self.cref, self.ccur,
+                    self.opts["capnm"], self.sysdtw, 0])
+                self.opts["mf"].dbm.commitDbase()
+                self.df.advanceLine(1)
+            else:
+                self.df.selPage("Products")
+                self.df.focusField("C", 2, 1)
+        elif self.df.pag == 2:
+            # End of Col Page 2
+            self.ibts = {}
+            self.tqty = 0
+            self.aqty = self.cqty
+            self.aval = float(ASD(self.aval) + ASD(self.cexc))
+            self.df.selPage("Allocation")
+            self.df.focusField("C", 3, 1)
         else:
-            if self.ibttyp == 2:
-                col = ["ibm_sinv", "ibm_sinc", "ibm_stax"]
-            else:
-                col = ["ibm_tinv", "ibm_tinc", "ibm_ttax"]
-            self.sql.updRec("ibtmst", cols=col, data=[self.refno,
-                self.tramt, self.taxamt], where=[("ibm_cono", "=",
-                self.opts["conum"]), ("ibm_docno", "=", self.ibtnum)])
-            data = [self.opts["conum"], self.ibtnum, self.ibttyp, self.code,
-                self.desc, self.price, self.quant, self.value, self.pjno,
-                self.curdt, self.opts["capnm"], self.sysdtw, 0]
+            # End of Col Page 3
+            data = [self.opts["conum"], self.inum, self.ityp, self.code,
+                self.desc, self.cpri, self.iqty, self.ival, "", 0,
+                self.pjno, self.cacc, self.ctyp, self.cref, self.ccur,
+                self.opts["capnm"], self.sysdtw, 0]
             self.sql.insRec("ibttrn", data=data)
-            self.excamt = float(ASD(self.excamt) - ASD(self.value))
-            if self.excamt:
-                self.df.advanceLine(2)
+            self.aqty = float(ASD(self.aqty) - ASD(self.iqty))
+            self.tqty = float(ASD(self.tqty) + ASD(self.iqty))
+            self.ibts[self.inum] = self.iqty
+            self.cval = float(ASD(self.cval) - ASD(self.cexc))
+            if self.aqty:
+                self.df.advanceLine(3)
             else:
-                self.opts["mf"].dbm.commitDbase()
-                self.df.clearFrame("C", 2)
-                self.df.selPage("Invoice")
-                self.df.advanceLine(1)
+                self.df.clearFrame("C", 3)
+                if self.cval:
+                    self.df.selPage("Products")
+                    self.df.advanceLine(2)
+                else:
+                    self.opts["mf"].dbm.commitDbase()
+                    self.df.clearFrame("C", 2)
+                    self.df.selPage("Invoice")
+                    self.df.advanceLine(1)
 
     def doCancel(self):
         self.opts["mf"].dbm.rollbackDbase()
         self.df.clearFrame("C", 2)
+        self.df.clearFrame("C", 3)
         self.df.selPage("Invoice")
         self.df.clearLine(1, focus=True)
 
@@ -310,8 +365,50 @@
         if self.df.pag == 0:
             self.df.closeProcess()
             self.opts["mf"].closeLoop()
-        else:
+        elif self.df.pag == 1:
             self.df.clearFrame("C", 1)
             self.df.focusField("T", 0, 1)
+        elif self.df.pag == 2:
+            cval = CCD(self.cval, "SD", 11.2)
+            ok = askQuestion(self.opts["mf"].body, "Difference",
+                "Entered Value Differs from Invoiced Value by %s"
+                % cval.disp, default="no")
+            if ok == "no":
+                self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+            else:
+                self.opts["mf"].dbm.commitDbase()
+                self.df.clearFrame("C", 2)
+                self.df.selPage("Invoice")
+                self.df.advanceLine(1)
+        else:
+            if self.aqty:
+                aqty = CCD(self.aqty, "SD", 11.2)
+                ok = askQuestion(self.opts["mf"].body, "Difference",
+                    "IBT Quantity Differs from Invoiced Quantity by %s"
+                    % aqty.disp, default="no")
+                if ok == "no":
+                    self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+                    return
+                whr = [("ibt_cono", "=", self.opts["conum"])]
+                for ibt in self.ibts:
+                    qty = round(self.aqty * (self.ibts[ibt] / self.tqty), 2)
+                    qty = float(ASD(self.ibts[ibt]) + ASD(qty))
+                    val = round(qty * self.cpri, 2)
+                    w = copyList(whr)
+                    w.extend([
+                        ("ibt_docno", "=", ibt),
+                        ("ibt_type", "=", self.ityp),
+                        ("ibt_code", "=", self.code)])
+                    self.sql.updRec("ibttrn", cols=["ibt_quant", "ibt_value"],
+                        data=[qty, val], where=w)
+            self.df.clearFrame("C", 3)
+            if self.aval == self.cval:
+                self.opts["mf"].dbm.commitDbase()
+                self.df.clearFrame("C", 2)
+                self.df.selPage("Invoice")
+                self.df.advanceLine(1)
+            else:
+                self.df.selPage("Products")
+                self.df.advanceLine(2)
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'ibt/ib3010.py'
--- ibt/ib3010.py	2016-02-27 13:18:41 +0000
+++ ibt/ib3010.py	2016-05-11 03:37:55 +0000
@@ -48,28 +48,30 @@
                 ("tpm_type", "=", "I"),
                 ("tpm_system", "=", "IBT")],
             "order": "tpm_tname"}
-        iv1 = {
+        doc = {
             "stype": "R",
             "tables": ("ibtmst","ctlmst"),
             "cols": [
                 ("ibm_docno", "",  0, "Doc-Num"),
-                ("ibm_date", "",  0, "Date"),
                 ("ibm_branch",  "", 0, "Bch"),
                 ("ctm_name",  "", 0, "Name", "Y")],
             "where": [
                 ("ibm_cono", "=", self.opts["conum"]),
-                ("ibm_cono=ctm_cono",)],
+                ("ctm_cono=ibm_branch",)],
             "screen": self.opts["mf"].body}
-        r1s = (("Range","R"),("Singles", "S"))
+        r1s = (("Invoices","I"),("Credit Notes", "C"))
+        r2s = (("Range","R"),("Singles", "S"))
         fld = (
             (("T",0,0,0),"INA",20,"Template Name","",
-                self.stpl,"N",self.doTplNam,tpm,None,None),
-            (("T",0,1,0),("IRB",r1s),0,"Documents","",
-                "S","Y",self.doSelect,None,None,None),
-            (("T",0,2,0),"IUI",7,"From Number","From Document Number",
-                "","N",self.doDocno,iv1,None,("notzero",)),
-            [("T",0,3,0),"IUI",7,"To   Number","To Document Number",
-                "","N",self.doDocno,iv1,None,("notzero",)])
+                self.stpl,"Y",self.doTplNam,tpm,None,None),
+            (("T",0,1,0),("IRB",r1s),0,"Document Type","",
+                "I","N",self.doDocTyp,None,None,None),
+            (("T",0,2,0),("IRB",r2s),0,"Documents","",
+                "S","N",self.doSelect,None,None,None),
+            (("T",0,3,0),"IUI",7,"From Number","From Document Number",
+                "","N",self.doDocno,doc,None,("notzero",)),
+            [("T",0,4,0),"IUI",7,"To   Number","To Document Number",
+                "","N",self.doDocno,doc,None,("notzero",)])
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
             tend=((self.doEnd, "y"),), txit=(self.doExit,),
             view=("N","V"), mail=("B","Y"))
@@ -86,12 +88,9 @@
             self.copy = "y"
         else:
             self.copy = "n"
-            self.df.topf[pag][4][5] = "V"
-            if len(self.df.topf[pag]) == 8:
-                self.df.topf[pag][6][5] = "N"
 
-    def doType(self, frt, pag, r, c, p, i, w):
-        self.typ = w
+    def doDocTyp(self, frt, pag, r, c, p, i, w):
+        self.dtyp = w
 
     def doSelect(self, frt, pag, r, c, p, i, w):
         self.select = w
@@ -107,7 +106,7 @@
             self.opts["conum"]), ("ibm_docno", "=", w)])
         if not doc:
             return "Document Number Does Not Exist"
-        if p == 2:
+        if p == 3:
             self.frm = w
             self.df.topf[pag][3][5] = self.frm
         elif w < self.frm:
@@ -118,7 +117,7 @@
     def doEnd(self):
         self.df.closeProcess()
         tab = ["ibtmst", "ctlmst"]
-        col = ["ibm_docno", "ibm_date", "ibm_branch", "ctm_name"]
+        col = ["ibm_docno", "ibm_cdte", "ibm_branch", "ctm_name"]
         dic = {}
         for c in col:
             for t in tab:
@@ -126,24 +125,32 @@
                 if c in d:
                     dic[c] = d[c]
         if self.select == "S":
-            recs = self.sql.getRec(tables=tab, cols=col, where=[("ibm_cono",
-                "=", self.opts["conum"]), ("ctm_cono=ibm_branch",)],
+            whr = [
+                ("ibm_cono", "=", self.opts["conum"]),
+                ("ctm_cono=ibm_branch",)]
+            if self.dtyp == "C":
+                col[1] = "ibm_cdte"
+                whr.append(("ibm_cdte", "<>", 0))
+            recs = self.sql.getRec(tables=tab, cols=col, where=whr,
                 order="ibm_docno")
             recs = getSingleRecords(self.opts["mf"], tab, col, dic=dic,
                 where=recs, ttype="D")
-            iv1 = []
+            doc = []
             if recs:
                 for rec in recs:
-                    iv1.append([rec[0]])
+                    doc.append([rec[0]])
         else:
-            iv1 = self.sql.getRec(tables="ibtmst", cols=["ibm_docno"],
-            where=[
+            whr = [
                 ("ibm_cono", "=", self.opts["conum"]),
                 ("ibm_docno", ">=", self.frm),
-                ("ibm_docno", "<=", self.to)])
-        if iv1:
+                ("ibm_docno", "<=", self.to)]
+            if self.dtyp == "C":
+                whr.append(("ibm_cdte", "<>", 0))
+            doc = self.sql.getRec(tables="ibtmst", cols=["ibm_docno"],
+                where=whr, order="ibm_docno")
+        if doc:
             PrintTransfer(self.opts["mf"], self.opts["conum"],
-                self.opts["conam"], iv1, crcoy=self.ccoy,
+                self.opts["conam"], self.dtyp, doc, crcoy=self.ccoy,
                 tname=self.tname, repprt=self.df.repprt,
                 repeml=self.df.repeml)
         self.opts["mf"].closeLoop()

=== modified file 'ibt/ib3020.py'
--- ibt/ib3020.py	2016-02-27 13:18:41 +0000
+++ ibt/ib3020.py	2016-04-23 11:52:57 +0000
@@ -57,13 +57,13 @@
             "order": "ctm_cono"}
         self.num = {
             "stype": "R",
-            "tables": ("ibtmst",),
+            "tables": ("ibttrn",),
             "cols": [
-                ("ibm_tjnl", "", 0, "Pj-Number"),
-                ("ibm_tjdt", "", 0, "Pj-Date")],
+                ("ibt_tjnl", "", 0, "Pj-Number"),
+                ("ibt_tjdt", "", 0, "Pj-Date")],
             "where": [],
-            "group": "ibm_tjnl, ibm_tjdt",
-            "order": "ibm_tjnl, ibm_tjdt"}
+            "group": "ibt_tjnl, ibt_tjdt",
+            "order": "ibt_tjnl, ibt_tjdt"}
         r1s = (("Yes", "Y"), ("No", "N"))
         fld = (
             (("T",0,0,0),("IRB",r1s),0,"Reprints","",
@@ -84,8 +84,8 @@
     def doReprint(self, frt, pag, r, c, p, i, w):
         self.reprint = w
         self.num["where"] = [
-            ("ibm_cono", "=", self.opts["conum"]),
-            ("ibm_tjnl", "<>", "")]
+            ("ibt_cono", "=", self.opts["conum"]),
+            ("ibt_tjnl", "<>", "")]
         if self.reprint == "Y":
             return "sk1"
 
@@ -103,9 +103,9 @@
             self.endn = 0
             return "sk1"
         self.num["where"] = [
-            ("ibm_cono", "=", self.opts["conum"]),
-            ("ibm_tjnl", "<>", ""),
-            ("ibm_tjnl", ">", self.startn)]
+            ("ibt_cono", "=", self.opts["conum"]),
+            ("ibt_tjnl", "<>", ""),
+            ("ibt_tjnl", ">", self.startn)]
 
     def doEndN(self, frt, pag, r, c, p, i, w):
         self.endn = w
@@ -114,18 +114,29 @@
 
     def doEnd(self):
         self.df.closeProcess()
-        whr = [("ibm_cono", "=", self.opts["conum"])]
+        col = ["ibm_docno", "ibm_date", "ibm_branch"]
+        whr = [
+            ("ibm_cono", "=", self.opts["conum"]),
+            ("ibm_docno", "<>", 999999999)]
         if self.reprint == "N":
-            whr.append(("ibm_tjnl", "=", ""))
+            whr.append(("ibt_tjnl", "=", ""))
         else:
             if self.bchno:
                 whr.append(("ibm_branch", "=", self.bchno))
             if self.startn:
-                whr.append(("ibm_tjnl", "between", self.startn, self.endn))
-        odr = "ibm_branch, ibm_tjnl, ibm_date"
+                whr.append(("ibt_tjnl", "between", self.startn, self.endn))
+            else:
+                whr.append(("ibt_tjnl", "<>", ""))
+        whr.extend([
+            ("ibt_cono=ibm_cono",),
+            ("ibt_docno=ibm_docno",),
+            ("ibt_type", "in", (1, 2))])
+        grp = "ibm_docno, ibm_date, ibm_branch"
+        odr = "ibm_branch, ibm_docno"
         sp = SplashScreen(self.opts["mf"].body,
             "Generating Report\n\nPlease Wait...")
-        recs = self.sql.getRec(tables="ibtmst", where=whr, order=odr)
+        recs = self.sql.getRec(tables=["ibtmst", "ibttrn"], cols=col,
+            where=whr, order=odr, group=grp)
         sp.closeSplash()
         if not recs:
             showError(self.opts["mf"].body, "Selection Error",
@@ -142,13 +153,13 @@
                 if self.pglin > self.fpdf.lpp:
                     self.doTotHead()
                 a = self.deptot[key][0]
-                b = CCD(self.deptot[key][1], "SD", 13.2)
-                self.fpdf.drawText("Totals for Branch %3s %-43s %s" %
+                b = CCD(self.deptot[key][1], "CD", 15.2)
+                self.fpdf.drawText("Totals for Branch %3s %-41s %s" %
                     (key, a, b.disp))
                 tots = float(ASD(tots) + ASD(b.work))
                 self.pglin += 1
-            a = CCD(tots, "SD", 13.2).disp
-            txt = "%-65s %s" % ("Grand Totals", a)
+            a = CCD(tots, "CD", 15.2)
+            txt = "%-63s %s" % ("Grand Totals", a.disp)
             self.fpdf.underLine(txt=txt)
             self.fpdf.drawText(txt)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
@@ -163,51 +174,65 @@
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")
         self.pgnum += 1
-        txt = "%-65s %13s" % ("Summary of Branch Totals", "Amount ")
+        txt = "%-63s %15s" % ("Summary of Branch Totals", "Amount ")
         self.fpdf.drawText(txt)
         self.fpdf.underLine(txt=txt)
         self.pglin = 6
 
     def printReport(self, recs):
-        imc = self.sql.ibtmst_col
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
         for num, dat in enumerate(recs):
             p.displayProgress(num)
-            docno = CCD(dat[imc.index("ibm_docno")], "Na", 9)
-            date = CCD(dat[imc.index("ibm_date")], "D1", 10)
-            branch = CCD(dat[imc.index("ibm_branch")], "UI", 3)
-            self.tjnl = CCD(dat[imc.index("ibm_tjnl")], "NA", 9)
-            self.tjdt = CCD(dat[imc.index("ibm_tjdt")], "d1", 10)
+            docno = CCD(dat[0], "Na", 9)
+            date = CCD(dat[1], "D1", 10)
+            branch = CCD(dat[2], "UI", 3)
             name = "Spargs Fuel Services"
-            acc = self.sql.getRec(tables="ibttrn", cols=["sum(ibt_value)"],
-                where=[("ibt_cono", "=", self.opts["conum"]), ("ibt_docno",
-                "=", docno.work), ("ibt_type", "=", 1)], limit=1)
-            if not acc:
+            col = ["ibt_type", "ibt_tjnl", "ibt_tjdt", "sum(ibt_value)"]
+            whr = [
+                ("ibt_cono", "=", self.opts["conum"]),
+                ("ibt_docno", "=", docno.work),
+                ("ibt_type", "in", (1, 2))]
+            if self.reprint == "N":
+                whr.append(("ibt_tjnl", "=", ""))
+            else:
+                whr.append(("ibt_tjnl", "<>", ""))
+            trns = self.sql.getRec(tables="ibttrn", cols=col,
+                where=whr, group="ibt_type, ibt_tjnl, ibt_tjdt",
+                order="ibt_type")
+            if not trns:
                 continue
-            tramt = CCD(acc[0], "SD", 13.2)
-            if branch.work != self.branch:
-                if self.branch:
-                    self.branchTotal()
-                self.branch = branch.work
-                self.getVariables()
-                self.pageHeading()
-            if self.reprint == "Y" and self.tjnl.work != self.ltjnl:
-                if self.ltjnl:
-                    self.branchTotal()
-                self.ltjnl = self.tjnl.work
-                self.pageHeading()
-            if self.pglin > self.fpdf.lpp:
-                if self.reprint == "N":
-                    self.branchTotal(fullpg=True)
-                self.pageHeading()
-            if self.reprint == "N" and self.preview == "N":
-                self.sql.updRec("ibtmst", cols=["ibm_tjnl", "ibm_tjdt"],
-                    data=[self.ltjnl, self.sysdtw], where=[("ibm_cono", "=",
-                    self.opts["conum"]), ("ibm_docno", "=", docno.work)])
-            self.totamt = float(ASD(self.totamt) + ASD(tramt.work))
-            self.fpdf.drawText("%-30s %9s %-24s %13s" % (name, docno.disp,
-                date.disp, tramt.disp))
-            self.pglin += 1
+            for trn in trns:
+                if trn[0] == 1:
+                    typ = "Inv"
+                else:
+                    typ = "C/N"
+                self.tjnl = CCD(trn[1], "NA", 9)
+                self.tjdt = CCD(trn[2], "d1", 10)
+                tramt = CCD(trn[3], "CD", 15.2)
+                if branch.work != self.branch:
+                    if self.branch:
+                        self.branchTotal()
+                    self.branch = branch.work
+                    self.getVariables()
+                    self.pageHeading()
+                if self.reprint == "Y" and self.tjnl.work != self.ltjnl:
+                    if self.ltjnl:
+                        self.branchTotal()
+                    self.ltjnl = self.tjnl.work
+                    self.pageHeading()
+                if self.pglin > self.fpdf.lpp:
+                    if self.reprint == "N":
+                        self.branchTotal(fullpg=True)
+                    self.pageHeading()
+                if self.reprint == "N" and self.preview == "N":
+                    self.sql.updRec("ibttrn", cols=["ibt_tjnl", "ibt_tjdt"],
+                        data=[self.ltjnl, self.sysdtw], where=[("ibt_cono", "=",
+                        self.opts["conum"]), ("ibt_docno", "=", docno.work),
+                        ("ibt_type", "=", trn[0])])
+                self.totamt = float(ASD(self.totamt) + ASD(tramt.work))
+                self.fpdf.drawText("%-30s %9s %3s %-18s %15s" % (name,
+                    docno.disp, typ, date.disp, tramt.disp))
+                self.pglin += 1
         p.closeProgress()
         if self.fpdf.page:
             self.branchTotal()
@@ -236,20 +261,20 @@
             self.branch))
         self.fpdf.drawText("V.A.T. Numb: %-13s" % self.vatno)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-30s %-9s %-24s %13s" % ("Supplier-Name",
-            "Reference", "   Date   ", "Amount "))
+        self.fpdf.drawText("%-30s %-9s %3s %-18s %15s" % ("Supplier-Name",
+            "Reference", "Typ", "   Date   ", "Amount "))
         self.fpdf.drawText(self.fpdf.suc * len(self.head))
         self.fpdf.setFont()
         self.pglin = 13
 
     def branchTotal(self, fullpg=False):
-        totamt = CCD(self.totamt, "SD", 13.2)
+        totamt = CCD(self.totamt, "CD", 15.2)
         if not self.branch in self.deptot:
             self.deptot[self.branch] = [self.bname, 0]
         self.deptot[self.branch][1] = float(
             ASD(self.deptot[self.branch][1]) + ASD(totamt.work))
         self.fpdf.drawText(self.fpdf.suc * len(self.head))
-        self.fpdf.drawText("%-65s %13s" % ("Totals", totamt.disp))
+        self.fpdf.drawText("%-63s %15s" % ("Totals", totamt.disp))
         self.getVariables(fullpg)
         self.totamt = 0
 
@@ -263,8 +288,8 @@
         elif fullpg:
             self.ltjnl += 1
         else:
-            tjnl = self.sql.getRec(tables="ibtmst", cols=["max(ibm_tjnl)"],
-                where=[("ibm_cono", "=", self.opts["conum"])], limit=1)
+            tjnl = self.sql.getRec(tables="ibttrn", cols=["max(ibt_tjnl)"],
+                where=[("ibt_cono", "=", self.opts["conum"])], limit=1)
             if not tjnl[0]:
                 self.ltjnl = "T00000001"
             else:

=== modified file 'ibt/ib3030.py'
--- ibt/ib3030.py	2016-02-27 13:18:41 +0000
+++ ibt/ib3030.py	2016-04-23 03:11:31 +0000
@@ -86,7 +86,8 @@
             "ibt_code",
             "ibt_quant",
             "ibt_price",
-            "ibt_value"]
+            "ibt_value",
+            "ibt_ctyp"]
         whr = [
             ("ibm_cono", "=", self.opts["conum"]),
             ("ibt_curdt", "between", self.startw, self.endw)]
@@ -101,37 +102,45 @@
             self.closeProcess()
             return
         old = {}
-        l = None
+        val = None
         for num, dat in enumerate(recs):
-            b, n, d, t, c, q, p, v = dat
+            b, n, d, t, c, q, p, v, ct = dat
             if not b in old:
                 old[b] = {}
             if not n in old[b]:
                 old[b][n] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
-            if t == 1:
-                if l:
-                    self.doChange(old, l)
-                l = [b, n, v, q]
+            if t in (1, 2):
+                # IBT Invoice
+                doc = (b, n)
+                qty = q
+                val = v
                 old[b][n][0] = d
                 old[b][n][1] = float(ASD(old[b][n][1]) + ASD(v))
-            elif t == 2:
+                old[b][n][2] = float(ASD(old[b][n][2]) + ASD(v))
+            elif t == 3:
+                # Supplier Invoice
+                if (b, n) == doc:
+                    old[b][n][2] = float(ASD(old[b][n][2]) - ASD(val))
+                    old[b][n][3] = float(ASD(old[b][n][3]) + ASD(val))
+                    old[b][n][7] = float(ASD(old[b][n][7]) + ASD(val))
                 old[b][n][4] = float(ASD(old[b][n][4]) + ASD(v))
                 old[b][n][6] = float(ASD(old[b][n][6]) + ASD(v))
-                old[b][n][7] = float(ASD(old[b][n][7]) - ASD(v))
-                if not q == l[3]:
-                    sb = round(l[3] * p, 2)
-                    df = float(ASD(v) - ASD(sb))
-                    old[b][n][8] = float(ASD(old[b][n][8]) + ASD(df))
+                if not ct == 4:
+                    old[b][n][7] = float(ASD(old[b][n][7]) - ASD(v))
+                    if not q == qty:
+                        sb = round(qty * p, 2)
+                        df = float(ASD(v) - ASD(sb))
+                        old[b][n][8] = float(ASD(old[b][n][8]) + ASD(df))
             else:
+                # Transport Invoice
                 old[b][n][5] = float(ASD(old[b][n][5]) + ASD(v))
                 old[b][n][6] = float(ASD(old[b][n][6]) + ASD(v))
-                old[b][n][7] = float(ASD(old[b][n][7]) - ASD(v))
-                if not q == l[3]:
-                    sb = round(l[3] * p, 2)
-                    df = float(ASD(v) - ASD(sb))
-                    old[b][n][8] = float(ASD(old[b][n][8]) + ASD(df))
-            if dat == recs[-1]:
-                self.doChange(old, l)
+                if not ct == 4:
+                    old[b][n][7] = float(ASD(old[b][n][7]) - ASD(v))
+                    if not q == qty:
+                        sb = round(qty * p, 2)
+                        df = float(ASD(v) - ASD(sb))
+                        old[b][n][8] = float(ASD(old[b][n][8]) + ASD(df))
         hds = [
             "Branch Sales Report for %s" % self.bdesc,
             "From Period %s to Period %s" % (self.startd, self.endd)]
@@ -139,14 +148,14 @@
             ["a", "UI",   3,   "Bch",         "y"],
             ["b", "Na",   9,   "Inv-Numbr",   "y"],
             ["c", "D1",  10,   "Trans-Date",  "y"],
-            ["d", "SD",  11.2, "Sales-Total", "y"],
-            ["e", "SD",  11.2, "Inv-Outst",   "y"],
-            ["f", "SD",  11.2, "Net-Sales",   "y"],
-            ["g", "SD",  11.2, "Prod-Cost",   "y"],
-            ["h", "SD",  11.2, "Tran-Cost",   "y"],
-            ["i", "SD",  11.2, "Total-Cost",  "y"],
-            ["j", "SD",  11.2, "Total-Net",   "y"],
-            ["k", "SD",  11.2, "TotalDiff",   "y"]]
+            ["d", "SD",  13.2, "Sales-Total", "y"],
+            ["e", "SD",  13.2, "Inv-Outst",   "y"],
+            ["f", "SD",  13.2, "Net-Sales",   "y"],
+            ["g", "SD",  13.2, "Prod-Cost",   "y"],
+            ["h", "SD",  13.2, "Trpt-Cost",   "y"],
+            ["i", "SD",  13.2, "Total-Cost",  "y"],
+            ["j", "SD",  13.2, "Total-Net",   "y"],
+            ["k", "SD",  13.2, "TotalDiff",   "y"]]
         sdy = [["a", "Branch Code", "Y"]]
         tot = ["d", "e", "f", "g", "h", "i", "j", "k"]
         data = []
@@ -154,22 +163,19 @@
         bkey.sort()
         for k1 in bkey:
             nkey = old[k1].keys()
+            nkey.sort()
             for k2 in nkey:
                 data.append([k1, k2] + old[k1][k2])
+        if self.bcode:
+            summ = False
+        else:
+            summ = True
         RepPrt(self.opts["mf"], conum=self.opts["conum"], ttype="D",
             conam=self.opts["conam"], name=__name__, tables=data, heads=hds,
             cols=col, stots=sdy, gtots=tot, repprt=self.df.repprt,
-            repeml=self.df.repeml, pbar="P")
+            repeml=self.df.repeml, pbar="P", summ=summ)
         self.closeProcess()
 
-    def doChange(self, old, l):
-        b1, n1, v1 = l[:3]
-        if not old[b1][n1][4]:
-            old[b1][n1][2] = old[b1][n1][1]
-        else:
-            old[b1][n1][3] = float(ASD(old[b1][n1][3]) + ASD(v1))
-            old[b1][n1][7] = float(ASD(old[b1][n1][7]) + ASD(v1))
-
     def doExit(self):
         self.df.closeProcess()
         self.closeProcess()

=== added file 'ibt/ib3040.py'
--- ibt/ib3040.py	1970-01-01 00:00:00 +0000
+++ ibt/ib3040.py	2016-05-21 10:56:41 +0000
@@ -0,0 +1,188 @@
+#! /usr/bin/env python
+
+"""
+SYNOPSIS
+    Branch Transfer Statements.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2016 Paul Malherbe.
+"""
+
+import time
+from TartanClasses import ASD, CCD, MyFpdf, ProgressBar, Sql, TartanDialog
+from tartanFunctions import doPrinter, getModName, getSingleRecords, showError
+
+class ib3040:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "ibtmst", "ibttrn"],
+            prog=__name__)
+        if self.sql.error:
+            return
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i)" % \
+            (t[0], t[1], t[2], t[3], t[4])
+        self.curdt = self.sysdtw / 100
+        return True
+
+    def mainProcess(self):
+        self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Branch Transfer Statements (%s)" % __name__)
+        r1s = (("Yes","Y"),("Singles","S"))
+        fld = (
+            (("T",0,0,0),"ID2",7,"Period","",
+                self.curdt,"Y",self.doPeriod,None,None,("efld",)),
+            (("T",0,1,0),("IRB",r1s),0,"All Branches","",
+                "S","Y",self.doWhole,None,None,None))
+        tnd = ((self.doEnd,"Y"), )
+        txt = (self.doExit, )
+        self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
+            tend=tnd, txit=txt, view=("N","V"), mail=("Y","N"))
+
+    def doPeriod(self, frt, pag, r, c, p, i, w):
+        self.curdt = w
+        self.curdd = self.df.t_disp[0][0][0]
+
+    def doWhole(self, frt, pag, r, c, p, i, w):
+        self.whole = w
+
+    def doEnd(self):
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.prnt = "N"
+        if self.whole == "S":
+            recs = getSingleRecords(self.opts["mf"], ["ctlmst", "ibtmst"],
+                ("ctm_cono", "ctm_name"), where=[("ibm_cono", "=",
+                self.opts["conum"]), ("ctm_cono=ibm_branch",)],
+                group=True, order="ctm_cono", selcol="ctm_cono")
+        else:
+            recs = self.sql.getRec(tables="ctlmst", order="ctm_cono")
+        if not recs:
+            showError(self.opts["mf"].body, "Error", "No Accounts Available")
+        else:
+            num = len(recs)
+            p = ProgressBar(self.opts["mf"].body, mxs=num, esc=True)
+            for num, ctm in enumerate(recs):
+                p.displayProgress(num)
+                if p.quit:
+                    break
+                self.doProcess(ctm)
+            p.closeProgress()
+            if self.prnt == "Y" and self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    pdfnam=pdfnam, head=self.tit, repprt=self.df.repprt,
+                    repeml=self.df.repeml)
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.focusField("T", 0, 1)
+
+    def doProcess(self, ctm):
+        self.pgnum = 0
+        self.totbal = 0
+        ctc = self.sql.ctlmst_col
+        self.cono = CCD(ctm[ctc.index("ctm_cono")], "UI", 3)
+        col = ["ibm_docno", "ibm_date", "ibm_cdte"]
+        whr = [
+            ("ibm_cono", "=", self.opts["conum"]),
+            ("ibm_branch", "=", self.cono.work),
+            ("ibt_cono=ibm_cono",),
+            ("ibt_docno=ibm_docno",),
+            ("ibt_curdt", "=", self.curdt)]
+        grp = "ibm_docno, ibm_date, ibm_cdte"
+        odr = "ibm_docno"
+        self.ibm = self.sql.getRec(tables=["ibtmst", "ibttrn"], cols=col,
+            where=whr, group=grp, order=odr)
+        if self.ibm:
+            if self.prnt == "N":
+                self.printSetup()
+            self.name = CCD(ctm[ctc.index("ctm_name")], "NA", 30)
+            self.add1 = CCD(ctm[ctc.index("ctm_add1")], "NA", 30)
+            self.add2 = CCD(ctm[ctc.index("ctm_add2")], "NA", 30)
+            self.add3 = CCD(ctm[ctc.index("ctm_add3")], "NA", 30)
+            self.pcod = CCD(ctm[ctc.index("ctm_pcode")], "NA", 4)
+            self.printHeader()
+            self.printBody()
+
+    def printSetup(self):
+        self.head = ("%03u %-30s %37s %6s" % \
+            (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
+        self.fpdf = MyFpdf(name=__name__, head=self.head)
+        self.prnt = "Y"
+
+    def pageHeading(self):
+        self.fpdf.add_page()
+        self.fpdf.setFont(style="B")
+
+    def printHeader(self):
+        self.pageHeading()
+        self.pgnum += 1
+        self.fpdf.drawText(self.head)
+        self.fpdf.drawText()
+        self.fpdf.drawText("%-40s %-10s %-19s %7s" % \
+            (self.name.disp, "", "Branch:", self.cono.disp))
+        self.fpdf.drawText("%-40s %-10s %-19s %7s" % \
+            (self.add1.disp, "", "Period", self.curdd))
+        self.fpdf.drawText("%-40s %-10s %-21s %5s" % \
+            (self.add2.disp, "", "Page:", self.pgnum))
+        self.fpdf.drawText("%-40s %-10s %-16s %-10s" % \
+            (self.add3.disp, "", "", ""))
+        self.fpdf.drawText("%-40s" % (self.pcod.disp))
+        self.fpdf.drawText()
+        self.fpdf.drawText("%-30s %-9s %3s %-18s %15s" % ("Supplier-Name",
+            "Reference", "Typ", "   Date   ", "Amount "))
+        self.fpdf.underLine(txt=self.head)
+        self.fpdf.setFont()
+        if self.pgnum > 1:
+            totbal = CCD(self.totbal, "CD", 15.2)
+            self.fpdf.drawText("%41s %3s %18s %15s" % \
+                ("", "B/F", "", totbal.disp))
+            self.pglin = 11
+        else:
+            self.pglin = 10
+        self.fpdf.setFont()
+
+    def printBody(self):
+        for acc in self.ibm:
+            docno = CCD(acc[0], "UI", 9)
+            trns = self.sql.getRec(tables="ibttrn", cols=["ibt_type",
+                "sum(ibt_value)"], where=[("ibt_cono", "=", self.opts["conum"]),
+                ("ibt_docno", "=", docno.work), ("ibt_type", "in", (1, 2)),
+                ("ibt_curdt", "=", self.curdt)], group="ibt_type",
+                order="ibt_type")
+            for trn in trns:
+                if trn[0] == 1:
+                    typ = "INV"
+                    date = CCD(acc[1], "D1", 10)
+                else:
+                    typ = "C/N"
+                    date = CCD(acc[2], "D1", 10)
+                tramt = CCD(trn[1], "CD", 15.2)
+                self.totbal = float(ASD(self.totbal) + ASD(tramt.work))
+                self.fpdf.drawText("%-30s %9s %3s %-18s %15s" %
+                    (self.opts["conam"], docno.disp, typ, date.disp,
+                    tramt.disp))
+                self.pglin += 1
+        self.fpdf.underLine(txt=self.head)
+        tramt = CCD(self.totbal, "CD", 15.2)
+        self.fpdf.drawText("%-30s %9s %-22s %15s" % ("", "", "", tramt.disp))
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.closeProcess()
+
+    def closeProcess(self):
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'lon/ln2010.py'
--- lon/ln2010.py	2016-02-27 13:18:41 +0000
+++ lon/ln2010.py	2016-03-23 14:47:45 +0000
@@ -149,7 +149,7 @@
                 (("C",2,0,6),"INA",30,"Allocation Details","",
                     "","N",self.doAllDet,None,None,("notblank",))])
             if not self.incoac:
-                fld[11][1] = "OUI"
+                fld[15][1] = "OUI"
         but = [("Interrogate",None,self.querySln,0,("C",1,1),("C",1,2))]
         tag = [("Transaction", None, None, None, False)]
         cnd = [(None,"n"), (self.endPage1,"y")]

=== added file 'lon/ln2020_rne.py'
--- lon/ln2020_rne.py	1970-01-01 00:00:00 +0000
+++ lon/ln2020_rne.py	2016-04-21 16:32:11 +0000
@@ -0,0 +1,124 @@
+#! /usr/bin/python
+
+"""
+SYNOPSIS
+    Loans Raise Interest.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2016 Paul Malherbe.
+"""
+
+import time
+from TartanClasses import GetCtl, LoanInterest, ProgressBar, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import mthendDate
+
+class ln2020:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.dataHeader()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        tab = ["ctlmst", "lonctl", "lonmf2", "lontrn", "gentrn"]
+        self.sql = Sql(self.opts["mf"].dbm, tables=tab, prog=__name__)
+        if self.sql.error:
+            return
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        yr = self.sysdtw / 10000
+        mt = (self.sysdtw / 100 % 100) - 1
+        self.lme = mthendDate((yr * 10000) + (mt * 100) + 1)
+        return True
+
+    def dataHeader(self):
+        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+                "Staff Loans Raise Interest (%s)" % __name__)
+        r1s = (("Yes", "Y"), ("No", "N"))
+        fld = (
+            (("T",0,0,0),"ID1",10,"Transaction Date","",
+                self.lme,"N",self.doTrdate,None,None,("efld",)),
+            (("T",0,1,0),("IRB",r1s),0,"All Companies","",
+                "N","N",self.doAllCoy,None,None,None))
+        tnd = ((self.endPage0, "y"),)
+        txt = (self.exitPage0,)
+        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld, tend=tnd,
+            txit=txt)
+
+    def doTrdate(self, frt, pag, r, c, p, i, w):
+        self.trdate = w
+        if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
+            return "Invalid Date, Not in Financial Period"
+        if not w == mthendDate(w):
+            return "Invalid Date, Not a Month End"
+
+    def doAllCoy(self, frt, pag, r, c, p, i, w):
+        if w == "N":
+            self.coys = [self.opts["conum"]]
+        else:
+            self.coys = []
+            recs = self.sql.getRec(tables="ctlmst", order="ctm_cono")
+            for rec in recs:
+                cono = rec[self.sql.ctlmst_col.index("ctm_cono")]
+                mods = rec[self.sql.ctlmst_col.index("ctm_modules")]
+                for x in range(0, len(mods), 2):
+                    if mods[x:x+2] == "LN":
+                        self.coys.append(cono)
+                        break
+
+    def endPage0(self):
+        self.df.closeProcess()
+        batch = "L%s" % (self.trdate / 100)
+        p1 = ProgressBar(self.opts["mf"].body, typ="Interest on Loans",
+            mxs=len(self.coys))
+        for n1, coy in enumerate(self.coys):
+            p1.displayProgress(n1)
+            if not self.getControls(coy):
+                continue
+            recs = self.sql.getRec(tables="lonmf2", where=[("lm2_cono",
+                "=", coy), ("lm2_start", "<", self.trdate)],
+                order="lm2_acno, lm2_loan")
+            p2 = ProgressBar(self.opts["mf"].body, inn=p1,
+                typ="Raising Interest for Company %s" % coy, mxs=len(recs))
+            for n2, lonmf2 in enumerate(recs):
+                p2.displayProgress(n2)
+                LoanInterest("L", self.opts["mf"].dbm, lonmf2, update="Y",
+                    tdate=self.trdate, batch=batch, curdt=self.trdate / 100,
+                    refno=True, glctl=self.glctl, capnm=self.opts["capnm"])
+            self.sql.updRec("lonctl", cols=["cln_last"], data=[self.trdate],
+                where=[("cln_cono", "=", coy)])
+            p2.closeProgress()
+        p1.closeProgress()
+        self.opts["mf"].dbm.commitDbase()
+        self.opts["mf"].closeLoop()
+
+    def getControls(self, coy):
+        gc = GetCtl(self.opts["mf"])
+        lonctl = gc.getCtl("lonctl", coy)
+        if not lonctl:
+            return
+        glint = lonctl["cln_glint"]
+        if glint == "Y":
+            ctlctl = gc.getCtl("ctlctl", coy)
+            if not ctlctl:
+                return
+            ctls = ["lon_ctl", "int_rec", "int_pay"]
+            if gc.chkRec(coy, ctlctl, ctls):
+                return
+            self.glctl = (
+                ctlctl["lon_ctl"], ctlctl["int_rec"], ctlctl["int_pay"])
+        else:
+            self.glctl = None
+        return True
+
+    def exitPage0(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'lon/ln3020.py'
--- lon/ln3020.py	2016-02-27 13:18:41 +0000
+++ lon/ln3020.py	2016-04-18 11:48:31 +0000
@@ -16,7 +16,8 @@
 import time
 from TartanClasses import ASD, CCD, GetCtl, MyFpdf, ProgressBar, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import doPrinter, getModName, showError
+from tartanFunctions import copyList, doPrinter, doWriteExport, getModName
+from tartanFunctions import showError
 from tartanWork import lntrtp
 
 class ln3020:
@@ -38,8 +39,19 @@
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i)" % \
             (t[0], t[1], t[2], t[3], t[4])
+        self.head = ("%03u %-30s %s" % (self.opts["conum"],
+            self.opts["conam"], "%s"))
+        self.colsh = ["TP", "BatchNo", "Acc-Num", "Ln", "Reference",
+            "Trans-Date", "Remarks", "Debits", "Credits"]
+        self.forms = [("UI", 2), ("NA", 7), ("UA", 7), ("UI", 2),
+            ("Na", 9), ("D1", 10), ("NA", 30), ("SD", 13.2), ("SD", 13.2)]
         self.sper = self.opts["period"][1][0] / 100
         self.eper = self.opts["period"][2][0] / 100
+        self.gqt = [0,0,0,0,0]
+        self.gam = [0,0,0,0,0]
+        self.prtrtp = copyList(lntrtp)
+        self.prtrtp[3] = ("DRI", "Debit Interest")
+        self.prtrtp.append(("CRI", "Credit Interest"))
         self.totind = "N"
         return True
 
@@ -47,7 +59,7 @@
         self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
             "Loans Audit Trail (%s)" % __name__)
         data = ["All Types"]
-        for typ in lntrtp:
+        for typ in self.prtrtp:
             data.append(typ[1])
         btt = {
             "stype": "C",
@@ -59,7 +71,7 @@
             "tables": ("lontrn",),
             "cols": (
                 ("lnt_batch", "", 0, "Bat-Num"),
-                ("lnt_type", ("xx", lntrtp), 20, "Type"),
+                ("lnt_type", ("xx", self.prtrtp), 20, "Type"),
                 ("lnt_curdt", "", 0, "Cur-Dat")),
             "where": [("lnt_cono", "=", self.opts["conum"])],
             "group": "lnt_batch, lnt_type, lnt_curdt",
@@ -79,7 +91,7 @@
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
-            tend=tnd, txit=txt, view=("N","V"), mail=("Y","N"))
+            tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
 
     def doStartPer(self, frt, pag, r, c, p, i, w):
         if w > self.eper:
@@ -98,7 +110,7 @@
         self.edatd = CCD(self.edatw, "d2", 7).disp
 
     def doBatTyp(self, frt, pag, r, c, p, i, w):
-        if w > len(lntrtp):
+        if w > len(self.prtrtp):
             return "Invalid Batch Type"
         self.btype = w
         if self.btype:
@@ -111,6 +123,12 @@
 
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
+        if self.totsonly == "Y":
+            self.df.setWidget(self.df.topEntry[0][5][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][5][4][0], state="hide")
+        else:
+            self.df.setWidget(self.df.topEntry[0][5][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][5][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()
@@ -132,45 +150,74 @@
         if not recs:
             showError(self.opts["mf"].body, "Transaction Error",
             "No Transactions Selected")
+        elif self.df.repprt[2] == "export":
+            self.exportReport(recs)
         else:
             self.printReport(recs)
         self.closeProcess()
 
+    def exportReport(self, recs):
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        expnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+            self.opts["conum"])
+        self.expheads = [self.head % self.sysdttm]
+        self.expheads.append("Loans's Ledger Audit Trail for Period "\
+            "%s to %s" % (self.sdatd, self.edatd))
+        self.expcolsh = [self.colsh]
+        self.expforms = self.forms
+        self.expdatas = []
+        self.gdrs = 0
+        self.gcrs = 0
+        for num, dat in enumerate(recs):
+            p.displayProgress(num)
+            if p.quit:
+                p.closeProgress()
+                return
+            vals = self.getValues(dat)
+            if not vals:
+                continue
+            acno, loan, batch, trtp, trdt, ref, drs, crs, desc = vals
+            line = ["BODY", [trtp.work, batch.work, acno.work, loan.work,
+                ref.work, trdt.work, desc.work, drs.work, crs.work]]
+            self.expdatas.append(line)
+            self.gdrs = float(ASD(self.gdrs) + ASD(drs.work))
+            self.gcrs = float(ASD(self.gcrs) + ASD(crs.work))
+        p.closeProgress()
+        self.grandTotal()
+        doWriteExport(xtype=self.df.repprt[1], name=expnam,
+            heads=self.expheads, colsh=self.expcolsh, forms=self.expforms,
+            datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
+
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if self.totsonly == "Y":
-            self.head = ("%03u %-30s %38s %6s" % \
+            self.head = ("%03u %-30s %48s %6s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         else:
-            self.head = ("%03u %-30s %12s %33s %12s %6s" % (self.opts["conum"],
-                self.opts["conam"], "", self.sysdttm, "", __name__))
+            self.head = ("%03u %-30s %48s %6s" % (self.opts["conum"],
+                self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.bqty = 0
-        self.bamt = 0
+        self.bdrs = 0
+        self.bcrs = 0
         self.tqty = 0
-        self.tamt = 0
-        self.gqt = [0,0,0,0,0,0,0]
-        self.gam = [0,0,0,0,0,0,0]
+        self.tdrs = 0
+        self.tcrs = 0
         self.trtp = 0
         self.pgnum = 0
         self.pglin = 999
-        col = self.sql.lontrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
             if p.quit:
                 break
-            acno = CCD(dat[col.index("lnt_acno")], "UA", 7)
-            loan = CCD(dat[col.index("lnt_loan")], "UI", 2)
-            batch = CCD(dat[col.index("lnt_batch")], "Na", 7)
-            trtp = CCD(dat[col.index("lnt_type")], "UI", 2)
-            trdt = CCD(dat[col.index("lnt_trdt")], "D1", 10)
-            ref = CCD(dat[col.index("lnt_refno")], "Na", 9)
-            amt = CCD(dat[col.index("lnt_tramt")], "SD", 13.2)
-            desc = CCD(dat[col.index("lnt_desc")], "NA", 42)
+            vals = self.getValues(dat)
+            if not vals:
+                continue
+            acno, loan, batch, trtp, trdt, ref, drs, crs, desc = vals
             if not self.trtp:
                 self.trtp = trtp.work
                 self.batch = batch.work
-            if trtp.work != self.trtp:
+            if trtp.work != self.trtp and self.trtp < 4:
                 self.batchTotal()
                 self.typeTotal()
                 self.trtp = trtp.work
@@ -179,21 +226,21 @@
             if batch.work != self.batch:
                 self.batchTotal()
                 self.batch = batch.work
-                if self.totsonly != "Y":
+                if self.totsonly == "N":
                     self.typeHeading()
             if self.pglin > self.fpdf.lpp:
                 self.pageHeading()
-            if self.totsonly != "Y":
-                self.fpdf.drawText("%s %s %s %s %s %13s %s" % (acno.disp,
-                    loan.disp, ref.disp, trdt.disp, desc.disp, "", amt.disp))
+            if self.totsonly == "N":
+                self.fpdf.drawText("%s %s %s %s %s %s %s" % (acno.disp,
+                    loan.disp, ref.disp, trdt.disp, desc.disp, drs.disp,
+                    crs.disp))
                 self.pglin += 1
             self.bqty = self.bqty + 1
-            self.bamt = float(ASD(self.bamt) + ASD(amt.work))
+            self.bdrs = float(ASD(self.bdrs) + ASD(drs.work))
+            self.bcrs = float(ASD(self.bcrs) + ASD(crs.work))
             self.tqty = self.tqty + 1
-            self.tamt = float(ASD(self.tamt) + ASD(amt.work))
-            self.gqt[trtp.work - 1] = self.gqt[trtp.work - 1] + 1
-            self.gam[trtp.work - 1] = float(ASD(self.gam[trtp.work - 1]) + \
-                ASD(amt.work))
+            self.tdrs = float(ASD(self.tdrs) + ASD(drs.work))
+            self.tcrs = float(ASD(self.tcrs) + ASD(crs.work))
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             self.batchTotal()
@@ -206,6 +253,31 @@
                 pdfnam=pdfnam, head=self.tit, repprt=self.df.repprt,
                 repeml=self.df.repeml)
 
+    def getValues(self, data):
+        col = self.sql.lontrn_col
+        acno = CCD(data[col.index("lnt_acno")], "UA", 7)
+        loan = CCD(data[col.index("lnt_loan")], "UI", 2)
+        batch = CCD(data[col.index("lnt_batch")], "Na", 7)
+        trtp = CCD(data[col.index("lnt_type")], "UI", 2)
+        trdt = CCD(data[col.index("lnt_trdt")], "D1", 10)
+        ref = CCD(data[col.index("lnt_refno")], "Na", 9)
+        amt = data[col.index("lnt_tramt")]
+        if amt < 0:
+            crs = CCD(amt, "SD", 13.2)
+            drs = CCD(0, "SD", 13.2)
+            if trtp.work == 4:
+                trtp = CCD(trtp.work + 1, "UI", 2)
+        else:
+            drs = CCD(amt, "SD", 13.2)
+            crs = CCD(0, "SD", 13.2)
+        desc = CCD(data[col.index("lnt_desc")], "NA", 30)
+        self.gqt[trtp.work - 1] = self.gqt[trtp.work - 1] + 1
+        self.gam[trtp.work - 1] = float(
+            ASD(self.gam[trtp.work - 1]) + ASD(drs.work))
+        self.gam[trtp.work - 1] = float(
+            ASD(self.gam[trtp.work - 1]) + ASD(crs.work))
+        return (acno, loan, batch, trtp, trdt, ref, drs, crs, desc)
+
     def pageHeading(self):
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")
@@ -214,12 +286,12 @@
         self.fpdf.drawText()
         if self.totsonly == "Y":
             self.fpdf.drawText(
-            "%-34s %-7s %2s %-7s %20s %5s" % \
+            "%-34s %-7s %2s %-7s %30s %5s" % \
             ("Loans Audit Trail for Period",
             self.sdatd, "to", self.edatd, "Page", self.pgnum))
         else:
             self.fpdf.drawText(
-            "%-34s %-7s %-2s %-7s %41s %5s" % \
+            "%-34s %-7s %-2s %-7s %30s %5s" % \
             ("Loans Audit Trail for Period",
             self.sdatd, "to", self.edatd, "Page", self.pgnum))
         self.fpdf.drawText()
@@ -229,8 +301,8 @@
         else:
             self.fpdf.drawText("%-14s" % "Totals Summary")
             self.fpdf.drawText()
-            self.fpdf.drawText("%-79s%-8s  %-13s" % \
-                ("Document Type", "Quantity", "      Amount"))
+            self.fpdf.drawText("%-67s%-8s  %13s" % \
+                ("Document Type", "Quantity", "Amount "))
             self.fpdf.underLine(txt=self.head)
             self.fpdf.setFont()
             self.pglin += 4
@@ -244,76 +316,78 @@
             self.pageHeading()
             return
         self.fpdf.setFont(style="B")
-        self.fpdf.drawText("%-7s %-7s %-10s %3s" % ("Batch", batch,
-            "    Type", lntrtp[self.trtp - 1][1]))
+        self.fpdf.drawText("%-7s %-7s %-10s %3s" % ("Batch:", batch,
+            "   Type:", self.prtrtp[self.trtp - 1][1]))
         self.fpdf.drawText()
         if self.totsonly == "Y":
-            self.fpdf.drawText("%-67s %-13s" % ("Details", "      Amount"))
+            self.fpdf.drawText("%-62s %13s %13s" % ("Details",
+                "Debits ", "Credits "))
         else:
             self.fpdf.drawText(
-                "%-7s %-2s %-9s %-10s %-56s %-13s" % ("Acc-Num", "Ln",
-                "Reference", "Trans-Date", "Remarks", "      Amount"))
+                "%-7s %-2s %-9s %-10s %-30s %13s %13s" % ("Acc-Num", "Ln",
+                "Reference", "Trans-Date", "Remarks", "Debits ", "Credits "))
         self.fpdf.underLine(txt=self.head)
         self.fpdf.setFont()
         self.pglin += 4
 
     def batchTotal(self):
-        j = CCD(self.bamt, "SD", 13.2)
+        j = CCD(self.bdrs, "SD", 13.2)
+        k = CCD(self.bcrs, "SD", 13.2)
         if self.totsonly == "Y":
-            self.fpdf.drawText("%-5s %-7s %-53s %13s" % \
-                ("Batch", self.batch, "Totals", j.disp))
+            self.fpdf.drawText("%-5s %-7s %-48s %13s %13s" %
+                ("Batch", self.batch, "Totals", j.disp, k.disp))
         else:
             self.fpdf.drawText()
             self.pglin += 1
-            self.fpdf.drawText("%-31s %-56s %13s" % \
-                (" ", "Batch " + self.batch + " Totals", j.disp))
+            self.fpdf.drawText("%-31s %-30s %13s %13s" %
+                (" ", "Batch " + self.batch + " Totals", j.disp, k.disp))
         self.pglin += 1
         if self.totsonly == "N":
             self.fpdf.drawText()
             self.pglin += 1
         self.bqty = 0
-        self.bamt = 0
+        self.bdrs = 0
+        self.bcrs = 0
 
     def typeTotal(self):
-        j = CCD(self.tamt, "SD", 13.2)
+        j = CCD(self.tdrs, "SD", 13.2)
+        k = CCD(self.tcrs, "SD", 13.2)
         if self.totsonly == "Y":
             self.fpdf.drawText()
-            self.fpdf.drawText("%-67s %13s" % \
-                ("Type Totals", j.disp))
+            self.fpdf.drawText("%-62s %13s %13s" %
+                ("Type Totals", j.disp, k.disp))
             self.pglin += 2
         else:
-            self.fpdf.drawText("%-31s %-56s %13s" % \
-                (" ", "Type Totals", j.disp))
+            self.fpdf.drawText("%-31s %-30s %13s %13s" %
+                (" ", "Type Totals", j.disp, k.disp))
             self.pglin += 1
         self.fpdf.drawText()
         self.pglin += 1
         self.tqty = 0
-        self.tamt = 0
+        self.tdrs = 0
+        self.tcrs = 0
 
     def grandTotal(self):
+        if self.df.repprt[2] == "export":
+            self.expdatas.append(["ULINES"])
+            self.expdatas.append(["TOTAL", ["", "", "", "", "", "",
+                "Grand Totals", self.gdrs, self.gcrs]])
+            self.expdatas.append(["ULINED"])
+            return
+        tot = [0, 0]
         self.totind = "Y"
         self.pageHeading()
-        tot = [0,0,0,0]
-        for x in xrange(0, len(lntrtp)):
+        for x in xrange(0, len(self.prtrtp)):
             qt = CCD(self.gqt[x], "SI", 8)
             am = CCD(self.gam[x], "SD", 13.2)
-            if self.totsonly == "Y":
-                self.fpdf.drawText("%-58s %s %s" % \
-                (lntrtp[x][1], qt.disp, am.disp))
-            else:
-                self.fpdf.drawText("%-79s %s %s" % \
-                (lntrtp[x][1], qt.disp, am.disp))
+            self.fpdf.drawText("%-67s %s %s" % (self.prtrtp[x][1],
+                qt.disp, am.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(am.work))
-        self.fpdf.drawText()
+        self.fpdf.underLine(txt=self.head)
         qt = CCD(tot[0], "SI", 8)
         am = CCD(tot[1], "SD", 13.2)
-        if self.totsonly == "Y":
-            self.fpdf.drawText("%-58s %s %s" % \
-            ("Grand Totals", qt.disp, am.disp))
-        else:
-            self.fpdf.drawText("%-79s %s %s" % \
-            ("Grand Totals", qt.disp, am.disp))
+        self.fpdf.drawText("%-67s %s %s" % ("Grand Totals", qt.disp, am.disp))
         self.fpdf.drawText()
 
     def doExit(self):

=== modified file 'lon/ln3040.py'
--- lon/ln3040.py	2016-02-27 13:18:41 +0000
+++ lon/ln3040.py	2016-04-21 10:25:54 +0000
@@ -17,7 +17,7 @@
 from TartanClasses import ASD, CCD, DrawForm, GetCtl, LoanInterest, ProgressBar
 from TartanClasses import Sql, TartanDialog
 from tartanFunctions import copyList, doPrinter, getModName, getSingleRecords
-from tartanFunctions import mthendDate, showError
+from tartanFunctions import mthendDate, projectDate, showError
 from tartanWork import lntrtp
 
 class ln3040:
@@ -32,10 +32,15 @@
         lonctl = gc.getCtl("lonctl", self.opts["conum"])
         if not lonctl:
             return
+        self.capb = lonctl["cln_capb"]
+        self.capf = lonctl["cln_capf"]
+        self.lint = lonctl["cln_last"]
         self.stpl = lonctl["cln_tplnam"]
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.curdt = self.sysdtw / 100
+        self.sper = self.opts["period"][1][0] / 100
+        self.eper = self.opts["period"][2][0] / 100
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmes", "ctlmst", "lonmf1",
             "lonmf2", "lontrn", "tplmst"], prog=__name__)
         if self.sql.error:
@@ -61,9 +66,9 @@
             (("T",0,0,0),"INA",20,"Template Name","",
                 self.stpl,"Y",self.doTplNam,tpm,None,None),
             (("T",0,1,0),"Id2",7,"Start Period","",
-                0,"N",self.doSPer,None,None,None),
+                self.sper,"N",self.doSPer,None,None,None),
             (("T",0,2,0),"ID2",7,"End Period","",
-                self.curdt,"N",self.doEPer,None,None,None),
+                self.eper,"N",self.doEPer,None,None,None),
             (("T",0,3,0),("IRB",r1s),0,"Whole File","",
                 "N","N",self.doWhole,None,None,None),
             (("T",0,4,0),("IRB",r2s),0,"Sort Order","",
@@ -71,7 +76,9 @@
             (("T",0,5,0),("IRB",r1s),0,"Include Zero Balances","",
                 "N","N",self.doZeros,None,None,None),
             (("T",0,6,0),("IRB",r1s),0,"Include Pending Interest","",
-                "N","N",self.doPend,None,None,None))
+                "N","N",self.doPend,None,None,None),
+            (("T",0,7,0),("IRB",r1s),0,"Interest Totals Only","",
+                "Y","N",self.doITots,None,None,None))
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
@@ -105,6 +112,9 @@
     def doPend(self, frt, pag, r, c, p, i, w):
         self.pend = w
 
+    def doITots(self, frt, pag, r, c, p, i, w):
+        self.itot = w
+
     def doEnd(self):
         self.df.closeProcess()
         self.emadd = self.df.repeml[2]
@@ -198,6 +208,64 @@
         trns = self.sql.getRec(tables="lontrn", where=whr, order=odr)
         if not trns:
             return
+        if self.itot == "Y":
+            if self.capb == "A":                        # Anniversary
+                fcap = [lm2[l2c.index("lm2_start")], 0]
+                if self.capf == "A":
+                    fcap[1] = projectDate(fcap[1], 1, typ="years")
+                else:
+                    fcap[1] = projectDate(fcap[1], 6, typ="months")
+            else:                                       # Financial
+                periods = self.sql.getRec(tables="ctlynd",
+                    cols=["cye_period", "cye_start", "cye_end"],
+                    where=[("cye_cono", "=", self.opts["conum"])],
+                    order="cye_period")
+                fcap = [periods[0][1], periods[0][2]]
+            if self.capf == "B":                        # Bi-Annual
+                fcap[1] = projectDate(fcap[1], -6, typ="months")
+            capdt = [copyList(fcap)]
+            while fcap[1] < self.date.work:
+                if self.capf == "A":
+                    fcap[0] = projectDate(fcap[0], 1, typ="years")
+                    fcap[1] = projectDate(fcap[1], 1, typ="years")
+                else:
+                    fcap[0] = projectDate(fcap[0], 6, typ="months")
+                    fcap[1] = projectDate(fcap[1], 6, typ="months")
+                if fcap[1] <= self.date.work:
+                    capdt.append(copyList(fcap))
+            dbal = 0
+            cbal = 0
+            trans = []
+            ddes = "Dr Int %s to %s"
+            cdes = "Cr Int %s to %s"
+            for trn in trns:
+                if trn[ltc.index("lnt_type")] == 4:
+                    iamt = trn[ltc.index("lnt_tramt")]
+                    if iamt < 0:
+                        cbal = float(ASD(cbal) + ASD(iamt))
+                    else:
+                        dbal = float(ASD(dbal) + ASD(iamt))
+                    for capd in capdt:
+                        if trn[ltc.index("lnt_trdt")] == capd[1]:
+                            if dbal:
+                                trn[ltc.index("lnt_tramt")] = dbal
+                                trn[ltc.index("lnt_desc")] = ddes % (
+                                    CCD(capd[0] / 100, "D2", 7).disp,
+                                    CCD(capd[1] / 100, "D2", 7).disp)
+                                trans.append(copyList(trn))
+                                dbal = 0
+                            if cbal:
+                                trn[ltc.index("lnt_tramt")] = cbal
+                                trn[ltc.index("lnt_desc")] = cdes % (
+                                    CCD(capd[0] / 100, "D2", 7).disp,
+                                    CCD(capd[1] / 100, "D2", 7).disp)
+                                trans.append(copyList(trn))
+                                cbal = 0
+                        else:
+                            continue
+                else:
+                    trans.append(trn)
+            trns = trans
         self.bal = 0
         self.tots = 0
         if self.sperw:

=== modified file 'lon/ln4010.py'
--- lon/ln4010.py	2016-02-27 13:18:41 +0000
+++ lon/ln4010.py	2016-04-04 13:58:25 +0000
@@ -15,7 +15,7 @@
 
 import time
 from TartanClasses import ASD, CCD, LoanInterest, NotesCreate, MyFpdf, SChoice
-from TartanClasses import Sql, SRec, TartanDialog
+from TartanClasses import SelectChoice, Sql, TartanDialog
 from tartanFunctions import getModName, doPrinter
 from tartanWork import lntrtp
 
@@ -36,6 +36,7 @@
         self.sysdtd = "%i/%02i/%02i" % (t[0], t[1], t[2])
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i)" % \
             (t[0], t[1], t[2], t[3], t[4])
+        self.history = "N"
         return True
 
     def mainProcess(self):
@@ -83,7 +84,7 @@
             (("T",1,6,0),"Od1",10,"Last Interest Raised"),
             (("T",1,7,0),"Od1",10,"Last Payment Received"),
             (("T",2,0,0),("IRB",r1s),0,"History","",
-                "Y","Y",self.doTrans2,None,None,None))
+                self.history,"Y",self.doTrans2,None,None,None))
         tnd = ((self.doEndTop,"N"), None, None)
         txt = (self.doExit, None, None)
         cnd = (None, None, None)
@@ -104,7 +105,6 @@
             return "Invalid Account Number"
         self.acno = w
         self.name = acc[0]
-        self.history = "Y"
         self.df.loadEntry("T", pag, p+1, data=self.name)
         chk = self.sql.getRec(tables="lonmf2", cols=["lm2_loan"],
             where=[("lm2_cono", "=", self.opts["conum"]),
@@ -171,9 +171,6 @@
         self.df.loadEntry("T", 1, 7, data=self.pdt)
         self.opts["mf"].updateStatus("")
 
-    def doHist(self, frt, pag, r, c, p, i, w):
-        self.history = w
-
     def doEndTop(self):
         self.df.last[0] = [0, 0]
         self.df.setWidget(self.df.topEntry[0][0], state="disabled")
@@ -186,26 +183,43 @@
 
     def doTrans2(self, frt, pag, r, c, p, i, w):
         self.history = w
+        tab = ["lontrn"]
+        col = ["lnt_trdt", "lnt_batch", "lnt_type", "lnt_refno",
+            "lnt_tramt", "lnt_desc", "lnt_curdt"]
+        whr = [
+            ("lnt_cono", "=", self.opts["conum"]),
+            ("lnt_acno", "=", self.acno),
+            ("lnt_loan", "=", self.loan)]
+        odr = "lnt_curdt, lnt_trdt, lnt_type, lnt_refno"
+        recs = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+        data = []
+        bals = 0
+        fini = False
+        curdt = self.opts["period"][1][0] / 100
+        for rec in recs:
+            if self.history == "N":
+                if rec[6] < curdt:
+                    bals = float(ASD(bals) + ASD(rec[4]))
+                    continue
+                if not fini:
+                    fini = True
+                    data.append([self.opts["period"][1][0], "", 3, "", bals,
+                        bals, "Opening Balance"])
+            bals = float(ASD(bals) + ASD(rec[4]))
+            rec.insert(5, bals)
+            data.append(rec[:7])
         tit = "Transactions for Loan: %s %s - %s" % \
             (self.acno, self.name, self.desc)
-        tab = ["lontrn"]
         col = (
-            ("lnt_trdt", "", 0, "   Date"),
-            ("lnt_batch", "", 0, "Batch"),
-            ("lnt_type", ("XX", lntrtp), 3, "Typ"),
-            ("lnt_refno", "", 0, "Reference", "Y"),
-            ("lnt_tramt", "", 0, "      Amount"),
-            ("lnt_desc", "", 0, "Remarks"))
-        whr = [
-            ("lnt_cono", "=", self.opts["conum"]),
-            ("lnt_acno", "=", self.acno),
-            ("lnt_loan", "=", self.loan)]
-        if self.history == "N":
-            whr.append(("lnt_curdt", ">=", self.opts["period"][1][0] / 100))
-        odr = "lnt_trdt, lnt_type, lnt_refno"
+            ("lnt_trdt", "   Date", 10, "D1", "N"),
+            ("lnt_batch", "Batch", 7, "NA", "N"),
+            ("lnt_type", "Typ", 3, ("XX", lntrtp), "N"),
+            ("lnt_refno", "Reference", 9, "Na", "Y"),
+            ("lnt_tramt", "      Amount", 13.2, "SD", "N"),
+            ("balan", "     Balance", 13.2, "SD", "N"),
+            ("lnt_desc", "Remarks", 30, "NA", "N"))
         state = self.df.disableButtonsTags()
-        SRec(self.opts["mf"], screen=self.df.nb.Page2, title=tit, tables=tab,
-            cols=col, where=whr, order=odr, rows=12)
+        SelectChoice(self.df.nb.Page2, tit, col, data)
         self.df.enableButtonsTags(state=state)
         self.df.focusField("T", 2, 1)
 
@@ -262,7 +276,6 @@
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, head=self.tit, repprt=["N", "V", "view"])
             else:
-                self.acctot = 0
                 self.pageHeading()
                 self.pageHeadingTrans()
                 self.printTrans()
@@ -271,7 +284,6 @@
                     pdfnam=pdfnam, head=self.tit, repprt=["N", "V", "view"])
         elif self.pr_opts == "T":
             if self.lnt:
-                self.acctot = 0
                 self.pageHeading()
                 self.pageHeadingTrans()
                 self.printTrans()
@@ -297,8 +309,10 @@
             ("lnt_cono", "=", self.opts["conum"]),
             ("lnt_acno", "=", self.acno),
             ("lnt_loan", "=", self.loan)]
-        odr = "lnt_trdt, lnt_type"
+        odr = "lnt_curdt, lnt_trdt, lnt_type"
         recs = self.sql.getRec(tables="lontrn", where=whr, order=odr)
+        bals = 0
+        fini = False
         for rec in recs:
             trd = CCD(rec[self.sql.lontrn_col.index("lnt_trdt")], "D1", 10)
             typ = CCD(rec[self.sql.lontrn_col.index("lnt_type")], "UI", 1)
@@ -306,13 +320,26 @@
             bat = CCD(rec[self.sql.lontrn_col.index("lnt_batch")], "Na", 7)
             amt = CCD(rec[self.sql.lontrn_col.index("lnt_tramt")], "SD", 13.2)
             det = CCD(rec[self.sql.lontrn_col.index("lnt_desc")], "NA", 30)
+            if self.history == "N":
+                cdt = rec[self.sql.lontrn_col.index("lnt_curdt")]
+                if cdt < (self.opts["period"][1][0] / 100):
+                    bals = float(ASD(bals) + ASD(amt.work))
+                    continue
+                if not fini:
+                    fini = True
+                    dte = CCD(self.opts["period"][1][0], "D1", 10)
+                    bal = CCD(bals, "SD", 13.2)
+                    self.fpdf.drawText("%s %s %9s %7s %s %s %-30s" % (dte.disp,
+                        "Jnl", "", "", bal.disp, bal.disp, "Opening Balance"))
+                    self.pglin += 1
+            bals = float(ASD(bals) + ASD(amt.work))
+            bal = CCD(bals, "SD", 13.2)
             if self.pglin > self.fpdf.lpp:
                 self.pageHeading()
                 self.pageHeadingTrans()
-            self.acctot = float(ASD(self.acctot) + ASD(amt.work))
-            self.fpdf.drawText("%s %s %s %s %s %s" % (trd.disp,
+            self.fpdf.drawText("%s %s %s %s %s %s %s" % (trd.disp,
                 lntrtp[(typ.work - 1)][0], ref.disp, bat.disp,
-                amt.disp, det.disp))
+                amt.disp, bal.disp, det.disp))
             self.pglin += 1
 
     def pageHeading(self):
@@ -338,16 +365,12 @@
             self.df.topf[0][2][3], self.df.t_disp[0][0][2], "",
             self.df.topf[0][3][3], self.df.t_disp[0][0][3]))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-10s %-3s %-9s %-7s %-13s %-30s" % ("   Date",
-            "Typ", "Reference", "Batch", "      Amount", "Remarks"))
+        self.fpdf.drawText("%-10s %-3s %-9s %-7s %-13s %-13s %-30s" %
+            ("   Date", "Typ", "Reference", "Batch", "      Amount",
+            "     Balance", "Remarks"))
         self.fpdf.underLine(txt=self.head)
         self.fpdf.setFont()
         self.pglin = 8
-        b = CCD(self.acctot / 100, "SD", 15.2)
-        if self.acctot != 0:
-            self.fpdf.drawText("%-42s %13s %-30s" % \
-                (" ", b.disp, "Brought Forward"))
-            self.pglin += 1
 
     def doExit(self, widget=None):
         try:

=== modified file 'mem/ml3020.py'
--- mem/ml3020.py	2016-02-27 13:18:41 +0000
+++ mem/ml3020.py	2016-04-18 10:08:31 +0000
@@ -170,11 +170,11 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()

=== modified file 'mem/ml3030.py'
--- mem/ml3030.py	2016-02-27 13:18:41 +0000
+++ mem/ml3030.py	2016-04-18 10:08:49 +0000
@@ -144,8 +144,8 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][13][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][13][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][13][4][0], state="hide")
             self.sort = "N"
             self.acc1 = 0
             self.fm = "First"
@@ -157,8 +157,8 @@
             self.zero = "Y"
             return "sk7"
         else:
-            self.df.setWidget(self.df.topEntry[0][13][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][13][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][13][4][0], state="show")
 
     def doSort(self, frt, pag, r, c, p, i, w):
         self.sort = w

=== modified file 'mem/ml3090.py'
--- mem/ml3090.py	2016-02-27 13:18:41 +0000
+++ mem/ml3090.py	2016-04-27 08:18:02 +0000
@@ -218,9 +218,9 @@
 
 Membership Secretary
 %s""" % (text, self.opts["conam"])
-            err = sendMail(self.smtp, self.fadd, mail,
+            ok = sendMail(self.smtp, self.fadd, mail,
                 "Member's Details", mess=text)
-            if err and self.ignore == "N":
+            if not ok and self.ignore == "N":
                 ok = askChoice(self.opts["mf"].body, "SMTP Server Error",
                     "Mail to %s Could Not be Sent" % mail,
                     butt=(("Continue","C"), ("Quit","Q")),

=== modified file 'men/bwlmen.py'
--- men/bwlmen.py	2016-02-27 13:18:41 +0000
+++ men/bwlmen.py	2016-05-10 05:13:54 +0000
@@ -30,7 +30,7 @@
     ["ms", "Control Routines"],
     ["bc", "Bowling Clubs"],
     ["rp", "Reporting Tools"],
-    ["rp", "Telephone Directory"]]
+    ["td", "Telephone Directory"]]
 
 # Control Routines
 msmen = [
@@ -55,9 +55,8 @@
     ["PNNY","mm_ms","ms1010",5,"Club Master Record"],
     ["PNNN","mm_ms","ms3030",3,"Email Log Report"],
     ["PYNN","mm_uy","bm1010",3,"Bulk Mail/SMS Utility"],
-    ["PNNY","mm_uy","pm1010",0,"Personal Password Manager"],
+    ["PNNY","mm_uy","pm1010",0,"Password Manager"],
     ["PNNY","mm_uy","rp1010",2,"Report Generator"],
-    ["PNNY","mm_uy","td1010",0,"Telephone Directory"],
     ["PNNN","mm_uy","tp1010",5,"Template Manager"],
     ["F","mm_hp","doAbout",0,"About"],
     ["F","mm_hp","doManual",0,"Manual"]]
@@ -98,4 +97,11 @@
     ["PYNN","bc_tb","bc6010",3,"Change Tab Numbers"],
     ["PYNN","bc_tb","bc6020",0,"Merge Duplicate Visitors"],
     ["PYNN","bc_tb","bc6030",0,"Clear History"]]
+
+# Telephone Directory
+tdmen = [
+    ["CM","mm_uy","td_mm","Telephone Directory"]]
+tdmod = [
+    ["PNNY","td_mm","tdc110",0,"Directory Groups"],
+    ["PNNY","td_mm","td1010",0,"Directory Entries"]]
 # End

=== modified file 'men/cshmen.py'
--- men/cshmen.py	2015-08-25 15:02:35 +0000
+++ men/cshmen.py	2016-05-04 08:35:11 +0000
@@ -88,8 +88,8 @@
     ["PYYY","gl_dc","gl2030",2,"Sales",1],
     ["PYYY","gl_dc","gl2030",2,"Payments",2],
     ["PYYY","gl_dc","gl2030",2,"Petty Cash",3],
-    ["PYYY","gl_dc","gl2040",2,"Manual Journals",1],
-    ["PYYY","gl_dc","gl2040",2,"Standard Journals",2],
+    ["PYYY","gl_dc","gl2040",2,"Manual Journals",4],
+    ["PYYY","gl_dc","gl2050",2,"Standard Journals",4],
     ["PYYY","gl_dc","gl2030",2,"Purchases",5],
     ["PYYY","gl_dc","gl2030",2,"Receipts",6],
     ["PYYY","gl_dc","gl2030",2,"Bank Statements",7],

=== modified file 'men/posmen.py'
--- men/posmen.py	2015-10-25 09:33:02 +0000
+++ men/posmen.py	2016-05-04 08:35:25 +0000
@@ -113,8 +113,8 @@
     ["PYYY","gl_dc","gl2030",2,"Sales",1],
     ["PYYY","gl_dc","gl2030",2,"Payments",2],
     ["PYYY","gl_dc","gl2030",2,"Petty Cash",3],
-    ["PYYY","gl_dc","gl2040",2,"Manual Journals",1],
-    ["PYYY","gl_dc","gl2040",2,"Standard Journals",2],
+    ["PYYY","gl_dc","gl2040",2,"Manual Journals",4],
+    ["PYYY","gl_dc","gl2050",2,"Standard Journals",4],
     ["PYYY","gl_dc","gl2030",2,"Purchases",5],
     ["PYYY","gl_dc","gl2030",2,"Receipts",6],
     ["PYYY","gl_dc","gl2030",2,"Bank Statements",7],

=== modified file 'men/rnemen.py'
--- men/rnemen.py	2016-03-01 14:42:33 +0000
+++ men/rnemen.py	2016-05-04 08:35:38 +0000
@@ -105,8 +105,8 @@
     ["PYYY","gl_dc","gl2030",2,"Sales",1],
     ["PYYY","gl_dc","gl2030",2,"Payments",2],
     ["PYYY","gl_dc","gl2030",2,"Petty Cash",3],
-    ["PYYY","gl_dc","gl2040",2,"Manual Journals",1],
-    ["PYYY","gl_dc","gl2040",2,"Standard Journals",2],
+    ["PYYY","gl_dc","gl2040",2,"Manual Journals",4],
+    ["PYYY","gl_dc","gl2050",2,"Standard Journals",4],
     ["PYYY","gl_dc","gl2030",2,"Purchases",5],
     ["PYYY","gl_dc","gl2030",2,"Receipts",6],
     ["PYYY","gl_dc","gl2030",2,"Bank Statements",7],
@@ -121,6 +121,7 @@
     ["PYNN","gl_rp","gl3090",1,"Imported Bank Statements"],
     ["PNNN","gl_rp","gl3100",1,"Consolidated Trial Balance"],
     ["PNNN","gl_rp","gl3110",1,"Multi-Company Reports"],
+    ["PNNN","gl_rp","gl3120",1,"Quick Trading Results"],
     ["PYNN","gl_tb","gl6010",5,"Change Account Numbers"],
     ["PYNN","gl_tb","gl6020",5,"Copy Masterfile Records"],
     ["PYYN","gl_tb","gl6030",1,"Integrated Controls Report"],
@@ -201,11 +202,12 @@
     ["CM","mm_ib","ib_tb","Toolbox"]]
 ibmod = [
     ["PYNY","ib_fm","ibc110",2,"Control Record"],
-    ["PYYY","ib_dc","ib2010",2,"Sales Invoices"],
+    ["PYYY","ib_dc","ib2010",2,"Sales Documents"],
     ["PYNY","ib_dc","ib2020",2,"Creditor's Invoices"],
-    ["PYNN","ib_rp","ib3010",1,"Reprint Sales Invoices"],
+    ["PYNN","ib_rp","ib3010",1,"Reprint Documents"],
     ["PYNN","ib_rp","ib3020",1,"Purchase Journals"],
-    ["PYNN","ib_rp","ib3030",1,"Sales Report"]]
+    ["PYNN","ib_rp","ib3030",1,"Sales Report"],
+    ["PYNN","ib_rp","ib3040",1,"Statements"]]
 
 # Loan's Ledger
 lnmen = [
@@ -225,7 +227,7 @@
     ["PYNN","ln_rp","ln3010",1,"Batch Error Listing"],
     ["PYYN","ln_rp","ln3020",1,"Transaction Audit Trail"],
     ["PYNN","ln_rp","ln3030",1,"Balances Listing"],
-    ["PYNN","ln_rp","ln3040",1,"Statements"],
+    ["PYYN","ln_rp","ln3040",1,"Statements"],
     ["PYNN","ln_rp","ln3050",1,"Notes Listing"],
     ["PYNN","ln_tb","ln6010",5,"Change Account Numbers"],
     ["PYLY","mm_ln","ln4010",0,"Interrogation"]]
@@ -300,29 +302,6 @@
     ["PYNN","mm_si","si3060",1,"Sales By Salesman"],
     ["PYNN","mm_si","si3080",1,"Reprint Documents"]]
 
-# Loan's Ledger
-lnmen = [
-    ["CM","mm_ln","ln_fm","File Maintenance"],
-    ["CM","mm_ln","ln_dc","Data Capture"],
-    ["CM","mm_ln","ln_rp","Reporting"],
-    ["CM","mm_ln","ln_tb","Toolbox"]]
-lnmod = [
-    ["PYNY","ln_fm","lnc110",5,"Control Record"],
-    ["PYNY","ln_fm","ln1010",3,"Loans Masterfile"],
-    ["PYYY","ln_dc","ln2010",2,"Payments",1],
-    ["PYYY","ln_dc","ln2010",2,"Receipts",2],
-    ["PYYY","ln_dc","ln2010",2,"Journals",3],
-    ["PYYY","ln_dc","ln2010",2,"Interest Adjustments",4],
-    ["PYYY","ln_dc","ln2020",2,"Raise Interest",0],
-    ["PYYY","ln_dc","ln2030",2,"Rate Change",0],
-    ["PYNN","ln_rp","ln3010",1,"Batch Error Listing"],
-    ["PYYN","ln_rp","ln3020",1,"Transaction Audit Trail"],
-    ["PYNN","ln_rp","ln3030",1,"Balances Listing"],
-    ["PYNN","ln_rp","ln3040",1,"Statements"],
-    ["PYNN","ln_rp","ln3050",1,"Notes Listing"],
-    ["PYNN","ln_tb","ln6010",5,"Change Account Numbers"],
-    ["PYLY","mm_ln","ln4010",0,"Interrogation"]]
-
 # Telephone Directory
 tdmen = [
     ["CM","mm_uy","td_mm","Telephone Directory"]]

=== modified file 'men/stdmen.py'
--- men/stdmen.py	2016-02-27 13:18:41 +0000
+++ men/stdmen.py	2016-05-10 05:11:47 +0000
@@ -116,8 +116,8 @@
     ["PYYY","gl_dc","gl2030",2,"Sales",1],
     ["PYYY","gl_dc","gl2030",2,"Payments",2],
     ["PYYY","gl_dc","gl2030",2,"Petty Cash",3],
-    ["PYYY","gl_dc","gl2040",2,"Manual Journals",1],
-    ["PYYY","gl_dc","gl2040",2,"Standard Journals",2],
+    ["PYYY","gl_dc","gl2040",2,"Manual Journals",4],
+    ["PYYY","gl_dc","gl2050",2,"Standard Journals",4],
     ["PYYY","gl_dc","gl2030",2,"Purchases",5],
     ["PYYY","gl_dc","gl2030",2,"Receipts",6],
     ["PYYY","gl_dc","gl2030",2,"Bank Statements",7],
@@ -336,7 +336,7 @@
     ["PYNN","ln_rp","ln3010",1,"Batch Error Listing"],
     ["PYYN","ln_rp","ln3020",1,"Transaction Audit Trail"],
     ["PYNN","ln_rp","ln3030",1,"Balances Listing"],
-    ["PYNN","ln_rp","ln3040",1,"Statements"],
+    ["PYYN","ln_rp","ln3040",1,"Statements"],
     ["PYNN","ln_rp","ln3050",1,"Notes Listing"],
     ["PYNN","ln_tb","ln6010",5,"Change Account Numbers"],
     ["PYLY","mm_ln","ln4010",0,"Interrogation"]]

=== modified file 'mst/ms0000.py'
--- mst/ms0000.py	2016-03-01 14:42:33 +0000
+++ mst/ms0000.py	2016-05-21 12:42:20 +0000
@@ -12,9 +12,10 @@
 """
 
 import getopt, os, sys
+from tartanFunctions import getPrgPath
 
 # Add the program path to the PATH variable if possible
-ppath = sys.path[0]
+ppath = getPrgPath()
 if ppath:
     if os.path.basename(ppath) == "library.zip":
         ppath = os.path.normpath(os.path.dirname(ppath))
@@ -37,7 +38,7 @@
     temp = tuple(os.environ["TARVER"].split("."))
     VERSION = (int(temp[0]), int(temp[1]), int(temp[2]))
 else:
-    VERSION = (5, 2, 1)
+    VERSION = (5, 2, 2)
 if __name__ == "__main__":
     # Run Tartan
     try:

=== modified file 'mst/ms3010.py'
--- mst/ms3010.py	2016-02-27 13:18:41 +0000
+++ mst/ms3010.py	2016-04-18 10:09:12 +0000
@@ -193,11 +193,11 @@
     def doTotsOnly(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
         if self.sper or not\
            self.cat in ("A", "B") or \
            self.code or \

=== modified file 'mst/msc000.py'
--- mst/msc000.py	2016-03-01 14:42:33 +0000
+++ mst/msc000.py	2016-05-20 06:47:59 +0000
@@ -14,8 +14,9 @@
 import cStringIO, fpdf, getpass, gc, glob, os, sys, time, urllib2
 from TartanClasses import AboutTartan, CCD, Dbase, DBCreate, FileDialog
 from TartanClasses import GetCtl, GUI, MainFrame, MkWindow, PwdConfirm
-from TartanClasses import ScrollText, SelectChoice, Sql, TarBckRes
-from TartanClasses import TartanConfig, TartanDialog, TartanMenu, TartanUser
+from TartanClasses import ScrollText, SelectChoice, SplashScreen, Sql
+from TartanClasses import TarBckRes, TartanConfig, TartanDialog, TartanMenu
+from TartanClasses import TartanUser
 from tartanFunctions import askQuestion, b64Convert, dateDiff, ftpDownload
 from tartanFunctions import getPeriods, getPrgPath, copyList, loadRcFile
 from tartanFunctions import parsePrg, projectDate, runModule, sendMail
@@ -129,9 +130,12 @@
                 else:
                     name = "stdout_%s.txt" % pid
                 self.stdout = os.path.join(getPrgPath(), name)
-                if not os.path.exists(self.stdout):
-                    sys.stdout = open(self.stdout, "w")
-                    break
+                try:
+                    if not os.path.exists(self.stdout):
+                        sys.stdout = open(self.stdout, "w")
+                        break
+                except:
+                    pass
         if self.script:
             __import__(self.script)
             self.doExit(dbm=False)
@@ -171,59 +175,63 @@
                 print "xdisplay False but program not in %s" % str(nodisp)
                 self.doExit(dbm=False)
             elif not self.user:
-                print "xdisplay False but no User Name"
+                print "xdisplay False but No User Name"
                 self.doExit(dbm=False)
         if not self.version and self.xdisplay and not GUI:
             print "Tkinter/ttk not Available or Installed"
             self.doExit(dbm=False)
         if self.version:
-            print "%-12sVersion: %s" % ("Tartan", self.current[1])
-            print "%-12sVersion: %s" % ("Python", sys.version.split()[0])
+            print "%-16sVersion: %s" % ("Tartan", self.current[1])
+            print "%-16sVersion: %s" % ("Python", sys.version.split()[0])
             if self.xdisplay:
                 from TartanClasses import tk
                 from PIL import VERSION
-                print "%-12sVersion: %s" % ("Tcl/Tk", tk.Tcl().eval("info patchlevel"))
-                print "%-12sVersion: %s" % ("PIL", VERSION)
-
+                print "%-16sVersion: %s" % ("Tcl/Tk",
+                        tk.Tcl().eval("info patchlevel"))
+                print "%-16sVersion: %s" % ("PIL", VERSION)
             try:
                 import fdb
-                print "%-12sVersion: %s" % ("FDB", fdb.__version__)
+                print "%-16sVersion: %s" % ("FDB", fdb.__version__)
             except:
                 pass
             try:
                 import MySQLdb
-                print "%-12sVersion: %s" % ("MySQLdb", MySQLdb.__version__)
+                print "%-16sVersion: %s" % ("MySQLdb", MySQLdb.__version__)
             except:
-                pass
+                try:
+                    import pymysql
+                    print "%-16sVersion: %s" % ("Pymysql", pymysql.__version__)
+                except:
+                    pass
             try:
                 import psycopg2
-                print "%-12sVersion: %s" % ("Psycopg2",
+                print "%-16sVersion: %s" % ("Psycopg2",
                         psycopg2.__version__.split()[0])
             except:
                 pass
             try:
                 import pychart.version
-                print "%-12sVersion: %s" % ("Pychart", pychart.version.version)
+                print "%-16sVersion: %s" % ("Pychart", pychart.version.version)
             except:
                 pass
             try:
                 import sqlite3
-                print "%-12sVersion: %s" % ("Pysqlite", sqlite3.version)
-                print "%-12sVersion: %s" % ("Sqlite3", sqlite3.sqlite_version)
+                print "%-16sVersion: %s" % ("Pysqlite", sqlite3.version)
+                print "%-16sVersion: %s" % ("Sqlite3", sqlite3.sqlite_version)
             except:
                 pass
             try:
-                print "%-12sVersion: %s" % ("Fpdf", fpdf.__version__)
+                print "%-16sVersion: %s" % ("Fpdf", fpdf.__version__)
             except:
                 pass
             try:
                 import xlrd
-                print "%-12sVersion: %s" % ("Xlrd", xlrd.info.__VERSION__)
+                print "%-16sVersion: %s" % ("Xlrd", xlrd.info.__VERSION__)
             except:
                 pass
             try:
                 import xlwt
-                print "%-12sVersion: %s" % ("Xlwt", xlwt.__VERSION__)
+                print "%-16sVersion: %s" % ("Xlwt", xlwt.__VERSION__)
             except:
                 pass
             self.doExit(dbm=False)
@@ -1091,6 +1099,7 @@
             self.db.closeDbase()
         if not self.user:
             self.doExit()
+        self.tarmen.usr = self.user["name"]
         self.tarmen.lvl = self.user["lvl"]
         self.tarmen.men = self.usrmen
         self.tarmen.mod = self.usrmod
@@ -1390,6 +1399,8 @@
             return "nd"
 
     def endReg(self):
+        self.rg.closeProcess()
+        sp = SplashScreen(self.mf.body, "Please Wait .... Initialising System")
         sql = Sql(self.db, "ctlmst", prog="msc000")
         coy = sql.getRec(tables="ctlmst", cols=["ctm_name", "ctm_email"],
             where=[("ctm_cono=1",)], limit=1)
@@ -1401,12 +1412,13 @@
             eml = coy[1]
         mes = "%s - %s - %s" % (coy[0], nam, eml)
         svr = ["smtp.gmail.com", 587, 1, 1, "tartansys@gmail.com", "tarpwd09"]
-        err = sendMail(svr, eml, "register@tartan.co.za", mes)
-        if not err or self.newreg == "X":
+        ok = sendMail(svr, eml, "register@tartan.co.za", mes)
+        if ok or self.newreg == "X":
             sql = Sql(self.db, "ctlsys", prog="msc000")
             sql.updRec("ctlsys", cols=["sys_regdet"], data=[self.newreg])
             self.db.commitDbase()
-        self.xitReg()
+        sp.closeSplash()
+        self.mf.closeLoop()
 
     def xitReg(self):
         self.rg.closeProcess()

=== modified file 'mst/msc110.py'
--- mst/msc110.py	2016-02-27 13:18:41 +0000
+++ mst/msc110.py	2016-05-03 10:35:47 +0000
@@ -15,6 +15,7 @@
 
 import time
 from TartanClasses import Sql, TartanDialog
+from tartanFunctions import sendMail, showError
 
 class msc110:
     def __init__(self, **opts):
@@ -160,6 +161,16 @@
             return "General Ledger Accounts Already Exist"
 
     def doEnd(self):
+        svr = self.df.t_work[0][0][5]
+        if svr:
+            prt = self.df.t_work[0][0][8]
+            sec = self.df.t_work[0][0][6]
+            chk = sendMail([svr, prt, sec, "", "", ""], "", "", "", check=True)
+            if not chk:
+                showError(self.opts["mf"].body, "Server Error",
+                    "The SMTP Server Settings are Invalid.")
+                self.df.focusField("T", 0, 6)
+                return
         tme = time.localtime()
         if self.new:
             self.sql.insRec("ctlsys", data=self.df.t_work[0][0])

=== modified file 'mst/msy010.py'
--- mst/msy010.py	2016-02-27 13:18:41 +0000
+++ mst/msy010.py	2016-04-26 13:00:56 +0000
@@ -124,8 +124,14 @@
                     return "Depreciation Has Not Been Raised for Assets"
             if "LN" in self.mod:
                 c = self.gc.getCtl("lonctl", self.opts["conum"])
-                if c and c["cln_glint"] == "Y" and c["cln_last"] < self.end:
-                    return "Interest Has Not Been Raised for Loans"
+                lst = c["cln_last"]
+                if c:
+                    glt = c["cln_glint"]
+                    drt = c["cln_drte"]
+                    crt = c["cln_crte"]
+                    lst = c["cln_last"]
+                    if glt == "Y" and (drt or crt) and lst < self.end:
+                        return "Interest Has Not Been Raised for Loans"
             if "ML" in self.mod:
                 c = self.gc.getCtl("memctl", self.opts["conum"])
                 if c and c["mcm_glint"] == "Y" and c["mcm_lme"] < self.end:
@@ -140,8 +146,12 @@
                     return "A Month-End Has Not Been Completed for Rentals"
             if "WG" in self.mod:
                 c = self.gc.getCtl("wagctl", self.opts["conum"])
-                if c and c["ctw_glint"] == "Y" and c["ctw_i_date"] < self.end:
-                    return "Interest Has Not Been Raised for Staff Loans"
+                if c:
+                    glt = c["ctw_glint"]
+                    rte = c["ctw_i_rate"]
+                    lst = c["ctw_i_date"]
+                    if glt == "Y" and rte and lst < self.end:
+                        return "Interest Has Not Been Raised for Staff Loans"
         self.final = w
 
     def doEnd(self):

=== modified file 'rtl/rt3020.py'
--- rtl/rt3020.py	2016-02-27 13:18:41 +0000
+++ rtl/rt3020.py	2016-04-18 10:10:43 +0000
@@ -152,13 +152,11 @@
     def doTots(self, frt, pag, r, c, p, i, w):
         self.totsonly = w
         if self.totsonly == "Y":
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="hide")
-            if len(self.df.topEntry[0][8]) == 4:
-                self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="hide")
         else:
-            self.df.setWidget(self.df.topEntry[0][8][2][0], state="show")
-            if len(self.df.topEntry[0][8]) == 4:
-                self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][8][4][0], state="show")
 
     def doEnd(self):
         self.df.closeProcess()

=== modified file 'scp/sc2020.py'
--- scp/sc2020.py	2016-02-27 13:18:41 +0000
+++ scp/sc2020.py	2016-04-28 12:45:55 +0000
@@ -321,12 +321,12 @@
         if self.fmat == "K" or self.ctyp == "P":
             head = (self.rnds * 26) + 25
             self.fpdf = MyFpdf(name=__name__, head=head, font="Helvetica",
-                prog=__name__)
+                foot=True)
             self.fpdf.def_orientation = "P"
             self.fpdf.font[2] = 5
         else:
             self.fpdf = MyFpdf(name=__name__, head=65, font="Helvetica",
-                prog=__name__)
+                foot=True)
         recs = self.sql.getRec(tables="scpgme", cols=["scg_snum", "scg_subs"],
             where=self.gwhr, group="scg_snum, scg_subs",
             order="scg_snum, scg_subs")
@@ -1694,7 +1694,7 @@
         x = ox
         y = oy + 4.5
         w = [5, 5, 5, 10, 10, 5]
-        for z in xrange(1, self.rnds+2):
+        for z in xrange(1, self.rnds + 2):
             row = [x, y, []]
             if z == (self.rnds + 1):
                 row[2].append((w[0]+w[1]+w[2], h, 0.8, "Totals", True))
@@ -1729,7 +1729,7 @@
                 self.ccod), ("scg_snum", "=", sec), ("scg_subs", "=", sub),
                 ("scg_scod", "=", skp[3])], limit=1)
             nskp[skp[0]][3][skp[2]] = [skp[3], opp[0]] + skp[4:8]
-        po = ["A", "B", "C", "D"]
+        po = ["A", "B", "C", "D", "E", "F", "G", "H"]
         ox = cw * ox
         oy = ld * oy
         sk = 0

=== modified file 'scp/sc2030.py'
--- scp/sc2030.py	2016-02-27 13:18:41 +0000
+++ scp/sc2030.py	2016-04-28 15:35:03 +0000
@@ -642,15 +642,28 @@
                 else:
                     win2 = 0
                 # Create next round record
-                one[self.sql.scpgme_col.index("scg_rnum")] = nrnd
-                one[self.sql.scpgme_col.index("scg_scod")] = win1
-                one[self.sql.scpgme_col.index("scg_ocod")] = win2
-                one[self.sql.scpgme_col.index("scg_sfor")] = 0
-                one[self.sql.scpgme_col.index("scg_sagt")] = 0
-                one[self.sql.scpgme_col.index("scg_pnts")] = 0
-                one[self.sql.scpgme_col.index("scg_pair")] = pair
-                if not self.sql.getRec(tables="scpgme", data=one):
+                sgc = self.sql.scpgme_col
+                whr = [
+                    ("scg_cono", "=", one[sgc.index("scg_cono")]),
+                    ("scg_ccod", "=", one[sgc.index("scg_ccod")]),
+                    ("scg_ctyp", "=", one[sgc.index("scg_ctyp")]),
+                    ("scg_snum", "=", one[sgc.index("scg_snum")]),
+                    ("scg_subs", "=", one[sgc.index("scg_subs")]),
+                    ("scg_rnum", "=", nrnd),
+                    ("scg_ktyp", "=", one[sgc.index("scg_ktyp")]),
+                    ("scg_scod", "=", win1)]
+                one[sgc.index("scg_rnum")] = nrnd
+                one[sgc.index("scg_scod")] = win1
+                one[sgc.index("scg_ocod")] = win2
+                one[sgc.index("scg_sfor")] = 0
+                one[sgc.index("scg_sagt")] = 0
+                one[sgc.index("scg_pnts")] = 0
+                one[sgc.index("scg_pair")] = pair
+                if not self.sql.getRec(tables="scpgme", where=whr, limit=1):
                     self.sql.insRec("scpgme", data=one)
+                else:
+                    self.sql.updRec("scpgme", cols=["scg_ocod", "scg_pair"],
+                        data=[win2, pair], where=whr)
                 if self.rnum == self.lrnd and \
                         self.ctyp == "M" and self.nsec > 2:
                     # Create playoff records with winners codes

=== modified file 'scp/sc3010.py'
--- scp/sc3010.py	2016-02-27 13:18:41 +0000
+++ scp/sc3010.py	2016-05-15 05:53:46 +0000
@@ -73,9 +73,8 @@
         recs = self.sql.getRec(tables=["scpent", "scpmem", "scpclb"], cols=col,
             where=whr, order="scm_surname")
         if recs:
-            self.fpdf = MyFpdf(prog=__name__)
-            self.fpdf.header = self.header
-            self.fpdf.alias_nb_pages()
+            self.fpdf = MyFpdf(auto=True, foot=True)
+            self.fpdf.header = self.doHead
             self.fpdf.add_page()
             self.fpdf.set_font("Courier","",12)
             cwth = self.fpdf.get_string_width("X")
@@ -95,7 +94,7 @@
                 repeml=self.df.repeml)
         self.opts["mf"].closeLoop()
 
-    def header(self):
+    def doHead(self):
         if os.path.isfile(self.image):
             self.fpdf.image(self.image, 10, 10, 15, 11)
         self.fpdf.set_font("Arial","B",15)

=== modified file 'sls/si2010.py'
--- sls/si2010.py	2016-02-27 13:18:41 +0000
+++ sls/si2010.py	2016-05-02 10:52:27 +0000
@@ -116,7 +116,7 @@
             self.dnote = "N"
         self.pr = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=fld, tend=((self.doPrtClose,"y"),), txit=(self.doPrtExit,),
-            view=("N","P"), mail=("N","Y"))
+            view=("N","P"), mail=("N","Y","Y"))
         self.opts["mf"].startLoop()
 
     def doTplNam(self, frt, pag, r, c, p, i, w):
@@ -204,10 +204,10 @@
             "autoc": False}
         r1s = (
             ("Invoice","I"),
-            ("Credit Note","C"),
-            ("Sales Order","O"),
-            ("Works Order","W"),
-            ("Quotation","Q"))
+            ("Credit-Note","C"),
+            ("Sales-Order","O"),
+            ("Works-Order","W"),
+            ("Quote","Q"))
         r2s = (("Account","A"),("Cash","C"))
         fld = [
             (("T",0,0,0),("IRB",r1s),0,"Type","Transaction Type",
@@ -362,7 +362,7 @@
                 return "ff1"
 
     def doAction(self):
-        tit = ("Select Method",)
+        tit = ("Select Action",)
         doc = {
             "stype": "R",
             "tables": ("slsiv1", "drsmst"),
@@ -451,8 +451,8 @@
         self.doActClose()
 
     def doActExit(self):
-        self.doActClose()
         self.actxit = True
+        self.doActClose()
 
     def doActClose(self):
         self.at.closeProcess()
@@ -1318,7 +1318,7 @@
             (("T",0,idx,0),"IUI",9,"From Number","From Document Number",
                 "","N",self.doIv1,iv1,None,("notblank",)),
             (("T",0,idx+1,0),"IUI",9,"To   Number","To Document Number",
-                "","N",None,iv1,None,("notblank",))])
+                "","N",self.doIv1,iv1,None,("notblank",))])
         state = self.df.disableButtonsTags()
         self.rp = TartanDialog(self.opts["mf"], title=tit, tops=True,
             eflds=fld, tend=((self.doReprntEnd, "n"),),
@@ -1332,21 +1332,24 @@
             self.copy = "y"
         else:
             self.copy = "n"
-            if self.delnos == "Y":
-                idx = 5
-            else:
-                idx = 4
-            self.rp.topf[pag][idx][5] = "P"
-            self.rp.topf[pag][idx+2][5] = "Y"
-
-    def doIv1(self, frt, pag, r, c, p, i, w):
-        self.rp.loadEntry(frt, pag, p+1, data=w)
 
     def doReprntType(self, frt, pag, r, c, p, i, w):
-        if self.delnos == "Y" and not w == "I":
+        self.dtyp = w
+        if self.delnos == "Y" and not self.dtyp == "I":
             self.rp.loadEntry(frt, pag, p+1, data="N")
             return "sk1"
 
+    def doIv1(self, frt, pag, r, c, p, i, w):
+        chk = self.sql.getRec(tables="slsiv1", where=[("si1_cono",
+            "=", self.opts["conum"]), ("si1_rtn", "=", self.dtyp),
+            ("si1_docno", "=", w)], limit=1)
+        if not chk:
+            return "Invalid Document Number"
+        if chk[self.sql.slsiv1_col.index("si1_invno")] == "cancel":
+            return "This Document Was Cancelled"
+        if p == self.rp.topq[0] - 8:
+            self.rp.loadEntry(frt, pag, p+1, data=w)
+
     def doReprntEnd(self):
         self.rp.closeProcess()
         self.df.setWidget(self.df.mstFrame, state="hide")
@@ -1384,6 +1387,7 @@
             self.opts["conam"]), period=None, user=self.opts["capnm"])
 
     def doAccept(self, widget=None):
+        self.df.setWidget(self.df.B11, "disabled")
         if self.df.col == 1:
             self.doCancel()
             return

=== modified file 'sls/si2020.py'
--- sls/si2020.py	2016-02-27 13:18:41 +0000
+++ sls/si2020.py	2016-03-22 10:02:56 +0000
@@ -13,7 +13,7 @@
     Copyright (C) 2004-2016 Paul Malherbe.
 """
 
-import copy, socket, sys, time
+import copy, socket, sys, time, functools
 from textwrap import wrap
 from TartanClasses import tk, tkfont, ttk
 from TartanClasses import AgeAll, ASD, Balances, CCD, GetCtl, MyButton, MyFrame
@@ -133,6 +133,7 @@
         self.totqty = 0
         self.totval = CCD(0, "SD", 12.2)
         self.totvat = CCD(0, "SD", 12.2)
+        self.butcmd = {}
         self.row = 0
         return True
 
@@ -614,14 +615,23 @@
         self.rs.pack(anchor="nw", side="left")
 
     def doButton(self, parent, text, cmd, img, style, var=None):
+        if type(cmd) == tuple:
+            cmd = functools.partial(self.doCommand, cmd)
         f = MyFrame(parent, padding=10, relief="ridge", style="RoundedFrame")
-        b = MyButton(f, text=text, cmd=cmd, img=img, padding=10,
+        b = MyButton(f, text=text, img=img, command=cmd, padding=10,
             style="%s.TButton" % style, takefocus=False)
         if var:
             b.configure(textvariable=var)
         b.pack(fill="both", expand="yes")
+        self.butcmd[b] = cmd
         return f
 
+    def doCommand(self, cmd):
+        if type(cmd) in (list, tuple):
+            cmd[0](cmd[1])
+        else:
+            cmd()
+
     def doPtype(self, ptype):
         self.ptype = ptype
         if self.ttype == "C":

=== modified file 'sls/si3010.py'
--- sls/si3010.py	2016-02-27 13:18:41 +0000
+++ sls/si3010.py	2016-04-18 10:12:26 +0000
@@ -82,12 +82,12 @@
         if self.rtype == "L":
             self.ord1 = 0
             self.ord2 = 999999999
-            self.df.setWidget(self.df.topEntry[0][5][2][0], state="show")
             self.df.setWidget(self.df.topEntry[0][5][3][0], state="show")
+            self.df.setWidget(self.df.topEntry[0][5][4][0], state="show")
         else:
             self.df.loadEntry(frt, pag, p+1, data="")
-            self.df.setWidget(self.df.topEntry[0][5][2][0], state="hide")
             self.df.setWidget(self.df.topEntry[0][5][3][0], state="hide")
+            self.df.setWidget(self.df.topEntry[0][5][4][0], state="hide")
             return "sk1"
 
     def doContent(self, frt, pag, r, c, p, i, w):

=== modified file 'sls/si3080.py'
--- sls/si3080.py	2016-02-27 13:18:41 +0000
+++ sls/si3080.py	2016-05-02 10:44:57 +0000
@@ -102,9 +102,6 @@
             self.copy = "y"
         else:
             self.copy = "n"
-            self.df.topf[pag][6][5] = "V"
-            if len(self.df.topf[pag]) == 8:
-                self.df.topf[pag][8][5] = "N"
 
     def doType(self, frt, pag, r, c, p, i, w):
         self.typ = w

=== modified file 'std/TartanClasses.py'
--- std/TartanClasses.py	2016-02-27 13:18:41 +0000
+++ std/TartanClasses.py	2016-05-21 09:48:39 +0000
@@ -17,14 +17,20 @@
 #   from profilehooks import profile
 # Then insert the following line before the function to profile
 #   @profile(entries=40, immediate=True)
-import calendar, csv, functools, getpass, glob, gzip, os, re, shutil
-import sys, tarfile, textwrap, threading, time, urllib2, webbrowser
+import calendar, csv, functools, glob, gzip, os, re, shutil, sys
+import tarfile, textwrap, threading, time, urllib2, webbrowser
 from pkgutil import iter_modules
 #========================================================
 # TARTAN Standard Functions and Variables e.g. showError
 #========================================================
-from tartanFunctions import *
-from tartanWork import *
+from tartanFunctions import askQuestion, b64Convert, chkAggregate, copyList
+from tartanFunctions import dateDiff, doPrinter, doWriteExport, getFileName
+from tartanFunctions import getFontSize, getModName, getPeriods, getPrgPath
+from tartanFunctions import getSingleRecords, getTrn, getUnderline
+from tartanFunctions import importTkinter, loadRcFile, makeArray, mthendDate
+from tartanFunctions import projectDate, removeFunctions, sendMail, showError
+from tartanFunctions import showException, showPrinters, showWarning
+import tartanWork
 #========================================================
 # PyFPDF
 #========================================================
@@ -132,6 +138,7 @@
         "interrogate": os.path.join(imgdir, "question.png"),
         "logout": os.path.join(imgdir, "quit.png"),
         "maintain": os.path.join(imgdir, "edit.png"),
+        "manual": os.path.join(imgdir, "edit.png"),
         "modify": os.path.join(imgdir, "convert.png"),
         "movements": os.path.join(imgdir, "question.png"),
         "none": os.path.join(imgdir, "no.png"),
@@ -327,6 +334,44 @@
             kw["style"] = "L.TButton" if direction == "left" else "R.TButton"
             ttk.Button.__init__(self, master, **kw)
 
+    class MyButtonBox(ttk.Frame):
+        def __init__(self, parent, row=None, padx=0, pady=0, **kwargs):
+            ttk.Frame.__init__(self, parent, **kwargs)
+            parent.update_idletasks()
+            if getManager(parent) in ("grid", "place"):
+                if row is None:
+                    row = parent.grid_size()[1]
+                self.grid(row=row, padx=padx, pady=pady, sticky="ew")
+            else:
+                self.pack(fill="x", side="bottom")
+            self.rows = {}
+
+        def addButton(self, text, cmd, row=0, spn=1):
+            if not row in self.rows:
+                self.rows[row] = 0
+            text, pos = getUnderline(widget=self, text=text)
+            but = MyButton(self, cmd=cmd, text=text, underline=pos)
+            but.grid(column=self.rows[row], row=row, columnspan=spn,
+                sticky="ew")
+            self.columnconfigure(self.rows[row], weight=1)
+            self.rows[row] += spn
+            return but
+
+        def focusNext(self, event):
+            key = event.keysym
+            idx = self.buttons.index(event.widget["text"])
+            if key == "Left":
+                if not idx:
+                    idx = len(self.buttons) - 1
+                else:
+                    idx -= 1
+            elif idx == (len(self.buttons) - 1):
+                idx = 0
+            else:
+                idx += 1
+            widgets = self.winfo_children()
+            widgets[idx].focus_set()
+
     class MyButton(ttk.Button):
         def __init__(self, parent, cmd=None, img=True, fnt=None, **kwargs):
             kwargs["width"] = -1
@@ -782,6 +827,19 @@
                 self.frame.place(anchor="center", relx=0.5, rely=0.5)
             # Save and clear toplevel bindings
             self.topbinds = unbindAllWidgets(self.frame)
+            # Save and disable buttons
+            frm = [self.frame.winfo_toplevel()]
+            self.butsve = []
+            for x in range(10):
+                try:
+                    for ch in frm[x].winfo_children():
+                        if ch.winfo_class() == "TFrame":
+                            frm.append(ch)
+                        elif ch.winfo_class() == "TButton":
+                            self.butsve.append((ch, str(ch.cget("state"))))
+                            ch.configure(state="disabled")
+                except:
+                    break
             tit = MyLabel(self.frame, text=title, anchor="c", relief="raised")
             tit.pack(fill="x", expand="yes", ipadx=2, ipady=5)
             if not self.geom:
@@ -806,7 +864,7 @@
             except:
                 pass
             label.pack(fill="both", expand="yes")
-            bbox = ButtonBox(self.frame, row=1)
+            bbox = MyButtonBox(self.frame, row=1)
             self.butts = []
             if dtype in ("error", "info", "warning"):
                 butt = (("Close", self.doChoice),)
@@ -827,10 +885,12 @@
                 b.bind("<Left>", ecmd)
                 b.bind("<Right>", ecmd)
                 self.butts.append(b)
-                if dflt and but[0].lower() == dflt.lower():
-                    b.focus_set()
-                elif not dflt and not num:
-                    b.focus_set()
+                if dflt:
+                    b.bind("<Enter>", self.doEnter)
+                    b.bind("<Leave>", self.doLeave)
+                    if but[0].lower() == dflt.lower():
+                        b.focus_set()
+                        self.dflt = b
             self.frame.update_idletasks()
             if self.geom:
                 x = int(self.frame.winfo_screenwidth()) / 2 - 200
@@ -843,6 +903,12 @@
             if plc:
                 self.frame.mainloop()
 
+        def doEnter(self, event):
+            event.widget.focus_set()
+
+        def doLeave(self, event):
+            self.dflt.focus_set()
+
         def doChoice(self, answer=None):
             self.answer = answer
             # Clear frame bindings
@@ -851,6 +917,9 @@
             # Reinstate toplevel bindings
             for bind in self.topbinds:
                 self.frame.winfo_toplevel().bind(bind[0], bind[1])
+            # Reinstate buttons
+            for butt in self.butsve:
+                butt[0].configure(state=butt[1])
             self.frame.destroy()
             self.frame.update()
             self.frame.quit()
@@ -892,8 +961,9 @@
                     break
             if self.focus_get() == childs[x]:
                 return
-            self.tk_focusPrev().focus_set()
-            return "break"
+            if self.tk_focusPrev().winfo_class() == "TRadiobutton":
+                self.tk_focusPrev().focus_set()
+                return "break"
 
         def goRight(self, event):
             childs = self.parent.winfo_children()
@@ -902,8 +972,9 @@
                     break
             if self.focus_get() == childs[x]:
                 return
-            self.tk_focusNext().focus_set()
-            return "break"
+            if self.tk_focusNext().winfo_class() == "TRadiobutton":
+                self.tk_focusNext().focus_set()
+                return "break"
 
     class MyText(tk.Text):
         def __init__(self, parent, **kwargs):
@@ -1244,16 +1315,16 @@
             for key in ("Left", "Right", "Up", "Down", "Prior", "Next"):
                 self.window.bind("<%s>" % key, self._scroll)
             # Close and Other buttons
-            close = True
-            box = ButtonBox(self.window)
+            quit = True
+            bbox = MyButtonBox(self.window)
             if "butt" in self.opts:
                 for but in self.opts["butt"]:
-                    box.addButton(but[0], but[1])
-                    if but[0] == "Exit":
-                        close = False
+                    bbox.addButton(but[0], but[1])
+                    if but[0] in ("Exit", "Quit"):
+                        quit = False
                         self.window.bind("<Escape>", but[1])
-            if close:
-                box.addButton("Close", self._quit)
+            if quit:
+                bbox.addButton("Quit", self._quit)
                 self.window.bind("<Escape>", self._quit)
             # Pack frame
             self.cframe.pack(fill="both", expand="yes")
@@ -1262,7 +1333,7 @@
             height += self.cv3.bbox("all")[3]
             height += self.cv4.bbox("all")[3]
             height += hsb.winfo_reqheight()
-            height += box.bbox.winfo_reqheight()
+            height += bbox.winfo_reqheight()
             if wh > height:
                 self.window.configure(height=height)
                 self.window.maxsize(width=ww, height=height)
@@ -1276,8 +1347,7 @@
             self.cv2.configure(scrollregion=self.cv2.bbox("all"))
             b = self.cv3.bbox("all")
             w = self.cv4.bbox("all")[2]
-            bbox = (b[0], b[1], w, b[3])
-            self.cv3.configure(scrollregion=bbox)
+            self.cv3.configure(scrollregion=(b[0], b[1], w, b[3]))
             self.cv4.configure(scrollregion=self.cv4.bbox("all"))
 
         def _scroll(self, event):
@@ -1304,17 +1374,16 @@
 
         def _get_cell(self, *args):
             # execute command with following arguments:
-            #   ((row, col), text, (rframed, (x, y)), window)
+            #   (row, col, (rframed, (x, y)), window)
             plc = (args[3].x, args[3].y)
             args[0](args[1], args[2], (self.rframed, plc), self.window)
 
         def _quit(self, *args):
             self.window.destroy()
-            if self.opts["loop"]:
-                if "mf" in self.opts:
-                    self.opts["mf"].closeLoop()
-                else:
-                    self.window.quit()
+            if "mf" in self.opts:
+                self.opts["mf"].closeLoop()
+            else:
+                self.window.quit()
 
     class ScrollWindow(MyFrame):
         """
@@ -1473,6 +1542,8 @@
                 focuscolor=[
                     ("focus", "gray")])
         self.style.configure("TEntry",
+            foreground="black",
+            background="white",
             selectforeground="black",
             selectbackground="light gray")
         self.style.map("TEntry",
@@ -1488,12 +1559,22 @@
             fieldbackground=[
                 ("active", "white"),
                 ("disabled", "white")])
+        self.style.configure("TLabel",
+            foreground="black")
         self.style.configure("CLabel.TLabel",
             foreground=self.rcdic["nfg"],
             background=self.rcdic["nbg"])
         self.style.configure("Horizontal.TProgressbar",
             background=self.rcdic["fbg"],
             troughcolor=self.rcdic["ffg"])
+        self.style.configure("Treeview",
+            background="white",
+            foreground="black")
+        self.style.map("Treeview",
+            foreground=[
+                ("selected", self.rcdic["nfg"])],
+            background=[
+                ("selected", self.rcdic["nbg"])])
         self.window.update_idletasks()
 
     def createChildren(self):
@@ -1604,12 +1685,16 @@
                 if os.path.isdir(tdir):
                     thms = glob.glob(os.path.join(tdir, "*", "*.tcl"))
                     for thm in thms:
-                        chk = os.path.basename(thm).replace(".tcl", "")
-                        if chk in stdthm:
-                            try:
-                                self.newwin.tk.eval("source {%s}" % thm)
-                            except:
-                                pass
+                        if os.path.isdir(thm):
+                            continue
+                        if thm.count("pkgIndex"):
+                            continue
+                        if thm.count("8.4"):
+                            continue
+                        try:
+                            self.newwin.tk.eval("source {%s}" % thm)
+                        except:
+                            pass
             except:
                 pass
             # Enable button to show hidden files
@@ -1975,7 +2060,6 @@
             self.window = MkWindow(decor=False, remov=False).newwin
             self.frame = MyFrame(self.window, bg="black", borderwidth=5)
         else:
-            self.scrn = scrn
             self.frame = MyFrame(self.scrn, bg="black", borderwidth=5)
         if not text:
             text = """Welcome to TARTAN Systems,
@@ -1985,13 +2069,12 @@
         self.label = MyLabel(self.frame, text=text, font=("Helvetica", 16),
             justify="center")
         self.label.pack(fill="both", expand="yes")
-        mgr = getManager(self.scrn)
-        if not mgr or mgr == "grid":
+        if self.scrn:
             self.frame.place(anchor="center", relx=0.5, rely=0.5)
         else:
             self.frame.pack()
         self.frame.update()
-        if not scrn:
+        if not self.scrn:
             sw = int(self.window.winfo_screenwidth())
             sh = int(self.window.winfo_screenheight())
             rootsize = tuple(int(_) for _ in self.window.geometry().
@@ -2052,16 +2135,16 @@
                     self.dbdsn = self.dbname
             self.mrecs = True
             if self.dbase == "FBird":
+                self.dbmod = "fdb"
+                import fdb as engine
+                self.dbf = "?"
+            elif self.dbase == "MySQL":
                 try:
-                    self.dbmod = "fdb"
-                    import fdb as engine
+                    import MySQLdb as engine
+                    self.dbmod = "MySQLdb"
                 except:
-                    self.dbmod = "kinterbasdb"
-                    import kinterbasdb as engine
-                self.dbf = "?"
-            elif self.dbase == "MySQL":
-                self.dbmod = "MySQLdb"
-                import MySQLdb as engine
+                    import pymysql as engine
+                    self.dbmod = "pymysql"
                 self.dbf = "%s"
             elif self.dbase == "PgSQL":
                 self.dbmod = "psycopg2"
@@ -3083,8 +3166,8 @@
     Data Types
     ============================================================================
     CB = CheckButton Box
-    CI = Currency Integer i.e. thousands separated by comma
-    CD = Currency Decimal i.e. thousands separated by comma
+    CI = Currency Integer Signed i.e. thousands separated by comma
+    CD = Currency Decimal Signed i.e. thousands separated by comma
     D0 = Date (CCYYMMDD)
     D1 = Date (CCYYMMDD)
     d1 = Date (CCYYMMDD) Alowing Zero
@@ -3283,7 +3366,7 @@
                 if mm < 1 or mm > 12:
                     self.err = "Invalid Date (D1-1)"
                     return
-                chkmth = copyList(mthnam)
+                chkmth = copyList(tartanWork.mthnam)
                 if mm == 2:
                     if not yy % 4:
                         chkmth[2][2] = 29
@@ -3295,8 +3378,8 @@
                 self.work = (yy * 10000) + (mm * 100) + dd
                 self.disp = "%04i-%02i-%02i" % (yy, mm, dd)
                 if len(self.disp) < self.size:
-                    self.disp = self.disp + \
-                        (" " * (int(self.size/1) - len(self.disp)))
+                    self.disp = self.disp + (" " *
+                            (int(self.size/1) - len(self.disp)))
             except:
                 self.err = "Invalid Date (D1-3)"
 
@@ -3338,7 +3421,7 @@
                 yy += 1900
             elif yy < 100:
                 yy += 2000
-            chkmth = copyList(mthnam)
+            chkmth = copyList(tartanWork.mthnam)
             if mm == 2:
                 if not yy % 4:
                     chkmth[2][2] = 29
@@ -3390,7 +3473,7 @@
             if mm < 1 or mm > 12:
                 self.err = "Invalid Date (D1-1)"
                 return
-            chkmth = copyList(mthnam)
+            chkmth = copyList(tartanWork.mthnam)
             if mm == 2:
                 if not yy % 4:
                     chkmth[2][2] = 29
@@ -3402,8 +3485,8 @@
             self.work = (yy*100000000)+(mm*1000000)+(dd*10000)+(hh*100)+tt
             self.disp = "%04i-%02i-%02i %02i:%02i" % (yy, mm, dd, hh, tt)
             if len(self.disp) < self.size:
-                self.disp = self.disp + \
-                    (" " * (int(self.size/1) - len(self.disp)))
+                self.disp = self.disp + (" " *
+                        (int(self.size/1) - len(self.disp)))
         except:
             self.err = "Invalid Date (DT)"
 
@@ -3424,7 +3507,8 @@
             self.work = (hh*100)+mm
             self.disp = "%02i:%02i" % (hh, mm)
             if len(self.disp) < self.size:
-                self.disp = self.disp+(" "*(int(self.size/1)-len(self.disp)))
+                self.disp = self.disp + (" " *
+                        (int(self.size/1)-len(self.disp)))
         except:
             self.err = "Invalid Time (%s)" % self.types
 
@@ -3557,7 +3641,7 @@
 
 class ASD:
     """
-    Used for Adding and Subtracting Decimal Amounts as follows:
+    Used for Adding and Subtracting Floats as follows:
 
     answer = float(ASD(amount1) + ASD(amount2))
     answer = float(ASD(amount1) - ASD(amount2))
@@ -4210,19 +4294,19 @@
             self.repprt = ["N", "N", ""]
         else:
             self.repprt = ["Y", "", ""]
-        smtp = None
-        if self.mf.dbm and self.mf.dbm.dbopen:
+        self.repeml = ["N", "N", "", "", "Y"]
+        if self.mail:
             try:
                 gc = GetCtl(self.mf)
                 ctlsys = gc.getCtl("ctlsys", error=False)
                 if ctlsys:
-                    smtp = ctlsys["sys_msvr"]
+                    server = [ctlsys["sys_msvr"], ctlsys["sys_mprt"],
+                        ctlsys["sys_msec"], ctlsys["sys_maut"],
+                        ctlsys["sys_mnam"], ctlsys["sys_mpwd"]]
+                    if sendMail(server, "", "", "", check=True):
+                        self.repeml = ["Y", "", "", "", "Y"]
             except:
                 pass
-        if not self.mail or not smtp:
-            self.repeml = ["N", "N", "", "", "Y"]
-        else:
-            self.repeml = ["Y", "", "", "", "Y"]
         if self.view or self.mail:
             if self.eflds and not tuple(self.eflds[0][0][:2]) == ("T", 0):
                 showError(self.master, "View or Mail Option",
@@ -4748,6 +4832,7 @@
         self.lastnbpage = index
         cmd = self.tags[index][1]
         if cmd:
+            self.window.focus_set()
             cmd()
         elif self.last[self.pag][1]:
             m = self.colq[self.pag]
@@ -5071,7 +5156,7 @@
         cols = len(self.butt) / rows
         if len(self.butt) % rows:
             cols += 1
-        butfrm = ButtonBox(self.mstFrame)
+        bbox = MyButtonBox(self.mstFrame)
         for num, but in enumerate(self.butt):
             if but[1]:
                 cmd = (self.selectBut, num)
@@ -5086,7 +5171,7 @@
             else:
                 row = num / cols
                 spn = 1
-            butts = butfrm.addButton(but[0], cmd, row=row, spn=spn)
+            butts = bbox.addButton(but[0], cmd, row=row, spn=spn)
             binds = butts.bind()
             for bind in binds:
                 if "<Key-Alt_L>" in bind:
@@ -5372,18 +5457,18 @@
             return
         # Force focus to application
         self.window.focus_force()
-        if col == 1:
-            if tuple(self.first[:2]) == (frt, pag) and clr:
-                # First field of first screen and page
-                for x in xrange(0, self.pgs+1):
-                    self.clearFrame("T", x)
-                    self.clearFrame("C", x)
-                self.skip[pag] = []
+        if col == 1 and tuple(self.first[:2]) == (frt, pag) and clr:
+            # First field of first screen and page
+            for x in xrange(0, self.pgs+1):
+                self.clearFrame("T", x)
+                self.clearFrame("C", x)
+            self.skip[pag] = []
         for widget in self.has_focus:
             try:
                 widget.configure(state="disabled")
             except:
                 pass
+        self.has_focus = []
         self.frt = frt
         self.pag = int(pag)
         self.col = int(col)
@@ -5718,7 +5803,7 @@
                 fldd.delete(0, "end")
                 fldd.configure(state="disabled")
 
-    def loadEntry(self, frt, pag, pos, data=None):
+    def loadEntry(self, frt, pag, pos, data=None, zero=False):
         """
         where
             frt  =    Frame Type ('T', 'C')
@@ -5739,7 +5824,7 @@
                 else:
                     d = CCD(data, self.topf[pag][pos][1],
                         self.topf[pag][pos][2][1])
-                    if d.err or d.work == 0:
+                    if d.err or (d.work == 0 and not zero):
                         d.disp = ""
                 self.t_disp[pag][0][pos] = d.disp
                 self.t_work[pag][0][pos] = d.work
@@ -5770,7 +5855,7 @@
             if not data is None:
                 d = CCD(data, self.colf[pag][idx][1],
                     self.colf[pag][idx][2][1])
-                if d.err or d.work == 0:
+                if d.err or (d.work == 0 and not zero):
                     d.disp = ""
                 self.c_disp[pag][row][idx] = d.disp
                 self.c_work[pag][row][idx] = d.work
@@ -6018,10 +6103,16 @@
                         else:
                             self.focusField(frt, pag, self.col + 1)
                     elif ok[:2] == "ff":            # Force new column focus
-                        col = int(ok[2:])
+                        ok = ok.split("|")          # ff[col]|Message|Clear
+                        col = int(ok[0][2:])
                         if col == 0:
                             col = 1
-                        self.focusField(frt, pag, col)
+                        if len(ok) == 1:
+                            self.focusField(frt, pag, col)
+                        elif len(ok) == 2:
+                            self.focusField(frt, pag, col, err=ok[1])
+                        else:
+                            self.focusField(frt, pag, col, err=ok[1], clr=ok[2])
                     elif ok == "xt":                  # Force frame exit
                         self.doExitFrame(frt, pag)
                     elif ok == "nc":                  # End frame, no confirm
@@ -6426,6 +6517,7 @@
                     self.col = self.col - 1
             self.focusField(frt, pag, self.col, dir="B")
         elif cmd:
+            self.window.focus_set()
             cmd()
         elif frt == "C":
             self.advanceLine(pag)
@@ -7168,9 +7260,9 @@
         self.buttons = []
         if butt:
             self.button = None
-            self.bbox = ButtonBox(self.window)
+            bbox = MyButtonBox(self.window)
             for num, but in enumerate(butt):
-                b = self.bbox.addButton(but[0], (self.doButton, but))
+                b = bbox.addButton(but[0], (self.doButton, but))
                 self.buttons.append(b)
 
     def doButton(self, button):
@@ -7577,7 +7669,7 @@
                 resiz=resiz, decor=decor, frame=True)
             self.window = win.newwin
             self.frame = win.newfrm
-        bbox = ButtonBox(self.frame)
+        bbox = MyButtonBox(self.frame)
         self.binds = []
         for but in self.butt:
             b = bbox.addButton(but[0], but[1])
@@ -7625,43 +7717,6 @@
             self.window.unbind("<Key-Alt_L>%s" % c.upper())
         self.window.quit()
 
-class ButtonBox:
-    def __init__(self, parent, row=None, padx=0, pady=0, bd=0):
-        self.grid = {}
-        parent.update_idletasks()
-        self.bbox = MyFrame(parent, borderwidth=bd)
-        if getManager(parent) in ("grid", "place"):
-            if row is None:
-                row = parent.grid_size()[1]
-            self.bbox.grid(row=row, padx=padx, pady=pady, sticky="ew")
-        else:
-            self.bbox.pack(fill="x", side="bottom")
-
-    def addButton(self, text, cmd, row=0, spn=1):
-        if not row in self.grid:
-            self.grid[row] = 0
-        text, pos = getUnderline(widget=self.bbox, text=text)
-        but = MyButton(self.bbox, cmd=cmd, text=text, underline=pos)
-        but.grid(column=self.grid[row], row=row, columnspan=spn, sticky="ew")
-        self.bbox.columnconfigure(self.grid[row], weight=1)
-        self.grid[row] += spn
-        return but
-
-    def focusNext(self, event):
-        key = event.keysym
-        idx = self.buttons.index(event.widget["text"])
-        if key == "Left":
-            if not idx:
-                idx = len(self.buttons) - 1
-            else:
-                idx -= 1
-        elif idx == (len(self.buttons) - 1):
-            idx = 0
-        else:
-            idx += 1
-        widgets = self.bbox.winfo_children()
-        widgets[idx].focus_set()
-
 class ProgressBar:
     """
     A progress bar widget where:
@@ -7702,18 +7757,13 @@
             self.typ = "G"
         if self.typ == "G":
             mode = "indeterminate"
-            if not text:
-                text = "Generating the Report ... Please Wait"
-        elif self.typ == "P":
-            mode = "determinate"
-            if not text:
-                text = "Generating the Report ... Please Wait"
-        elif self.typ == "F":
-            mode = "determinate"
-            if not text:
-                text = "Updating Files ... Please Wait"
-        else:
-            mode = "determinate"
+        else:
+            mode = "determinate"
+        if self.typ in ("G", "P") and not text:
+            text = "Generating the Report ... Please Wait"
+        elif self.typ == "F" and not text:
+            text = "Updating Files ... Please Wait"
+        else:
             text = self.typ
             self.typ = "P"
         self.quit = False
@@ -7723,11 +7773,7 @@
             self.pbframe.pack(fill="x", expand="yes")
         else:
             self.pbframe = MyFrame(self.scrn, padding=2)
-            mgr = getManager(self.scrn)
-            if not mgr or mgr == "grid":
-                self.pbframe.place(anchor="center", relx=0.5, rely=0.5)
-            else:
-                self.pbframe.pack(pady=10)
+            self.pbframe.place(anchor="center", relx=0.5, rely=0.5)
         self.txtlab = MyLabel(self.pbframe, text=text, anchor="c", width=60,
             borderwidth=2, relief="raised")
         self.txtlab.pack(anchor="n", fill="x", expand="yes")
@@ -7829,10 +7875,9 @@
                 height = msiz
                 width = int(height / relate)
             self.currentImage = {}
-            image = pilimg.resize((width, height), 0)
+            image = pilimg.resize((width, height), Image.ANTIALIAS)
             self.currentImage["data"] = image
-            self.frm = MyFrame(self.vbox, borderwidth=5, relief="raised",
-                width=width, height=height)
+            self.frm = MyFrame(self.vbox, width=width, height=height)
             if self.vbox:
                 mgr = getManager(self.vbox)
                 if mgr == "grid":
@@ -8127,7 +8172,7 @@
             (("T",3,9,0),"OTv",10," "))
         but = (
             ("Save", None, self.doSave, 1, ("T",1,1), ("T",0,1)),
-            ("Cancel", None, self.doCancel, 1, None, None))
+            ("Quit", None, self.doQuit, 1, None, None))
         tnd = (
             (self.doEnd, "n"),
             (self.doEnd, "n"),
@@ -8290,7 +8335,7 @@
 
     def doExit(self):
         if self.df.pag == 0:
-            self.doCancel()
+            self.doQuit()
         elif self.df.pag == 1:
             pass
         else:
@@ -8459,7 +8504,7 @@
             "Changes will Only take effect once Tartan is Restarted.")
         self.closeProcess()
 
-    def doCancel(self, widget=None):
+    def doQuit(self, widget=None):
         self.rcfile = None
         self.closeProcess()
 
@@ -8492,11 +8537,7 @@
 
     def loadThemes(self):
         self.style = ttk.Style()
-        themes = self.style.theme_names()
-        self.thm = []
-        for theme in themes:
-            if theme in stdthm:
-                self.thm.append(theme)
+        self.thm = list(self.style.theme_names())
         self.thm.sort()
 
 class AgeAll:
@@ -8670,11 +8711,11 @@
 
     def setVariables(self):
         if self.system == "crs":
-            typ = ("XX", crtrtp)
+            typ = ("XX", tartanWork.crtrtp)
         elif self.system == "drs":
-            typ = ("XX", drtrtp)
+            typ = ("XX", tartanWork.drtrtp)
         elif self.system == "mem":
-            typ = ("XX", mltrtp)
+            typ = ("XX", tartanWork.mltrtp)
         self.cols = (
             (0, "   Date",    10,   "D1", None),
             (1, "Reference",   9,   "Na", None),
@@ -8710,7 +8751,7 @@
         self.allBal.insert(0, self.total.disp)
         self.allBal.configure(state="disabled")
         self.allBal.grid(row=0, column=3, sticky="ew")
-        bbox = ButtonBox(self.lb.window)
+        bbox = MyButtonBox(self.lb.window)
         self.allBut = bbox.addButton(text="Apply", cmd=self.enterAmt)
         self.allBut.configure(state="disabled")
         if self.xits:
@@ -8740,6 +8781,9 @@
 
     def enterAmt(self, widget=None):
         wrk = CCD(self.allAmt.get(), "SD", 13.2)
+        if wrk.err:
+            showError(self.lb.mstFrame, "Error", "Invalid Allocation Amount")
+            wrk = CCD(0, "SD", 13.2)
         self.data[self.pos][6] = float(ASD(self.data[self.pos][6]) + \
             ASD(wrk.work))
         recs = float(ASD(self.work[self.pos][4]) + ASD(wrk.work))
@@ -8747,7 +8791,7 @@
         self.work[self.pos][4] = recs
         self.work[self.pos][5] = bal
         tot = float(ASD(self.total.work) - ASD(wrk.work))
-        self.total = CCD(tot,"SD",13.2)
+        self.total = CCD(tot, "SD", 13.2)
         self.closeProcess()
 
     def exitAge(self, widget=None):
@@ -9276,48 +9320,48 @@
         self.e_per = self.per[2][0] / 100
         self.bankctl = False
         if self.sys == "ASS":
-            self.ttp = artrtp
-            self.nam = artrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.artrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (1, 2) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "CRS":
-            self.ttp = crtrtp
-            self.nam = crtrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.crtrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 5) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "DRS":
-            self.ttp = drtrtp
-            self.nam = drtrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.drtrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 5) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "GEN":
-            self.ttp = gltrtp
-            self.nam = gltrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.gltrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 6, 7):
                 self.bankctl = True
         elif self.sys == "LON":
-            self.ttp = lntrtp
-            self.nam = lntrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.lntrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (1, 2) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "MEM":
-            self.ttp = mltrtp
-            self.nam = mltrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.mltrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 5) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "RTL":
-            self.ttp = rttrtp
-            self.nam = rttrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.rttrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 3) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "SLN":
-            self.ttp = sltrtp
-            self.nam = sltrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.sltrtp)
+            self.nam = self.ttp[self.rtn-1][1]
             if self.rtn in (2, 4) and self.glint == "Y":
                 self.bankctl = True
         elif self.sys == "STR":
-            self.ttp = sttrtp
-            self.nam = sttrtp[self.rtn-1][1]
+            self.ttp = copyList(tartanWork.sttrtp)
+            self.nam = self.ttp[self.rtn-1][1]
         if self.bankctl:
             acc = self.sql.getRec(tables="ctlctl", cols=["ctl_code"],
                 where=[("ctl_cono", "=", self.conum), ("ctl_code", "like",
@@ -9326,7 +9370,8 @@
                 self.ckCtl(acc[0][0])
 
     def doBatchHeader(self):
-        tit = ("%s %s - Batch Details" % (finsys[self.sys][0], self.nam),)
+        tit = ("%s %s - Batch Details" % (tartanWork.finsys[self.sys][0],
+            self.nam),)
         btm = {
             "stype": "R",
             "tables": ("ctlbat",),
@@ -10939,7 +10984,7 @@
 
     def doFixed(self):
         # Fixed Period Loan
-        cpymth = copyList(mthnam)
+        cpymth = copyList(tartanWork.mthnam)
         self.cap = self.sql.getRec(tables="lontrn",
             cols=["round(sum(lnt_tramt), 2)"],
             where=[("lnt_cono", "=", self.cono),
@@ -10961,8 +11006,8 @@
                     cpymth[2][2] = 29
                 else:
                     cpymth[2][2] = 28
-            if dd > mthnam[mm][2]:
-                dd = mthnam[mm][2]
+            if dd > cpymth[mm][2]:
+                dd = cpymth[mm][2]
             date = (yy * 10000) + (mm * 100) + dd
             date = projectDate(date, -1, typ="days")
             if date > self.tdate:
@@ -10989,7 +11034,8 @@
                     if chk:
                         ita = float(ASD(ita) + ASD(chk))
                 if self.update == "Y":
-                    desc = "%0.2f @ %0.2f for 1 month" % (self.cap, rte)
+                    cap = CCD(self.cap, "SD", 13.2)
+                    desc = "%s @ %0.2f%s for 1 mth" % (cap.disp, "%", rte)
                     # Loans Transaction
                     self.sql.insRec("lontrn", data=[self.cono, self.acno,
                         self.loan, self.batch, 4, date, self.refno, ita,
@@ -11115,7 +11161,7 @@
             else:
                 lcap = projectDate(lcap, 6, typ="months")
             if lcap <= self.tdate:
-                capdt.append((projectDate(lcap, -1, typ="days"), True))
+                capdt.append((lcap, True))
             else:
                 capdt.append((self.tdate, False))
         # Raise Interest
@@ -11187,34 +11233,33 @@
             if self.glctl:
                 ctl = self.glctl[2]
         if self.ityp == "D":
-            period = dateDiff(fdte, tdte, "days") + 1
-        else:
-            period = 1
-        if self.ityp == "D":
-            rin = round((self.cap * rte * period / 36500), 2)
-            desc = "%0.2f @ %0.2f for %s day" % (self.cap, rte, period)
+            per = dateDiff(fdte, tdte, "days") + 1
+            rin = round((self.cap * rte * per / 36500), 2)
+            cap = CCD(self.cap, "SD", 13.2)
+            desc = "%s @ %0.2f%s for %s day" % (cap.disp, rte, "%", per)
+            if per > 1:
+                desc += "s"
         else:
             rin = round((self.cap * rte / 1200), 2)
-            desc = "%0.2f @ %0.2f for %s month" % (self.cap, rte, period)
-        if period > 1:
-            desc += "s"
+            cap = CCD(self.cap, "SD", 13.2)
+            desc = "%s @ %0.2f%s for 1 mth" % (cap.disp, rte, "%")
         self.rin = float(ASD(self.rin) + ASD(rin))
         # Capitalisation
         if tdte == self.ncap[0] and self.ncap[1]:
             self.cap = float(ASD(self.cap) + ASD(self.rin))
+            self.lcap = self.ncap[0]
             self.rin = 0
-            self.lcap = self.ncap[0]
         # Update Tables
         if rin and self.update == "Y":
             # Loans Transaction
             if self.sys == "L":
                 data = [self.cono, self.acno, self.loan, self.batch, 4,
-                    tdte, self.refno, rin, self.curdt, desc, "",
+                    tdte, self.refno, rin, tdte / 100, desc, "",
                     self.capnm, self.sysdtw, 0]
                 self.sql.insRec("lontrn", data=data)
             else:
                 data = [self.cono, self.acno, self.loan, self.batch, 4,
-                    tdte, self.refno, rin, self.curdt, desc, "",
+                    tdte, self.refno, rin, tdte / 100, desc, "",
                     self.capnm, self.sysdtw, 0]
                 self.sql.insRec("wagltf", data=data)
             if not self.refno == "Pending":
@@ -11225,7 +11270,7 @@
                 vals = ((self.glctl[0], rin), (ctl, iti))
                 for val in vals:
                     whr = [("glt_cono", "=", self.cono), ("glt_acno", "=",
-                        val[0]), ("glt_curdt", "=", self.curdt), ("glt_trdt",
+                        val[0]), ("glt_curdt", "=", tdte / 100), ("glt_trdt",
                         "=", tdte), ("glt_type", "=", 4), ("glt_refno", "=",
                         self.refno), ("glt_batch", "=", self.batch)]
                     data = self.sql.getRec(tables="gentrn", where=whr, limit=1)
@@ -11236,7 +11281,7 @@
                             data=[tramt], where=whr)
                     else:
                         self.sql.insRec("gentrn", data=[self.cono, val[0],
-                            self.curdt, tdte, 4, self.refno, self.batch, val[1],
+                            tdte / 100, tdte, 4, self.refno, self.batch, val[1],
                             0.00, "Interest on Loans", "", "", 0, self.capnm,
                             self.sysdtw, 0])
 
@@ -11296,9 +11341,6 @@
                 self.conum), ("pom_ordno", "=", self.docno.work)], limit=1)
             if not pom:
                 continue
-            if self.splash:
-                sp = SplashScreen(self.mf.body,
-                    "Generating Forms\n\n   Please Wait...")
             for fld in pmc:
                 if fld in self.form.tptp:
                     self.form.tptp[fld][1] = pom[pmc.index(fld)]
@@ -11335,6 +11377,9 @@
                 self.conum), ("pot_ordno", "=", self.docno.work)])
             if not pot:
                 continue
+            if self.splash:
+                sp = SplashScreen(self.mf.body,
+                    "Generating Forms\n\n   Please Wait...")
             self.doBody(ptc, pot, tdc)
             self.doTotal(tdc)
             self.doTail(tdc)
@@ -11500,8 +11545,6 @@
         if "document_type" in self.form.tptp:
             if self.copy.lower() == "a":
                 typ = "AMENDED"
-            elif self.copy.lower() == "d":
-                typ = "CANCELLED"
             elif self.copy.lower() == "y":
                 typ = "COPY"
             else:
@@ -12110,9 +12153,7 @@
             include = copyList(self.form.body)
             for code in self.form.body:
                 seq = "%s_C%02i" % (code, count)
-                if code == "rtt_desc":
-                    data = l
-                elif code in include:
+                if code in include:
                     data = ldic[code].work
                 else:
                     data = "BLANK"
@@ -12793,10 +12834,11 @@
             self.fpdf.setFont(style="", size=14)
 
 class PrintTransfer:
-    def __init__(self, mf, conum, conam, docs, **args):
+    def __init__(self, mf, conum, conam, dtyp="I", docs=[], **args):
         self.mf = mf
         self.conum = conum
         self.conam = conam
+        self.dtyp = dtyp
         if type(docs) in (int, str):
             self.docs = [[docs]]
         else:
@@ -12842,9 +12884,13 @@
             self.docno = CCD(doc[0], "UI", 9.0)
             ibm = self.sql.getRec(tables="ibtmst", where=[("ibm_cono", "=",
                 self.conum), ("ibm_docno", "=", self.docno.work)], limit=1)
+            if self.dtyp == "I":
+                mtyp = 1
+            else:
+                mtyp = 2
             ibt = self.sql.getRec(tables="ibttrn", where=[("ibt_cono",
                 "=", self.conum), ("ibt_docno", "=", self.docno.work),
-                ("ibt_type", "=", 1)], order="ibt_seq")
+                ("ibt_type", "=", mtyp)], order="ibt_seq")
             if not ibm or not ibt:
                 continue
             if self.splash:
@@ -12891,7 +12937,10 @@
                     self.transporter = acc[0]
                 else:
                     self.transporter = False
-            self.form.document_date(ibm[imc.index("ibm_date")])
+            if self.dtyp == "I":
+                self.form.document_date(ibm[imc.index("ibm_date")])
+            else:
+                self.form.document_date(ibm[imc.index("ibm_cdte")])
             self.doBody(itc, ibt, tdc)
             self.doTotal(tdc)
             self.doTail(tdc)
@@ -13015,9 +13064,10 @@
                         head += ", %s" % doc[0]
             pdfnam = getModName(self.mf.rcdic["wrkdir"], "Invoice",
                 "%s_all" % self.conum, ext="pdf")
-        self.form.output(pdfnam, "F")
-        doPrinter(mf=self.mf, conum=self.conum, pdfnam=pdfnam, head=head,
-            repprt=self.repprt, repeml=self.repeml)
+        if self.form.page:
+            self.form.output(pdfnam, "F")
+            doPrinter(mf=self.mf, conum=self.conum, pdfnam=pdfnam, head=head,
+                repprt=self.repprt, repeml=self.repeml)
         if self.repeml[1] == "Y" and not self.emadd:
             self.form = DrawForm(self.mf.dbm, self.tname)
             self.doLoadStatic()
@@ -13036,6 +13086,13 @@
                 self.form.tptp[fld][1] = dat
         if "letterhead" in self.form.tptp:
             self.form.letterhead(cmc, ctm, "letterhead", None)
+        if "document_type" in self.form.tptp:
+            if self.dtyp == "C":
+                self.form.tptp["document_type"][1] = "CREDIT NOTE"
+            elif self.dtyp == "E":
+                self.form.tptp["document_type"][1] = "AMENDED INVOICE"
+            else:
+                self.form.tptp["document_type"][1] = "INVOICE"
 
     def doHeader(self, page, tdc):
         self.form.add_page()
@@ -13565,6 +13622,7 @@
                         column or "as" name
                 Use a blank list for no totals.
                 e.g. ["value",]
+    summ    :   Whether or not to print a summary of stots. Defaults to True
     where   :   A list of tuples of where statements e.g.
                 [("omb_recon", "=", "Y"), ("omb_recon", "=", "Y")]
                 None = No where statement
@@ -13626,6 +13684,7 @@
             "repeml": None,
             "repprt": None,
             "stots": [],
+            "summ": True,
             "tables": [],
             "tails": [],
             "trtp": None,
@@ -13659,31 +13718,24 @@
 
     def doPrtDialog(self):
         tit = ("Printer/Email Selection",)
-        self.pr = TartanDialog(self.mf, tops=True, title=tit, eflds=[],
+        self.pd = TartanDialog(self.mf, tops=True, title=tit, eflds=[],
             tend=((self.doPrtEnd,"y"),), txit=(self.doPrtExit,),
             view=self.prtdia[0], mail=self.prtdia[1])
         self.mf.startLoop()
 
     def doPrtEnd(self):
-        self.repprt = copyList(self.pr.repprt)
-        self.repeml = copyList(self.pr.repeml)
+        self.repprt = copyList(self.pd.repprt)
+        self.repeml = copyList(self.pd.repeml)
         self.xits = False
-        self.pr.closeProcess()
+        self.pd.closeProcess()
         self.mf.closeLoop()
 
     def doPrtExit(self):
         self.xits = True
-        self.pr.closeProcess()
+        self.pd.closeProcess()
         self.mf.closeLoop()
 
     def setVariables(self):
-        try:
-            user = getpass.getuser()
-        except:
-            user = "unknown"
-        t = time.localtime()
-        self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i by %s)" % (t[0],
-            t[1], t[2], t[3], t[4], user)
         if not self.gtots:
             self.stots = []
         if self.ttype == "T":
@@ -13850,28 +13902,13 @@
             self.head5 = self.head4
         self.tf = tf
         self.cf = cf
-        self.maxc = len(self.head4)
-        plus = len(self.sysdttm) + 47
-        if self.maxc <= plus:
-            self.maxc = plus + 1
-            self.head4 = self.head4 + (" " * (self.maxc - len(self.head4)))
-        fill = int(self.maxc - plus)
         if len(self.heads) == 4:
             self.head0 = self.heads.pop(0)
-        elif not self.conum:
-            hf = "%-34s %"+str(fill)+"s %"+str(len(self.sysdttm))+"s %10s"
-            self.head0 = hf % \
-                ("TARTAN Systems", "", self.sysdttm, self.name)
-        else:
-            hf = "%03s %-30s %"+str(fill)+"s %"+str(len(self.sysdttm))+"s %10s"
-            self.head0 = hf % \
-                (self.conum, self.conam, "", self.sysdttm, self.name)
-        fill = int(self.maxc - len(self.heads[0]) - 12)
-        if not self.pages:
-            self.head1 = "%-s" % self.heads[0]
-        else:
-            hf = "%-"+str(len(self.heads[0]))+"s %"+str(fill)+"s"
-            self.head1 = hf % (self.heads[0], "") + " Page %5s"
+        elif self.conum:
+            self.head0 = "%03i %-30s" % (self.conum, self.conam)
+        else:
+            self.head0 = None
+        self.head1 = "%-s" % self.heads[0]
         self.head2 = ""
         self.head3 = ""
         if len(self.heads) > 1:
@@ -13974,11 +14011,7 @@
         self.pglin = 999
         self.expdatas = []
         if not self.repprt[2] == "export":
-            if self.heads[0]:
-                name = self.heads[0]
-            else:
-                name = self.heads[1]
-            self.fpdf = MyFpdf(name=name, head=self.head0)
+            self.fpdf = MyFpdf(name=self.name, head=len(self.head4), foot=True)
             for num, font in enumerate(self.fonts):
                 if not font:
                     self.fonts[num] = self.fpdf.font[1]
@@ -14108,14 +14141,11 @@
             return
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")
-        self.fpdf.drawText(txt=self.head0)
-        self.fpdf.drawText()
-        if self.pages:
-            self.fpdf.setFont(style="B", size=self.fonts[0])
-            self.fpdf.drawText(txt=self.head1 % self.fpdf.page)
-        else:
-            self.fpdf.setFont(style="B", size=self.fonts[0])
-            self.fpdf.drawText(txt=self.head1)
+        if self.head0:
+            self.fpdf.drawText(txt=self.head0)
+            self.fpdf.drawText()
+        self.fpdf.setFont(style="B", size=self.fonts[0])
+        self.fpdf.drawText(txt=self.head1)
         self.pglin = 3
         if self.head2:
             self.fpdf.drawText()
@@ -14186,7 +14216,7 @@
                 self.fpdf.underLine(t="D")
                 self.fpdf.setFont()
                 self.pglin += 2
-        if not self.repprt[2] == "export" and self.stots:
+        if not self.repprt[2] == "export" and self.stots and self.summ:
             self.printSummary()
 
     def printTotals(self, typ, snum=None, sdet=None):
@@ -14674,8 +14704,9 @@
             if self.con:
                 return "Invalid Module, Company Exists"
             else:
-                self.df.loadEntry(frt, pag, p+1, data="")
-                self.df.loadEntry(frt, pag, p+2, data="")
+                self.pwd = ""
+                self.df.loadEntry(frt, pag, p+1, data=self.pwd)
+                self.df.loadEntry(frt, pag, p+2, data=self.pwd)
                 return "sk2"
         pwd = self.getPassword()
         if pwd:
@@ -14777,12 +14808,13 @@
     def __init__(self, mf, mode="B", csys=None, ver=None, bar=True):
         self.mf = mf
         self.mode = mode
+        self.smtp = False
         if csys:
             self.budays = csys[0]
-            self.smtp = csys[1:]
+            if sendMail(csys[1:], "", "", "", check=True):
+                self.smtp = csys[1:]
         else:
             self.budays = 0
-            self.smtp = None
         self.ver = ver
         self.bar = bar
         if self.setVariables():
@@ -15032,11 +15064,11 @@
             if self.mf.window and self.smtp and self.smtp[0]:
                 if self.bu.repeml[2]:
                     dated = CCD(self.sysdtw, "D1", 10).disp
-                    err = sendMail(self.smtp, self.coys[0][2],
+                    ok = sendMail(self.smtp, self.coys[0][2],
                         self.bu.repeml[2], "Tartan Backup for %s at %s" %
                         (self.coys[0][1], dated), self.bu.repeml[3],
                         attach=self.arcfle)
-                    if err:
+                    if not ok:
                         showError(self.mf.window, "Error",
                             "Email Unsuccessful, Check SMTP Settings")
                 self.mf.closeLoop()
@@ -15297,9 +15329,19 @@
     mchart   - A list of manual chart values
     xlab     - The x-axis's label
     ylab     - The y-axis's label
-    args     - The chart arguments
+    xcol     - The x-axis's columb labels
+    args     - The dictionary of chart arguments:
+                    chart  - The type of chart to generate
+                    color  - Whether to use colour, Y or N (default Y)
+                    format - The format of the chart (default pdf)
+                    repeml - The email variables
+                    repprt - The printer variables
+                    width  - The width of bars in bar charts (default 5)
+                    xcol   - The x-axis column names
+                    tic    - Use None for the default interval
+                    legend - Use None for no legend
     """
-    def __init__(self, mf, conum, conam, periods, title, achart, mchart, xlab=None, ylab=None, args=None):
+    def __init__(self, mf, conum, conam, periods, title, achart, mchart, xlab=None, ylab=None, args={}):
         if not PYCHART:
             return
         self.mf = mf
@@ -15319,11 +15361,14 @@
             self.ylab = "Values"
         self.args = args
         self.setVariables()
-        if self.achart and self.args:
+        if self.achart and self.args and "chart" in self.args:
             self.act = "A"
             self.chart = copyList(self.achart)
-            self.cht = self.args[0]
-            self.col = self.args[1]
+            self.cht = self.args["chart"]
+            if "color" in self.args:
+                self.col = self.args["color"]
+            else:
+                self.col = "Y"
             self.doChtEnd()
         else:
             self.doProcess()
@@ -15390,29 +15435,46 @@
         self.col = w
 
     def doChtEnd(self):
-        if self.args:
-            self.repprt = ["N", "V", "view"]
-            self.repeml = ["N", "N", "", "", "Y"]
+        def axisFormat(axis):
+            return "{:,}".format(axis)
+        if self.args and "chart" in self.args:
+            if "repprt" in self.args:
+                self.repprt = self.args["repprt"]
+            else:
+                self.repprt = ["N", "V", "view"]
+            if "repeml" in self.args:
+                self.repeml = self.args["repeml"]
+            else:
+                self.repeml = ["N", "N", "", "", "Y"]
         else:
             self.repprt = copyList(self.dc.repprt)
             self.repeml = copyList(self.dc.repeml)
+        if "format" in self.args:
+            self.fmat = self.args["format"]
+        else:
+            self.fmat = "pdf"
         if self.col == "Y":
             pychart_theme.use_color = 1
         else:
             pychart_theme.use_color = 0
         pychart_theme.reinitialize()
-        self.pdfnam = getModName(self.mf.rcdic["wrkdir"], "chart",
-            self.conum, ext="pdf")
-        cnv = pychart_canvas.init(fname=self.pdfnam, format="pdf")
+        self.flenam = getModName(self.mf.rcdic["wrkdir"], "chart",
+            self.conum, ext=self.fmat)
+        cnv = pychart_canvas.init(fname=self.flenam, format=self.fmat)
         if self.cht == "P":
             cnv.show(250, 550,"/14/hC/vT%s" % self.title[0][0])
             cnv.show(250, 530, "/12/hC/vT%s For Period %s to %s (%s)" % \
                 (self.title[0][1], self.s_per.disp, self.e_per.disp,
                 self.title[1]))
-            cnv.show(250, 510, "/12/hC/vT%s" % self.chart[0][1])
+            if self.chart[0][1]:
+                cnv.show(250, 510, "/12/hC/vT%s" % self.chart[0][1])
         else:
-            cnv.show(200, 550,"/14/hC/vT%s" % self.title[0][0])
-            cnv.show(200, 530, "/12/hC/vT%s For Period %s to %s (%s)" % \
+            if self.cht == "L":
+                w = 200
+            else:
+                w = 300
+            cnv.show(w, 550,"/14/hC/vT%s" % self.title[0][0])
+            cnv.show(w, 530, "/12/hC/vT%s For Period %s to %s (%s)" % \
                 (self.title[0][1], self.s_per.disp, self.e_per.disp,
                 self.title[1]))
         labs = []
@@ -15435,58 +15497,114 @@
             self.dc.focusField("T",0,1)
             return
         data = []
-        maxs = 0
-        mins = 0
+        if "mins" in self.args:
+            mins = self.args["mins"]
+        else:
+            mins = 0
+        if "maxs" in self.args:
+            maxs = self.args["maxs"]
+        else:
+            maxs = 0
         tots = 0
-        y = (self.s_per.work / 100) % 100
-        m = self.s_per.work % 100
-        for x in xrange(0, 12):
-            data.append(["%s '%02i" % (mthnam[m][0], y)])
-            for z in xrange(0, len(self.chart)):
-                amt = self.chart[z][x+2]
-                data[x].append(amt)
-                if self.cht == "S":
-                    tots = tots + amt
-                elif amt < 0 and amt < mins:
-                    mins = amt
-                elif amt > maxs:
-                    maxs = amt
-            if self.cht == "S":
-                if tots < 0 and tots < mins:
-                    mins = tots
-                elif tots > maxs:
-                    maxs = tots
-                tots = 0
-            if m == (self.e_per.work % 100):
-                break
-            m += 1
-            if m > 12:
-                y += 1
-                m = 1
+        if self.args and "xcol" in self.args:
+            for num, col in enumerate(self.args["xcol"]):
+                dat = [col]
+                for cht in self.chart:
+                    dat.append(cht[num + 2])
+                    if self.cht == "S":
+                        tots += cht[num + 2]
+                    else:
+                        if cht[num + 2] < mins:
+                            mins = cht[num + 2]
+                        if cht[num + 2] > maxs:
+                            maxs = cht[num + 2]
+                if self.cht == "S":
+                    if tots < mins:
+                        mins = tots
+                    if tots > maxs:
+                        maxs = tots
+                    tots = 0
+                data.append(dat)
+        else:
+            y = (self.s_per.work / 100) % 100
+            m = self.s_per.work % 100
+            for x in xrange(0, 12):
+                data.append(["%s '%02i" % (tartanWork.mthnam[m][0], y)])
+                for z in xrange(0, len(self.chart)):
+                    amt = self.chart[z][x+2]
+                    data[x].append(amt)
+                    if self.cht == "S":
+                        tots += amt
+                    else:
+                        if amt < mins:
+                            mins = amt
+                        if amt > maxs:
+                            maxs = amt
+                if self.cht == "S":
+                    if tots < mins:
+                        mins = tots
+                    if tots > maxs:
+                        maxs = tots
+                    tots = 0
+                if m == (self.e_per.work % 100):
+                    break
+                m += 1
+                if m > 12:
+                    y += 1
+                    m = 1
         if self.cht == "P":
-            are = area.T(size=(500,500), legend=None, x_grid_style=None,
+            are = area.T(size=(500, 500), legend=None, x_grid_style=None,
                 y_grid_style=None)
             plot = pie_plot.T(data=data, center=(250, 250), radius=190,
-                arc_offsets=[], label_offset=25, arrow_style=arrow.a3)
+                arc_offsets=[], label_offset=25, arrow_style=arrow.a0)
             are.add_plot(plot)
         else:
-            tots = maxs + (0 - mins)
-            itg = 100
-            num = tots / itg
-            while num > 9:
-                itg += 100
-                num = tots / itg
-            if maxs:
-                maxs = (((maxs / itg) + 1) * itg)
-            if mins:
-                mins = (((mins / (0 - itg)) - 1) * itg)
+            if "tic" in self.args:
+                tic = None
+            else:
+                tots = maxs + (0 - mins)
+                tic = 100
+                num = int(tots / tic)
+                while num > 9:
+                    tic = tic * 10
+                    num = int(tots / tic)
+                th = int(tic * .1)
+                while int((tots / tic)) < 6 and tic != th:
+                    tic -= th
+                if maxs:
+                    chk = int(maxs / tic)
+                    if (tic * chk) < maxs:
+                        chk += 1
+                    maxs = tic * chk
+                if mins:
+                    chk = int(mins / tic)
+                    if (tic * chk) > maxs:
+                        chk += 1
+                    mins = tic * chk
             if self.cht in ("B", "S"):
-                are = area.T(size=(400, 500), loc=(10, 0),
-                    x_coord=category_coord.T(data, 0), y_range=(mins, maxs),
-                    x_axis=axis.X(label=self.xlab),
-                    y_axis=axis.Y(label=self.ylab, tic_interval=itg),
-                    y_grid_interval=itg)
-                chart_object.set_defaults(bar_plot.T, data=data, width=5)
+                if "legend" in self.args or len(data) == 1:
+                    are = area.T(size=(600, 500), loc=(10, 0),
+                        x_coord=category_coord.T(data, 0),
+                        x_axis=axis.X(label=self.xlab),
+                        y_range=(mins, maxs),
+                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
+                            format=axisFormat),
+                        y_grid_interval=tic, legend=None)
+                else:
+                    are = area.T(size=(600, 500), loc=(10, 0),
+                        x_coord=category_coord.T(data, 0),
+                        x_axis=axis.X(label=self.xlab),
+                        y_range=(mins, maxs),
+                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
+                            format=axisFormat),
+                        y_grid_interval=tic)
+                if self.args and "width" in self.args:
+                    width = self.args["width"]
+                elif (len(data) * len(self.chart)) > 36:
+                    width = 5
+                else:
+                    width = 10
+                chart_object.set_defaults(bar_plot.T, data=data, width=width)
                 t = len(labs)
                 for n, d in enumerate(labs):
                     if self.cht == "B":
@@ -15499,21 +15617,33 @@
                             plot = bar_plot.T(label=d, hcol=n+1, stack_on=stak)
                     are.add_plot(plot)
             elif self.cht == "L":
-                are = area.T(size=(400, 500), loc=(0, 0),
-                    x_coord=category_coord.T(data, 0), y_range=(mins, maxs),
-                    x_axis=axis.X(label=self.xlab),
-                    y_axis=axis.Y(label=self.ylab, tic_interval=itg),
-                    y_grid_interval=itg)
+                if "legend" in self.args or len(data) == 1:
+                    are = area.T(size=(400, 500), loc=(0, 0),
+                        x_coord=category_coord.T(data, 0),
+                        x_axis=axis.X(label=self.xlab),
+                        y_range=(mins, maxs),
+                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
+                            format=axisFormat),
+                        y_grid_interval=tic, legend=None)
+                else:
+                    are = area.T(size=(400, 500), loc=(0, 0),
+                        x_coord=category_coord.T(data, 0),
+                        x_axis=axis.X(label=self.xlab),
+                        y_range=(mins, maxs),
+                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
+                            format=axisFormat),
+                        y_grid_interval=tic)
                 chart_object.set_defaults(line_plot.T, data=data)
                 for n, d in enumerate(labs):
                     plot = line_plot.T(label=d, ycol=n+1)
                     are.add_plot(plot)
         are.draw(cnv)
         cnv.close()
-        doPrinter(mf=self.mf, conum=self.conum, pdfnam=self.pdfnam,
-            head=self.title[0], repprt=self.repprt, repeml=self.repeml)
-        if not self.args:
-            self.dc.focusField("T",0,1)
+        if self.fmat == "pdf":
+            doPrinter(mf=self.mf, conum=self.conum, pdfnam=self.flenam,
+                head=self.title[0], repprt=self.repprt, repeml=self.repeml)
+            if not self.args or not "chart" in self.args:
+                self.dc.focusField("T", 0, 1)
 
     def doChtExit(self):
         self.dc.closeProcess()
@@ -15540,7 +15670,8 @@
         self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
 
     def mainProcess(self):
-        tit = ["%s Notes for - %s" % (finsys[self.sys][0], self.key.strip())]
+        tit = ["%s Notes for - %s" % (tartanWork.finsys[self.sys][0],
+            self.key.strip())]
         if self.conum:
             tit.insert(0, "%03i %s" % (self.conum, self.conam))
         cal = {
@@ -15712,7 +15843,7 @@
 
     def mainProcess(self):
         tit = ("%03i %s" % (self.conum, self.conam),
-            "%s Masterfile Notes" % finsys[self.sys][0])
+            "%s Masterfile Notes" % tartanWork.finsys[self.sys][0])
         r1s = (("All", "A"), ("Normal", "N"), ("Urgent", "U"))
         fld = (
             (("T",0,0,0),("IRB",r1s),0,"Action Flag","",
@@ -15805,6 +15936,7 @@
     def __init__(self, mf, **args):
         self.mf = mf
         self.impdat = []
+        self.impskp = []
         self.impfld = []
         self.impfle = ""
         self.impsht = None
@@ -16098,15 +16230,24 @@
 
 class MyFpdf(fpdf.FPDF):
     """
-    head - String or List / Tuple as folows:
-                Text - Heading or
-                Integer - Number of characters or
-                List / Tuple - (Heading, ("Family", "Style", Size))
+    This class generates a subclass of fpdf with a self.font variable i.e.
+        self.font = (family, size, height)
+
+    orientation - Portrait or Landscape
+    unit        - mm or cm
+    fmat        - Page format e.g. A4
+    font        - A family string or a tuple (family, style, size)
+    name        - Document title
+    head        - String or List / Tuple as folows:
+                    Text - Heading or
+                    Integer - Number of characters or
+                    List / Tuple - (Heading, ("Family", "Style", Size))
+    foot        - Turn footer on or off
     """
-    def __init__(self, orientation="P", unit="mm", fmat="A4", font="courier", name=None, head=None, prog=None):
+    def __init__(self, orientation="P", unit="mm", fmat="A4", font="courier", name="", head="", auto=False, foot=False):
         self.unit = unit
         self.fmat = fmat
-        self.prog = prog
+        self.foot = foot
         self.suc = chr(151)
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
@@ -16115,20 +16256,30 @@
             self.setValues(name, head, font)
         else:
             if type(font) == str:
-                self.font = (font, "", 10)
-            else:
-                self.font = font
-            self.setFont(self.font[0], self.font[1], self.font[2])
+                font = [font, "", 10]
+            self.setFont(font[0], font[1], font[2], default=True)
+        self.cwth = self.get_string_width("X")
+        self.set_author("Tartan Systems")
+        self.set_fill_color(220)
+        self.set_title(name)
+        if not auto:
+            self.set_auto_page_break(False, margin=0)
+        if foot:
+            self.alias_nb_pages()
 
     def setValues(self, name, head, font="", border=""):
         # Defaults
         portrait = (190, 275)
         # Adjust to heading width
-        self.font = None
         if type(head) == int:
             head = "X" * head
-        if font.lower() == "courier" and len(head) > 120:
+        if type(font) == str:
+            family = font
+        else:
+            family = font[0]
+        if family.lower() == "courier" and len(head) > 120:
             self.def_orientation = "L"
+        self.font = None
         while not self.font:
             if self.def_orientation == "P":
                 mm = portrait[0]
@@ -16139,13 +16290,13 @@
                 self.chgt = round(siz * .4, 1)
                 if border:
                     self.chgt += 1
-                self.setFont(font, "", siz)
+                self.setFont(family, "", siz, default=True)
                 self.width = self.get_string_width(head)
                 if self.def_orientation == "P":
                     if self.width > portrait[0]:
                         continue
                     else:
-                        self.font = [font, siz, self.chgt]
+                        self.font = [family, siz, self.chgt]
                         self.lpp = int(portrait[1] / self.chgt)
                         break
                 if self.def_orientation == "L":
@@ -16161,11 +16312,6 @@
                 else:
                     print "Invalid head length", len(head)
                     sys.exit()
-        self.cwth = self.get_string_width("X")
-        self.set_auto_page_break(False, margin=0)
-        self.set_author("Tartan Systems")
-        self.set_fill_color(220)
-        self.set_title(name)
 
     def drawText(self, txt="", x=0, y=0, w=0, h=0, font=[], border=0, ln=1, align="", fill=0, ctyp="S"):
         if not type(txt) == str:
@@ -16178,34 +16324,45 @@
             if y:
                 self.set_y(y)
         if font:
-            if len(font) == 3:
-                name, style, size = font
-                self.setFont(name, style, size)
-            elif len(font) == 2:
-                name = self.font_family
+            if type(font) in (list, tuple) and len(font) == 3:
+                family, style, size = font
+                self.setFont(family, style, size)
+            elif type(font) in (list, tuple) and len(font) == 2:
+                family = self.font_family
                 style, size = font
-                self.setFont(name, style, size)
+                self.setFont(family, style, size)
             else:
-                name = self.font_family
-                style = font[0]
-                self.setFont(name, style)
+                family = self.font_family
+                if type(font) == str:
+                    style = font
+                else:
+                    style = font[0]
+                self.setFont(family, style)
         if not h:
             h = self.font[2]
         if ctyp == "S":
             self.cell(w=w, h=h, ln=ln, txt=txt, border=border, align=align,
-                    fill=fill)
+                fill=fill)
         else:
             self.multi_cell(w=w, h=h, txt=txt, border=border, align=align,
-                    fill=fill)
+                fill=fill)
 
-    def setFont(self, name="", style="", size=0):
-        if not name:
-            name = self.font_family
+    def setFont(self, family="", style="", size=0, default=False):
+        if not family:
+            if self.font:
+                family = self.font[0]
+            else:
+                family = self.font_family
         if not size:
-            size = self.font[1]
+            if self.font:
+                size = self.font[1]
+            else:
+                size = 10
         try:
-            self.set_font(name, style, size)
+            self.set_font(family, style, size)
             self.cwth = self.get_string_width("X")
+            if default:
+                self.font = [family, size, self.font_size]
         except:
             pass
 
@@ -16235,21 +16392,23 @@
             self.set_xy(x, y + h)
 
     def footer(self):
-        if not self.prog:
+        if not self.foot:
             return
         self.set_y(-15)
         self.set_font("Arial", "I", 8)
-        self.cell(0, 10, "Tartan Systems %s (%s)" %
-            (self.sysdt, self.prog), 0, 0, "L")
-        self.alias_nb_pages()
+        if self.title:
+            txt = "Tartan Systems (%s) %s" % (self.title, self.sysdt)
+        else:
+            txt = "Tartan Systems %s" % self.sysdt
+        self.cell(0, 10, txt, 0, 0, "L")
         self.cell(0, 10, "Page " + str(self.page_no()) + "/{nb}", 0, 0, "C")
 
 class TartanLabel(MyFpdf):
     def __init__(self, label, unit="mm", posY=1, posX=1):
         MyFpdf.__init__(self, name="__name__", head=90, font="arial")
         self.setFont(self.font[0], "", self.font[1])
-        if label in labels:
-            type_format = labels[label]
+        if label in tartanWork.labels:
+            type_format = tartanWork.labels[label]
         else:
             raise NameError("Model %s is not in the database" % label)
         self.margin_left = type_format["marginLeft"]
@@ -16351,11 +16510,12 @@
         self.newdic = {}
         for line in self.tpldet:
             mrgcod = line[self.sql.tpldet_col.index("tpd_mrgcod")]
-            if mrgcod in tptrtp["G"]["codes"]:
-                self.tptp[mrgcod] = copyList(tptrtp["G"]["codes"][mrgcod])
-            elif mrgcod in tptrtp[self.tptyp]["codes"]:
-                self.tptp[mrgcod] = copyList(
-                    tptrtp[self.tptyp]["codes"][mrgcod])
+            if mrgcod in tartanWork.tptrtp["G"]["codes"]:
+                self.tptp[mrgcod] = copyList(
+                    tartanWork.tptrtp["G"]["codes"][mrgcod])
+            elif mrgcod in tartanWork.tptrtp[self.tptyp]["codes"]:
+                self.tptp[mrgcod] = copyList(
+                    tartanWork.tptrtp[self.tptyp]["codes"][mrgcod])
             else:
                 fld = self.sql.getRec(tables="ffield", cols=["ff_tabl",
                     "ff_type", "ff_size"], where=[("ff_name", "=", mrgcod)],
@@ -16817,7 +16977,7 @@
         label.tag_add("text", "1.0", "end")
         label.tag_config("text", justify="center")
         label.configure(state="disabled")
-        bbox = ButtonBox(self.about, row=1)
+        bbox = MyButtonBox(self.about, row=1)
         self.b0 = bbox.addButton("Licence", self.licenceAbout)
         self.b1 = bbox.addButton("Changes", self.changesAbout)
         self.b2 = bbox.addButton("Exit", self.exitAbout)
@@ -16942,10 +17102,7 @@
                     nf.configure(family=font[1], size=font[2], weight=font[3])
                 self.sframe.option_add(font[0], nf)
             self.sframe.grid()
-        elif getManager(self.parent) in ("pack", "place"):
-            self.sframe.place(anchor="center", relx=0.5, rely=0.5)
-        else:
-            self.sframe.grid()
+        self.sframe.place(anchor="center", relx=0.5, rely=0.5)
         if titl:
             head = MyLabel(self.sframe, text=titl, color=True, borderwidth=2,
                 anchor="c", padding=0, relief="ridge")
@@ -16980,16 +17137,9 @@
             relief="ridge")
         self.stat.grid(row=num+1, column=0, columnspan=2, pady=2, sticky="ew")
         if butt:
-            bbox = ButtonBox(self.sframe, row=1)
+            bbox = MyButtonBox(self.sframe, row=1)
             for but in butt:
                 bbox.addButton(but[0], but[1])
-        #if parent and parent.winfo_class() == "Tk":
-        #    parent.update_idletasks()
-        #    sw, sh = parent.winfo_screenwidth(), parent.winfo_screenheight()
-        #    ww, wh = self.sframe.winfo_reqwidth(), self.sframe.winfo_reqheight()
-        #    parent.geometry("%sx%s+%s+%s" % (ww, wh,
-        #        ((sw / 2) - (ww / 2)), ((sh / 2) - (wh / 2))))
-        #    parent.update_idletasks()
         self.fld = self.ents[self.cols[0][0]]
         self.fld.focus_set()
 

=== modified file 'std/tartanFunctions.py'
--- std/tartanFunctions.py	2016-02-27 13:18:41 +0000
+++ std/tartanFunctions.py	2016-05-13 19:16:12 +0000
@@ -23,9 +23,9 @@
 
 def getPrgPath():
     import os, sys
-    prgdir = sys.path[0]
-    while not os.path.isdir(prgdir):
-        prgdir = os.path.normpath(prgdir.replace(os.path.basename(prgdir), ""))
+    prgdir = os.path.realpath(sys.path[0])
+    if not os.path.isdir(prgdir):
+        prgdir = os.path.dirname(prgdir)
     return prgdir
 
 def showDialog(screen, dtype, title, mess, butt=None, dflt=None):
@@ -102,34 +102,32 @@
     """
 
     import getpass, os, sys
-    from tartanWork import stdthm
     # Defaults
-    prgdir = getPrgPath()
-    home = os.environ.get("HOME")
     try:
         user = getpass.getuser()
     except:
         user = ""
+    prgdir = getPrgPath()
     if sys.platform == "win32":
-        basedir = os.path.dirname(prgdir)
+        homedir = os.path.normpath("C:/Tartan")
     else:
-        basedir = home
+        homedir = os.path.expanduser("~")
     opts = {
         "dbase": ["SQLite"],
         "dbname": ["tartan"],
         "dbhost": ["localhost"],
-        "dbdir": [os.path.join(basedir, "fle")],
+        "dbdir": [os.path.join(homedir, "fle")],
         "dbport": [""],
         "dbuser": [user],
         "dbpwd": [""],
         "prgdir": [prgdir],
-        "bupdir": [os.path.join(basedir, "bup")],
-        "wrkdir": [os.path.join(basedir, "wrk")],
-        "upgdir": [os.path.join(basedir, "upg")],
-        "vwr": ["/usr/bin/evince", os.path.join(prgdir, "uty",
-                "SumatraPDF.exe")],
-        "prn": ["/usr/bin/lpr", os.path.join(prgdir, "uty",
-                "SumatraPDF.exe")],
+        "bupdir": [os.path.join(homedir, "bup")],
+        "wrkdir": [os.path.join(homedir, "wrk")],
+        "upgdir": [os.path.join(homedir, "upg")],
+        "vwr": ["/usr/bin/evince",
+            os.path.join(prgdir, "uty", "SumatraPDF.exe")],
+        "prn": ["/usr/bin/lpr",
+            os.path.join(prgdir, "uty", "SumatraPDF.exe")],
         "cnv": ["", ""],
         "exp": ["", ""],
         "geo": [0],
@@ -166,10 +164,9 @@
                 if os.path.isfile(os.path.normpath("C:/tartanrc")):
                     rcfile = os.path.normpath("C:/tartanrc")
                 else:
-
-                    rcfile = os.path.join(basedir, "tartanrc")
+                    rcfile = os.path.normpath("C:/Tartan/tartanrc")
             else:
-                rcfile = os.path.join(basedir, ".tartanrc")
+                rcfile = os.path.join(homedir, ".tartanrc")
     try:
         rcdic = {"name": rcfile}
         fle = open(rcfile, "r")
@@ -206,8 +203,11 @@
             rcdic[o] = int(rcdic[o])
         if o == "acnf" and rcdic[o].lower() == "y":
             rcdic["acnf"] = "L"
-    if not rcdic["geo"]:
-        w, h, f = getFontSize()
+    if not rcdic["geo"] or rcdic["geo"] == "0":
+        try:
+            w, h, f = getFontSize()
+        except:
+            w, h, f = 800, 600, 10
         m = f
     else:
         g = rcdic["geo"].split("x")
@@ -221,7 +221,7 @@
     rcdic["geo"] = "%sx%s" % (w, h)
     rcdic["mfs"] = m
     rcdic["dfs"] = f
-    if rcdic["theme"] not in stdthm:
+    if not rcdic["theme"]:
         rcdic["theme"] = "clam"
     if prgdir.count("_MEI"):
         # Change for pyinstaller
@@ -393,7 +393,7 @@
     period = The period number
     check  = Check if a Year End needs to be run
     """
-    from TartanClasses import CCD, Sql
+    from TartanClasses import CCD, SplashScreen, Sql
 
     sql = Sql(mf.dbm, ["ctlynd", "gentrn"], prog=__name__)
     p = sql.getRec(tables="ctlynd", cols=["cye_start", "cye_end",
@@ -404,12 +404,15 @@
             "Invalid Financial Period %s for Company %s" % (period, conum))
         return (None, None, None)
     if period and check:
+        sp = SplashScreen(mf.window,
+            "Checking if Period is Up To Date,\n\nPlease Wait....")
         chk1 = sql.getRec(tables="ctlynd", cols=["cye_last"],
             where=[("cye_cono", "=", conum), ("cye_period", "=",
                 (period - 1))], limit=1)
         chk2 = sql.getRec(tables="gentrn", cols=["max(glt_capdt)"],
             where=[("glt_cono", "=", conum), ("glt_curdt", "<",
             (p[0] / 100))], limit=1)
+        sp.closeSplash()
         if chk2[0] and chk2[0] > chk1[0]:
             ok = askQuestion(mf.window, "Year End Error",
                 """A Year End Must be Performed for Period %s as Transactions Have Been Captured After the last Year End Run for that Period!
@@ -541,8 +544,8 @@
                     att = [pdfnam]
                 else:
                     att = [pdfnam] + copyList(attach)
-                err = sendMail(smtp[0:6], fromad, toad, subj, mess, attach=att)
-                if err:
+                ok = sendMail(smtp[0:6], fromad, toad, subj, mess, attach=att)
+                if not ok:
                     if skip:
                         ok = "SKIPPED"
                     else:
@@ -679,7 +682,7 @@
                     elif flenam.lower() == name.lower():
                         return os.path.join(root, flenam)
 
-def sendMail(server, ex, to, subj, mess="", attach=[], embed=[], timeout=30):
+def sendMail(server, ex, to, subj, mess="", attach=[], embed=[], check=False, timeout=30):
     """
     A routine to email a message plus a file as an attachment
 
@@ -709,6 +712,22 @@
         from email.mime.multipart import MIMEMultipart
         from email.utils import COMMASPACE, formatdate
 
+    host, port, secu, auth, unam, upwd = server
+    try:
+        if secu == 2:
+            smtp = smtplib.SMTP_SSL(host, port, timeout=timeout)
+        else:
+            smtp = smtplib.SMTP(host, port, timeout=timeout)
+        if check:
+            smtp.quit()
+            return True
+        if secu == 1:
+            smtp.ehlo()
+            smtp.starttls()
+        if auth:
+            smtp.login(unam, upwd)
+    except:
+        return
     if type(to) == str:
         to = [to]
     if type(attach) == str:
@@ -776,21 +795,12 @@
                 part.add_header("Content-Disposition",
                     'attachment; filename="%s"' % os.path.basename(flenam))
                 msgRoot.attach(part)
-    host, port, secu, auth, unam, upwd = server
     try:
-        if secu == 2:
-            smtp = smtplib.SMTP_SSL(host, port, timeout=timeout)
-        else:
-            smtp = smtplib.SMTP(host, port, timeout=timeout)
-        if secu == 1:
-            smtp.ehlo()
-            smtp.starttls()
-        if auth:
-            smtp.login(unam, upwd)
         smtp.sendmail(ex, to, msgRoot.as_string())
         smtp.quit()
-    except:
         return True
+    except:
+        return
 
 def mthendDate(date):
     """
@@ -1222,9 +1232,9 @@
 
 def chkGenAcc(mf, coy, acc, ctl=True, pwd=True):
     """
-    This function returns None if the account does allow postings or is not
-    an integrated control else if pwd it asks for a Password and returns an
-    Error Message if not correct.
+    This function returns None if the account allows postings or is not an
+    integrated control else if pwd it asks for a Password and returns an
+    Error Message if not correct otherwise return desc, ind, vat and type.
     """
     from TartanClasses import GetCtl, PwdConfirm, Sql
 
@@ -2253,5 +2263,105 @@
             return copy.copy(orig)
     except:
         return orig[:]
+
+def simpleLineChart(fpdf, head="", xcol=[], vals=[], ycol=None, labs=True):
+    from TartanClasses import rgb
+    if not vals or not vals[0]:
+        return
+    if len(vals) > 3:
+        print "Only a maximum of 3 lines allowed"
+        return
+    # Minimum and Maximum Values
+    mins = 999999999
+    maxs = 0
+    for val in vals:
+        for v in val:
+            if v < mins:
+                mins = v
+            if v > maxs:
+                maxs = v
+    uu = len(str(int(maxs - mins)))
+    if uu == 3:
+        vi = 100
+    elif uu > 3:
+        vi = 10 ** (uu - 2)
+    else:
+        vi = 1
+    mins = (int(mins) / vi) * vi
+    maxs = ((int(maxs) / vi) + 1) * vi
+    # Heading
+    lm = 20                                 # Left margin
+    cw = int(fpdf.fw * .90) - lm            # Chart width
+    fpdf.drawText()
+    fpdf.setFont("Courier", "B", 12)
+    if head:
+        fpdf.drawText(head, x=lm, w=cw, align="C")
+        fpdf.drawText()
+    if maxs > 999:
+        txt = "{:,}'s".format(vi)
+        fpdf.drawText(txt, align="C")
+        fpdf.drawText()
+    # Chart Variables
+    sy = int(fpdf.get_y()) + 1              # Initial y value
+    ch = (fpdf.fh * .80) - sy               # Chart height
+    vb = (maxs - mins) / vi                 # Vertical blocks
+    vd = ch / vb                            # Depth of blocks
+    ly = sy + ch                            # Last y value
+    cl = ["#ff0000", "#0000ff", "#00ff00"]  # Line colours (red/blue/green)
+    # Horizontal Lines
+    for z in range(vb + 1):
+        num = maxs - (z * vi)
+        if num:
+            if vb > 50 and num % (vi * 10):
+                continue
+            fpdf.set_line_width(0)
+        else:
+            fpdf.set_line_width(1)
+        txt = num / vi
+        fpdf.drawText(txt, x=lm-8, y=sy+(z*vd)-2, w=3, align="R")
+        fpdf.line(lm-3, sy+(z*vd), lm+cw, sy+(z*vd))
+    # Vertical Lines
+    fpdf.set_line_width(1)
+    fpdf.line(lm, sy, lm, ly)
+    hw = int(cw / len(xcol))
+    for num, tab in enumerate(xcol):
+        txt = "%12s" % tab
+        fpdf.set_line_width(0)
+        fpdf.line(lm+10+(num*hw), ly+3, lm+10+(num*hw), sy)
+        fpdf.rotate(60, x=lm+(num*hw)-7, y=ly+fpdf.get_string_width(txt))
+        fpdf.drawText(txt=txt, x=lm+(num*hw)-7, y=ly+fpdf.get_string_width(txt))
+        fpdf.rotate(0)
+    # Chart
+    clrs = cl[:len(vals)]
+    for col, val in enumerate(vals):
+        fpdf.set_draw_color(*rgb(clrs[col]))
+        for num, tab in enumerate(xcol):
+            x1 = lm + 10 + (num * hw)
+            y1 = sy + ((vd / vi) * (maxs - val[num]))
+            if tab != xcol[-1]:
+                fpdf.set_line_width(.80)
+                y2 = sy + ((vd / vi) * (maxs - val[num + 1]))
+                fpdf.line(x1, y1, x1 + hw, y2)
+                fpdf.set_line_width(0)
+            if labs:
+                fpdf.drawText(vals[col][num], x1-5, y1-4, w=11, fill=1,
+                    font=["courier", "B", 8], border="TLRB")
+            fpdf.setFont("Courier", "B", 12)
+        fpdf.set_draw_color(*rgb(0))
+    # Legend
+    if len(vals) > 1 and ycol:
+        fpdf.drawText()
+        x1 = cw
+        #for col, val in enumerate(vals):
+        for x in range(len(vals) - 1, -1, -1):
+            txt = "     %s" % ycol[x]
+            wth = (len(txt) + 1) * fpdf.cwth
+            x1 -= wth
+            fpdf.drawText(txt, x=x1, y=ly+34, h=5, w=wth, border="TLRB")
+            fpdf.set_line_width(1)
+            fpdf.set_draw_color(*rgb(clrs[x]))
+            fpdf.line(x1+2, ly+36, x1+10, ly+36)
+            fpdf.set_line_width(0)
+            fpdf.set_draw_color(0)
 # END
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'std/tartanWork.py'
--- std/tartanWork.py	2016-02-27 13:18:41 +0000
+++ std/tartanWork.py	2016-04-28 09:14:17 +0000
@@ -12,19 +12,6 @@
 """
 
 #--------
-# Themes
-#--------
-stdthm = (
-    "alt",
-    "clam",
-    "classic",
-    "default",
-    "keramik",
-    "keramik_alt",
-    "plastik",
-    "winnative",
-    "xpnative")
-#--------
 # Systems
 #--------
 finsys = {

=== modified file 'std/tartanWork_rne.py'
--- std/tartanWork_rne.py	2016-02-27 13:18:41 +0000
+++ std/tartanWork_rne.py	2016-05-10 19:38:43 +0000
@@ -12,19 +12,6 @@
 """
 
 #--------
-# Themes
-#--------
-stdthm = (
-    "alt",
-    "clam",
-    "classic",
-    "default",
-    "keramik",
-    "keramik_alt",
-    "plastik",
-    "winnative",
-    "xpnative")
-#--------
 # Systems
 #--------
 finsys = {
@@ -189,7 +176,7 @@
             "CRS": ["crsmst", "crstrn", "crsrmf", "crsrtf"]},
         "codes": {
             "account_details": [["", "RW", 30, "Account Name & Address"], []],
-            "dep_pj_code": [["", "NA", 8, "Department and PJ Code"], []],
+            "dep_pj_code": [["", "NA", 10, "Department and PJ Code"], []],
             "line_amount": [["", "SD", 11.2, "Amount"], []],
             "line_set-%": [["", "UD", 5.2, "Set-Discount Percent"], []],
             "line_inc-%": [["", "UD", 5.2, "Inc-Discount Percent"], []],

=== modified file 'str/st2010.py'
--- str/st2010.py	2016-02-27 13:18:41 +0000
+++ str/st2010.py	2016-04-28 11:34:16 +0000
@@ -16,7 +16,7 @@
 import time
 from TartanClasses import ASD, Balances, CCD, GetCtl, PrintOrder, PwdConfirm
 from TartanClasses import Sql, TartanDialog
-from tartanFunctions import callModule, getVatRate, showError
+from tartanFunctions import askQuestion, callModule, getVatRate, showError
 
 class st2010:
     def __init__(self, **opts):
@@ -88,7 +88,7 @@
                 self.automu,"N",self.doAutoMkUp,None,None,None))
         self.pr = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=fld, tend=((self.doPrtEnd,"y"),), txit=(self.doPrtExit,),
-            view=("N","P"), mail=("N","Y", "Y"))
+            view=("N","P"), mail=("N","Y","Y"))
         self.opts["mf"].startLoop()
 
     def doTplNam(self, frt, pag, r, c, p, i, w):
@@ -277,6 +277,16 @@
             self.opts["conum"]), ("pom_ordno", "=", w)], limit=1)
         if not strpom:
             return "Invalid Document"
+        if strpom[self.sql.strpom_col.index("pom_delno")] == "cancel":
+            ok = askQuestion(self.opts["mf"].body, "Cancelled",
+                "This order was Cancelled.\n\nDo you want to Reinstate It?",
+                default="no")
+            if ok == "no":
+                return "Order Cancelled"
+            self.sql.updRec("strpom", cols=["pom_delno"], data=[""],
+                where=[("pom_cono", "=", self.opts["conum"]),
+                ("pom_ordno", "=", w)])
+            strpom[self.sql.strpom_col.index("pom_delno")] = ""
         if strpom[self.sql.strpom_col.index("pom_delno")]:
             return "Order Already Received"
         self.ordno = CCD(w, "UI", 9.0).work
@@ -359,14 +369,7 @@
             self.sql.updRec("strpom", cols=["pom_delno"], data=["cancel"],
                 where=[("pom_cono", "=", self.opts["conum"]), ("pom_ordno",
                 "=", self.ordno)])
-            self.sql.delRec("strpot", where=[("pot_cono", "=",
-                self.opts["conum"]), ("pot_ordno", "=", self.ordno)])
-            # COMMIT Deletetion
             self.opts["mf"].dbm.commitDbase()
-            # Print Deletetion
-            PrintOrder(self.opts["mf"], self.opts["conum"], self.opts["conam"],
-                self.ordno, tname=self.tname, repprt=self.pr.repprt,
-                repeml=self.pr.repeml, copy="d")
             # Clear totals and focus
             self.doClearTots()
             self.df.focusField("T", 0, 1)
@@ -447,8 +450,8 @@
             return "This Item is Already On This Order"
         odq = self.sql.getRec(tables=["strpom", "strpot"],
             cols=["sum(pot_qty)"], where=[("pom_cono", "=",
-            self.opts["conum"]), ("pom_loc", "=", self.loc), ("pom_delno",
-            "=", ""), ("pot_cono", "=", self.opts["conum"]),
+            self.opts["conum"]), ("pom_loc", "=", self.loc),
+            ("pom_delno", "=", ""), ("pot_cono", "=", self.opts["conum"]),
             ("pot_ordno=pom_ordno",), ("pot_group", "=", self.grp),
             ("pot_code", "=", w)], limit=1)
         if odq[0]:
@@ -777,6 +780,7 @@
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doAccept(self, widget=None):
+        self.df.setWidget(self.df.B11, "disabled")
         if self.df.col == 1:
             self.doCancel()
         else:

=== modified file 'str/st2020.py'
--- str/st2020.py	2016-02-27 13:18:41 +0000
+++ str/st2020.py	2016-04-28 11:40:34 +0000
@@ -414,6 +414,7 @@
         data = []
         for d in dat:
             try:
+                # Exclude purchase orders
                 doc = int(d[2])
                 chk = self.sql.getRec(tables="strpom", where=[("pom_cono", "=",
                     self.opts["conum"]), ("pom_ordno", "=", doc), ("pom_loc",

=== modified file 'str/st2030.py'
--- str/st2030.py	2016-02-27 13:18:41 +0000
+++ str/st2030.py	2016-04-28 11:41:45 +0000
@@ -442,7 +442,7 @@
             2)], group="stt_ref1, stt_trdt", order="stt_trdt, stt_ref1")
         iss = {
             "stype": "R",
-            "tables": ("strtrn", "strpom"),
+            "tables": ("strtrn",),
             "cols": (
                 ("stt_ref1", "", 0, "Reference"),
                 ("stt_trdt", "", 0, "Date", "Y")),

=== modified file 'str/st5040.py'
--- str/st5040.py	2016-02-27 13:18:41 +0000
+++ str/st5040.py	2016-04-01 08:25:29 +0000
@@ -14,7 +14,8 @@
 """
 
 import time
-from TartanClasses import ASD, Balances, CCD, GetCtl, Sql, TartanDialog
+from TartanClasses import ASD, Balances, CCD, GetCtl, ProgressBar, Sql
+from TartanClasses import TartanDialog
 from tartanFunctions import showError
 
 class st5040:
@@ -66,6 +67,7 @@
         self.curdt = w / 100
 
     def endPage(self):
+        self.df.closeProcess()
         col = ["stv_group", "stv_code", "stv_loc", "stv_bin", "stv_qty",
             "stv_ucost", "stv_usell"]
         recs = self.sql.getRec(tables=["strmf1", "strvar"], cols=col,
@@ -76,15 +78,18 @@
             showError(self.opts["mf"].body, "Processing Error",
             "No Records Selected")
         else:
+            p = ProgressBar(self.opts["mf"].body, typ="F", mxs=len(recs))
             for num, dat in enumerate(recs):
+                p.displayProgress(num)
                 self.updateTables(num+1, col, dat)
                 self.sql.delRec("strvar", where=[("stv_cono", "=",
                     self.opts["conum"]), ("stv_group", "=",
                     dat[col.index("stv_group")]),
                     ("stv_code", "=", dat[col.index("stv_code")]),
                     ("stv_loc", "=", dat[col.index("stv_loc")])])
-                self.opts["mf"].dbm.commitDbase()
-        self.exitPage()
+            self.opts["mf"].dbm.commitDbase()
+            p.closeProgress()
+        self.opts["mf"].closeLoop()
 
     def exitPage(self):
         self.df.closeProcess()
@@ -113,9 +118,8 @@
                 self.sql.insRec("strprc", data=[self.opts["conum"], grp, code,
                     loc, 1, sell.work])
         # Test for Variances
-        bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
-            (self.sysdtw/100), keys=(grp, code, loc, ("P",
-            self.opts["period"][0])))
+        bals = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
+            keys=(grp, code, loc, ("P", self.opts["period"][0])))
         m_ob, m_mv, m_cb, y_ob, y_mv, y_cb, ac, lc = bals.doStrBals()
         fqty = CCD(y_cb[0], "SD", 12.2)
         fval = CCD(y_cb[1], "SD", 12.2)

=== modified file 'str/st6030.py'
--- str/st6030.py	2016-02-27 13:18:41 +0000
+++ str/st6030.py	2016-03-17 12:20:35 +0000
@@ -113,8 +113,6 @@
             self.sql.updRec("strpom", cols=["pom_delno"], data=["cancel"],
                 where=[("pom_cono", "=", self.opts["conum"]), ("pom_ordno",
                 "=", rec[0])])
-            self.sql.delRec("strpot", where=[("pot_cono", "=",
-                self.opts["conum"]), ("pot_ordno", "=", rec[0])])
         self.opts["mf"].dbm.commitDbase(ask=True)
         self.opts["mf"].closeLoop()
 

=== modified file 'uty/bm1010.py'
--- uty/bm1010.py	2016-02-27 13:18:41 +0000
+++ uty/bm1010.py	2016-04-27 08:17:37 +0000
@@ -1041,10 +1041,10 @@
                 sp = SplashScreen(self.opts["mf"].body, "E-Mailing the "\
                     "Message to %s\n\nPlease Wait........ (%s of %s)" %
                     (mail[0], num+1, len(accs)))
-                err = sendMail(self.smtp, self.fadd, mail, self.subj,
+                ok = sendMail(self.smtp, self.fadd, mail, self.subj,
                     mess=(mess, html), attach=self.attach, embed=self.embed)
                 sp.closeSplash()
-                if err:
+                if not ok:
                     if self.skip == "Y":
                         ok = "SKIPPED"
                     else:

=== modified file 'uty/pkgprg.py'
--- uty/pkgprg.py	2016-03-01 14:42:33 +0000
+++ uty/pkgprg.py	2016-05-14 07:42:57 +0000
@@ -1,14 +1,8 @@
 #!/usr/bin/python
 
-import compileall
-import getopt
-import os
-import shutil
-import subprocess
-import sys
-import time
+import compileall, getopt, glob, os, shutil, subprocess, sys, time
+from tartanFunctions import findFile, sendMail
 from ms0000 import VERSION
-from tartanFunctions import findFile, sendMail
 
 def exeCmd(cmd):
     ret = 1
@@ -31,13 +25,16 @@
 windows = False
 publish = False
 email = False
-opts, args = getopt.getopt(sys.argv[1:], "b:eis:v:hwp")
+py3 = False
+opts, args = getopt.getopt(sys.argv[1:], "b:eis:v:hwp3")
 for o, v in opts:
     if o == "-h":
         print "Usage: pkgprg [-h help] -[b base directory] [-i increment] "\
             "[-s system] [-v new version] [-w windows] [-p publish] "\
-            "[-e email]"
+            "[-e email] [-3 python3]"
         sys.exit()
+    elif o == "-3":
+        py3 = True
     elif o == "-b":
         bd = v
     elif o == "-e":
@@ -78,9 +75,10 @@
 
 dirs = ["tab", "mst"]
 if system == "t":
-    exeCmd("mv %s/TartanExe/Tartan_5.?.?.tgz %s/TartanOld/" % (bd, bd))
-    if windows:
-        exeCmd("mv %s/TartanExe/Tartan_5.?.?.exe %s/TartanOld/" % (bd, bd))
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/Tartan_5.?.?.tgz %s/TartanOld/" % (bd, bd))
+        if windows:
+            exeCmd("mv %s/TartanExe/Tartan_5.?.?.exe %s/TartanOld/" % (bd, bd))
     system = "tartan"
     sysmod = "stdsys"
     modfle = "tarmod"
@@ -91,7 +89,8 @@
     custom = [""]
     exclude = ["msy030", "pw1010", "si2020", "ss1010"]
 elif system == "b":
-    exeCmd("mv %s/TartanExe/Bwlclb_5.* %s/TartanOld/" % (bd, bd))
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/Bwlclb_5.* %s/TartanOld/" % (bd, bd))
     system = "bwlclb"
     sysmod = "bwlsys"
     modfle = "tarmod"
@@ -104,7 +103,8 @@
                "ms3010", "ms3020", "msy010", "msy020", "msy030", "pm1010",
                "pw1010"]
 elif system == "s":
-    exeCmd("mv %s/TartanExe/Seccmp_5.* %s/TartanOld/" % (bd, bd))
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/Seccmp_5.* %s/TartanOld/" % (bd, bd))
     system = "seccmp"
     sysmod = "scpsys"
     modfle = "tarmod"
@@ -116,7 +116,8 @@
                "ms3010", "ms3020", "ms3030", "msy010", "msy020", "msy030",
                "pm1010", "pw1010"]
 elif system == "r":
-    exeCmd("mv %s/TartanExe/Rnehol_5.* %s/TartanOld/" % (bd, bd))
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/Rnehol_5.* %s/TartanOld/" % (bd, bd))
     system = "rnehol"
     sysmod = "rnesys"
     modfle = "tarmod"
@@ -127,7 +128,8 @@
     custom = ["rne", ["ar6020", "ar6030", "cr1010", "cr2010", "cr2020",
               "cr2030", "cr3030", "cr3070", "cr3310", "cr3320", "cr3330",
               "cr3340", "cr3350", "cr3360", "cr3370", "cr3380", "cr4010",
-              "cr6010", "gl3100", "gl3110", "gl6060", "ms1010", "tartanWork"]]
+              "cr6010", "gl3100", "gl3110", "gl3120", "gl6060", "ln2020",
+              "ms1010", "tartanWork"]]
     exclude = ["cr3080", "dr1020", "dr2030", "dr6030", "drc210", "drc220",
                "drc310", "drc320", "drc510", "drc520", "drc610", "drc620",
                "drc710", "drc810", "msy020", "si2020", "si3010", "si3070",
@@ -136,8 +138,10 @@
                "st3070", "st3080", "st3090", "st3100", "st3110", "st3120",
                "st4010", "st5010", "st5020", "st5030", "st5040", "st6010",
                "st6020", "stc220", "stc320", "stc410", "stc420", "tb1010",
-               "tb1030", "tb1040", "tb3010", "pm1010", "pw1010"]
+               "tb1030", "tb1040", "tb3010", "pw1010"]
 elif system == "c":
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/Cshana_5.* %s/TartanOld/" % (bd, bd))
     system = "cshana"
     sysmod = "cshsys"
     modfle = "tarmod"
@@ -379,6 +383,7 @@
     shutil.copy("%s/men/cshmen.py" % pypath, "%s/tmp/stdmen.py" % pypath)
     shutil.copy("%s/csv/cshsys.py" % pypath, "%s/tmp/stdsys.py" % pypath)
 os.chdir("%s/tmp" % pypath)
+# Generate zip file
 exeCmd("zip -rqm %s/TartanSve/%s *" % (bd, zipfle))
 os.chdir(os.path.join(pypath, "std"))
 if system == "rnehol":
@@ -435,39 +440,40 @@
     shutil.rmtree("%s/tmp" % pypath)
 man = system.capitalize()
 if system == "seccmp":
-    shutil.copy("doc/SC.rst", "doc/%s.rst" % man)
-elif system == "bwlclb":
-    shutil.copy("doc/MB.rst", "doc/%s.rst" % man)
+    fles = ["doc/SC.rst"]
 else:
-    fles = [
-        "doc/MD.rst",
-        "doc/GL.rst"]
-    if system == "rnehol":
-        fles.extend([
-            "doc/AR.rst",
-            "doc/CR_rne.rst",
-            "doc/DR.rst",
-            "doc/IB.rst",
-            "doc/LN.rst",
-            "doc/RT.rst",
-            "doc/SI.rst",
-            "doc/ST.rst"])
+    if system == "bwlclb":
+        fles = ["doc/MB.rst", "doc/BC.rst", "doc/UB.rst"]
     else:
-        fles.extend([
-            "doc/AR.rst",
-            "doc/BK.rst",
-            "doc/BC.rst",
-            "doc/CR.rst",
-            "doc/DR.rst",
-            "doc/LN.rst",
-            "doc/ML.rst",
-            "doc/RT.rst",
-            "doc/RC.rst",
-            "doc/SI.rst",
-            "doc/ST.rst",
-            "doc/WG.rst",
-            "doc/SL.rst"])
-    fles.extend(["doc/UD.rst", "doc/HD.rst"])
+        fles = ["doc/MD.rst"]
+        if system == "rnehol":
+            fles.extend([
+                "doc/GL_rne.rst",
+                "doc/AR.rst",
+                "doc/CR_rne.rst",
+                "doc/DR.rst",
+                "doc/IB.rst",
+                "doc/LN.rst",
+                "doc/RT.rst",
+                "doc/SI.rst",
+                "doc/ST.rst"])
+        else:
+            fles.extend([
+                "doc/GL.rst",
+                "doc/AR.rst",
+                "doc/BC.rst",
+                "doc/BK.rst",
+                "doc/CR.rst",
+                "doc/DR.rst",
+                "doc/LN.rst",
+                "doc/ML.rst",
+                "doc/RC.rst",
+                "doc/RT.rst",
+                "doc/SI.rst",
+                "doc/ST.rst",
+                "doc/WG.rst",
+                "doc/SL.rst"])
+        fles.extend(["doc/UD.rst", "doc/HD.rst"])
     doc = open("doc/%s.rst" % man, "w")
     for fle in fles:
         if fle == fles[-1]:
@@ -487,7 +493,31 @@
 exeCmd("zip -q %s/TartanSve/%s img/*.png" % (bd, zipfle))
 exeCmd("zip -q %s/TartanSve/%s uty/SumatraPDF.exe" % (bd, zipfle))
 exeCmd("zip -q %s/TartanSve/%s uty/SumatraPDF-settings.txt" % (bd, zipfle))
-# Create tgz
+if py3:
+    # Create python 3 zip file
+    shutil.rmtree("/home/paul/tartan")
+    os.mkdir("/home/paul/tartan")
+    os.chdir("/home/paul/tartan")
+    exeCmd("unzip -q %s/TartanSve/%s" % (bd, zipfle))
+    if os.path.exists("sitecustomize.py"):
+        os.remove("sitecustomize.py")
+    if os.path.exists("paramiko"):
+        shutil.rmtree("paramiko")
+    if os.path.exists("progressbar"):
+        shutil.rmtree("progressbar")
+    if os.path.exists("ghostscript"):
+        shutil.rmtree("ghostscript")
+    if os.path.exists("pychart"):
+        shutil.rmtree("pychart")
+    exeCmd("python /home/paul/Tartan-5/sdy/my2to3.py *.py")
+    exeCmd("python /home/paul/Tartan-5/sdy/my2to3.py csv/*_fld.csv")
+    exeCmd("2to3 -w --no-diffs *.py")
+    for fle in glob.glob("*.bak"):
+        os.remove(fle)
+    exeCmd("unzip -q ~/Python3/PyChart-1.39 pychart/*")
+    exeCmd("zip -qr ~/TartanSve/%s-5-py3 *" % system)
+    os.chdir(pypath)
+# Create tgz file
 if os.path.isdir("%s/prg" % bd):
     shutil.rmtree("%s/prg" % bd)
 os.mkdir("%s/prg" % bd)
@@ -512,39 +542,45 @@
     compileall.compile_dir(".", maxlevels=10, quiet=True)
     exeCmd("rm `find . -name '*.py'`")
     exeCmd("unzip -q %s/TartanSve/%s-5 ms0000.py" % (bd, system))
-exeCmd("tar -czf %s/TartanExe/%s_%s.%s.%s.tgz *" % (bd, system.capitalize(),
-    ver[0], ver[1], ver[2]))
-exeCmd("cp %s/TartanSve/%s-5.zip %s/TartanSve/%s_%s.%s.%s.zip" %
-    (bd, system, bd, system.capitalize(), ver[0], ver[1], ver[2]))
+if publish or verinc:
+    exeCmd("tar -czf %s/TartanExe/%s_%s.%s.%s.tgz *" % (bd,
+        system.capitalize(), ver[0], ver[1], ver[2]))
+    exeCmd("cp %s/TartanSve/%s-5.zip %s/TartanSve/%s_%s.%s.%s.zip" %
+        (bd, system, bd, system.capitalize(), ver[0], ver[1], ver[2]))
 if windows:
+    # Python 2 windows executable
     exeCmd("wineconsole c:/PyTartan/tartan.bat %s" % system)
-    exeCmd("mv %s/TartanExe/%s-5.exe %s/TartanExe/%s_%s.%s.%s.exe" %
-        (bd, system, bd, system.capitalize(), ver[0], ver[1], ver[2]))
-    if system == "tartan":
-        # Create CD
-        if os.path.isdir("%s/TartanCD" % bd):
-            exeCmd("rm -r %s/TartanCD" % bd)
-            exeCmd("mkdir %s/TartanCD" % bd)
-        if os.path.isdir("%s/tempcd" % bd):
-            exeCmd("rm -r %s/tempcd" % bd)
-        # Executables
-        exeCmd("mkdir %s/tempcd" % bd)
-        exeCmd("mkdir %s/tempcd/Other" % bd)
-        exeCmd("cp -p %s/TartanExe/Tartan* %s/tempcd/" % (bd, bd))
-        exeCmd("cp -pr %s/TartanWin/* %s/tempcd/Other/" % (bd, bd))
-        auto = open("%s/tempcd/AUTORUN.INF" % bd, "w")
-        auto.write("""[autorun]
-        shell\install=&Install
-        shell\install\command=Tartan_%s.%s.%s.exe
-        """ % (ver[0], ver[1], ver[2]))
-        auto.close()
-        exeCmd("todos -o %s/tempcd/AUTORUN.INF" % bd)
-        exeCmd("chmod a+x %s/tempcd/AUTORUN.INF" % bd)
-        # Add Documentation
-        exeCmd("cp -p %s/Tartan-5/doc/Manual.pdf %s/tempcd/" % (bd, bd))
-        # Make CD iso
-        exeCmd("mkisofs -r -J -l -D -V 'Tartan Systems %s.%s.%s' -p 'Paul Malherbe paul@tartan.co.za' -copyright 'Paul Malherbe' -o %s/TartanCD/Tartan.iso -graft-points /\=%s/tempcd" % (ver[0], ver[1], ver[2], bd, bd))
-        exeCmd("rm -r %s/tempcd" % bd)
+    if py3:
+        # Python 3 windows executable
+        exeCmd("wine3 wineconsole c:/PyInstall/maker.bat %s" % system)
+    if publish or verinc:
+        exeCmd("mv %s/TartanExe/%s-5.exe %s/TartanExe/%s_%s.%s.%s.exe" %
+            (bd, system, bd, system.capitalize(), ver[0], ver[1], ver[2]))
+        if system == "tartan":
+            # Create CD
+            if os.path.isdir("%s/TartanCD" % bd):
+                shutil.rmtree("%s/TartanCD" % bd)
+                exeCmd("mkdir %s/TartanCD" % bd)
+            if os.path.isdir("%s/tempcd" % bd):
+                shutil.rmtree("%s/tempcd" % bd)
+            # Executables
+            exeCmd("mkdir %s/tempcd" % bd)
+            exeCmd("mkdir %s/tempcd/Other" % bd)
+            exeCmd("cp -p %s/TartanExe/Tartan* %s/tempcd/" % (bd, bd))
+            exeCmd("cp -pr %s/TartanWin/* %s/tempcd/Other/" % (bd, bd))
+            auto = open("%s/tempcd/AUTORUN.INF" % bd, "w")
+            auto.write("""[autorun]
+            shell\install=&Install
+            shell\install\command=Tartan_%s.%s.%s.exe
+            """ % (ver[0], ver[1], ver[2]))
+            auto.close()
+            exeCmd("todos -o %s/tempcd/AUTORUN.INF" % bd)
+            exeCmd("chmod a+x %s/tempcd/AUTORUN.INF" % bd)
+            # Add Documentation
+            exeCmd("cp -p %s/Tartan-5/doc/Manual.pdf %s/tempcd/" % (bd, bd))
+            # Make CD iso
+            exeCmd("mkisofs -r -J -l -D -V 'Tartan Systems %s.%s.%s' -p 'Paul Malherbe paul@tartan.co.za' -copyright 'Paul Malherbe' -o %s/TartanCD/Tartan.iso -graft-points /\=%s/tempcd" % (ver[0], ver[1], ver[2], bd, bd))
+            shutil.rmtree("%s/tempcd" % bd)
     # Publish
     if not system == "rnehol" and publish:
         print
@@ -562,9 +598,9 @@
             exeCmd("rsync -artz %s/Tartan-5/doc/QS.rst root@mailserver:/var/www/tartan.co.za/htdocs/QuickStart/QuickStart.rst --progress" % bd)
             exeCmd("rsync -artz %s/Tartan-5/doc/Downloads.rst root@mailserver:/var/www/tartan.co.za/htdocs/Downloads/ --progress" % bd)
             exeCmd("rsync -artz %s/Tartan-5/doc/Changes.rst root@mailserver:/var/www/tartan.co.za/htdocs/Changes/ --progress" % bd)
-exeCmd("rm %s/Tartan-5/doc/%s.rst" % (bd, man))
+os.remove("%s/Tartan-5/doc/%s.rst" % (bd, man))
 # Remove Duplicate File
-exeCmd("rm %s/TartanSve/%s-5.zip" % (bd, system))
+# os.remove("%s/TartanSve/%s-5.zip" % (bd, system))
 # Email Users
 if email:
     chgfle = "%s/ver/ver_%s.%s.%s.changes" % (pypath, ver[0], ver[1], ver[2])
@@ -584,7 +620,7 @@
                 text = "%s%s" % (text, dat)
         html = "<pre>%s</pre>" % text
         mess = (text, html)
-        addrs = [
+        self.addrs = [
             "admin@amadlelo.co.za",
             "admin@blueberry.co.za",
             "brt@volmoed.co.za",
@@ -593,13 +629,16 @@
             "johnv@wpcc.co.za",
             "keith@barrowdale.co.za",
             "lawrence@hawcweb.co.za",
+            "liezel@acsconsulting.co.za",
             "lorraine@agfin.co.za",
             "marindag@buildinn-el.co.za",
             "marlene@acsonline.co.za",
+            "mcbagro@gmail.com",
             "mel@acsaccounting.co.za",
             "mike@annettelaing.co.za",
             "no2pigstash@hotmail.com",
             "paul@tartan.co.za",
+            "rob@itennis.co.za",
             "rene@hazeldean.co.za",
             "rene@agfin.co.za",
             "ruthmiles52@gmail.com",
@@ -609,6 +648,6 @@
             #"deonk@spargs.co.za",
             #"knorton@xsinet.co.za"
             #"mjredman@bigpond.net.au"
-        for addr in addrs:
+        for addr in self.addrs:
             sendMail(serv, mfrm, addr, subj, mess=(text, html))
 # END

=== modified file 'uty/rp1010.py'
--- uty/rp1010.py	2016-02-27 13:18:41 +0000
+++ uty/rp1010.py	2016-03-22 10:26:10 +0000
@@ -1070,6 +1070,7 @@
         self.ic = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=fld, tend=tnd, txit=txt)
         self.opts["mf"].startLoop()
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doInsSeq(self, frt, pag, r, c, p, i, w):
         self.insseq = w

=== modified file 'uty/td1010.py'
--- uty/td1010.py	2016-02-27 13:18:41 +0000
+++ uty/td1010.py	2016-04-26 10:49:46 +0000
@@ -175,7 +175,8 @@
             self.df.focusField("T", 0, 2)
         else:
             showWarning(self.opts["mf"].body, "Beginning of File",
-            "This is the beginning of the file.")
+                "This is the beginning of the file.")
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doDn(self, widget=None):
         acc = self.sql.getRec(tables="telmst", where=[("tdm_name", ">",
@@ -185,7 +186,8 @@
             self.df.focusField("T", 0, 2, "N")
         else:
             showWarning(self.opts["mf"].body, "End of File",
-            "You have reached the end of the file.")
+                "You have reached the end of the file.")
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doContacts(self, widget=None):
         # Display contacts and allow adding, editing etc.
@@ -210,7 +212,7 @@
         self.chg = SelectChoice(self.df.mstFrame, titl=titl, cols=cols,
             data=recs, butt=butt, sort=False)
         self.df.enableButtonsTags(state=state)
-        if not self.contyp and self.chg.selection[1]:
+        if not self.contyp and self.chg.selection:
             self.contyp = "chg"
             self.conchg = self.chg.selection[1:]
         if self.contyp in ("add", "chg"):
@@ -394,7 +396,7 @@
                         "=", data[0])])
                 con = rec[col.index("crm_mgr")]
                 eml = rec[col.index("crm_mgr_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Manager", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -407,7 +409,7 @@
                             ("tdc_contact", "=", con)])
                 con = rec[col.index("crm_acc")]
                 eml = rec[col.index("crm_acc_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Accounts", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -420,7 +422,7 @@
                             ("tdc_contact", "=", con)])
                 con = rec[col.index("crm_ord")]
                 eml = rec[col.index("crm_ord_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Orders", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -459,7 +461,7 @@
                         "=", data[0])])
                 con = rec[col.index("drm_mgr")]
                 eml = rec[col.index("drm_mgr_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Manager", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -472,7 +474,7 @@
                             ("tdc_contact", "=", con)])
                 con = rec[col.index("drm_acc")]
                 eml = rec[col.index("drm_acc_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Accounts", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -485,7 +487,7 @@
                             ("tdc_contact", "=", con)])
                 con = rec[col.index("drm_sls")]
                 eml = rec[col.index("drm_sls_email")]
-                if con:
+                if eml:
                     data = [nam, con, "Orders", "", "", eml]
                     chk = self.sql.getRec(tables="telcon", cols=["count(*)"],
                         where=[("tdc_name", "=", nam), ("tdc_contact", "=",
@@ -679,7 +681,7 @@
                             repeml=self.notes.df.repeml)
             self.df.setWidget(self.df.mstFrame, state="show")
             self.df.enableButtonsTags(state=state)
-            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
+        self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def prGrp(self, frt, pag, r, c, p, i, w):
         self.prgrp = w

=== modified file 'wag/wg3010.py'
--- wag/wg3010.py	2016-02-27 13:18:41 +0000
+++ wag/wg3010.py	2016-05-15 05:54:33 +0000
@@ -76,9 +76,8 @@
                 return
             col = sql.wagmst_col
             dic = sql.wagmst_dic
-            self.fpdf = MyFpdf(name=__name__, prog=__name__, head=80)
-            self.fpdf.header = self.header
-            self.fpdf.alias_nb_pages()
+            self.fpdf = MyFpdf(name=__name__, head=80, auto=True, foot=True)
+            self.fpdf.header = self.doHead
             self.fpdf.set_font("Courier", "B", 12)
             cwth = self.fpdf.get_string_width("X")
             for rec in recs:
@@ -140,7 +139,7 @@
                 opts=opts, repprt=self.df.repprt, repeml=self.df.repeml)
         self.closeProcess()
 
-    def header(self):
+    def doHead(self):
         cdes = "%-30s" % self.opts["conam"]
         self.fpdf.drawText(cdes, font=["courier", "B", 24])
         self.fpdf.drawText(font=["courier", "B", 14])

=== modified file 'wag/wg3030.py'
--- wag/wg3030.py	2016-02-27 13:18:41 +0000
+++ wag/wg3030.py	2016-05-09 07:13:32 +0000
@@ -129,6 +129,9 @@
         if uifa:
             uifa = CCD(uifa, "SD", 13.2)
             uifp = CCD(int(uifa.work * 100.0) / uifr, "SD", 13.2)
+        else:
+            uifa = CCD(0, "SD", 13.2)
+            uifp = CCD(0, "SD", 13.2)
         # Print the Report
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")

