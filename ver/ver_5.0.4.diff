=== modified file 'ass/ar2020.py'
--- ass/ar2020.py	2014-12-30 15:37:38 +0000
+++ ass/ar2020.py	2015-01-20 07:55:50 +0000
@@ -245,6 +245,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
         if self.new == "y":
             self.trnmov = 1

=== modified file 'ass/ar2030.py'
--- ass/ar2030.py	2014-12-30 15:37:38 +0000
+++ ass/ar2030.py	2015-01-27 16:01:08 +0000
@@ -86,14 +86,13 @@
             recs = self.sql.getRec(tables="assmst", where=[("asm_cono", "=",
                 self.opts["conum"])])
         if recs:
+            abort = False
             if not self.args:
                 p = ProgressBar(self.opts["mf"].body, mxs=len(recs),
                     typ="Raising Depreciation ... Please Wait")
             for num, dat in enumerate(recs):
                 if not self.args:
-                    can = p.displayProgress(num)
-                    if can == "yes":
-                        break
+                    p.displayProgress(num)
                 self.group = CCD(dat[self.sql.assmst_col.index("asm_group")],
                     "UA", 3)
                 grp = self.sql.getRec(tables="assgrp", where=[("asg_cono", "=",
@@ -103,7 +102,7 @@
                     if not self.args:
                         showError(self.opts["mf"].body, "Group Error",
                             "Missing Group (%s) Record" % self.group.disp)
-                    can = "yes"
+                    abort = True
                     break
                 self.depacc = grp[self.sql.assgrp_col.index("asg_depacc")]
                 self.expacc = grp[self.sql.assgrp_col.index("asg_expacc")]
@@ -137,10 +136,10 @@
                     self.lurdt = self.doIncrCurdt()
             if not self.args:
                 p.closeProgress()
-                if can == "yes":
-                    self.opts["mf"].dbm.rollbackDbase()
-                else:
-                    self.opts["mf"].dbm.commitDbase()
+            if abort:
+                self.opts["mf"].dbm.rollbackDbase()
+            else:
+                self.opts["mf"].dbm.commitDbase()
         if not self.args:
             self.opts["mf"].closeLoop()
 

=== modified file 'ass/ar3010.py'
--- ass/ar3010.py	2014-12-30 15:37:38 +0000
+++ ass/ar3010.py	2015-01-27 16:15:38 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %49s %10s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.asstrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -148,16 +150,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'ass/ar3020.py'
--- ass/ar3020.py	2014-12-30 15:37:38 +0000
+++ ass/ar3020.py	2015-01-27 13:40:28 +0000
@@ -156,11 +156,8 @@
         self.pglin = 999
         tc = self.sql.asstrn_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             trtp = CCD(dat[tc.index("ast_type")], "UI", 2)
             batch = CCD(dat[tc.index("ast_batch")], "Na", 7)
@@ -211,17 +208,16 @@
             self.gvat[trtp.work -1] = float(ASD(self.gvat[trtp.work -1]) + \
                 ASD(vat.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'ass/ar3030.py'
--- ass/ar3030.py	2014-12-30 15:37:38 +0000
+++ ass/ar3030.py	2015-01-27 13:40:28 +0000
@@ -119,11 +119,8 @@
         self.pglin = 999
         mc = self.sql.assmst_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             self.grp = CCD(dat[mc.index("asm_group")], "UA", 3)
             self.cod = CCD(dat[mc.index("asm_code")], "Na", 7)
@@ -166,12 +163,13 @@
                     oldgrp = self.grp.work
                     oldcod = self.cod.work
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'ass/ar3040.py'
--- ass/ar3040.py	2014-12-30 15:37:38 +0000
+++ ass/ar3040.py	2015-01-27 13:40:28 +0000
@@ -145,8 +145,9 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
+                p.closeProgress()
                 return
             if not num:
                 desc = self.groupDesc(dat[0])
@@ -197,11 +198,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[0], "UA", 3)
             code = CCD(dat[1], "Na", 7)
@@ -224,16 +222,15 @@
             self.pglin += 1
             self.oldgrp = grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                if self.pglin > (self.fpdf.lpp - 2):
-                    self.pageHeading(grp)
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.groupTotal()
+            if self.pglin > (self.fpdf.lpp - 2):
+                self.pageHeading(grp)
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         bals = Balances(self.opts["mf"], "ASS", self.opts["conum"], self.sper,

=== modified file 'ass/ar3050.py'
--- ass/ar3050.py	2014-12-30 15:37:38 +0000
+++ ass/ar3050.py	2015-01-27 16:02:20 +0000
@@ -39,10 +39,10 @@
     def mainProcess(self):
         data = []
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
-            mxs=len(self.notes.data))
+            mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -59,7 +59,7 @@
                 else:
                     data.append(["", "", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Asset Register Notes Listing"]
             cols = [

=== modified file 'bkm/bk1010.py'
--- bkm/bk1010.py	2015-01-01 12:48:11 +0000
+++ bkm/bk1010.py	2015-02-05 15:31:21 +0000
@@ -14,8 +14,9 @@
 """
 
 import datetime, time
-from TartanClasses import CCD, GetCtl, ScrollGrid, SplashScreen, Sql, ToolTip
-from tartanFunctions import callModule, dateDiff, projectDate
+from TartanClasses import CCD, GetCtl, MyMessageBox, ScrollGrid, SelectChoice
+from TartanClasses import Sql
+from tartanFunctions import callModule, dateDiff, projectDate, showError
 
 class bk1010:
     def __init__(self, **opts):
@@ -38,7 +39,6 @@
         self.sql = Sql(self.opts["mf"].dbm, tables=tabs, prog=__name__)
         t = time.localtime()
         self.sysdtw = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.curdt = self.sysdtw / 100
         self.tt = None
         return True
 
@@ -46,33 +46,55 @@
         self.number = 0
         self.ptyp = None
         self.newb = False
-        starter = projectDate(self.sysdtw, 7, "-")
-        ender = projectDate(starter, 365)
-        days = dateDiff(starter, ender, "days") + 1
-        units = self.sql.getRec(tables="bkmunm", where=[("bum_cono",
-            "=", self.opts["conum"]), ("bum_room", "<>", 999)],
+        udics = {}
+        self.start = projectDate(self.sysdtw, 7, "-")
+        bkm = self.sql.getRec(tables="bkmmst", cols=["max(bkm_depart)"],
+            where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_state",
+            "<>", "X")], limit=1)
+        if not bkm or bkm[0] is None:
+            days = 15
+        else:
+            days = dateDiff(self.start, bkm[0], "days") + 1
+        bkmunm = self.sql.getRec(tables="bkmunm", where=[("bum_cono",
+            "=", self.opts["conum"]), ("bum_maxg", "<>", 999)],
             order="bum_btyp, bum_code")
-        udics = {}
-        for unit in units:
-            if unit[1] == "A" and unit[2] == "ALL":
+        if not bkmunm:
+            showError(self.opts["mf"].body, "Units", "No Units in the Database")
+            self.quit = True
+            return
+        col = self.sql.bkmunm_col
+        for unit in bkmunm:
+            t = unit[col.index("bum_btyp")]
+            c = unit[col.index("bum_code")]
+            d = unit[col.index("bum_desc")]
+            m = unit[col.index("bum_maxg")]
+            if t == "A" and c == "ALL":
                 continue
-            udics["%s-%s" % (unit[1], unit[2])] = \
-                [unit[3], CCD(unit[5], "UI", 3).disp] + [""] * days
-        books = self.sql.getRec(tables="bkmmst", cols=["bkm_number",
-            "bkm_btype", "bkm_arrive", "bkm_depart", "bkm_units",
-            "bkm_state"], where=[("bkm_cono", "=", self.opts["conum"]),
-            ("bkm_arrive", "<=", ender), ("bkm_depart", ">=", starter),
-            ("bkm_state", "<>", "X")])
+            udics["%s-%s" % (t, c)] = [d, CCD(m, "UI", 3).disp] + [""] * days
+        books = self.sql.getRec(tables="bkmmst",
+            cols=[
+                "bkm_number",
+                "bkm_btype",
+                "bkm_arrive",
+                "bkm_depart",
+                "bkm_state"],
+            where=[
+                ("bkm_cono", "=", self.opts["conum"]),
+                ("bkm_depart", ">=", self.start),
+                ("bkm_state", "<>", "X")])
         for book in books:
-            if book[2] < starter:
-                book[2] = starter
-            if book[3] > ender:
-                book[3] = ender
-            sday = dateDiff(starter, book[2], "days")
-            eday = dateDiff(starter, book[3], "days")
+            if book[2] < self.start:
+                book[2] = self.start
+            sday = dateDiff(self.start, book[2], "days")
+            eday = dateDiff(self.start, book[3], "days")
             if book[1] == "O":
                 eday += 1
-            units = book[4].split(":")
+            bkmrtt = self.sql.getRec(tables="bkmrtt", cols=["brt_utype",
+                "brt_ucode"], where=[("brt_cono", "=", self.opts["conum"]),
+                ("brt_number", "=", book[0])])
+            units = []
+            for rtt in bkmrtt:
+                units.append("%s-%s" % tuple(rtt))
             if "A-ALL" in units:
                 whole = True
                 units.remove("A-ALL")
@@ -85,29 +107,34 @@
                 if not unit in udics:
                     continue
                 for d in xrange(sday, eday):
-                    if book[5] == "Q":
+                    if book[4] == "Q":
                         udics[unit][d+2] = "Query|%s" % book[0]
-                    elif book[5] == "C":
+                    elif book[4] == "C":
                         udics[unit][d+2] = "Confirmed|%s" % book[0]
-                    elif book[5] == "S":
+                    elif book[4] == "S":
                         udics[unit][d+2] = "Settled|%s" % book[0]
         titl = "Bookings Calendar"
         labs = (
-            ("Code", 9),
+            ("Code", 8),
             ("Description", 30),
-            ("Qty", 3))
+            ("Qty", 4))
         tags = [
-            ("blank", ("black", "white")),
-            ("confirm", ("black", "lightblue")),
-            ("label", ("black", "lightgray")),
-            ("query", ("black", "pink")),
-            ("settle", ("white", "blue"))]
+            ("blank", (
+                "black", "white")),
+            ("label", (
+                "black", "lightgray")),
+            ("query", (
+                self.opts["mf"].rcdic["qfg"], self.opts["mf"].rcdic["qbg"])),
+            ("confirm", (
+                self.opts["mf"].rcdic["cfg"], self.opts["mf"].rcdic["cbg"])),
+            ("settle", (
+                self.opts["mf"].rcdic["sfg"], self.opts["mf"].rcdic["sbg"]))]
         cols = [[]]
         for x in xrange(days):
-            d1 = CCD(projectDate(starter, x), "D1", 10)
-            d2 = datetime.date(
-                d1.work / 10000, d1.work / 100 % 100, d1.work % 100)
-            cols[0].append(("%s\n%s" % (d1.disp, d2.strftime("%A")), 10))
+            d1 = CCD(projectDate(self.start, x), "D1", 10)
+            d2 = time.strftime("%A", time.strptime(str(d1.work), "%Y%m%d"))
+            txt = "%s\n%s" % ("{:^10}".format(d2), d1.disp)
+            cols[0].append((txt, 10))
         keys = udics.keys()
         keys.sort()
         data = []
@@ -117,7 +144,16 @@
             qty = ("%-s" % udics[key][1], "label")
             lab = (cod, des, qty)
             col = []
+            lst = None
+            spn = 1
             for c, d in enumerate(udics[key][2:]):
+                if d == lst:
+                    spn += 1
+                    continue
+                if not lst is None:
+                    col.append((txt, tag, spn))
+                    spn = 1
+                lst = d
                 if not d:
                     num = 0
                     txt = "\n"
@@ -131,27 +167,37 @@
                         tag = "confirm"
                     elif txt.count("Settle"):
                         tag = "settle"
-                col.append((txt, tag))
+            if spn > 300:
+                col.append((txt, tag, 300))
+                col.append((txt, tag, spn - 300))
+            else:
+                col.append((txt, tag, spn))
             data.append((lab, col))
         mess = """Generating the Bookings Calendar
 
 This Could Take a While
 
 Please Wait ..........."""
+        butt = [
+            ("New Booking", self.doNew),
+            ("Search Bookings", self.doSch),
+            ("Deposits List", (self.doRep, "D")),
+            ("Arrivals List", (self.doRep, "L")),
+            ("Exit", self.doExit)]
+        cmds = [
+            ("<Double-1>", self.doBkm),
+            ("<Button-3>", self.doEnq)]
         self.cal = ScrollGrid(**{"mf": self.opts["mf"], "titl": titl,
             "chgt": 2, "labs": labs, "tags": tags, "cols": cols,
-            "data": data, "font": ("Arial", self.opts["mf"].rcdic["dfs"]),
-            "butt": [("New Booking", self.doNew), ("Deposits List",
-            (self.doRep, "D")), ("Arrivals List", (self.doRep, "L")),
-            ("Exit", self.doExit)], "bcmd": self.doBrowse,
-            "hcmd": self.doHover, "splash": mess, "loop": False})
+            "data": data, "font": (self.opts["mf"].rcdic["mft"],
+            self.opts["mf"].rcdic["dfs"]), "butt": butt, "cmds": cmds,
+            "loop": False, "mess": mess, "minc": 14})
         self.opts["mf"].startLoop()
         if self.tt:
             self.tt.hideTip()
             self.tt = None
-        self.cal.window.withdraw()
         self.cal.window.destroy()
-        self.sp.closeSplash()
+        self.opts["mf"].setThemeFont()
         if not self.ptyp and not self.quit:
             callModule(self.opts["mf"], None, "bk1020",
                 coy=(self.opts["conum"], self.opts["conam"]),
@@ -167,69 +213,99 @@
 
     def doExit(self, event=None):
         self.quit = True
-        self.doSplash()
         self.opts["mf"].closeLoop()
 
     def doNew(self, *args):
         self.newb = True
-        self.doSplash()
         self.opts["mf"].closeLoop()
 
+    def doSch(self, *args):
+        cols = [
+            ("bkno", "Number", 7, "UI"),
+            ("sname", "Surname", 20, "TX", "Y"),
+            ("names", "Names", 20, "TX"),
+            ("group", "Group", 30, "TX"),
+            ("arrive", "Arrival-Dt", 10, "D1")]
+        data = self.sql.getRec(
+            tables=["bkmmst", "bkmcon"],
+            cols=[
+                "bkm_number", "bkc_sname", "bkc_names",
+                "bkm_group", "bkm_arrive"],
+            where=[
+                ("bkm_cono", "=", self.opts["conum"]),
+                ("bkm_depart", ">=", self.start),
+                ("bkc_cono=bkm_cono",),
+                ("bkc_ccode=bkm_ccode",)],
+            order="bkc_sname, bkc_names")
+        sc = SelectChoice(self.cal.window, "Select Booking", cols, data)
+        if sc.selection:
+            self.number = int(sc.selection[1])
+            self.opts["mf"].closeLoop()
+        else:
+            self.number = None
+
     def doRep(self, *args):
         self.ptyp = args[0]
-        self.doSplash()
         self.opts["mf"].closeLoop()
 
-    def doBrowse(self, *args):
-        number = args[0][1].split("\n")
+    def doEnq(self, *args):
+        number = args[1].split("\n")
+        if number[0]:
+            number = int(number[0])
+        else:
+            return
+        data = self.sql.getRec(tables=["bkmmst", "bkmcon"], cols=["bkc_sname",
+            "bkc_names", "bkm_group", "bkm_guests", "bkm_state", "bkm_value",
+            "bkm_stddep", "bkm_remarks"], where=[("bkm_cono", "=",
+            self.opts["conum"]), ("bkm_number", "=", number),
+            ("bkc_cono=bkm_cono",), ("bkc_ccode=bkm_ccode",)], limit=1)
+        name = "%s, %s" % (data[0], data[1])
+        text = "%-10s %s" % ("Name:", name)
+        if data[2]:
+            text = "%s\n%-10s %s" % (text, "Group:", data[2])
+        text = "%s\n%-10s %s" % (text, "Guests:", data[3])
+        val = CCD(data[5], "SD", 11.2).disp
+        text = "%s\n\n%-10s R%s" % (text, "Value:", val)
+        if data[4] == "Q":
+            dep = CCD(data[6], "SD", 11.2).disp
+            text = "%s\n%-10s R%s" % (text, "Deposit:", dep)
+        else:
+            bal = self.sql.getRec(tables="bkmtrn",
+                cols=["sum(bkt_tramt)"], where=[("bkt_cono", "=",
+                self.opts["conum"]), ("bkt_number", "=", number),
+                ("bkt_type", "<>", 1)], limit=1)
+            if bal[0] is None:
+                if data[4] == "C":
+                    bal = CCD(data[5], "SD", 11.2).disp
+                else:
+                    bal = CCD(0, "SD", 11.2).disp
+            elif not bal[0] and data[4] == "C":
+                bal = CCD(data[5], "SD", 11.2).disp
+            else:
+                bal = CCD(bal[0], "SD", 11.2).disp
+            text = "%s\n%-10s R%s" % (text, "Balance:", bal)
+            if data[7]:
+                text = "%s\n\n%s" % (text, data[7])
+        mbox = MyMessageBox(args[2][0], "info", "Booking %s" % number,
+            text, plc=False)
+        cp = list(args[2][1])
+        fp = args[2][0].winfo_geometry().split("+")[0].split("x")
+        rp = (mbox.frame.winfo_reqwidth(), mbox.frame.winfo_reqheight())
+        if cp[0] + int(rp[0]) > int(fp[0]):
+            cp[0] = int(fp[0]) - int(rp[0])
+        if cp[1] + int(rp[1]) > int(fp[1]):
+            cp[1] = int(fp[1]) - int(rp[1])
+        mbox.frame.place(x=cp[0], y=cp[1])
+        mbox.frame.update_idletasks()
+        mbox.frame.grab_set()
+        self.opts["mf"].startLoop()
+
+    def doBkm(self, *args):
+        number = args[1].split("\n")
         if number[0]:
             self.number = int(number[0])
-            self.doSplash()
             self.opts["mf"].closeLoop()
         else:
             self.number = None
 
-    def doHover(self, *args):
-        if self.tt and args[0][0] is None:
-            self.tt.hideTip()
-            self.tt = None
-        elif args[0][0]:
-            number = args[0][1].split("\n")
-            if number[0]:
-                number = int(number[0])
-                data = self.sql.getRec(tables=["bkmmst", "bkmcon"],
-                    cols=["bkc_sname", "bkc_names", "bkm_group",
-                    "bkm_state", "bkm_value", "bkm_stddep"],
-                    where=[("bkm_cono", "=", self.opts["conum"]),
-                    ("bkm_number", "=", number), ("bkc_cono=bkm_cono",),
-                    ("bkc_ccode=bkm_ccode",)], limit=1)
-                name = "%s, %s" % (data[0], data[1])
-                text = "%-10s %s" % ("Name:", name)
-                if data[2]:
-                    text = "%s\n%-10s %s" % (text, "Group:", data[2])
-                val = CCD(data[4], "SD", 11.2).disp
-                text = "%s\n%-10s R%s" % (text, "Value:", val)
-                if data[3] == "Q":
-                    dep = CCD(data[5], "SD", 11.2).disp
-                    text = "%s\n%-10s R%s" % (text, "Deposit:", dep)
-                else:
-                    bal = self.sql.getRec(tables="bkmtrn",
-                        cols=["sum(bkt_tramt)"], where=[("bkt_cono", "=",
-                        self.opts["conum"]), ("bkt_number", "=", number),
-                        ("bkt_type", "<>", 1)], limit=1)
-                    if bal[0] is None:
-                        bal = CCD(0, "SD", 11.2).disp
-                    else:
-                        bal = CCD(bal[0], "SD", 11.2).disp
-                    text = "%s\n%-10s R%s" % (text, "Balance:", bal)
-                self.tt = ToolTip(args[0][2].widget, text,
-                    font=("Courier", self.cal.fs, "bold"),
-                    color=("black", "white"))
-                self.tt.showTip(args[0][2])
-
-    def doSplash(self):
-        self.sp = SplashScreen(None, """Closing the Calendar
-
-Please Wait .....""")
-
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'bkm/bk1020.py'
--- bkm/bk1020.py	2015-01-01 12:48:11 +0000
+++ bkm/bk1020.py	2015-02-05 07:46:50 +0000
@@ -11,7 +11,6 @@
         self.edit   - editing the booking
         self.trans  - created a transaction
         self.ender  - self.doEnd has been executed for page 2
-        self.found  - existing bkmrtt record
         self.inv    - booking has been invoiced
         self.mprint - print statement of movements
         self.newcon - new contacts record
@@ -30,8 +29,8 @@
 from TartanClasses import PrintBookingInvoice, SelectChoice, TartanDialog
 from TartanClasses import Sql, TabPrt
 from tartanFunctions import askQuestion, callModule, dateDiff, doPrinter
-from tartanFunctions import getModName, getVatRate, projectDate, showError
-from tartanFunctions import textFormat
+from tartanFunctions import getFileName, getModName, getVatRate, projectDate
+from tartanFunctions import showError, textFormat
 from tartanWork import bktrtp, mthnam
 
 class bk1020:
@@ -107,9 +106,6 @@
                 ("bkc_cono=bkm_cono",),
                 ("bkc_ccode=bkm_ccode",)],
             "order": "bkc_sname, bkm_arrive"}
-        unt = {
-            "stype": "M",
-            "func": self.showUnits}
         bkc = {
             "stype": "R",
             "tables": ("bkmcon",),
@@ -117,7 +113,7 @@
                 ("bkc_ccode", "", 0, "Code"),
                 ("bkc_title", "", 0, "Title"),
                 ("bkc_sname", "", 0, "Surname", "Y"),
-                ("bkc_names", "", 0, "Names", "Y")),
+                ("bkc_names", "", 0, "Names", "F")),
             "where": [
                 ("bkc_cono", "=", self.opts["conum"])],
             "order": "bkc_sname"}
@@ -125,6 +121,9 @@
             ("Accommodation","A"),
             ("Other","O"))
         r2s = (
+            ("Continue","C"),
+            ("Edit","E"))
+        r3s = (
             ("Enquiry","Q"),
             ("Confirmed","C"),
             ("Settled","S"),
@@ -145,8 +144,10 @@
                 0,"N",self.doDate,None,None,("efld",)),
             (("T",1,5,0),"ID1",10,"Departure (YYYYMMDD)","",
                 0,"N",self.doDate,None,None,("efld",)),
-            (("T",1,6,0),"ITX",50,"Allocated Units","",
-                "","N",self.doUnits,unt,None,("notblank",)),
+            (("T",1,6,0),("IRB",r2s),0,"Units","",
+                "C","N",self.doUnits,None,None,None),
+            #(("T",1,6,86),"OTv",(45,2),""),
+            (("T",1,6,0),"OTv",45,""),
             (("T",1,7,0),"OSD",11.2,"Value"),
             (("T",1,8,0),"ISD",11.2,"Initial Deposit","",
                 0,"N",self.doDeposit,None,None,None),
@@ -157,9 +158,9 @@
             (("T",1,11,0),"Id1",10,"Additional Dep Due","",
                 0,"N",self.doDepdate,None,None,None),
             (("T",1,12,0),"OSD",11.2,"Account Balance"),
-            (("T",1,13,0),"ITX",50,"Remarks","",
-                "","N",self.doRequests,None,None,None),
-            (("T",1,14,0),("ORB",r2s),0,"Booking Status"),
+            (("T",1,13,0),"ITX",65,"Remarks","",
+                "","N",self.doRemarks,None,None,None),
+            (("T",1,14,0),("ORB",r3s),0,"Booking Status"),
             (("T",2,0,0),"IUA",7,"Contact Code","",
                 "","N",self.doContact,bkc,None,None),
             (("T",2,1,0),"ITX",6,"Title","",
@@ -254,43 +255,55 @@
                 self.number = 0
                 self.state = "Q"
                 self.newmst = True
-                self.units = None
-                self.df.loadEntry(frt, pag, p+14, data=self.state)
+                self.units = ""
+                self.df.loadEntry("T", 1, 6, data="E")
+                self.df.loadEntry(frt, pag, p+15, data=self.state)
                 return
         self.oldmst = self.sql.getRec(tables="bkmmst", where=[("bkm_cono",
             "=", self.opts["conum"]), ("bkm_number", "=", w)], limit=1)
         if not self.oldmst:
             return "Invalid Booking Number"
+        inv = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
+            self.opts["conum"]), ("bkt_number", "=", w), ("bkt_type", "=", 2)])
+        if inv:
+            self.inv = True
         self.number = w
         self.newmst = False
         self.newcon = False
-        self.state = self.oldmst[self.sql.bkmmst_col.index("bkm_state")]
+        self.ender = True
         self.btype = self.oldmst[self.sql.bkmmst_col.index("bkm_btype")]
+        self.df.loadEntry("T", 1, 1, data=self.btype)
         self.group = self.oldmst[self.sql.bkmmst_col.index("bkm_group")]
+        self.df.loadEntry("T", 1, 2, data=self.group)
         self.guests = self.oldmst[self.sql.bkmmst_col.index("bkm_guests")]
+        self.df.loadEntry("T", 1, 3, data=self.guests)
         self.arrive = self.oldmst[self.sql.bkmmst_col.index("bkm_arrive")]
+        self.df.loadEntry("T", 1, 4, data=self.arrive)
         self.depart = self.oldmst[self.sql.bkmmst_col.index("bkm_depart")]
+        self.df.loadEntry("T", 1, 5, data=self.depart)
+        if self.btype == "A":
+            self.bdays = dateDiff(self.arrive, self.depart, "days")
+        else:
+            self.bdays = dateDiff(self.arrive, self.depart, "days") + 1
+        self.df.loadEntry("T", 1, 6, data="C")
         self.units = self.oldmst[self.sql.bkmmst_col.index("bkm_units")]
+        self.df.loadEntry("T", 1, 7, data=self.units)
         self.value = self.oldmst[self.sql.bkmmst_col.index("bkm_value")]
+        self.df.loadEntry("T", 1, 8, data=self.value)
         self.stddep = self.oldmst[self.sql.bkmmst_col.index("bkm_stddep")]
+        self.df.loadEntry("T", 1, 9, data=self.stddep)
         self.stddte = self.oldmst[self.sql.bkmmst_col.index("bkm_stddte")]
+        self.df.loadEntry("T", 1, 10, data=self.stddte)
         self.grpdep = self.oldmst[self.sql.bkmmst_col.index("bkm_grpdep")]
+        self.df.loadEntry("T", 1, 11, data=self.grpdep)
         self.grpdte = self.oldmst[self.sql.bkmmst_col.index("bkm_grpdte")]
-        self.special = self.oldmst[self.sql.bkmmst_col.index("bkm_special")]
-        for num, dat in enumerate(self.oldmst[1:]):
-            if num == 14:
-                self.ccode = dat
-            elif num > 11:
-                if num == 12:
-                    self.df.loadEntry("T", 1, num, data=self.getBalance().work)
-                self.df.loadEntry("T", 1, num+1, data=dat)
-            else:
-                self.df.loadEntry("T", 1, num, data=dat)
-        inv = self.sql.getRec(tables="bkmtrn", where=[("bkt_cono", "=",
-            self.opts["conum"]), ("bkt_number", "=", self.number),
-            ("bkt_type", "=", 2)])
-        if inv:
-            self.inv = True
+        self.df.loadEntry("T", 1, 12, data=self.grpdte)
+        self.df.loadEntry("T", 1, 13, data=self.getBalance().work)
+        self.remarks = self.oldmst[self.sql.bkmmst_col.index("bkm_remarks")]
+        self.df.loadEntry("T", 1, 14, data=self.remarks)
+        self.state = self.oldmst[self.sql.bkmmst_col.index("bkm_state")]
+        self.df.loadEntry("T", 1, 15, data=self.state)
+        self.ccode = self.oldmst[self.sql.bkmmst_col.index("bkm_ccode")]
         self.oldcon = self.sql.getRec(tables="bkmcon", where=[("bkc_cono",
             "=", self.opts["conum"]), ("bkc_ccode", "=", self.ccode)], limit=1)
         self.title = self.oldcon[self.sql.bkmcon_col.index("bkc_title")]
@@ -314,7 +327,7 @@
                     self.df.loadEntry(frt, pag, p, data=self.btype)
                     return "Invalid Type"
                 self.doUnBook()
-                for x in xrange(6, 14):
+                for x in xrange(7, 15):
                     self.df.loadEntry("T", 1, x, data="")
         self.btype = w
 
@@ -325,7 +338,7 @@
         self.sql.delRec("bkmrtt", where=[("brt_cono", "=", self.opts["conum"]),
             ("brt_number", "=", self.number)])
         self.units = ""
-        self.df.loadEntry("T", 1, 6, data=self.units)
+        self.df.loadEntry("T", 1, 7, data=self.units)
 
     def doGroup(self, frt, pag, r, c, p, i, w):
         self.group = w
@@ -347,157 +360,310 @@
                 return "Invalid Date, Before Arrival Date"
             if self.btype == "A" and self.depart == self.arrive:
                 return "Arrival and Departure Dates are the Same"
-
-    def showUnits(self, f1=True):
-        # Get Available Units
-        col = self.sql.bkmunm_col
-        where = [("bum_cono", "=", self.opts["conum"])]
-        if self.btype == "O":
-            where.append(("bum_btyp", "=", self.btype))
-        recs = self.sql.getRec(tables="bkmunm", where=where,
-            order="bum_btyp, bum_code")
-        self.aunits = {}
-        whole = False
-        for rec in recs:
-            typ = rec[col.index("bum_btyp")]
-            cod = rec[col.index("bum_code")]
-            des = rec[col.index("bum_desc")]
-            rms = rec[col.index("bum_room")]
-            qty = rec[col.index("bum_maxg")]
-            unt = "%s-%s" % (typ, cod)
-            if cod == "ALL":
-                whole = [des, qty]
-            else:
-                self.aunits[unt] = {"desc": des, "qty": qty, "rms": {}}
-                for r in range(1, rms+1):
-                    self.aunits[unt]["rms"][r] = True
-        bks = self.sql.getRec(tables=["bkmmst", "bkmrtt"],
-            cols=[
-                "bkm_arrive",
-                "bkm_depart",
-                "brt_utype",
-                "brt_ucode",
-                "brt_uroom",
-                "brt_quant"],
-            where=[
-                ("bkm_cono", "=", self.opts["conum"]),
-                ("bkm_number", "<>", self.number),
-                ("bkm_state", "<>", "X"),
-                ("brt_cono=bkm_cono",),
-                ("brt_number=bkm_number",)],
-            order="bkm_arrive, brt_utype, brt_ucode, brt_uroom")
-        self.used = []
-        for bk in bks:
-            u = False
             if self.btype == "A":
-                if bk[0] < self.depart and self.arrive < bk[1]:
-                    u = True
+                self.bdays = dateDiff(self.arrive, self.depart, "days")
             else:
-                if bk[0] <= self.depart and self.arrive <= bk[1]:
-                    u = True
-            if u and not bk[4] == 999:
+                self.bdays = dateDiff(self.arrive, self.depart, "days") + 1
+
+    def doUnits(self, frt, pag, r, c, p, i, w):
+        if w == "E":
+            col = self.sql.bkmunm_col
+            where = [("bum_cono", "=", self.opts["conum"])]
+            if self.btype == "O":
+                where.append(("bum_btyp", "=", self.btype))
+            recs = self.sql.getRec(tables="bkmunm", where=where,
+                order="bum_btyp, bum_code")
+            self.aunits = {}
+            whole = False
+            for rec in recs:
+                typ = rec[col.index("bum_btyp")]
+                cod = rec[col.index("bum_code")]
+                des = rec[col.index("bum_desc")]
+                rms = rec[col.index("bum_room")]
+                qty = rec[col.index("bum_maxg")]
+                unt = "%s-%s" % (typ, cod)
+                if typ == "A" and cod == "ALL":
+                    whole = [des, qty]
+                else:
+                    self.aunits[unt] = {"desc": des, "qty": qty, "rms": {}}
+                    if typ == "A":
+                        for r in range(1, rms+1):
+                            self.aunits[unt]["rms"][r] = True
+            bks = self.sql.getRec(tables=["bkmmst", "bkmrtt"],
+                cols=[
+                    "bkm_arrive",
+                    "bkm_depart",
+                    "brt_utype",
+                    "brt_ucode",
+                    "brt_uroom",
+                    "brt_quant"],
+                where=[
+                    ("bkm_cono", "=", self.opts["conum"]),
+                    ("bkm_number", "<>", self.number),
+                    ("bkm_state", "<>", "X"),
+                    ("brt_cono=bkm_cono",),
+                    ("brt_number=bkm_number",)],
+                order="bkm_arrive, brt_utype, brt_ucode, brt_uroom")
+            self.used = []
+            for bk in bks:
                 cod = "%s-%s" % (bk[2], bk[3])
-                if bk[2] == "A" and bk[4]:
-                    self.aunits[cod]["qty"] -= bk[5]
-                    if not self.aunits[cod]["qty"]:
+                if not cod in self.aunits:
+                    continue
+                u = False
+                if self.btype == "A":
+                    if bk[0] < self.depart and self.arrive < bk[1]:
+                        u = True
+                else:
+                    if bk[0] <= self.depart and self.arrive <= bk[1]:
+                        u = True
+                if u:
+                    if bk[2] == "A":
+                        if bk[4]:
+                            self.aunits[cod]["qty"] -= bk[5]
+                            if cod in self.aunits:
+                                if not self.aunits[cod]["qty"]:
+                                    del self.aunits[cod]
+                                else:
+                                    self.aunits[cod]["rms"][bk[4]] = False
+                        else:
+                            del self.aunits[cod]
+                        if whole and bk[2] == "A":
+                            whole = False
+                    elif not self.aunits[cod]["qty"] == 999:
                         del self.aunits[cod]
-                    else:
-                        self.aunits[cod]["rms"][bk[4]] = False
-                else:
-                    del self.aunits[cod]
-                if whole and bk[2] == "A":
-                    whole = False
-        if whole:
-            self.aunits["A-ALL"] = {"desc": whole[0], "qty": whole[1],
-                "rms": {}}
-        if not self.aunits:
-            showError(self.opts["mf"].window, "No Vacancies",
-                "There are No Available Units for this Booking")
-            self.df.focusField("T", 1, 5)
-            return
-        #beds = 0
-        #for unit in self.aunits:
-        #    if unit[self.sql.bkmunm_col.index("bum_btyp")] == self.btype:
-        #        beds += unit[self.sql.bkmunm_col.index("bum_maxg")]
-        #if beds < self.guests:
-        #    showError(self.opts["mf"].window, "Capacity Shortage",
-        #        "There is Not Enough Capacity for this Booking")
-        #    self.df.focusField("T", 1, 5)
-        #    return
-        # Enter Units
-        tit = "Select Units and Rates"
-        unt = {
-            "stype": "M",
-            "func": self.getUnits}
-        rte = {
-            "stype": "R",
-            "tables": ("bkmrtm",),
-            "cols": (
-                ("brm_code", "", 0, "Cod"),
-                ("brm_desc", "", 0, "Description"),
-                ("brm_base", "", 0, "B")),
-            "where": [],
-            "order": "brm_type, brm_code"}
-        fld = (
-            (("T",0,0,0),"OUI",3,"Number of Guests"),
-            (("C",0,0,0),"IUA",8,"Unit-Cod","Unit Combined Code",
-                "r","Y",self.doUUnit,unt,None,("notblank",)),
-            (("C",0,0,1),"ITX",25,"Description","",
-                "","N",self.doUDesc,None,None,("notblank",)),
-            (("C",0,0,2),"IUI",3,"Rme","Room Number",
-                0,"N",self.doURme,None,None,("efld",),None,
-                "Enter the room number or 0 for the whole unit"),
-            (("C",0,0,3),"IUI",3,"Rte","Rate Code",
-                "r","N",self.doURate,rte,self.doUDelete,("efld",)),
-            (("C",0,0,4),"OTX",25,"Description"),
-            (("C",0,0,5),"OUD",10.2,"Normal-Rte"),
-            (("C",0,0,6),"IUI",3,"Qty","",
-                0,"N",self.doUQty,None,self.doUDelete,("notzero",)),
-            (("C",0,0,7),"IUD",6.2,"Disc-%","",
-                0,"N",self.doUDisc,None,None,None),
-            (("C",0,0,8),"IUD",10.2,"Applied-Rt","Applied Rate",
-                0,"N",self.doUAmount,None,None,("efld",)))
-        but = (
-            ("Clear",None,self.doUClear,0,("C",0,1),("C",0,2),
-                "Remove All Units from the Booking"),
-            ("Exit",None,self.doUExit,0,("C",0,1),("C",0,2)))
-        state = self.df.disableButtonsTags()
-        widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
-        self.df.setWidget(widget, "disabled")
-        self.df.setWidget(self.df.mstFrame, state="hide")
-        self.rt = TartanDialog(self.opts["mf"], tops=True, title=tit,
-            eflds=fld, tend=(None,), txit=(None,), cend=((self.doUEnd,"y"),),
-            cxit=(self.doUExit,), butt=but)
-        self.doLoadUnits()
-        self.opts["mf"].startLoop()
-        self.df.setWidget(self.df.mstFrame, state="show")
-        self.df.enableButtonsTags(state=state)
-        return self.units
+            if whole:
+                self.aunits["A-ALL"] = {"desc": whole[0], "qty": whole[1],
+                    "rms": {}}
+            quant = 0
+            units = copy.deepcopy(self.aunits)
+            for unit in units:
+                if unit[0] == "A":
+                    rooms = False
+                    for rm in units[unit]["rms"]:
+                        if units[unit]["rms"][rm]:
+                            rooms = True
+                    if not rooms:
+                        del self.aunits[unit]
+                    quant += units[unit]["qty"]
+            if not self.aunits:
+                showError(self.opts["mf"].window, "No Vacancies",
+                    "There are No Available Units for this Booking")
+                self.df.focusField("T", 1, 5)
+                return
+            if unit[0] == "A" and quant < self.guests:
+                showError(self.opts["mf"].window, "Quantity",
+                    "There is Insufficient Capacity for this Booking")
+                self.df.focusField("T", 1, 5)
+                return
+            # Enter Units
+            tit = "Select Units and Rates"
+            unt = {
+                "stype": "M",
+                "func": self.getUnits}
+            rms = {
+                "stype": "M",
+                "func": self.getRooms}
+            self.rte = {
+                "stype": "R",
+                "tables": ("bkmrtm",),
+                "cols": (
+                    ("brm_code", "", 0, "Cod"),
+                    ("brm_desc", "", 0, "Description"),
+                    ("brm_base", "", 0, "B")),
+                "where": [],
+                "order": "brm_type, brm_code"}
+            fld = (
+                (("T",0,0,0),"OUI",3,"Number of Guests"),
+                (("C",0,0,0),"IUA",8,"Unit-Cod","Unit Combined Code",
+                    "","Y",self.doUUnit,unt,None,("notblank",)),
+                (("C",0,0,1),"ITX",25,"Description","",
+                    "","N",self.doUDesc,None,None,("notblank",)),
+                (("C",0,0,2),"IUI",3,"Rme","Room Number",
+                    0,"N",self.doURme,rms,None,("efld",),None,
+                    "Enter the room number or 0 for the whole unit"),
+                (("C",0,0,3),"IUI",3,"Rte","Rate Code",
+                    "r","N",self.doURate,self.rte,None,("efld",)),
+                (("C",0,0,4),"OTX",25,"Description"),
+                (("C",0,0,5),"OUD",10.2,"Normal-Rte"),
+                (("C",0,0,6),"IUI",3,"Ppl","",
+                    0,"N",self.doUPpl,None,None,("notzero",),None,
+                    "Enter the number of Guests or Items"),
+                (("C",0,0,7),"IUI",3,"Per","",
+                    0,"N",self.doUPer,None,None,("notzero",),None,
+                    "Enter the number of Periods"),
+                (("C",0,0,8),"IUD",6.2,"Disc-%","",
+                    0,"N",self.doUDisc,None,None,None),
+                (("C",0,0,9),"IUD",10.2,"Applied-Rt","Applied Rate",
+                    0,"N",self.doUAmount,None,None,("efld",)))
+            but = (
+                ("Clear",None,self.doUClear,0,("C",0,1),("C",0,2),
+                    "Remove All Units from the Booking"),
+                ("Edit",None,self.doUEdit,0,("C",0,1),("C",0,2),
+                    "Edit Existing Un-Invoiced Units"),
+                ("Exit",None,self.doUExit,0,("C",0,1),("C",0,2)),
+                ("Quit",None,self.doUQuit,1,None,None))
+            cend = ((self.doUEnd,"y"),)
+            cxit = (self.doUExit,)
+            state = self.df.disableButtonsTags()
+            widget = self.df.getWidget(self.df.frt, self.df.pag, self.df.pos)
+            self.df.setWidget(widget, "disabled")
+            self.df.setWidget(self.df.mstFrame, state="hide")
+            self.rt = TartanDialog(self.opts["mf"], tops=True, title=tit,
+                eflds=fld, tend=(None,), txit=(None,), cend=cend, cxit=cxit,
+                butt=but)
+            self.doLoadUnits()
+            self.opts["mf"].startLoop()
+            self.df.setWidget(self.df.mstFrame, state="show")
+            self.df.enableButtonsTags(state=state)
+        self.df.loadEntry(frt, 1, 7, data=self.units)
+        err = self.doCheckUnits()
+        if err:
+            return err
+        self.getBookingValue()
+        self.df.loadEntry("T", 1, 8, data=self.value)
+        self.stddep, self.stddte, self.grpdep, self.grpdte = self.getDeposit()
+        self.df.loadEntry("T", 1, 9, data=self.stddep)
+        self.df.loadEntry("T", 1, 10, data=self.stddte)
+        self.df.loadEntry("T", 1, 11, data=self.grpdep)
+        self.df.loadEntry("T", 1, 12, data=self.grpdte)
+        self.df.loadEntry("T", 1, 13, data=self.getBalance().work)
+        if not self.stddep:
+            return "sk4"
 
     def doUClear(self):
         ok = askQuestion(self.opts["mf"].window, "Clear",
-            "Are You Sure You Want to Clear All Units?", default="no")
+            "Are You Sure You Want to Clear All Un-Invoiced Units?",
+            default="no")
         if ok == "no":
             self.rt.focusField(self.rt.frt, self.rt.pag, self.rt.col)
             return
         self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
-            self.opts["conum"]), ("brt_number", "=", self.number)])
-        self.doLoadUnits()
-
-    def doUDelete(self):
-        tp, cd = self.ucod.split("-")
-        if self.rt.idx == 2:
-            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
-                self.opts["conum"]), ("brt_number", "=", self.number),
-                ("brt_utype", "=", tp), ("brt_ucode", "=", cd)])
-        elif not self.found:
-            return
-        else:
-            self.sql.delRec("bkmrtt", where=[("brt_cono", "=",
-                self.opts["conum"]), ("brt_number", "=", self.number),
-                ("brt_utype", "=", tp), ("brt_ucode", "=", cd),
-                ("brt_rcode", "=", self.rcode)])
-        self.doLoadUnits()
+            self.opts["conum"]), ("brt_number", "=", self.number),
+            ("brt_invno", "=", 0)])
+        self.doLoadUnits()
+
+    def doUEdit(self, widget=None):
+        # Display units and allow editing
+        recs = self.sql.getRec(tables="bkmrtt",
+            cols=["brt_utype", "brt_ucode", "brt_udesc", "brt_uroom",
+                "brt_rcode", "brt_rdesc", "brt_nrate", "brt_quant",
+                "brt_bdays", "brt_discp", "brt_arate", "brt_seq"],
+            where=[
+                ("brt_cono", "=", self.opts["conum"]),
+                ("brt_number", "=", self.number),
+                ("brt_invno", "=", 0)],
+            order="brt_utype, brt_ucode, brt_uroom")
+        if recs:
+            data = []
+            for rec in recs:
+                d = ["%s-%s" % (rec[0], rec[1])]
+                d.extend(rec[2:])
+                data.append(d)
+            titl = "Entered Units"
+            head = ("Unit-Cod", "Description","Rme", "Rte", "Rate-Description",
+                "Normal-Rte", "Ppl", "Per", "Disc-%", "Applied-Rt", "Seq")
+            lin = {
+                "stype": "C",
+                "titl": titl,
+                "head": head,
+                "data": data}
+            state = self.rt.disableButtonsTags()
+            self.opts["mf"].updateStatus("Select a Product to Edit")
+            chg = self.rt.selChoice(lin)
+            if chg and chg.selection:
+                self.change = chg.selection
+                self.cseq = int(self.change[-1])
+                self.doChgChanges()
+            self.rt.enableButtonsTags(state=state)
+        self.doLoadUnits()
+
+    def doChgChanges(self):
+        tit = ("Change Unit",)
+        fld = (
+            (("T",0,0,0),"ONA",8,"Unit-Cod"),
+            (("T",0,0,0),"OTX",30,""),
+            (("T",0,1,0),"ONA",3,"Room Number"),
+            (("T",0,2,0),"IUI",3,"Rate Code","",
+                "","N",self.doChgRtc,self.rte,None,("notzero",)),
+            (("T",0,2,0),"OTX",30,""),
+            (("T",0,3,0),"OUD",10.2,"Normal Rate"),
+            (("T",0,4,0),"IUI",3,"Guests","",
+                "","N",self.doChgPpl,None,None,("notzero",)),
+            (("T",0,5,0),"IUI",3,"Periods","",
+                "","N",self.doChgPer,None,None,("notzero",)),
+            (("T",0,6,0),"IUD",6.2,"Discount","",
+                "","N",self.doChgDsc,None,None,("efld",)),
+            (("T",0,7,0),"IUD",10.2,"Applied Rate","",
+                "","N",self.doChgRte,None,None,("efld",)))
+        but = [["Delete",None,self.doChgDel,1,None,None]]
+        self.cg = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, butt=but, tend=((self.doChgEnd,"n"),),
+            txit=(self.doChgExit,))
+        for x in range(10):
+            if x == 0:
+                self.ctyp, self.ccod = self.change[x].split("-")
+            if x == 5:
+                self.cnrate = CCD(self.change[x], "UD", 10.2).work
+            self.cg.loadEntry("T", 0, x, data=self.change[x])
+        self.cg.focusField("T", 0, 4, clr=False)
+        self.opts["mf"].startLoop()
+
+    def doChgRtc(self, frt, pag, r, c, p, i, w):
+        racc = self.sql.getRec(tables=["bkmrtm", "bkmrtr"],
+            cols=["brm_desc", "brm_base", "brr_rate"],
+            where=[
+                ("brm_cono", "=", self.opts["conum"]),
+                ("brm_type", "=", self.ctyp),
+                ("brm_code", "=", w),
+                ("brr_cono=brm_cono",),
+                ("brr_type=brm_type",),
+                ("brr_code=brm_code",),
+                ("brr_date", "<=", self.arrive)],
+            order="brr_date desc", limit=1)
+        if not racc:
+            return "Invalid Rate Code"
+        self.crtc = w
+        self.crdesc = racc[0]
+        self.crbase = racc[1]
+        self.cnrate = racc[2]
+        self.cg.loadEntry(frt, pag, p+1, data=self.crdesc)
+        self.cg.loadEntry(frt, pag, p+2, data=self.cnrate)
+
+    def doChgPpl(self, frt, pag, r, c, p, i, w):
+        self.cppl = w
+
+    def doChgPer(self, frt, pag, r, c, p, i, w):
+        self.cper = w
+
+    def doChgDsc(self, frt, pag, r, c, p, i, w):
+        self.cdis = w
+        if self.cdis:
+            rte = int(self.cnrate * (100 - self.cdis) / 100)
+            dif = rte % 5
+            if dif:
+                rte = rte + (5 - dif)
+            self.cg.loadEntry(frt, pag, p+1, data=rte)
+
+    def doChgRte(self, frt, pag, r, c, p, i, w):
+        self.carate = w
+
+    def doChgDel(self):
+        self.sql.delRec("bkmrtt", where=[("brt_cono", "=", self.opts["conum"]),
+            ("brt_seq", "=", self.cseq)])
+        self.doChgExit()
+
+    def doChgEnd(self):
+        seq = self.change[0]
+        self.sql.updRec("bkmrtt", cols=["brt_rcode", "brt_rdesc", "brt_rbase",
+            "brt_nrate", "brt_quant", "brt_bdays", "brt_discp", "brt_arate"],
+            data=[self.crtc, self.crdesc, self.crbase, self.cnrate, self.cppl,
+            self.cper, self.cdis, self.carate], where=[("brt_seq", "=",
+            self.cseq)])
+        self.doChgExit()
+
+    def doChgExit(self):
+        self.cg.closeProcess()
+        self.opts["mf"].closeLoop()
 
     def getUnits(self):
         data = []
@@ -522,11 +688,46 @@
         rs = self.rt.selectItem(self.rt.pag, opts)
         return rs
 
+    def getRooms(self):
+        def getNum(num):
+            w1 = {
+                0: '', 1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five',
+                6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine', 10: 'Ten',
+                11: 'Eleven', 12: 'Twelve', 13: 'Thirteen', 14: 'Fourteen',
+                15: 'Fifteen', 16: 'Sixteen', 17: 'Seventeen', 18: 'Eighteen',
+                19: 'Nineteen'}
+            w2 = [
+                None, None, 'Twenty', 'Thirty', 'Forty',
+                'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']
+            if (num >= 0) and (num < 20):
+                mess = (w1[num])
+            elif (num > 19) and (num < 100):
+                mess = (w2[num/10]) + " " + (w1[num%10])
+            elif (num > 99) and (num < 1000):
+                mess = (w1[num/100]) + " Hundred and " + \
+                    (w2[(num-100)/10]) + " " + (w1[num%10])
+            return mess
+
+        data = []
+        for room in self.aunits[self.ucod]["rms"]:
+            if room:
+                data.append((room, "Room Number %s" % getNum(room)))
+        data.sort()
+        opts = {
+            "stype": "C",
+            "titl": "Select the Required Room",
+            "head": ("Num", "Description"),
+            "data": data}
+        rs = self.rt.selectItem(self.rt.pag, opts)
+        return rs
+
     def doUUnit(self, frt, pag, r, c, p, i, w):
+        if not "-" in w:
+            return "Invalid Unit Code Combination"
         tp, cd = w.split("-")
-        rec = self.sql.getRec(tables="bkmunm", cols=["bum_desc", "bum_maxg"],
-            where=[("bum_cono", "=", self.opts["conum"]), ("bum_btyp", "=", tp),
-            ("bum_code", "=", cd)], limit=1)
+        rec = self.sql.getRec(tables="bkmunm", cols=["bum_desc", "bum_maxg",
+            "bum_dflt"], where=[("bum_cono", "=", self.opts["conum"]),
+            ("bum_btyp", "=", tp), ("bum_code", "=", cd)], limit=1)
         if not rec:
             return "Invalid Unit Code"
         if not w in self.aunits:
@@ -534,7 +735,9 @@
         self.ucod = w
         self.udes = rec[0]
         self.uqty = rec[1]
+        self.dflt = rec[2]
         self.rt.loadEntry(frt, pag, p+1, data=self.udes)
+        self.rt.loadEntry(frt, pag, p+3, data=self.dflt)
         self.rt.colf[0][3][8]["where"] = [
             ("brm_cono", "=", self.opts["conum"]),
             ("brm_type", "=", tp)]
@@ -543,102 +746,75 @@
 
     def doUDesc(self, frt, pag, r, c, p, i, w):
         self.udes = w
-        if not self.ucod[0] == "A":
-            self.urme = 1
-            self.df.loadEntry(frt, pag, p+1, data=self.urme)
-            return "sk1"
+        self.urme = 0
+        self.rt.loadEntry(frt, pag, p+1, data=self.urme)
+        return "sk1"
 
     def doURme(self, frt, pag, r, c, p, i, w):
-        if not w:
-            for room in self.aunits[self.ucod]["rms"]:
-                if not self.aunits[self.ucod]["rms"][room]:
-                    return "Unit Partly Booked"
-        elif not self.aunits[self.ucod]["rms"][w]:
-            return "Room Already Booked"
+        if not self.aunits[self.ucod]["rms"] == 999:
+            if not w:
+                for room in self.aunits[self.ucod]["rms"]:
+                    if not self.aunits[self.ucod]["rms"][room]:
+                        return "Unit Partly Booked"
+            else:
+                if not w in self.aunits[self.ucod]["rms"]:
+                    return "Invalid Room"
+                if not self.aunits[self.ucod]["rms"][w]:
+                    return "Room Already Booked"
         self.urme = w
 
     def doURate(self, frt, pag, r, c, p, i, w):
-        tp, cd = self.ucod.split("-")
-        unit = self.sql.getRec(tables="bkmrtt",
+        # New bkmrtt Record
+        racc = self.sql.getRec(tables=["bkmrtm", "bkmrtr"],
+            cols=["brm_desc", "brm_base", "brr_rate"],
             where=[
-                ("brt_cono", "=", self.opts["conum"]),
-                ("brt_number", "=", self.number),
-                ("brt_utype", "=", tp),
-                ("brt_ucode", "=", cd),
-                ("brt_uroom", "=", self.urme),
-                ("brt_rcode", "=", w)],
-            limit=1)
-        if unit:
-            # Existing bkmrtt Record
-            self.found = True
-            self.rcode = w
-            self.rdesc = unit[self.sql.bkmrtt_col.index("brt_rdesc")]
-            self.nrate = unit[self.sql.bkmrtt_col.index("brt_nrate")]
-            self.rqty = unit[self.sql.bkmrtt_col.index("brt_quant")]
-            arate = unit[self.sql.bkmrtt_col.index("brt_arate")]
-            self.rt.loadEntry(frt, pag, p, data=self.rcode)
-            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
-            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
-            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
-            if self.ucod.split("-")[0] == "A":
-                self.aqty -= self.rqty
-        else:
-            # New bkmrtt Record
-            racc = self.sql.getRec(tables=["bkmrtm", "bkmrtr"],
-                cols=["brm_desc", "brm_base", "brr_rate"],
-                where=[("brm_cono", "=", self.opts["conum"]),
+                ("brm_cono", "=", self.opts["conum"]),
                 ("brm_type", "=", self.ucod[0]),
-                ("brm_code", "=", w), ("brr_cono=brm_cono",),
-                ("brr_type=brm_type",), ("brr_code=brm_code",),
-                ("brr_date", "<=", self.arrive)], limit=1)
-            if not racc:
-                return "Invalid Rate Code"
-            self.found = False
-            self.rcode = w
-            self.rdesc = racc[0]
-            self.rbase = racc[1]
-            self.nrate = racc[2]
-            self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
-            self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
-            if self.ucod.split("-")[0] == "A":
-                bqty = self.guests - self.aqty
-                if self.uqty > bqty:
-                    self.rqty = bqty
-                else:
-                    self.rqty = self.uqty
-            elif self.uqty > self.guests:
-                self.rqty = self.guests
-            else:
-                self.rqty = self.uqty
-            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
-        if self.nrate:
-            return "sk2"
+                ("brm_code", "=", w),
+                ("brr_cono=brm_cono",),
+                ("brr_type=brm_type",),
+                ("brr_code=brm_code",),
+                ("brr_date", "<=", self.arrive)],
+            order="brr_date desc", limit=1)
+        if not racc:
+            return "Invalid Rate Code"
+        self.rcode = w
+        self.rdesc = racc[0]
+        self.rbase = racc[1]
+        self.nrate = racc[2]
+        self.rt.loadEntry(frt, pag, p+1, data=self.rdesc)
+        self.rt.loadEntry(frt, pag, p+2, data=self.nrate)
+        if self.uqty == 999 or self.uqty > self.guests:
+            self.rt.loadEntry(frt, pag, p+3, data=self.guests)
         else:
-            self.rqty = 1
-            self.rdisc = 0
-            self.rt.loadEntry(frt, pag, p+3, data=self.rqty)
-            self.rt.loadEntry(frt, pag, p+4, data=self.rdisc)
-            return "sk4"
+            self.rt.loadEntry(frt, pag, p+3, data=self.uqty)
+        self.rt.loadEntry(frt, pag, p+4, data=self.bdays)
+        return "sk2"
 
-    def doUQty(self, frt, pag, r, c, p, i, w):
+    def doUPpl(self, frt, pag, r, c, p, i, w):
         if self.uqty and w > self.uqty:
             ok = askQuestion(self.opts["mf"].window, "Quantity",
                 "Quantity Exceeds Unit Quantity", default="no")
             if ok == "no":
                 return "rf"
-        if self.ucod.split("-")[0] == "A":
-            if (self.aqty + w) > self.guests:
-                return "Invalid Quantity, Exceeds Booking"
-        elif w > self.guests:
-            return "Invalid Quantity, Exceeds Booking"
+        if w > self.guests:
+            return "Invalid Quantity, Exceeds Booking Quantity"
         self.rqty = w
 
+    def doUPer(self, frt, pag, r, c, p, i, w):
+        if w > self.bdays:
+            return "Invalid Period, Exceeds Booking Period"
+        self.rper = w
+
     def doUDisc(self, frt, pag, r, c, p, i, w):
         self.rdisc = w
-        self.arate = int(self.nrate * (100 - self.rdisc) / 100)
-        dif = self.arate % 5
-        if dif:
-            self.arate = self.arate + (5 - dif)
+        if self.rdisc:
+            self.arate = int(self.nrate * (100 - self.rdisc) / 100)
+            dif = self.arate % 5
+            if dif:
+                self.arate = self.arate + (5 - dif)
+        else:
+            self.arate = self.nrate
         self.rt.loadEntry(frt, pag, p+1, data=self.arate)
 
     def doUAmount(self, frt, pag, r, c, p, i, w):
@@ -646,143 +822,127 @@
 
     def doUEnd(self):
         tp, cd = self.ucod.split("-")
-        if self.found:
-            self.sql.updRec("bkmrtt", cols=["brt_quant", "brt_discp",
-                "brt_arate"], data=[self.rqty, self.rdisc, self.arate],
-                where=[("brt_cono", "=", self.opts["conum"]),
-                ("brt_number", "=", self.number), ("brt_utype", "=", tp),
-                ("brt_ucode", "=", cd), ("brt_rcode", "=", self.rcode)])
-        else:
-            self.sql.insRec("bkmrtt", data=[self.opts["conum"], self.number,
-                tp, cd, self.udes, self.urme, self.rcode, self.rdesc,
-                self.rbase, self.nrate, self.rqty, self.rdisc, self.arate,
-                0, 0, 0, 0, self.opts["capnm"], self.sysdtw, 0])
-        self.doLoadUnits()
+        self.sql.insRec("bkmrtt", data=[self.opts["conum"], self.number,
+            tp, cd, self.udes, self.urme, self.rcode, self.rdesc,
+            self.rbase, self.nrate, self.rqty, self.rdisc, self.arate,
+            self.rper, 0, 0, 0, self.opts["capnm"], self.sysdtw, 0])
+        self.rt.advanceLine(0)
+        #self.doLoadUnits()
 
     def doLoadUnits(self):
         self.rt.clearFrame("C", 0)
         self.rt.loadEntry("T", 0, 0, data=self.guests)
         recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
             self.opts["conum"]), ("brt_number", "=", self.number)],
-            order="brt_ucode")
-        self.aqty = 0
+            order="brt_utype, brt_ucode")
         if not recs:
             self.rt.focusField("C", 0, 1)
             return
         for num, rec in enumerate(recs):
-            pos = num * 9
+            pos = num * 10
             ut = rec[self.sql.bkmrtt_col.index("brt_utype")]
             uc = rec[self.sql.bkmrtt_col.index("brt_ucode")]
-            uc = "%s-%s" % (ut, uc)
+            cc = "%s-%s" % (ut, uc)
             ud = rec[self.sql.bkmrtt_col.index("brt_udesc")]
             rm = rec[self.sql.bkmrtt_col.index("brt_uroom")]
             rc = rec[self.sql.bkmrtt_col.index("brt_rcode")]
             rd = rec[self.sql.bkmrtt_col.index("brt_rdesc")]
             nr = rec[self.sql.bkmrtt_col.index("brt_nrate")]
             qt = rec[self.sql.bkmrtt_col.index("brt_quant")]
+            dy = rec[self.sql.bkmrtt_col.index("brt_bdays")]
             ds = rec[self.sql.bkmrtt_col.index("brt_discp")]
             ar = rec[self.sql.bkmrtt_col.index("brt_arate")]
-            self.rt.loadEntry("C", 0, pos, data=uc)
+            self.rt.loadEntry("C", 0, pos, data=cc)
             self.rt.loadEntry("C", 0, pos+1, data=ud)
             self.rt.loadEntry("C", 0, pos+2, data=rm)
             self.rt.loadEntry("C", 0, pos+3, data=rc)
             self.rt.loadEntry("C", 0, pos+4, data=rd)
             self.rt.loadEntry("C", 0, pos+5, data=nr)
             self.rt.loadEntry("C", 0, pos+6, data=qt)
-            self.rt.loadEntry("C", 0, pos+7, data=ds)
-            self.rt.loadEntry("C", 0, pos+8, data=ar)
-            if ut == "A":
-                self.aqty += qt
+            self.rt.loadEntry("C", 0, pos+7, data=dy)
+            self.rt.loadEntry("C", 0, pos+8, data=ds)
+            self.rt.loadEntry("C", 0, pos+9, data=ar)
             if num == self.rt.rows[0] - 1:
                 self.rt.scrollScreen(0)
             else:
-                col = ((num + 1) * 9) + 1
+                col = ((num + 1) * 10) + 1
                 self.rt.focusField("C", 0, col)
 
     def doUExit(self):
-        recs = self.sql.getRec(tables="bkmrtt", cols=["brt_utype", "brt_ucode"],
-            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number", "=",
-            self.number)], group="brt_utype, brt_ucode",
+        err = self.doCheckUnits()
+        if err:
+            self.rt.focusField(self.rt.frt, self.rt.pag, self.rt.col, err=err)
+            return
+        self.rt.closeProcess()
+        recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_number", "=", self.number)],
             order="brt_utype, brt_ucode")
         self.units = ""
-        done = []
-        for tp, cd in recs:
+        for num, rec in enumerate(recs):
+            ut = rec[self.sql.bkmrtt_col.index("brt_utype")]
+            uc = rec[self.sql.bkmrtt_col.index("brt_ucode")]
+            uc = "%s-%s" % (ut, uc)
             if not self.units:
-                self.units = "%s-%s" % (tp, cd)
+                self.units = uc
             else:
-                self.units = "%s:%s-%s" % (self.units, tp, cd)
+                self.units = "%s:%s" % (self.units, uc)
+        self.df.loadEntry("T", 1, 7, data=self.units)
+        self.opts["mf"].closeLoop()
+
+    def doUQuit(self):
         self.rt.closeProcess()
         self.opts["mf"].closeLoop()
 
-    def doUnits(self, frt, pag, r, c, p, i, w):
-        err = self.doCheckUnits()
-        if err:
-            return err
-        self.units = w
-        self.df.loadEntry(frt, pag, p, data=self.units)
-        self.getBookingValue()
-        self.df.loadEntry("T", 1, 7, data=self.value)
-        self.stddep, self.stddte, self.grpdep, self.grpdte = self.getDeposit()
-        self.df.loadEntry("T", 1, 8, data=self.stddep)
-        self.df.loadEntry("T", 1, 9, data=self.stddte)
-        self.df.loadEntry("T", 1, 10, data=self.grpdep)
-        self.df.loadEntry("T", 1, 11, data=self.grpdte)
-        self.df.loadEntry("T", 1, 12, data=self.getBalance().work)
-        if not self.stddep:
-            return "sk4"
-
     def doCheckUnits(self):
+        if not self.btype == "A":
+            return
         cols = self.sql.bkmrtt_col
         recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
             self.opts["conum"]), ("brt_number", "=", self.number)])
         if not recs:
             return "No Units Selected"
-        quant = {}
+        quant = 0
         whole = False
         for rec in recs:
-            typ = rec[cols.index("brt_utype")]
-            cod = rec[cols.index("brt_ucode")]
-            qty = rec[cols.index("brt_quant")]
-            if not typ in quant:
-                quant[typ] = qty
-            else:
-                quant[typ] += qty
-            if typ == "A" and cod == "ALL":
-                whole = True
-        if self.btype == "A" and not "A" in quant:
+            if rec[cols.index("brt_utype")] == "A":
+                cod = rec[cols.index("brt_ucode")]
+                qty = rec[cols.index("brt_quant")]
+                per = rec[cols.index("brt_bdays")]
+                quant += (qty * per)
+                if cod == "ALL":
+                    whole = True
+        if not quant:
             return "Missing Accomodation Unit"
-        for typ in quant:
-            if not whole and typ == "A" and not quant[typ] == self.guests:
-                return "Accomodation Quantity (%s) Not Equal to Booking "\
-                    "Quantity (%s)" % (quant[typ], self.guests)
+        if quant > (self.guests * self.bdays):
+            return "Accomodation Quantity Exceeds Booking Quantity"
+        if quant < (self.guests * self.bdays):
+            ok = askQuestion(self.opts["mf"].window, "Quantity",
+                "Accommodation Quantity is Less than the Booked Quantity?",
+                default="no")
+            if ok == "no":
+                return "rf"
 
     def getBookingValue(self):
         self.value = 0
         col = self.sql.bkmrtt_col
         recs = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
             self.opts["conum"]), ("brt_number", "=", self.number)])
-        if self.btype == "A":
-            bdays = dateDiff(self.arrive, self.depart, "days")
-        else:
-            bdays = dateDiff(self.arrive, self.depart, "days") + 1
-        self.sql.updRec("bkmrtt", cols=["brt_bdays"], data=[bdays],
-            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number",
-            "=", self.number)])
         for rec in recs:
-            rbase = rec[col.index("brt_rbase")]
-            quant = rec[col.index("brt_quant")]
-            arate = rec[col.index("brt_arate")]
-            if rbase == "A":
-                self.value = float(ASD(self.value) + ASD(quant * bdays * arate))
-            elif rbase == "B":
-                self.value = float(ASD(self.value) + ASD(quant * arate))
-            elif rbase == "C":
-                self.value = float(ASD(self.value) + ASD(bdays * arate))
+            bas = rec[col.index("brt_rbase")]
+            qty = rec[col.index("brt_quant")]
+            per = rec[col.index("brt_bdays")]
+            rte = rec[col.index("brt_arate")]
+            if bas == "A":
+                self.value = float(ASD(self.value) + ASD(qty * per * rte))
+            elif bas == "B":
+                self.value = float(ASD(self.value) + ASD(qty * rte))
+            elif bas == "C":
+                self.value = float(ASD(self.value) + ASD(per * rte))
             else:
-                self.value = float(ASD(self.value) + ASD(arate))
+                self.value = float(ASD(self.value) + ASD(rte))
 
     def doDeposit(self, frt, pag, r, c, p, i, w):
-        if p == 8:
+        if p == 9:
             self.stddep = w
             if not self.stddep:
                 self.stddte = 0
@@ -800,13 +960,13 @@
                 return "sk1"
 
     def doDepdate(self, frt, pag, r, c, p, i, w):
-        if p == 9:
+        if p == 10:
             self.stddte = w
         else:
             self.grpdte = w
 
-    def doRequests(self, frt, pag, r, c, p, i, w):
-        self.special = w
+    def doRemarks(self, frt, pag, r, c, p, i, w):
+        self.remarks = w
 
     def doContact(self, frt, pag, r, c, p, i, w):
         if w:
@@ -912,9 +1072,12 @@
             self.sql.insRec("bkmtrn", data=data)
         data = [self.opts["conum"]]
         for x in xrange(len(self.df.t_work[1][0])):
-            if x == 12:
+            if x in (6, 13):
                 continue
-            data.append(self.df.t_work[1][0][x])
+            if self.df.topf[1][x][1][1:] == "Tv":
+                data.append(self.df.t_work[1][0][x].strip())
+            else:
+                data.append(self.df.t_work[1][0][x])
         data.append(self.ccode)
         if self.newmst:
             changed = True
@@ -939,11 +1102,9 @@
             return
         err = self.doCheckUnits()
         if err:
-            self.df.focusField("T", 1, 6, err=err)
+            self.df.focusField("T", 1, 7, err=err)
             return
-        flds = ["T", 1, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]
-        flds[2].append(14)
-        f, p, c, m = self.df.doCheckFields(flds)
+        f, p, c, m = self.df.doCheckFields(fields=["T", 1, None])
         if m:
             self.df.selPage("Booking")
             self.df.focusField(f, p, (c+1), err=m)
@@ -1189,8 +1350,8 @@
                 where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_number",
                 "=", self.number)])
             if (self.ttype == 4 and not self.charge) or self.ttype == 5:
-                self.df.loadEntry("T", 1, 12, data=self.getBalance().work)
-                self.df.loadEntry("T", 1, 14, data=self.state)
+                self.df.loadEntry("T", 1, 13, data=self.getBalance().work)
+                self.df.loadEntry("T", 1, 15, data=self.state)
                 self.doTExit()
                 return
         if self.ttype == 1:
@@ -1269,7 +1430,7 @@
             self.sql.insRec("ctlvtf", data=data)
         # Balance
         bal = self.getBalance().work
-        self.df.loadEntry("T", 1, 12, data=bal)
+        self.df.loadEntry("T", 1, 13, data=bal)
         # Status
         self.setStatus(bal)
         self.sql.updRec("bkmmst", cols=["bkm_state"], data=[self.state],
@@ -1390,7 +1551,8 @@
         else:
             mail = None
         printm = self.pr.repprt[1][3]
-        self.form = DrawForm(self.opts["mf"].dbm, self.bktpl)
+        self.form = DrawForm(self.opts["mf"].dbm, self.bktpl,
+            wrkdir=self.opts["mf"].rcdic["wrkdir"])
         self.doLoadStatic()
         self.form.doNewDetail()
         self.doBookingDetails()
@@ -1444,7 +1606,8 @@
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 key, ext="pdf")
             if self.terms:
-                att = [self.terms]
+                att = [getFileName(self.terms,
+                    wrkdir=self.opts["mf"].rcdic["wrkdir"])]
             self.form.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=view, prtnam=prtnam, mail=mail,
@@ -1532,9 +1695,9 @@
         nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = self.guests
         # Booked facilities
         rtt = self.sql.getRec(tables="bkmrtt", cols=["brt_utype", "brt_ucode",
-            "brt_udesc", "brt_uroom", "brt_rbase", "brt_quant", "brt_arate"],
-            where=[("brt_cono", "=", self.opts["conum"]), ("brt_number", "=",
-            self.number)], order="brt_utype, brt_udesc")
+            "brt_udesc", "brt_uroom", "brt_rbase", "brt_quant", "brt_bdays",
+            "brt_arate"], where=[("brt_cono", "=", self.opts["conum"]),
+            ("brt_number", "=", self.number)], order="brt_utype, brt_udesc")
         text = ""
         for n, u in enumerate(rtt):
             s += 1
@@ -1547,17 +1710,18 @@
                 u[2] = "%-s Room %3s" % (u[2], u[3])
             bas = u[4]
             qty = CCD(u[5], "UI", 3)
-            rte = CCD(u[6], "UD", 10.2)
+            per = CCD(u[6], "UI", 3)
+            rte = CCD(u[7], "UD", 10.2)
             if rte.work:
-                txt = "%-39s %-3s @ R%10s" % (u[2], qty.disp, rte.disp)
-                if bas in ("A", "C"):
-                    txt += " pd"
+                txt = "%-35s %-3s x %-3s @ R%10s" % (u[2], qty.disp,
+                    per.disp, rte.disp)
             else:
-                txt = "%-39s" % u[2]
+                txt = "%-35s" % u[2]
             nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
         # Special
-        if bd[13]:
-            lines = textFormat(bd[13], width=nd["%s_C%02i" %
+        if bd[14]:
+            s += 1
+            lines = textFormat(bd[14], width=nd["%s_C%02i" %
                 (t, s)][tc.index("tpd_mrg_chrs")], blong=False)
             for num, line in enumerate(lines):
                 s += 1
@@ -1567,11 +1731,12 @@
         # Values
         s += 2
         nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Value of Booking:"
-        if not bd[7]:
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "N/C" + bd[7]
+        if not bd[8]:
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "N/C"
+            return
         else:
-            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bd[7]
-        if not bd[7] or self.state == "X":
+            nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = "R" + bd[8]
+        if self.state == "X":
             return
         bl = self.getBalance()
         if self.state == "S":
@@ -1588,27 +1753,31 @@
             rc = bl
             bl = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
         if self.state == "Q":
-            od = CCD(float(ASD(bw[8]) + ASD(bw[10])), "SD", 11.2)
+            od = CCD(float(ASD(bw[9]) + ASD(bw[11])), "SD", 11.2)
             da = CCD(float(ASD(self.value) - ASD(od.work)), "SD", 11.2)
-        elif self.state == "C" and bw[10]:
-            od = CCD(float(ASD(bw[8]) + ASD(bw[10]) + ASD(rc.work)), "SD", 11.2)
+        elif self.state == "C" and bw[11]:
+            od = CCD(float(ASD(bw[9]) + ASD(bw[11]) + ASD(rc.work)), "SD", 11.2)
             da = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
         else:
             od = CCD(0, "SD", 11.2)
             da = CCD(float(ASD(self.value) + ASD(rc.work)), "SD", 11.2)
         s += 1
         if self.state == "Q":
-            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
-            txt = "R%s due by %s" % (bd[8], self.getDate(bw[9]))
+            if bw[11]:
+                txt = "1st Deposit"
+            else:
+                txt = "Deposit"
+            nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = txt
+            txt = "R%s due by %s" % (bd[9], self.getDate(bw[10]))
             nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
-            if bw[10]:
+            if bw[11]:
                 s += 1
-                nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
-                txt = "R%s due by %s" % (bd[10], self.getDate(bw[11]))
+                nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "2nd Deposit:"
+                txt = "R%s due by %s" % (bd[11], self.getDate(bw[12]))
                 nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
-        elif self.state == "C" and bw[10] and od.work > 0:
+        elif self.state == "C" and bw[11] and od.work > 0:
             nd["%s_T%02i" % (t, s)][tc.index("tpd_text")] = "Deposit:"
-            txt = "R%s due by %s" % (od.disp, self.getDate(bw[11]))
+            txt = "R%s due by %s" % (od.disp, self.getDate(bw[12]))
             nd["%s_C%02i" % (t, s)][tc.index("tpd_text")] = txt
         elif bl.work:
             txt = "Receipts:"
@@ -1673,7 +1842,7 @@
 
     def setStatus(self, bal):
         if self.state == "X":
-            self.df.loadEntry("T", 1, 14, data=self.state)
+            self.df.loadEntry("T", 1, 15, data=self.state)
             return
         if self.inv:
             if not bal:
@@ -1687,7 +1856,7 @@
                 self.state = "S"
             else:
                 self.state = "C"
-        self.df.loadEntry("T", 1, 14, data=self.state)
+        self.df.loadEntry("T", 1, 15, data=self.state)
 
     def getDate(self, date):
         if type(date) == str:

=== modified file 'bkm/bk2010.py'
--- bkm/bk2010.py	2015-01-01 12:48:11 +0000
+++ bkm/bk2010.py	2015-01-30 10:10:59 +0000
@@ -39,6 +39,8 @@
                 "ctm_regno", "ctm_taxno", "ctm_taxdf", "ctm_tel", "ctm_fax",
                 "ctm_b_name", "ctm_b_ibt", "ctm_b_acno", "ctm_logo"):
             exec "self.%s = ctl['%s']" % (col, col)
+        if self.ctm_logo and "LETTERHEAD" in os.environ:
+            self.ctm_logo = os.environ["LETTERHEAD"]
         if not self.ctm_logo or not os.path.exists(self.ctm_logo):
             self.ctm_logo = None
         bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
@@ -83,9 +85,7 @@
                 "N","Y",self.doBkmQry,None,None,None),
             (("T",0,3,0),("IRB",r2s),0,"Bookings","",
                 "S","Y",self.doBkmDoc,None,None,None),
-            (("T",0,4,0),("IRB",r1s),0,"Print Invoices","",
-                "N","Y",self.doPrtInv,None,None,None),
-            (("T",0,5,0),"INA",20,"Template Name","",
+            (("T",0,4,0),"INA",20,"Template Name","",
                 self.tplnam,"N",self.doTplNam,tpm,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
@@ -104,11 +104,6 @@
     def doBkmDoc(self, frt, pag, r, c, p, i, w):
         self.bkmdoc = w
 
-    def doPrtInv(self, frt, pag, r, c, p, i, w):
-        self.prtinv = w
-        if self.prtinv == "N":
-            return "sk1"
-
     def doTplNam(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="tplmst", where=[("tpm_tname", "=", w),
             ("tpm_type", "=", "I"), ("tpm_system", "=", "BKM")], limit=1)
@@ -230,7 +225,8 @@
                             invno, batno, gls[acc][1], 0, "Booking %s" % bkno,
                             "", "", 0, self.opts["capnm"], self.sysdtw, 0]
                         self.sql.insRec("gentrn", data=data)
-            docs.append(invno)
+            if not invno in docs:
+                docs.append(invno)
         self.opts["mf"].dbm.commitDbase()
         if docs:
             PrintBookingInvoice(self.opts["mf"], self.opts["conum"], "I",

=== modified file 'bkm/bk3010.py'
--- bkm/bk3010.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3010.py	2015-01-29 07:40:58 +0000
@@ -107,6 +107,8 @@
                     inv = True
             if inv:
                 continue
+            if num.work == 1141:
+                print bal
             dp1 = float(ASD(rec[5]) + ASD(bal))
             dt1 = rec[6]
             if dp1 > 0:
@@ -121,9 +123,9 @@
                 dp2 = 0
                 dt2 = 0
             if self.expired == "Y":
-                if dt1 > self.sysdtw:
+                if dp1 and dt1 > self.sysdtw:
                     continue
-                elif dt2 and dt2 > self.sysdtw:
+                elif not dp1 and dp2 and dt2 > self.sysdtw:
                     continue
             elif not dp1 > 0 and not dp2 > 0:
                 continue

=== modified file 'bkm/bk3020.py'
--- bkm/bk3020.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3020.py	2015-01-27 16:18:46 +0000
@@ -187,7 +187,7 @@
             return recs
 
     def exportReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
@@ -198,6 +198,9 @@
         self.expdatas = []
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                p.closeProgress()
+                return
             bkmno, trdt, trtp, refno, batch, debit, credit, taxamt, \
                 detail, taxind, name = self.getValues(dat)
             line = ["BODY", [trtp.work, batch.work, bkmno.work, name.work,
@@ -211,7 +214,7 @@
             datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if self.totsonly == "Y":
             self.head = ("%03u %-30s %49s %6s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, __name__))
@@ -234,6 +237,8 @@
         self.pglin = 999
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             bkmno, trdt, trtp, refno, batch, debit, credit, taxamt, \
                 detail, taxind, name = self.getValues(dat)
             if self.trtp == 0:
@@ -268,7 +273,7 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             self.batchTotal()
             self.typeTotal()
             self.grandTotal()

=== modified file 'bkm/bk3030.py'
--- bkm/bk3030.py	2015-01-01 12:48:11 +0000
+++ bkm/bk3030.py	2015-01-31 09:30:49 +0000
@@ -43,6 +43,8 @@
                 "ctm_regno", "ctm_taxno", "ctm_taxdf", "ctm_tel", "ctm_fax",
                 "ctm_b_name", "ctm_b_ibt", "ctm_b_acno", "ctm_logo"):
             exec "self.%s = ctl['%s']" % (col, col)
+        if self.ctm_logo and "LETTERHEAD" in os.environ:
+            self.ctm_logo = os.environ["LETTERHEAD"]
         if not self.ctm_logo or not os.path.exists(self.ctm_logo):
             self.ctm_logo = None
         bkmctl = gc.getCtl("bkmctl", self.opts["conum"])
@@ -85,13 +87,15 @@
                 0,"N",self.doStartDate,None,None,("efld",)),
             (("T",0,2,0),"ID1",10,"Ending Date","",
                 0,"N",self.doEndDate,None,None,("efld",)),
-            (("T",0,3,0),("IRB",r2s),0,"Housekeeping Report","",
+            (("T",0,3,0),("IRB",r2s),0,"Include Queries","",
+                "N","Y",self.doQuery,None,None,None),
+            (("T",0,4,0),("IRB",r2s),0,"Housekeeping Report","",
                 "Y","Y",self.doHkRpt,None,None,None),
-            (("T",0,4,0),("IRB",r2s),0,"Generate Invoices","",
+            (("T",0,5,0),("IRB",r2s),0,"Generate Invoices","",
                 "Y","Y",self.doGenInv,None,None,None),
-            (("T",0,5,0),("IRB",r2s),0,"Print Invoices","",
+            (("T",0,6,0),("IRB",r2s),0,"Print Invoices","",
                 "Y","Y",self.doPrtInv,None,None,None),
-            (("T",0,6,0),"INA",20,"Template Name","",
+            (("T",0,7,0),"INA",20,"Template Name","",
                 self.tplnam,"N",self.doTplNam,tpm,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
@@ -114,7 +118,7 @@
             if self.getStart(self.start):
                 return "Invalid Start Date"
             if self.period == "D":
-                self.end = projectDate(self.start, 4)
+                self.end = projectDate(self.start, 3)
             else:
                 self.end = projectDate(self.start, 2)
             self.df.loadEntry(frt, pag, p+1, data=self.end)
@@ -150,6 +154,9 @@
             return "Range More Than 7 Days"
         self.end = w
 
+    def doQuery(self, frt, pag, r, c, p, i, w):
+        self.query = w
+
     def doHkRpt(self, frt, pag, r, c, p, i, w):
         self.house = w
 
@@ -177,9 +184,7 @@
         # Headings and Mail subject
         self.cdes = "%-30s" % self.opts["conam"]
         start = self.getDate(self.start)
-        start = self.getDate(self.start)
-        end = self.getDate(self.end)
-        end = self.getDate(self.end)
+        end = self.getDate(projectDate(self.end, 1))
         if self.period == "D":
             self.hdes = "Arrivals for Weekdays %s - %s" % (start, end)
         elif self.period == "E":
@@ -220,8 +225,11 @@
         self.opts["mf"].closeLoop()
 
     def doArrival(self):
+        state = ["C", "S"]
+        if self.query == "Y":
+            state.append("Q")
         recs = self.sql.getRec(tables="bkmmst", where=[("bkm_cono", "=",
-            self.opts["conum"]), ("bkm_state", "in", ("C", "S"))],
+            self.opts["conum"]), ("bkm_state", "in", tuple(state))],
             order="bkm_ccode")
         books = []
         last = 0
@@ -233,9 +241,9 @@
             arrive = rec[self.sql.bkmmst_col.index("bkm_arrive")]
             depart = rec[self.sql.bkmmst_col.index("bkm_depart")]
             if btype == "A":
-                if depart <= self.start or arrive >= self.end:
+                if depart <= self.start or arrive > self.end:
                     continue
-            elif depart <= self.start or arrive > self.end:
+            elif depart < self.start or arrive > self.end:
                 continue
             if self.geninv == "Y":
                 books.append(number)
@@ -245,8 +253,8 @@
             sname = con[self.sql.bkmcon_col.index("bkc_sname")]
             names = con[self.sql.bkmcon_col.index("bkc_names")]
             name = "%s %s" % (names.split()[0], sname)
-            if group:
-                name = "%-25s %s" % (name, group)
+            #if group:
+            #    name = "%-25s %s" % (name, group)
             bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
                 where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
                 "=", number)], limit=1)
@@ -254,19 +262,17 @@
                 "brt_uroom", "sum(brt_quant)"], where=[("brt_cono", "=",
                 self.opts["conum"]), ("brt_number", "=", number)],
                 group="brt_utype, brt_ucode, brt_udesc, brt_uroom",
-                order="brt_utype, brt_ucode")
+                order="brt_utype, brt_ucode, brt_uroom")
             units = []
-            rm = False
+            unt = None
             for rec in recs:
                 if rec[1]:
-                    if not rm:
-                        unt = ["%s - Room %s" % (rec[0], rec[1]), rec[2]]
-                        rm = True
+                    if not unt:
+                        unt = ["%s - R%s" % (rec[0], rec[1]), rec[2]]
                     else:
-                        unt[0] = "%s,%s" % (unt[0], rec[1])
+                        unt = ["%s & R%s" % (unt[0], rec[1]), rec[2]]
                 else:
-                    units.append((rec[0], rec[2]))
-            if rm:
+                    unt = (rec[0], rec[2])
                 units.append(unt)
             namq = len(wrap(name, break_long_words=False, width=25))
             untq = 0
@@ -294,7 +300,11 @@
                     arr = d.strftime("%a")
                 else:
                     arr = "<--"
-                if depart <= self.end:
+                if btype == "A":
+                    td = projectDate(depart, 1, "-")
+                else:
+                    td = depart
+                if td <= self.end:
                     yr = depart / 10000
                     mt = depart / 100 % 100
                     dy = depart % 100
@@ -306,6 +316,12 @@
                     amt = CCD(bal[0], "SD", 11.2).disp
                 else:
                     amt = CCD(0, "SD", 11.2).disp
+                print name
+                print unit
+                print arr
+                print dep
+                print amt
+                print hh
                 self.printLine(name, unit[0], unit[1], arr, dep, amt, hh)
                 last = number
         self.opts["mf"].dbm.commitDbase()
@@ -317,12 +333,15 @@
         for rec in recs:
             col = ["bkm_number", "bkm_btype", "bkm_group", "bkc_sname",
                 "bkc_names", "bkm_arrive", "bkm_depart", "sum(brt_quant)"]
+            state = ["C", "S"]
+            if self.query == "Y":
+                state.append("Q")
             bks = self.sql.getRec(tables=["bkmmst", "bkmrtt", "bkmcon"],
                 cols=col, where=[("bkm_cono", "=", self.opts["conum"]),
-                ("bkm_state", "in", ("C", "S")), ("brt_cono=bkm_cono",),
+                ("bkm_state", "in", tuple(state)), ("brt_cono=bkm_cono",),
                 ("brt_number=bkm_number",), ("brt_utype", "=", rec[0]),
                 ("brt_ucode", "=", rec[1]), ("bkc_cono=bkm_cono",),
-                ("bkc_ccode=bkm_ccode",)], order="bkm_arrive")
+                ("bkc_ccode=bkm_ccode",)], order="bkm_arrive, bkc_sname")
             nme = ""
             qty = ""
             arr = ""
@@ -331,7 +350,6 @@
             totq = 0
             lines = []
             hh = [8, 8, 8]
-            self.y = self.fpdf.get_y()
             for bk in bks:
                 number = bk[0]
                 btype = bk[1]
@@ -342,9 +360,9 @@
                 arrive = bk[5]
                 depart = bk[6]
                 if btype == "A":
-                    if depart <= self.start or arrive >= self.end:
+                    if depart <= self.start or arrive > self.end:
                         continue
-                elif depart <= self.start or arrive > self.end:
+                elif depart < self.start or arrive > self.end:
                     continue
                 if arrive >= self.start:
                     yr = arrive / 10000
@@ -354,7 +372,11 @@
                     arrive = dt.strftime("%a")
                 else:
                     arrive = "<--"
-                if depart <= self.end:
+                if btype == "A":
+                    td = projectDate(depart, 1, "-")
+                else:
+                    td = depart
+                if td <= self.end:
                     yr = depart / 10000
                     mt = depart / 100 % 100
                     dy = depart % 100
@@ -368,16 +390,17 @@
                         ("brt_cono", "=", self.opts["conum"]),
                         ("brt_number", "=", number),
                         ("brt_utype", "=", rec[0]),
-                        ("brt_ucode", "=", rec[1])])
+                        ("brt_ucode", "=", rec[1])],
+                    order="brt_uroom")
                 rm = False
                 for r in rms:
                     if not r[0]:
                         continue
                     if not rm:
-                        name = "%s - Room %s" % (name, r[0])
+                        name = "%s - R%s" % (name, r[0])
                         rm = True
                     else:
-                        name = "%s,%s" % (name, r[0])
+                        name = "%s & R%s" % (name, r[0])
                 quant = bk[7]
                 bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
                     where=[("bkt_cono", "=", self.opts["conum"]), ("bkt_number",
@@ -506,13 +529,18 @@
         self.fpdf.drawText(self.cdes, x=7, font=["courier", "B", 24])
         self.fpdf.drawText(font=["courier", "B", 14])
         self.fpdf.drawText(self.hdes, x=7, font=["courier", "B", 16])
+        if self.query == "Y":
+            ides = "Queries Included"
+        else:
+            ides = "Queries Not Included"
         if self.rtyp == "A":
             if self.geninv == "Y":
-                ides = "Invoices Generated"
+                ides = "%s, Invoices Generated" % ides
             else:
-                ides = "Invoices Not Generated"
-            self.fpdf.drawText()
-            self.fpdf.drawText(ides, x=7, font=["courier", "B", 16])
+                ides = "%s, Invoices Not Generated" % ides
+        self.fpdf.drawText()
+        self.fpdf.drawText(ides, x=7, font=["courier", "B", 16])
+        if self.rtyp == "A":
             self.fpdf.drawText(font=["courier", "B", 12])
             self.printLine("%-25s" % "Name or Group",
                 "%-25s" % "Unit Description", "Qty", "Arr",

=== modified file 'bkm/bk3040.py'
--- bkm/bk3040.py	2015-01-01 12:48:11 +0000
+++ bkm/bk3040.py	2015-01-27 13:40:28 +0000
@@ -2,7 +2,7 @@
 
 """
 SYNOPSIS
-    Bookings Ledger Balance Listing..
+    Bookings Ledger Balance Listing.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -111,8 +111,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -130,7 +130,7 @@
             datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         chrs = len(self.colsh)
         for f in self.forms:
             chrs += int(f[1])
@@ -144,13 +144,13 @@
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         self.head3 = "Booking Status: %s" % self.statusd
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             vals = self.getValues(dat)
             if not vals:
                 continue
@@ -161,8 +161,10 @@
                 vals[5].disp, vals[6].disp, vals[7].disp))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],

=== modified file 'bkm/bk3050.py'
--- bkm/bk3050.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3050.py	2015-01-27 13:40:28 +0000
@@ -109,20 +109,18 @@
             self.fpdf.add_page()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, dat in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(dat)
             p.closeProgress()
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.view, prtnam=self.prtnam,
-                mail=self.emadd)
+            if self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.view,
+                    prtnam=self.prtnam, mail=self.emadd)
         self.closeProcess()
 
     def doProcess(self, dat):

=== modified file 'bkm/bk3060.py'
--- bkm/bk3060.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3060.py	2015-01-27 16:02:59 +0000
@@ -35,10 +35,10 @@
     def mainProcess(self):
         data = []
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
-            mxs=len(self.notes.data))
+            mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -55,7 +55,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Booking Master Notes Listing"]
             cols = [

=== modified file 'bkm/bk3070.py'
--- bkm/bk3070.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3070.py	2015-01-27 13:40:28 +0000
@@ -138,8 +138,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(acs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -188,11 +188,8 @@
         self.actno = None
         self.typno = None
         for num, dat in enumerate(acs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -217,11 +214,11 @@
                     vals[5].disp, vals[6]))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                if self.rep == "Y" or self.act == "Y" or self.typ == "Y":
-                    self.doTotals(ttype="S")
-                self.doTotals(ttype="G")
+        if not self.fpdf.page or p.quit:
+            return
+        if self.rep == "Y" or self.act == "Y" or self.typ == "Y":
+            self.doTotals(ttype="S")
+        self.doTotals(ttype="G")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
             head=self.tit, view=self.df.repprt[0][1],

=== modified file 'bkm/bk3080.py'
--- bkm/bk3080.py	2015-01-01 12:48:11 +0000
+++ bkm/bk3080.py	2015-02-05 07:47:52 +0000
@@ -170,17 +170,18 @@
             showError(self.opts["mf"].body, "Error",
                 "No Bookings Selected")
         else:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         if not "args" in self.opts:
             self.opts["mf"].closeLoop()
@@ -256,7 +257,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'bkm/bk3090.py'
--- bkm/bk3090.py	2014-12-30 15:37:38 +0000
+++ bkm/bk3090.py	2015-01-14 14:24:18 +0000
@@ -143,19 +143,19 @@
                 ("bkc_cono=bkt_cono",), ("bkc_ccode=bkm_ccode",)],
                 group="bkt_refno, bkt_date, bkc_sname, bkc_names")
             recs = getSingleRecords(self.opts["mf"], tab, col, dic=dic,
-                where=recs, ttype="D")
+                where=recs, ttype="D", selcol="bkc_sname")
         else:
             recs = self.sql.getRec(tables="bkmtrn", cols=["bkt_refno"],
                 where=[("bkt_cono", "=", self.opts["conum"]),
                 ("bkt_type", "=", 2), ("bkt_refno", ">=", self.frm),
                 ("bkt_refno", "<=", self.to)])
-        doc = []
+        docs = []
         if recs:
             for rec in recs:
-                doc.append(rec[0])
-        if doc:
+                docs.append(rec[0])
+        if docs:
             PrintBookingInvoice(self.opts["mf"], self.opts["conum"], "I",
-                doc, prtnam=prt, tname=self.tname, email=eml, copy=self.copy)
+                docs, prtnam=prt, tname=self.tname, email=eml, copy=self.copy)
         self.opts["mf"].closeLoop()
 
     def doExit(self):

=== modified file 'bkm/bkc210.py'
--- bkm/bkc210.py	2015-01-01 12:48:11 +0000
+++ bkm/bkc210.py	2015-01-05 11:11:00 +0000
@@ -25,7 +25,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "genmst", "bkmmst",
-            "bkmunm"], prog=__name__)
+            "bkmunm", "bkmrtm"], prog=__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -46,13 +46,22 @@
                 ("bum_desc", "", 0, "Description"),
                 ("bum_room", "", 0, "Rms"),
                 ("bum_maxg", "", 0, "Qty"),
-                ("bum_vatc", "", 0, "V")],
+                ("bum_dflt", "", 0, "Rte")],
             "where": [
                 ("bum_cono", "=", self.opts["conum"])],
             "whera": (("T", "bum_btyp", 0, 0),),
             "order": "bum_btyp, bum_code"}
         if self.glint == "Y":
             unm["cols"].append(("bum_slsa", "", 0, "Acc-Num"))
+        rte = {
+            "stype": "R",
+            "tables": ("bkmrtm",),
+            "cols": (
+                ("brm_code", "", 0, "Cod"),
+                ("brm_desc", "", 0, "Description"),
+                ("brm_base", "", 0, "B")),
+            "where": [],
+            "order": "brm_type, brm_code"}
         vtm = {
             "stype": "R",
             "tables": ("ctlvmf",),
@@ -74,18 +83,20 @@
             (("T",0,1,0),"IUA",6,"Unit Code","",
                 "","N",self.doUcode,unm,None,("notblank",)),
             (("T",0,2,0),"ITX",30,"Description","",
-                "","N",None,None,self.doDelete,("notblank",)),
+                "","N",self.doUDesc,None,self.doDelete,("notblank",)),
             (("T",0,3,0),"IUI",3,"Number of Rooms","",
                 0,"N",self.doURooms,None,None,("efld",)),
             (("T",0,4,0),"IUI",3,"Total Capacity","",
                 0,"N",None,None,None,("notzero",)),
-            (("T",0,5,0),"IUA",1,"V.A.T. Code","",
+            (("T",0,5,0),"IUI",3,"Default Rate","",
+                0,"N",self.doUrate,rte,None,("notzero",)),
+            (("T",0,6,0),"IUA",1,"V.A.T. Code","",
                 "","N",self.doVat,vtm,None,("notblank",))]
         if self.glint == "Y":
             self.fld.extend([
-                (("T",0,6,0),"IUI",7,"Sales Account","",
+                (("T",0,7,0),"IUI",7,"Sales Account","",
                     "","N",self.doSales,glm,None,("notzero",)),
-                (("T",0,6,0),"ONA",30,"")])
+                (("T",0,7,0),"ONA",30,"")])
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -94,6 +105,9 @@
 
     def doBtype(self, frt, pag, r, c, p, i, w):
         self.btyp = w
+        self.df.topf[0][5][8]["where"] = [
+            ("brm_cono", "=", self.opts["conum"]),
+            ("brm_type", "=", self.btyp)]
 
     def doUcode(self, frt, pag, r, c, p, i, w):
         self.ucod = w
@@ -108,22 +122,40 @@
             rms = acc[self.sql.bkmunm_col.index("bum_room")]
             qty = acc[self.sql.bkmunm_col.index("bum_maxg")]
             vcd = acc[self.sql.bkmunm_col.index("bum_vatc")]
+            dfr = acc[self.sql.bkmunm_col.index("bum_dflt")]
             sls = acc[self.sql.bkmunm_col.index("bum_slsa")]
             self.df.loadEntry(frt, pag, p+1, data=des)
             self.df.loadEntry(frt, pag, p+2, data=rms)
             self.df.loadEntry(frt, pag, p+3, data=qty)
-            self.df.loadEntry(frt, pag, p+4, data=vcd)
+            self.df.loadEntry(frt, pag, p+4, data=dfr)
+            self.df.loadEntry(frt, pag, p+5, data=vcd)
             if self.glint == "Y":
-                self.df.loadEntry(frt, pag, p+5,data=sls)
+                self.df.loadEntry(frt, pag, p+6,data=sls)
                 des = self.getGenDesc(sls)
                 if not des:
-                    self.df.loadEntry(frt,pag,p+6,data="Invalid Sales Code")
+                    self.df.loadEntry(frt,pag,p+7,data="Invalid Sales Code")
                 else:
-                    self.df.loadEntry(frt,pag,p+6,data=des[0])
+                    self.df.loadEntry(frt,pag,p+7,data=des[0])
+
+    def doUDesc(self, frt, pag, r, c, p, i, w):
+        self.udes = w
+        if self.btyp == "O":
+            self.urms = 0
+            self.df.loadEntry(frt, pag, p+1, data=self.urms)
+            return "sk1"
 
     def doURooms(self, frt, pag, r, c, p, i, w):
+        if self.btyp == "A" and not w:
+            return "Invalid Number of Rooms"
         self.urms = w
 
+    def doUrate(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="bkmrtm", where=[("brm_cono", "=",
+            self.opts["conum"]), ("brm_type", "=", self.btyp),
+            ("brm_code", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Rate Code"
+
     def doVat(self, frt, pag, r, c, p, i, w):
         vat = self.sql.getRec(tables="ctlvmf", cols=["vtm_desc"],
             where=[("vtm_cono", "=", self.opts["conum"]), ("vtm_code", "=",
@@ -144,14 +176,11 @@
             ("glm_acno", "=", acno)], limit=1)
 
     def doDelete(self):
-        chk = self.sql.getRec(tables="bkmmst", cols=["bkm_units"],
-            where=[("bkm_cono", "=", self.opts["conum"])])
-        for bkm in chk:
-            unt = bkm[0].split(":")
-            for un in unt:
-                u = un.split(",")
-                if u[0] == self.btyp and u[1] == self.ucod:
-                    return "Unit Used, Not Deleted"
+        chk = self.sql.getRec(tables="bkmrtt", where=[("brt_cono", "=",
+            self.opts["conum"]), ("brt_utype", "=", self.btyp), ("brt_ucode",
+            "=", self.ucod)])
+        if chk:
+            return "Unit Used, Not Deleted"
         self.sql.delRec("bkmunm", where=[("bum_cono", "=", self.opts["conum"]),
             ("bum_btyp", "=", self.btyp), ("bum_code", "=", self.ucod)])
         self.opts["mf"].dbm.commitDbase()
@@ -160,7 +189,7 @@
     def doEnd(self):
         data = [self.opts["conum"]]
         for x in xrange(0, len(self.df.t_work[0][0])):
-            if self.glint == "Y" and x == 7:
+            if self.glint == "Y" and x == 8:
                 continue
             data.append(self.df.t_work[0][0][x])
         if self.glint == "N":

=== modified file 'bkm/bkc510.py'
--- bkm/bkc510.py	2014-12-30 15:37:38 +0000
+++ bkm/bkc510.py	2015-01-27 16:21:14 +0000
@@ -173,8 +173,8 @@
     def doImport(self, widget=None):
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="bkmcon", impskp=["bkc_cono"])
-        sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Contacts", mxs=len(fi.impdat), esc=False)
+        sp = ProgressBar(self.opts["mf"].body, typ="Importing Contacts",
+            mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'bwl/bc1010.py'
--- bwl/bc1010.py	2014-12-30 15:37:38 +0000
+++ bwl/bc1010.py	2015-02-05 15:14:15 +0000
@@ -15,7 +15,7 @@
 
 from TartanClasses import CCD, FileImport, GetCtl, ProgressBar, RepPrt, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import askQuestion, getNextCode, showError
+from tartanFunctions import askQuestion, getNextCode, showError, showInfo
 
 class bc1010:
     def __init__(self, **opts):
@@ -346,6 +346,8 @@
                     self.sql.updRec(key[0], cols=[key[2]], data=[tab],
                         where=[(key[1], "=", self.opts["conum"]),
                         (key[2], "=", self.tab)])
+                showInfo(self.opts["mf"].body, "Non Member",
+                    "This Member has been converted to a Visitor")
             else:
                 return "There is History for this Player, Not Deleted"
         else:
@@ -543,7 +545,7 @@
             return
         fi = FileImport(self.opts["mf"], imptab="bwltab", impskp=self.impskp)
         sp = ProgressBar(self.opts["mf"].body, typ="Importing Ratings",
-            mxs=len(fi.impdat), esc=False)
+            mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'bwl/bc2020.py'
--- bwl/bc2020.py	2014-12-30 15:37:38 +0000
+++ bwl/bc2020.py	2015-01-21 19:22:14 +0000
@@ -143,9 +143,9 @@
         self.plr["where"] = [
             ("btb_cono", "=", self.opts["conum"]),
             ("btb_tab", "<", self.nstart)]
-        if acc[self.sql.bwlflf_col.index("bff_gender")] in ("M", "F"):
-            self.plr["where"].append(("btb_gender", "=",
-                acc[self.sql.bwlflf_col.index("bff_gender")]))
+        gndr = acc[self.sql.bwlflf_col.index("bff_gender")]
+        if gndr in ("F", "M"):
+            self.plr["where"].append(("btb_gender", "=", gndr))
         self.assess = acc[self.sql.bwlflf_col.index("bff_assess")]
         self.df.loadEntry(frt, pag, p+1, data=self.fdes)
 

=== modified file 'bwl/bc2050.py'
--- bwl/bc2050.py	2014-12-30 15:37:38 +0000
+++ bwl/bc2050.py	2015-02-05 07:48:11 +0000
@@ -1415,7 +1415,8 @@
             chk.extend([rec[0], rec[1]])
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             self.tname, ext="pdf")
-        self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+        self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+            wrkdir=self.opts["mf"].rcdic["wrkdir"])
         self.doLoadStatic()
         self.form.doNewDetail()
         tdc = self.form.sql.tpldet_col

=== modified file 'bwl/bc2070.py'
--- bwl/bc2070.py	2014-12-30 15:37:38 +0000
+++ bwl/bc2070.py	2015-01-24 10:50:02 +0000
@@ -374,7 +374,7 @@
             self.df.loadEntry("C", 0, idx+6, data=opp[2])
             self.df.loadEntry("C", 0, idx+7, data=opp[3])
             self.df.advanceLine(0)
-            if seq < 14:
+            if seq < 17:
                 seq += 1
 
     def doExit(self, widget=None):

=== modified file 'bwl/bc3020.py'
--- bwl/bc3020.py	2014-12-30 15:37:38 +0000
+++ bwl/bc3020.py	2015-02-05 15:21:25 +0000
@@ -167,7 +167,7 @@
             self.cnt = self.sql.getRec(tables=["bwltab", "bwldrt"],
                     cols=["count(*) as count", "bdt_tab"],
                     where=whr, group="bdt_tab",
-                    order="count desc")
+                    order="count desc, bdt_name")
             while self.cnt:
                 self.fpdf.add_page()
                 if len(self.cnt) < 26:

=== modified file 'crs/cr1010.py'
--- crs/cr1010.py	2014-12-30 15:37:38 +0000
+++ crs/cr1010.py	2015-01-27 16:24:39 +0000
@@ -261,7 +261,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="crsmst", impskp=["crm_cono"])
         sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Creditor's Accounts", mxs=len(fi.impdat), esc=False)
+            typ="Importing Creditor's Accounts", mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'crs/cr2010.py'
--- crs/cr2010.py	2014-12-30 15:37:38 +0000
+++ crs/cr2010.py	2015-01-20 07:56:17 +0000
@@ -251,6 +251,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):

=== modified file 'crs/cr2020_rne.py'
--- crs/cr2020_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr2020_rne.py	2015-02-05 07:48:33 +0000
@@ -212,7 +212,8 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
@@ -785,7 +786,8 @@
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
             head=self.tit, view=view, prtnam=self.prtnam, fadd=fadd, mail=mail)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'crs/cr3010.py'
--- crs/cr3010.py	2014-12-30 15:37:38 +0000
+++ crs/cr3010.py	2015-01-27 16:31:21 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %54s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.crstrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -146,16 +148,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'crs/cr3020.py'
--- crs/cr3020.py	2014-12-30 15:37:38 +0000
+++ crs/cr3020.py	2015-01-27 13:40:28 +0000
@@ -187,8 +187,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -229,11 +229,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -272,15 +269,14 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         acno = CCD(data[0], "NA", 7)

=== modified file 'crs/cr3030.py'
--- crs/cr3030.py	2014-12-30 15:37:38 +0000
+++ crs/cr3030.py	2015-01-27 13:40:28 +0000
@@ -94,10 +94,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(mst):
-            can = p.displayProgress(num)
-            if can == "yes":
-                self.fpdf.drawText()
-                self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             acno = CCD(rec[0], "NA", 7)
             name = CCD(rec[1], "NA", 30)
@@ -148,13 +146,12 @@
             if self.fpdf.page:
                 self.accountTotal()
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, acno, name, ptyp):
         self.fpdf.add_page()

=== modified file 'crs/cr3030_rne.py'
--- crs/cr3030_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3030_rne.py	2015-01-27 13:40:28 +0000
@@ -94,10 +94,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(mst):
-            can = p.displayProgress(num)
-            if can == "yes":
-                self.fpdf.drawText()
-                self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             acno = CCD(rec[0], "NA", 7)
             name = CCD(rec[1], "NA", 30)
@@ -170,13 +168,12 @@
             if self.fpdf.page:
                 self.accountTotal()
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, acno, name, ptyp):
         self.fpdf.add_page()

=== modified file 'crs/cr3040.py'
--- crs/cr3040.py	2014-12-30 15:37:38 +0000
+++ crs/cr3040.py	2015-01-27 13:40:28 +0000
@@ -85,11 +85,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(mst):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             acno = CCD(rec[0], "NA", 7)
             name = CCD(rec[1], "NA", 30)
@@ -133,15 +130,14 @@
             if  self.npag == "Y":
                 self.pglin = 999
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, acno, name):
         self.fpdf.add_page()

=== modified file 'crs/cr3050.py'
--- crs/cr3050.py	2014-12-30 15:37:38 +0000
+++ crs/cr3050.py	2015-01-27 13:40:28 +0000
@@ -182,8 +182,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -220,11 +220,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -238,16 +235,16 @@
                     vals[8].disp))
                 self.pglin += 1
         p.closeProgress()
-        if self.totsonly == "Y" and can != "yes":
+        if p.quit:
+            return
+        if self.totsonly == "Y":
             self.pageHeading()
+        if self.fpdf.page:
             self.grandTotal()
-        elif self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         acc = CCD(data[0], "NA", 7)

=== modified file 'crs/cr3060.py'
--- crs/cr3060.py	2014-12-30 15:37:38 +0000
+++ crs/cr3060.py	2015-01-27 13:40:28 +0000
@@ -81,18 +81,13 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %128s %10s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
         col = self.sql.crsmst_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             acno = CCD(dat[col.index("crm_acno")], "NA", 7)
             name = CCD(dat[col.index("crm_name")], "NA", 30)
@@ -133,10 +128,13 @@
                 self.pglin += 1
             self.pglin += 1
         p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def pageHeading(self):

=== modified file 'crs/cr3070.py'
--- crs/cr3070.py	2014-12-30 15:37:38 +0000
+++ crs/cr3070.py	2015-01-27 13:40:28 +0000
@@ -75,8 +75,6 @@
         self.view = self.df.repprt[0][1]
         self.prtnam = self.df.repprt[0][2]
         self.emadd = self.df.repprt[1][2]
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.prnt = "N"
         if self.whole == "S":
             recs = getSingleRecords(self.opts["mf"], "crsmst", ("crm_acno",
@@ -90,15 +88,14 @@
         if recs:
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-        if self.prnt == "Y":
+        if self.prnt == "Y" and self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=self.view, prtnam=self.prtnam,

=== modified file 'crs/cr3070_rne.py'
--- crs/cr3070_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3070_rne.py	2015-01-27 13:40:28 +0000
@@ -90,17 +90,14 @@
             num = len(recs)
             p = ProgressBar(self.opts["mf"].body, mxs=num, esc=True)
             for num, crm in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(crm)
             p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        if self.prnt == "Y":
+        if self.prnt == "Y" and self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=self.view, prtnam=self.prtnam,

=== modified file 'crs/cr3080.py'
--- crs/cr3080.py	2014-12-30 15:37:38 +0000
+++ crs/cr3080.py	2015-02-05 07:49:05 +0000
@@ -192,13 +192,14 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     self.opts["mf"].dbm.rollbackDbase()
                     break
                 self.doProcess(rec)
@@ -453,7 +454,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'crs/cr3090.py'
--- crs/cr3090.py	2014-12-30 15:37:38 +0000
+++ crs/cr3090.py	2015-01-27 13:40:28 +0000
@@ -110,20 +110,18 @@
             self.fpdf.add_page()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, dat in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(dat)
             p.closeProgress()
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.view, prtnam=self.prtnam,
-                mail=self.emadd)
+            if self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.view,
+                    prtnam=self.prtnam, mail=self.emadd)
         self.closeProcess()
 
     def doProcess(self, dat):

=== modified file 'crs/cr3100.py'
--- crs/cr3100.py	2014-12-30 15:37:38 +0000
+++ crs/cr3100.py	2015-01-27 13:40:28 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -59,7 +59,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Creditor's Masterfile Notes Listing"]
             cols = [

=== modified file 'crs/cr3110.py'
--- crs/cr3110.py	2014-12-30 15:37:38 +0000
+++ crs/cr3110.py	2015-01-27 13:40:28 +0000
@@ -103,8 +103,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -135,17 +135,12 @@
             "Period to %s%s" % (self.coffd, "%s%s")
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -156,9 +151,11 @@
                 vals[2]))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
+        if not self.fpdf.page or p.quit:
+            return
+        self.grandTotal()
+        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+            self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
             head=self.tit, view=self.df.repprt[0][1],

=== modified file 'crs/cr3310_rne.py'
--- crs/cr3310_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3310_rne.py	2015-01-27 13:40:28 +0000
@@ -106,8 +106,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -126,17 +126,12 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %110s %10s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if self.pglin > self.fpdf.lpp:
@@ -149,10 +144,13 @@
                 vals[15].disp, vals[16].disp, vals[17].disp, vals[18].disp))
             self.pglin += 1
         p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def getValues(self, data):

=== modified file 'crs/cr3320_rne.py'
--- crs/cr3320_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3320_rne.py	2015-02-05 10:48:37 +0000
@@ -13,10 +13,11 @@
     Copyright (C) 2004-2015 Paul Malherbe.
 """
 
-import time
+import copy, time
 from TartanClasses import ASD, CCD, MyFpdf, ProgressBar, SplashScreen, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import getModName, doPrinter, showError, showInfo
+from tartanFunctions import doPrinter, getModName, getSingleRecords, showError
+from tartanFunctions import showInfo
 from tartanWork import crtrtp
 
 class cr3320:
@@ -82,11 +83,20 @@
         self.reprint = w
         if self.reprint == "Y":
             self.preview = "Y"
-            return "sk1"
+            col=["ctm_cono", "ctm_name"]
+            dic={}
+            for c in col:
+                dic[c] = self.sql.ctlmst_dic[c]
+            brs = getSingleRecords(self.opts["mf"], "ctlmst",
+                col, dic=dic, order="ctm_cono")
+            self.branch = []
+            for b in brs:
+                self.branch.append(b[0])
+            return "sk2"
 
     def doPreview(self, frt, pag, r, c, p, i, w):
         self.preview = w
-        self.branch = 0
+        self.branch = [0]
         self.startn = 0
         self.endn = 0
         self.startd = 0
@@ -94,7 +104,7 @@
         return "sk5"
 
     def doBranch(self, frt, pag, r, c, p, i, w):
-        self.branch = w
+        self.branch = [w]
 
     def doStartN(self, frt, pag, r, c, p, i, w):
         self.startn = w
@@ -119,38 +129,47 @@
 
     def doEnd(self):
         self.df.closeProcess()
-        sp = SplashScreen(self.opts["mf"].body,
-            "Generating Report\n\nPlease Wait...")
         col = ["rtf_depno", "rtf_acno", "rtf_ref1", "rtf_type", "rtf_pjno",
             "rtf_prtdte"]
         whr = [("rtf_cono", "=", self.opts["conum"]), ("rtf_type", "<>", 5)]
+        odr = "rtf_depno, rtf_pjno, crt_seq"
         if self.reprint == "N":
             whr.extend([("rtf_depno", "<>", 0), ("rtf_pjno", "=", 0)])
         else:
-            if self.branch:
-                whr.append(("rtf_depno", "=", self.branch))
-            else:
-                whr.append(("rtf_depno", "<>", 0))
             if self.startn:
                 whr.append(("rtf_pjno", "between", self.startn, self.endn))
             if self.startd:
                 whr.append(("rtf_prtdte", "between", self.startd, self.endd))
-        whr.extend([("crt_cono=rtf_cono",), ("crt_acno=rtf_acno",),
-            ("crt_type=rtf_type",), ("crt_ref1=rtf_ref1",)])
-        odr = "rtf_depno, rtf_pjno, crt_seq"
-        recs = self.sql.getRec(tables=["crsrtf", "crstrn"], cols=col,
-            where=whr, order=odr)
-        sp.closeSplash()
-        if not recs:
-            showError(self.opts["mf"].body, "Selection Error",
-                "No Transactions Selected")
-        else:
-            self.printReport(recs)
-            if self.preview == "N":
-                self.opts["mf"].dbm.commitDbase(ask=True)
-                if self.opts["mf"].dbm.commit == "no":
-                    showInfo(self.opts["mf"].body, "Not Saved",
-                        "These Purchase Journals Have NOT Been Saved!")
+        for branch in self.branch:
+            sp = SplashScreen(self.opts["mf"].body,
+                "Generating Report for Branch %s\n\nPlease Wait..." % branch)
+            w = copy.deepcopy(whr)
+            if branch:
+                w.append(("rtf_depno", "=", branch))
+            else:
+                w.append(("rtf_depno", "<>", 0))
+            w.extend([("crt_cono=rtf_cono",), ("crt_acno=rtf_acno",),
+                ("crt_type=rtf_type",), ("crt_ref1=rtf_ref1",)])
+            recs = self.sql.getRec(tables=["crsrtf", "crstrn"], cols=col,
+                where=w, order=odr)
+            sp.closeSplash()
+            if not recs:
+                if self.reprint == "N":
+                    showError(self.opts["mf"].body, "Selection Error",
+                        "No Transactions Selected")
+            else:
+                self.printReport(recs)
+        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+            self.opts["conum"], ext="pdf")
+        self.fpdf.output(pdfnam, "F")
+        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+            rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.preview == "N":
+            self.opts["mf"].dbm.commitDbase(ask=True)
+            if self.opts["mf"].dbm.commit == "no":
+                showInfo(self.opts["mf"].body, "Not Saved",
+                    "These Purchase Journals Have NOT Been Saved!")
         self.opts["mf"].closeLoop()
 
     def printReport(self, recs):
@@ -159,11 +178,8 @@
         else:
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if self.preview == "Y" and can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if self.preview == "Y" and p.quit:
                 break
             depno = CCD(dat[0], "UI", 3)
             acno = CCD(dat[1], "NA", 7)
@@ -235,15 +251,8 @@
             self.totnet = float(ASD(self.totnet) + ASD(tramt.work))
             self.totdis = float(ASD(self.totdis) + ASD(disamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.branchTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.branchTotal()
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'crs/cr3330_rne.py'
--- crs/cr3330_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3330_rne.py	2015-01-27 13:40:28 +0000
@@ -203,8 +203,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -228,11 +228,8 @@
             self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         for num, dat in enumerate(data):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -246,13 +243,12 @@
                 ict.disp, adv.disp, avt.disp))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         dep = CCD(data[0], "UI", 3)

=== modified file 'crs/cr3340_rne.py'
--- crs/cr3340_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3340_rne.py	2015-01-27 13:40:28 +0000
@@ -221,8 +221,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -254,11 +254,8 @@
             self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         for num, dat in enumerate(data):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -285,14 +282,13 @@
             self.stot[7] = float(ASD(self.stot[7]) + ASD(avt.work))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.doBranchTotal()
-                self.doGrandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.doBranchTotal()
+            self.doGrandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         bch = CCD(data[0], "UI", 3)

=== modified file 'crs/cr3350_rne.py'
--- crs/cr3350_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3350_rne.py	2015-01-27 13:40:28 +0000
@@ -198,11 +198,8 @@
         self.gtot = [0, 0, 0, 0, 0, 0, 0, 0]
         p = ProgressBar(self.opts["mf"].body, mxs=len(data), esc=True)
         for num, rec in enumerate(data):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             acc = CCD(rec[0], "NA", 7)
             bch = CCD(rec[1], "UI", 3)
@@ -243,16 +240,15 @@
             self.stot[6] = float(ASD(self.stot[6]) + ASD(adv.work))
             self.stot[7] = float(ASD(self.stot[7]) + ASD(avt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.doSupplierTotal()
-                self.doGrandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.doSupplierTotal()
+            self.doGrandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'crs/cr3360_rne.py'
--- crs/cr3360_rne.py	2014-12-30 15:37:38 +0000
+++ crs/cr3360_rne.py	2015-02-05 07:49:23 +0000
@@ -138,7 +138,8 @@
         if not recs:
             showError(self.opts["mf"].body, "Error", "No Records Selected")
         else:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             self.df.setWidget(self.df.mstFrame, state="hide")
@@ -404,7 +405,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, fadd=fadd, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'csh/ca3010.py'
--- csh/ca3010.py	2014-12-30 15:37:38 +0000
+++ csh/ca3010.py	2015-01-27 13:40:28 +0000
@@ -110,19 +110,19 @@
         self.pglin = 999
         self.pageHeading()
         self.printPettyCash(self.tk1)
-        if self.can != "yes":
+        if not self.quit:
             self.pageHeading()
             self.printTakings(self.tk2)
-            if self.can != "yes":
+            if not self.quit:
                 self.pageHeading()
                 self.printSummary()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
+        if not self.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def printPettyCash(self, recs):
@@ -139,11 +139,9 @@
         c1 = self.sql.cshana_col
         pb = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         for num, dat in enumerate(recs):
-            self.can = pb.displayProgress(num)
-            if self.can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            pb.displayProgress(num)
+            self.quit = pb.quit
+            if self.quit:
                 break
             trdt = CCD(dat[c1.index("can_trdt")], "D1", 10)
             code = CCD(dat[c1.index("can_code")], "UI", 5)
@@ -158,7 +156,7 @@
             tot = float(ASD(tot) + ASD(inca.work))
             vat = float(ASD(vat) + ASD(vata.work))
         pb.closeProgress()
-        if self.can == "yes":
+        if self.quit:
             return
         self.exp = CCD(tot, "SD", 13.2)
         vat = CCD(vat, "SD", 13.2)
@@ -181,11 +179,9 @@
         c1 = self.sql.cshana_col
         pb = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         for num, dat in enumerate(recs):
-            self.can = pb.displayProgress(num)
-            if self.can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            pb.displayProgress(num)
+            self.quit = pb.quit
+            if self.quit:
                 break
             trdt = CCD(dat[c1.index("can_trdt")], "D1", 10)
             code = CCD(dat[c1.index("can_code")], "UI", 5)
@@ -198,7 +194,7 @@
             self.pglin += 1
             tot = float(ASD(tot) + ASD(inca.work))
         pb.closeProgress()
-        if self.can == "yes":
+        if self.quit:
             return
         tot = CCD(tot, "SD", 13.2)
         self.fpdf.drawText("%67s %-12s" % ("", self.fpdf.suc*12))

=== modified file 'csv/bkmmst_fld.csv'
--- csv/bkmmst_fld.csv	2014-12-09 16:32:44 +0000
+++ csv/bkmmst_fld.csv	2015-01-20 05:36:26 +0000
@@ -11,6 +11,6 @@
 10,"bkm_stddte","D1","10.0","Deposit I-Date","I-Due-Date"
 11,"bkm_grpdep","UD","10.2","Deposit G-Value","G-Dep-Val"
 12,"bkm_grpdte","D1","10.0","Deposit G-Date","G-Due-Date"
-13,"bkm_special","TX","50.0","Special Requests","Special-Requests"
+13,"bkm_remarks","TX","50.0","Remarks","Remarks"
 14,"bkm_state","UA","1.0","Booking Status","S"
 15,"bkm_ccode","UA","7.0","Contact Code","Contact"

=== modified file 'csv/bkmrtt_idx.csv'
--- csv/bkmrtt_idx.csv	2015-01-01 12:48:11 +0000
+++ csv/bkmrtt_idx.csv	2015-01-04 10:59:21 +0000
@@ -1,2 +1,1 @@
 "Bookings Rate Transactions",1,"U","brt_seq"
-"",2,"U","brt_cono","brt_number","brt_utype","brt_ucode","brt_uroom","brt_rcode"

=== modified file 'csv/bkmunm_fld.csv'
--- csv/bkmunm_fld.csv	2015-01-01 12:48:11 +0000
+++ csv/bkmunm_fld.csv	2015-01-04 11:24:48 +0000
@@ -4,5 +4,6 @@
 3,"bum_desc","TX","30.0","Description","Description"
 4,"bum_room","UI","3.0","Number of Rooms","Rms"
 5,"bum_maxg","UI","3.0","Maximum Guests","Qty"
-6,"bum_vatc","UA","1.0","Vat Code","V"
-7,"bum_slsa","UI","7.0","G/L Sales Account","Acc-Num"
+6,"bum_dflt","UI","3.0","Default Rate","Rte"
+7,"bum_vatc","UA","1.0","Vat Code","V"
+8,"bum_slsa","UI","7.0","Sales Account","Sls-Acc"

=== added file 'csv/bwlclb.sys'
--- csv/bwlclb.sys	1970-01-01 00:00:00 +0000
+++ csv/bwlclb.sys	2015-01-01 16:39:40 +0000
@@ -0,0 +1,76 @@
+bwlclb
+bwlcmp
+bwlctl
+bwldrm
+bwldrt
+bwlent
+bwlflf
+bwlflm
+bwlflo
+bwlfls
+bwlflt
+bwlgme
+bwlrnd
+bwltab
+bwltyp
+chglog
+ctlare
+ctlbat
+ctlctl
+ctldep
+ctllog
+ctlmes
+ctlmst
+ctlnot
+ctlpwm
+ctlpwr
+ctlpwu
+ctlrep
+ctlsys
+ctlvmf
+ctlvrf
+ctlvtf
+ctlynd
+emllog
+frelat
+genbal
+genbud
+gendtm
+gendtt
+genint
+genjlm
+genjlt
+genmst
+genrcc
+genrct
+genrpc
+genrpt
+genstr
+gentrn
+memadd
+memage
+memcat
+memctc
+memctk
+memctl
+memcto
+memctp
+memkon
+memlnk
+memmst
+memsta
+memtrn
+memtrs
+rptcol
+rptexc
+rptjon
+rptmst
+rptord
+rpttab
+rptvar
+telcon
+telgrp
+telmst
+tplmst
+tpldet
+verupd

=== modified file 'csv/genrct_fld.csv'
--- csv/genrct_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/genrct_fld.csv	2015-02-04 19:05:28 +0000
@@ -1,9 +1,9 @@
 0,"grt_cono","UI","3.0","Company Number","Coy"
 1,"grt_acno","UI","7.0","Account Number","Acc-Num"
 2,"grt_date","D1","10.0","Date","Date"
-3,"grt_memo","NA","100.0","Memo Details","Memo Details"
+3,"grt_memo","TX","50.0","Memo Details","Memo Details"
 4,"grt_refno","Na","9.0","Reference Number","Reference"
-5,"grt_payee","NA","50.0","Payee","Payee"
+5,"grt_payee","TX","50.0","Payee","Payee"
 6,"grt_amount","SD","13.2","Amount","Amount"
 7,"grt_flag","UA","1.0","Used Flag","F"
 8,"grt_seq","US","10.0","Sequence","Sequence"

=== modified file 'csv/memctl_fld.csv'
--- csv/memctl_fld.csv	2014-03-28 07:32:49 +0000
+++ csv/memctl_fld.csv	2015-02-04 19:03:37 +0000
@@ -2,7 +2,7 @@
 1,"mcm_glint","UA","1.0","Integration","I"
 2,"mcm_ldays","UI","2.0","Days Limit","DL"
 3,"mcm_lme","d1","10.0","Last Month End","LME-Date"
-4,"mcm_photo","NA","100.0","Photo Directory","Photo-Directory"
+4,"mcm_photo","TX","50.0","Photo Directory","Photo-Directory"
 5,"mcm_acs","UA","1.0","Access Control","A"
 6,"mcm_ahst","NA","20.0","Access Host","Host Name or IP"
 7,"mcm_adbn","TX","20.0","Access Database","Database-Name"

=== modified file 'csv/rnehol.sys'
--- csv/rnehol.sys	2014-12-30 15:37:38 +0000
+++ csv/rnehol.sys	2015-02-06 09:33:54 +0000
@@ -88,6 +88,7 @@
 struoi
 strvar
 telcon
+telgrp
 telmst
 tplmst
 tpldet

=== modified file 'csv/tpldet.dat'
--- csv/tpldet.dat	2015-01-01 12:48:11 +0000
+++ csv/tpldet.dat	2015-02-02 07:33:59 +0000
@@ -30,7 +30,7 @@
 booking_invoice|10.0|C|A|L|FaxNo:|courier|10|#000000|Y|N|N|L||N|124.0|7|139.0|26.0|31.0|0.0|ctm_fax|courier|10|#000000|Y|N|N|L||N|139.0|15|171.0|26.0|31.0|1|1
 booking_invoice|11.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|document_type|courier|12|#000000|Y|N|N|R||N|222.0|22|278.0|15.0|20.0|1|1
 booking_invoice|12.0|C|A|H|Charge To:|courier|10|#000000|Y|N|N|L|TLRB|Y|30.0|30|96.0|35.0|40.0|0.0|contact_details|courier|10|#000000|N|N|N|L|TLRB|N|30.0|30|96.0|40.0|44.0|5|1
-booking_invoice|13.0|C|A|H|Booking|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|36.0|41.0|0.0|bkm_number|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|41.0|45.0|1|1
+booking_invoice|13.0|C|A|H|Doc-Number|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|36.0|41.0|0.0|document_number|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|41.0|45.0|1|1
 booking_invoice|14.0|C|A|H|Page No|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|45.0|50.0|0.0|page_number|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|50.0|54.0|1|1
 booking_invoice|15.0|C|A|H|Date|courier|10|#000000|Y|N|N|C|TLRB|Y|255.0|10|278.0|54.0|59.0|0.0|document_date|courier|10|#000000|N|N|N|C|TLRB|N|255.0|10|278.0|59.0|63.0|1|1
 booking_invoice|16.0|C|A|H|Arrival|courier|10|#000000|Y|N|N|C|TLRB|Y|30.0|10|53.0|63.0|68.0|0.0|bkm_arrive|courier|10|#000000|N|N|N|C|TLRB|N|30.0|10|53.0|68.0|72.0|1|1
@@ -59,7 +59,7 @@
 booking_invoice|39.0|C|D|L|Account:|courier|10|#000000|Y|N|N|L|LB|N|111.0|8|130.0|180.0|184.0|0.0|ctm_b_acno|courier|10|#000000|N|N|N|L|RB|N|130.0|30|196.0|180.0|184.0|1|1
 booking_invoice|40.0|C|C|L|Movements|courier|10|#000000|Y|N|N|L|TLRB|Y|218.0|13|248.0|162.0|167.0|0.0|total_movements|courier|10|#000000|Y|N|N|R|TLRB|N|248.0|13|278.0|162.0|167.0|1|1
 booking_invoice|41.0|C|C|L|Balance|courier|10|#000000|Y|N|N|L|TLRB|Y|218.0|13|248.0|167.0|172.0|0.0|total_balance|courier|10|#000000|Y|N|N|R|TLRB|N|248.0|13|278.0|167.0|172.0|1|1
-booking_statement|1.0|I|A||||0|#000000|||||||15.0|0|130.0|15.0|35.0|0.0|ctm_logo||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+booking_statement|1.0|I|A||||0|#000000|||||||15.0|0|130.0|15.0|45.0|0.0|letterhead||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
 booking_statement|2.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|15.0|30|129.0|15.0|20.0|1|1
 booking_statement|3.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|15.0|30|78.0|21.0|25.0|1|1
 booking_statement|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|85.0|7|100.0|21.0|25.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|100.0|20|142.0|21.0|25.0|1|1
@@ -106,7 +106,7 @@
 member_cards|5.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|name_init|helvetica|12|Y|N|N|L||N|28.0|30|116.0|32.0|37.0|1|1
 member_cards|6.0|C|A|N|||0|||||||0.0|0|0.0|0.0|0.0|0.0|main_category|helvetica|12|Y|N|N|L||N|28.0|30|116.0|42.0|47.0|1|1
 member_cards|7.0|T|A||Membership cards are NOT transferable|helvetica|10|N|N|N|C||Y|2.0|34|84.0|49.0|54.0|0.0|||0|||||||0.0|0|0.0|0.0|0.0|0|0
-payslip|1.0|I|A||||0|#000000|||||||30.0|0|145.0|15.0|35.0|0.0|letterhead||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
+payslip|1.0|I|A||||0|#000000|||||||30.0|0|185.0|10.0|40.0|0.0|letterhead||0|#000000|||||||0.0|0|0.0|0.0|0.0|0|0
 payslip|2.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_name|courier|18|#000000|Y|N|N|L||N|30.0|30|144.0|15.0|20.0|1|1
 payslip|3.0|C|A|N|||0|#000000|||||||0.0|0|0.0|0.0|0.0|0.0|ctm_add1|courier|10|#000000|Y|N|N|L||N|30.0|30|93.0|21.0|25.0|1|1
 payslip|4.0|C|A|L|RegNo:|courier|10|#000000|Y|N|N|L||N|100.0|7|115.0|21.0|25.0|0.0|ctm_regno|courier|10|#000000|Y|N|N|L||N|115.0|20|157.0|21.0|25.0|1|1

=== modified file 'csv/wagmst_fld.csv'
--- csv/wagmst_fld.csv	2014-04-07 20:41:10 +0000
+++ csv/wagmst_fld.csv	2015-01-30 12:46:14 +0000
@@ -15,7 +15,7 @@
 14,"wgm_telno","NA","16.0","Telephone Number","Telephone Number"
 15,"wgm_emadd","TX","50.0","Email Address","Email Address"
 16,"wgm_start","d1","10.0","Start Date","Start-Date"
-17,"wgm_payamt","UD","10.2","Salary","Salary"
+17,"wgm_payamt","UD","10.2","Salary/Rate","Salary/Rte"
 18,"wgm_freq","UA","1.0","Pay Frequency","F"
 19,"wgm_ptype","UA","1.0","Pay Type","T"
 20,"wgm_paye","UA","1.0","Pay PAYE (Y/N)","P"

=== modified file 'doc/BK.rst'
--- doc/BK.rst	2014-12-30 15:37:38 +0000
+++ doc/BK.rst	2015-01-07 12:06:04 +0000
@@ -16,12 +16,13 @@
 +++++++++++++++++
 Use this routine to maintain unit records.
 
-+  **Type** - Select the type of unit.
-+  **Code** - Enter a code which can be up to 6 alphanumeric characters.
++  **Booking Type** - Select the type of unit.
++  **Unit Code** - Enter a code which can be up to 6 alphanumeric characters.
 +  **Description** - Enter a description for the unit.
-+  **Multiple** - Select whether the unit can appear on multiple bookings for the same period.
-+  **Capacity** - Enter the minimum capacity for bookings.
-+  **Vat Code** - Enter the vat code applicable to this unit.
++  **Number of Rooms** - Enter the number of bookable rooms in the unit.
++  **Total Capacity** - Enter the total booking capacity for the unit. Enter 999 for infinite capacity.
++  **Default Rate** - The default rate code for the unit.
++  **Vat Code** - Enter the vat code applicable to the unit.
 +  **Sales Account** - Enter the G/L sales account, if integrated.
 
 Rate Records (BK)
@@ -165,13 +166,15 @@
 + **Number of Persons** - The number of people.
 + **Arrival (YYYYMMDD)** - The date of arrival.
 + **Departure (YYYYMMDD)** - The date of departure.
-+ **Allocated Units** - The units allocated to this booking.
++ **Units** - Select whether to Continue with the existing booking or Edit the units booked.
     + **Unit-Cod** - The unit's code made up of the unit type and the unit's code.
     + **Description** - The description of the unit.
-    + **Rate** - The rate code to apply to this unit.
-    + **Qty** - The quantity to multiply the rate by.
-    + **Disc** - The discount percentage if applicable.
-    + **Applied-Rt** - The final applicable rate.
+    + **Rme** - The room code to allocate or zero for all rooms in the unit.
+    + **Rte** - The rate code to apply to this unit.
+    + **Ppl** - The number of guests.
+    + **Per** - The periods, if applicable.
+    + **Disc-%** - The discount percentage, if applicable.
+    + **Applied-Rt** - The final applicable rate or zero for no charge.
 + **Value** - The total value of the booking.
 + **Initial Deposit** - The initial deposit if applicable. If no deposit is entered the status of the booking will immediately be upgraded to confirmed.
 + **Initial Dep Due** - The last date that the initial deposit must be received by.
@@ -180,6 +183,12 @@
 + **Account Balance** - The balance of the account. This could be a minus amount if a deposit has been received and the invoice not yet raised.
 + **Remarks** - Any additional details.
 
+Contact (BK)
+++++++++++++
+This page contains all the relevant contact details. All the fields are self explanatory with the exception of the following:
+
++ **Contact Code** - The contact's code or blank for a new contact.
+
 Booking Buttons (BK)
 ++++++++++++++++++++
 + **Edit** - Select this button to alter an existing booking.
@@ -203,8 +212,9 @@
 + **Accept** - Select this button to accept the booking and to print a booking letter.
 + **Quit** - Select this button to terminate the current displayed booking.
 
-Contact (BK)
-++++++++++++
-This page contains all the relevant contact details. All the fields are self explanatory with the exception of the following:
-
-+ **Contact Code** - The contact's code or blank for a new contact.
+Unit and Rate Buttons (BK)
+++++++++++++++++++++++++++
++ **Clear** - Select this button to clear all un-invoiced units.
++ **Edit** - Select this button to edit an existing unit.
++ **Exit** - Select this button to exit the screen.
++ **Quit** - Select this button the quit the screen.

=== modified file 'doc/Bowls.rst'
--- doc/Bowls.rst	2014-12-30 15:37:38 +0000
+++ doc/Bowls.rst	2015-01-20 06:34:36 +0000
@@ -302,7 +302,7 @@
 
 + **Database**
 
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL, Firebird or MsSQL 2000. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
+    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
     + **Database Name** - This can be any single word name defaulting to **tartan**.
     + **Host Name** - This is the host name of the Server. This is not used with SQLite.
     + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.

=== modified file 'doc/Changes.rst'
--- doc/Changes.rst	2014-12-30 15:37:38 +0000
+++ doc/Changes.rst	2015-01-01 12:48:18 +0000
@@ -1,3 +1,8 @@
+ver_5.0.3
+=========
+This version, 5.0.2, fixes some more minor bugs and includes some additional
+new modules especially in the Bookings system.
+
 ver_5.0.2
 =========
 This version, 5.0.2, fixes some minor bugs and includes some minor enhancements.

=== modified file 'doc/Downloads.rst'
--- doc/Downloads.rst	2015-01-01 12:48:11 +0000
+++ doc/Downloads.rst	2015-02-07 06:31:07 +0000
@@ -11,16 +11,16 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.0.3 and was released on the 1st January, 2015.
+The latest version of Tartan is 5.0.4 and was released on the 7th February, 2015.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Documentation: http://www.tartan.co.za/cgi-bin/simple_web.py/Documentation
-.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.0.3.tar.gz
+.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.0.4.tar.gz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.10.tar.gz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tar.gz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tar.gz
-.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.0.3.exe
+.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.0.4.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.10.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
 .. _Tartan-2-win: ftp://tartan.co.za/Tartan_2.5.29.exe

=== modified file 'doc/HD.rst'
--- doc/HD.rst	2014-12-30 15:37:38 +0000
+++ doc/HD.rst	2015-01-31 12:25:37 +0000
@@ -7,6 +7,10 @@
 + **Licence** - The Tartan licence details.
 + **Changes** - The Tartan changes since version 4 to date.
 
-Tartan Manual
-.............
-This routine will display this manual using your default browser.
+Reference Manual
+................
+This routine will display this manual, if available, or the on-line one using your default browser.
+
+Quick Start Manual
+..................
+This routine will display the quick start manual, if available, or the on-line one using your default browser.

=== modified file 'doc/MD.rst'
--- doc/MD.rst	2015-01-01 12:48:11 +0000
+++ doc/MD.rst	2015-02-07 06:31:07 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.0.3
+:Version:   5.0.4
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -54,14 +54,17 @@
 ~~~~~~~~~~~~~~~~
 Ensure that the following dependencies are installed on your system:
 
-+ python >= 2.7.0 and < 3.0.0
-+ python Imaging >= 1.1.7
++ python >= 2.7.5 and < 3.0.0
++ python-tk >= 2.7.5 and < 3.0.0
++ python-imaging >= 2.3.0
++ python-pil >= 2.3.0
++ python-pil.imagetk >= 2.3.0
 
-Additionally, the following dependencies should also be installed:
+Additionally, the following dependencies should also be installed using pip:
 
 + odfpy >= 0.9.6
-+ python Markdown >= 2.0
-+ pychart >= 1.39
++ markdown >= 2.0
++ Python-Chart >= 1.39
 + xlrd >= 0.7.1
 + xlwt >= 0.7.1
 
@@ -69,14 +72,14 @@
 
 + Pysqlite >= 2.6.3
 
-or
+or one of:
 
 + Postgresql >= 8.4.0
 + Psycopg2 >= 2.0.4
 
-or
+or one of:
 
-+ Mysql >= 5.0.3
++ Mysql >= 5.0.4
 + Mysql-python >= 1.2.0
 
 Download the following file from ftp://ftp.tartan.co.za
@@ -95,7 +98,7 @@
 
 + Tartan_full_5.x.x.exe
 
-Install Tartan_full_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, agree to creating an icon on your desktop.
+Install Tartan_full_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, also agree to creating an icon on your desktop.
 
 Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
 
@@ -249,7 +252,7 @@
 
 .. csv-table::
   :header: "Coy", "SS", "Prog", "Password", "Meaning"
-  :widths: 4, 4, 6, 8, 50
+  :widths: 5, 5, 6, 10, 50
 
   "0", "gl", "    ", "    ", "All general ledger modules for all companies would be denied."
   "0", "gl", "2032", "    ", "General ledger payments data capture for all companies would be denied."
@@ -302,7 +305,7 @@
 
 + **Database**
 
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL, Firebird or MsSQL 2000. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
+    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
     + **Database Name** - This can be any single word name defaulting to **tartan**.
     + **Host Name** - This is the host name of the Server. This is not used with SQLite.
     + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
@@ -331,21 +334,31 @@
 + **Dialog**
 
     + **Menu Font**
-        + **Name** - This is the font to be used for all menu items.
+        + **Name** - This is the font family to be used for all menu items.
         + **Size** - This is font size to be used for all menu items.
     + **Default Font**
-        + **Name** - This is the font to be used in all other cases.
+        + **Name** - This is the font family to be used in all other cases.
         + **Size** - This is font size to be used in all other cases.
     + **Theme** - The theme to be used. The default theme is `clam`.
+    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
     + **Normal**
         + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button foreground colour.
+        + **BG** - The normal label and button background colour.
     + **Focus**
         + **FG** - The focused button foreground colour.
-        + **BG** - The focused button foreground colour.
+        + **BG** - The focused button background colour.
     + **Disable**
         + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button foreground colour.
+        + **BG** - The disabled button background colour.
+    + **Booking Query**
+        + **FG** - The booking manager calendar query foreground colour.
+        + **BG** - The booking manager calendar query background colour.
+    + **Booking Confirmed**
+        + **FG** - The booking manager calendar confirm foreground colour.
+        + **BG** - The booking manager calendar confirm background colour.
+    + **Booking Settled**
+        + **FG** - The booking manager calendar settle foreground colour.
+        + **BG** - The booking manager calendar settle background colour.
 
 If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Company Record`.
 

=== modified file 'doc/Manual.rst'
--- doc/Manual.rst	2014-12-30 15:37:38 +0000
+++ doc/Manual.rst	2015-01-31 08:47:01 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.0.2
+:Version:   5.0.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -76,7 +76,7 @@
 
 or
 
-+ Mysql >= 5.0.2
++ Mysql >= 5.0.3
 + Mysql-python >= 1.2.0
 
 Download the following file from ftp://ftp.tartan.co.za
@@ -249,7 +249,7 @@
 
 .. csv-table::
   :header: "Coy", "SS", "Prog", "Password", "Meaning"
-  :widths: 4, 4, 6, 8, 50
+  :widths: 5, 5, 6, 10, 50
 
   "0", "gl", "    ", "    ", "All general ledger modules for all companies would be denied."
   "0", "gl", "2032", "    ", "General ledger payments data capture for all companies would be denied."
@@ -302,7 +302,7 @@
 
 + **Database**
 
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL, Firebird or MsSQL 2000. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
+    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
     + **Database Name** - This can be any single word name defaulting to **tartan**.
     + **Host Name** - This is the host name of the Server. This is not used with SQLite.
     + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
@@ -331,21 +331,31 @@
 + **Dialog**
 
     + **Menu Font**
-        + **Name** - This is the font to be used for all menu items.
+        + **Name** - This is the font family to be used for all menu items.
         + **Size** - This is font size to be used for all menu items.
     + **Default Font**
-        + **Name** - This is the font to be used in all other cases.
+        + **Name** - This is the font family to be used in all other cases.
         + **Size** - This is font size to be used in all other cases.
     + **Theme** - The theme to be used. The default theme is `clam`.
+    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
     + **Normal**
         + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button foreground colour.
+        + **BG** - The normal label and button background colour.
     + **Focus**
         + **FG** - The focused button foreground colour.
-        + **BG** - The focused button foreground colour.
+        + **BG** - The focused button background colour.
     + **Disable**
         + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button foreground colour.
+        + **BG** - The disabled button background colour.
+    + **Booking Query**
+        + **FG** - The booking manager calendar query foreground colour.
+        + **BG** - The booking manager calendar query background colour.
+    + **Booking Confirmed**
+        + **FG** - The booking manager calendar confirm foreground colour.
+        + **BG** - The booking manager calendar confirm background colour.
+    + **Booking Settled**
+        + **FG** - The booking manager calendar settle foreground colour.
+        + **BG** - The booking manager calendar settle background colour.
 
 If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Company Record`.
 
@@ -1457,12 +1467,13 @@
 +++++++++++++++++
 Use this routine to maintain unit records.
 
-+  **Type** - Select the type of unit.
-+  **Code** - Enter a code which can be up to 6 alphanumeric characters.
++  **Booking Type** - Select the type of unit.
++  **Unit Code** - Enter a code which can be up to 6 alphanumeric characters.
 +  **Description** - Enter a description for the unit.
-+  **Multiple** - Select whether the unit can appear on multiple bookings for the same period.
-+  **Capacity** - Enter the minimum capacity for bookings.
-+  **Vat Code** - Enter the vat code applicable to this unit.
++  **Number of Rooms** - Enter the number of bookable rooms in the unit.
++  **Total Capacity** - Enter the total booking capacity for the unit. Enter 999 for infinite capacity.
++  **Default Rate** - The default rate code for the unit.
++  **Vat Code** - Enter the vat code applicable to the unit.
 +  **Sales Account** - Enter the G/L sales account, if integrated.
 
 Rate Records (BK)
@@ -1606,13 +1617,15 @@
 + **Number of Persons** - The number of people.
 + **Arrival (YYYYMMDD)** - The date of arrival.
 + **Departure (YYYYMMDD)** - The date of departure.
-+ **Allocated Units** - The units allocated to this booking.
++ **Units** - Select whether to Continue with the existing booking or Edit the units booked.
     + **Unit-Cod** - The unit's code made up of the unit type and the unit's code.
     + **Description** - The description of the unit.
-    + **Rate** - The rate code to apply to this unit.
-    + **Qty** - The quantity to multiply the rate by.
-    + **Disc** - The discount percentage if applicable.
-    + **Applied-Rt** - The final applicable rate.
+    + **Rme** - The room code to allocate or zero for all rooms in the unit.
+    + **Rte** - The rate code to apply to this unit.
+    + **Ppl** - The number of guests.
+    + **Per** - The periods, if applicable.
+    + **Disc-%** - The discount percentage, if applicable.
+    + **Applied-Rt** - The final applicable rate or zero for no charge.
 + **Value** - The total value of the booking.
 + **Initial Deposit** - The initial deposit if applicable. If no deposit is entered the status of the booking will immediately be upgraded to confirmed.
 + **Initial Dep Due** - The last date that the initial deposit must be received by.
@@ -1621,6 +1634,12 @@
 + **Account Balance** - The balance of the account. This could be a minus amount if a deposit has been received and the invoice not yet raised.
 + **Remarks** - Any additional details.
 
+Contact (BK)
+++++++++++++
+This page contains all the relevant contact details. All the fields are self explanatory with the exception of the following:
+
++ **Contact Code** - The contact's code or blank for a new contact.
+
 Booking Buttons (BK)
 ++++++++++++++++++++
 + **Edit** - Select this button to alter an existing booking.
@@ -1644,11 +1663,12 @@
 + **Accept** - Select this button to accept the booking and to print a booking letter.
 + **Quit** - Select this button to terminate the current displayed booking.
 
-Contact (BK)
-++++++++++++
-This page contains all the relevant contact details. All the fields are self explanatory with the exception of the following:
-
-+ **Contact Code** - The contact's code or blank for a new contact.
+Unit and Rate Buttons (BK)
+++++++++++++++++++++++++++
++ **Clear** - Select this button to clear all un-invoiced units.
++ **Edit** - Select this button to edit an existing unit.
++ **Exit** - Select this button to exit the screen.
++ **Quit** - Select this button the quit the screen.
 
 .. raw:: pdf
 
@@ -2939,23 +2959,15 @@
 .....................
 Control Record (WG)
 +++++++++++++++++++
-Use this routine to create and amend the salary's and wage's control record.
-
-Branch Records (WG)
-+++++++++++++++++++
-Use this routine to create and amend the salary's and wage's branch records.
-
-Department Records (WG)
-+++++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's department records.
+Use this routine to create and amend the control record.
 
 Receiver Codes (WG)
 +++++++++++++++++++
-Use this routine to create and amend the salary's and wage's receiver of revenue irp5 records.
+Use this routine to create and amend the receiver of revenue irp5 codes.
 
 Earning and Deduction Codes (WG)
 ++++++++++++++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's earnings and deduction records.
+Use this routine to create and amend the earnings and deduction records.
 
 The following fields need more explanation:
 
@@ -3012,21 +3024,81 @@
 
 Payslip Messages (WG)
 +++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's payslip message records.
+Use this routine to create and amend the payslip message records.
+
+PAYE Tables (WG)
+++++++++++++++++
+Use this routine to maintain PAYE tax rates.
+
++ **Tax Year** - The applicable tax year.
++ **Rebate - Primary** - The primary rebate amount.
++ **Rebate - 65 and Older** - The 65-74 rebate amount.
++ **Rebate - 75 and Older** - The 75 and older rebate amount.
++ **Gratuity - Exemption** - The gratuity exemption amount.
++ **SITE Limit** - The SITE limit, if applicable.
++ **UIF Rates - Employee** - The employee's UIF rate.
++ **UIF Rates - Employer** - The employer's UIF rate.
++ **SDL Rates - Employee** - The employee's SDL rate.
++ **SDL Rates - Employer** - The employer's SDL rate.
+
+The following columns refer to the basic tax rates:
+
++ **Inc-Fr** - The starting income bracket e.g. 0.
++ **Inc-To** - The ending income bracket e.g. 174550.
++ **Tax-Amt** - The initial tax amount for the Inc-Fr column e.g. 0.
++ **Rate** - The rate for the income up to the Inc-To column e.g. 18.00.
 
 Employee Masterfile (WG)
 ++++++++++++++++++++++++
 Use this routine to create, amend or delete employee masterfile records.
 
++ **Emp-Num** - The employee number.
++ **Department** - The department number.
++ **Class** - The class of employee.
 + **General**
-
+    + **Surname**
+    + **Names**
+    + **Date of Birth**
+    + **ID Number**
+    + **Spouse Name**
+    + **Spouse ID Number**
+    + **Address Line 1**
+    + **Address Line 2**
+    + **Address Line 3**
+    + **Postal Code**
+    + **Telephone Number**
+    + **E-Mail Address**
+    + **Start Date**
+    + **Salary/Rate**
+    + **Pay Freq**
+    + **Pay Type**
 + **Tax**
-
+    + **P.A.Y.E.**
+    + **Tax Office**
+    + **Tax Number**
+    + **Nature of Employee**
+    + **Reg Number**
+    + **Voluntary Excess**
+    + **Fixed Rate**
+    + **Directive**
 + **Bank**
-
+    + **Account Type**
+    + **Bank Name**
+    + **Branch Code**
+    + **Account Number**
+    + **Account Holder's Name**
+    + **Holder's Relationship**
 + **Earnings**
-
+    + **Cod** - The code of the earning to be automatically raised.
+    + **Amnt/Rate** - The value or rate of the earning to be raised.
 + **Deductions**
+    + **Cod** - The code of the deduction to be automatically raised.
+    + **Amnt/Rate** - The value or rate of the employee's portion of the deduction to be raised.
+    + **Amnt/Rate** - The value or rate of the employer's portion of the deduction to be raised.
++ **Balances**
+    + **Balance-1** - A balance to be deducted linked to the balance field in the deduction records.
+    + **Balance-2** - A 2nd balance to be deducted linked to the balance field in the deduction records.
+    + **Balance-3** - A 3rd balance to be deducted linked to the balance field in the deduction records.
 
 Data Capture (WG)
 .................
@@ -3034,18 +3106,128 @@
 ++++++++++++++++
 Use this routine to capture daily, weekly or monthly clock cards.
 
++ **EmpNo** - The employee's number.
++ **JobNo** - A job number if applicable.
++ **T** - The type of entry, either `E` for earning or `D` for deduction.
++ **Cde** - The earning or deduction code.
++ **P** - Whether or not to apply this earning or deduction.
++ **Amount** - The quantity or value of the earning or deduction.
+
 Payslips (WG)
 +++++++++++++
 Use this routine to create weekly, fortnightly or monthly payslips.
 
-Integration (WG)
-++++++++++++++++
-Use this routine to generate journal entries.
++ **Template Name** - The template to be used for payslips.
++ **Pay-Run Date** - The actual pay-run date.
++ **Payment Date** - The date on which payment will be made.
++ **Message Code** - The message code to print on the payslips.
++ **Frequency** - The frequency, weekly, fortnightly or monthly, to process.
++ **Whole File** - The records to be processed. Either all records or individuals.
++ **Department** - The department, if applicable, to process.
++ **Ignore Standards** - Whether or not to ignore standard deductions.
++ **Include Monthly** - Whether or not to include once-off monthly deductions in the case of weekly paid employees.
++ **Exclude Minus Balances** - Whether or not to exclude payslips going into minus i.e. where the deductions exceed the earnings.
++ **Preview Only** - Whether or not to only preview the payslips i.e. the payslips will not be saved and the accounts will not be updated.
 
 Terminations (WG)
 +++++++++++++++++
 Use this routine to capture employee terminations.
 
++ **Employee Number** - The employee's number.
++ **Termination Date** - The actual date of the termination.
+
+Reporting (WG)
+..............
+Receiver Codes Listing (WG)
++++++++++++++++++++++++++++
+Use this routine to print the receiver of revenue irp5 codes.
+
++ **Sort Order** - Select the print order of the codes.
+
+Earning and Deduction Codes (WG)
+++++++++++++++++++++++++++++++++
+Use this routine to print earnings and deduction details.
+
++ **Report Type** - Select which codes to print.
++ **Sort Order** - Select the print order of the codes.
+
+Union Records Listing (WG)
+++++++++++++++++++++++++++
+Use this routine to print a union report.
+
++ **Sort Order** - Select the print order of the records.
+
+Payslip Messages Listing (WG)
++++++++++++++++++++++++++++++
+Use this routine to print existing payslip messages.
+
+Employee Master Listing (WG)
+++++++++++++++++++++++++++++
+Use this routine to print an employee master listing.
+
++ **Report Type** - Select the report format, either List or Card.
++ **Department Code** - The department, if applicable, to print.
+
+Data Capture Listing (WG)
++++++++++++++++++++++++++
+Use this routine to print clock cards captured.
+
++ **Reporting Date** - The date of the report.
+
+SARS EMP201 Report (WG)
++++++++++++++++++++++++
+Use this routine to print SARS EMP201 report.
+
++ **Start Date** - The starting pay-run date to use for the report.
++ **End Date** - The ending pay-run date to use for the report.
+
+Earning and Deduction Values (WG)
++++++++++++++++++++++++++++++++++
+Use this routine to list all earnings and deductions for pay-runs.
+
++ **Start Date** - The starting pay-run date to use for the report.
++ **End Date** - The ending pay-run date to use for the report.
++ **Type** - The type to print.
++ **Code per Page** - Select whether to print each code on a separate page.
+
+IRP5 Statements (WG)
+++++++++++++++++++++
+Use this routine to print IRP5's and produce SARS import file.
+
++ **Submission Type** - Select the type of submission.
++ **Tax Year** - Enter the applicable tax year.
++ **Cut Off Date** - The last pay-run date to take into affect.
++ **Reprint** - Whether or not this is a reprint of a previous report.
++ **Preview** - Whether or not this is only a preview.
++ **Whole File** - Select the employees to process.
++ **Include Other Companies** - Whether or not to include other companies in the report.
++ **From Employee** - If range was selected above enter the first number of the range.
++ **To Employee** - If range was selected above enter the last number of the range.
+
+Notes Listing (WG)
+++++++++++++++++++
+Use this routine to print notes.
+
++ **Action Flag** - Normal or Urgent.
++ **From Capture Date** - The starting creation date.
++ **To Capture Date** - The ending creation date.
++ **From Action Date** - The starting action date.
++ **To Action Date** - The ending action date.
+
+Payslips Reprint (WG)
++++++++++++++++++++++
+Use this routine to reprint payslips.
+
++ **Template Name** - The template to be used for payslips.
++ **Pay-Run Date** - The date of the pay-run to be reprinted.
++ **Frequency** - The frequency of the pay-run to be reprinted.
++ **Whole File** - The payslips to be printed. Either all payslips or individuals.
++ **Department** - The department, if applicable, to print.
+
+Interrogation (WG)
+..................
+Use this routine to interrogate employee's details.
+
 .. raw:: pdf
 
     PageBreak
@@ -3148,19 +3330,52 @@
 Use this routine to send bulk MAIL or bulk SMSes. In order to use the MAIL facility you must enter a valid SMTP server in the `System Control Record`. In order to use the SMS facility you must register with www.smsportal.co.za and then enter your username and password in the `System Control Record` using `System Record Maintenance`_.
 
 + **Delivery Type** - The available delivery types will depend on what is entered in the `System Control Record` and can be either E-Mail, SMS or both.
-+ **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number.
++ **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number. Please note that Creditors and Debtors do not have SMS capabilities.
     + **Bookings** - This list accesses the tartan booking's contacts.
+        + **Individuals** - Allow selection of individual recipients.
     + **Bowls** - This list accesses the tartan bowl's tabs.
+        + **Category** - Allow selection by category.
+        + **Gender** - Allow selection by gender.
+        + **Individuals** - Allow selection of individual recipients.
     + **Creditors** - This list accesses the tartan creditor's masterfile.
+        + **Email To** - Select the recipient.
+        + **Individuals** - Allow selection of individual recipients.
     + **Debtors** - This list accesses the tartan debtor's masterfile.
+        + **Email To** - Select the recipient.
+        + **Activity** - Allow selection by business activity.
+        + **Type** - Allow selection by business type.
+        + **Individuals** - Allow selection of individual recipients.
     + **Members** - This list accesses the tartan member's masterfile.
+        + **Category** - Allow selection by membership category.
+        + **Gender** - Allow selection by gender.
+        + **Personalise** - Allow penalisation of the recipient.
+        + **Name Detail** - Select whether to use the names or initials.
+        + **Individuals** - Allow selection of individual recipients.
     + **Directory** - This list accesses the tartan telephone directory.
+        + **Group Selection** - Allow selection by group.
+        + **Include Contacts** - Include the recipient's contacts.
+        + **Individuals** - Allow selection of individual recipients.
     + **CSV and XLS File** - This is a csv or xls file containing a name, email address and/or a mobile number.
+        + **File Name** - The full path of the file to use.
+        + **Ignore Invalid Lines** - Select whether to ignore invalid lines.
+        + **Mobile/Email Column** - Enter the column of the mobile number or email address.
+        + **Personalise** - Allow penalisation of the recipient.
+        + **Title** - Select whether or not to use titles.
+        + **Title Column** - Enter the column of the title.
+        + **Surname Column** - Enter the column of the surname.
+        + **Names Column** - Enter the column of the names.
+        + **Name Detail** - Select whether to use the names or initials.
 + **Skip Delivery Errors** - Select whether or not to skip invalid email addresses.
 + **Subject** - The subject of the email.
 + **In-line Attachment** - Any in-line image to be included in the email.
 + **Separate Attachment** - Any attachment to be attached to the email.
-+ **Message** - Any text message. In order to get the recipients name in this message use `{{name}}` which will be substituted by the name.
++ **Message** - Any text message. In order to get the recipients name in the message use one of the following methods:
+    + **{{name}}** - Use this method if the recipient has separate surname and names fields.
+    + **{{surname}}** - Use this method if the recipient has a single name field where the surname and names are comma separated e.g. Malherbe, Paul.
+
+.. raw:: pdf
+
+    PageBreak
 
 Report Generator
 ................
@@ -3201,6 +3416,10 @@
 + **Exceptions**
 + **Order**
 
+.. raw:: pdf
+
+    PageBreak
+
 Template Manager
 ................
 Use this routine to create, edit or delete templates.
@@ -3208,54 +3427,40 @@
 + **Name** - The name of the template.
 + **Title** - The title of the template.
 + **TT** - The template type as follows:
-
     + **I** - Sales Document
     + **O** - Purchase Order
     + **P** - Payslip
     + **R** - Remittance Advice
     + **S** - Statement
-
 + **Sys** - The relevant system code relating to the type.
 + **ST** - This only applies to statements and is the type of statement as follows:
-
     + **N** - Normal
     + **O** - Other
-
 + **Size** - The page size i.e. A4, A5 or A6
 + **Orient** - The page orientation i.e. Portrait or Landscape.
-
 + **Sequence**
-
     + **Line Number** - The line number to edit or 0 for the next available number.
     + **Line Type** - The line type as follows:
-
         + **C Merge Code** - Use this code for lines that will be populated with data.
         + **I Image** - Use this code to display an image.
         + **L Line** - Use this code to draw a line.
         + **R Rectangle** - Use this code to draw a rectangle.
         + **T Text** - Use this code to print some fixed text.
-
     + **Placement** - Where to place this line.
-
 + **Rectangle**
-
     + **X1 Co-Ordinate** - The left hand position of the rectangle in mm.
     + **X2 Co-Ordinate** - The right hand position of the rectangle in mm.
     + **Y1 Co-Ordinate** - The top position of the rectangle in mm.
     + **Y2 Co-Ordinate** - The bottom position of the rectangle in mm.
     + **Line Thickness** - The thickness of the line.
-
 + **Image**
-
     + **X1 Co-Ordinate** - The left hand position of the image in mm.
     + **X2 Co-Ordinate** - The right hand position of the image in mm.
     + **Y1 Co-Ordinate** - The top position of the image in mm.
     + **Y2 Co-Ordinate** - The bottom position of the image in mm.
     + **File name** - The full path of the file name of the image.
     + **Merge Code** - The merge code containing the path to the image e.g. ctlmst ctm_logo.
-
 + **Line**
-
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
     + **Colour** - The line colour.
@@ -3266,9 +3471,7 @@
     + **Y1 Co-Ordinate** - The top position of the line in mm.
     + **Y2 Co-Ordinate** - The bottom position of the line in mm.
     + **Line Thickness** - The thickness of the line.
-
 + **Text**
-
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
     + **Colour** - The text colour.
@@ -3284,9 +3487,7 @@
     + **Y1 Co-Ordinate** - The top position of the text in mm.
     + **Y2 Co-Ordinate** - The bottom position of the text in mm.
     + **Text Detail** - The text.
-
 + **Code**
-
     + **Text Type** - The text type. Heading, Label of a Column or No text.
     + **Text Detail** - The text.
     + **Font Name** - The name of the font to use.
@@ -3321,10 +3522,29 @@
     + **Number of Lines** - The number of lines the imported data can contain e.g. a name and address could be 5 lines.
     + **Repeats** - The number of time to repeat the imported data e.g. the number of lines in the body of a statement could be 30.
 
+.. raw:: pdf
+
+    PageBreak
+
 Telephone Directory
 ...................
 Use this routine to manage a telephone directory.
 
+All the fields are self explanatory with the exception of the following:
+
++ **Contact Group** - This is a 3 letter group code. If the code does not exist you will have to also enter the group description. This code is used in the bulk mailing module.
+
++ **Buttons**
+    + **Back** - Select this button to display the previous directory entry.
+    + **Forward** - Select this button to display the next directory entry.
+    + **Import** - Select this button to import all contacts from other sources e.g. Creditors, Debtors, Members, Bookings etc.
+    + **Notes** - Select this button to maintain notes relating to this entry.
+    + **Print** - Select this button to print all entries or the current entry.
+    + **Apply** - Select this button to apply current addition or change.
+    + **Contacts** - Select this button to maintain contacts of the current entry.
+    + **Cancel** - Select this button to cancel any current additions or changes.
+    + **Quit** - Select this button to quit the application.
+
 .. raw:: pdf
 
     PageBreak
@@ -3341,165 +3561,3 @@
 Tartan Manual
 .............
 This routine will display this manual using your default browser.
-
-.. raw:: pdf
-
-    PageBreak
-
-Quick Start
------------
-Once Tartan Systems has been installed, the following procedures have to be performed before any meaningful work can be done. These procedures obviously depend on which modules are going to be used but this will be explained as we progress.
-
-+ Start Tartan by either clicking on the icon on the desktop or from the command line as follows:
-
-    + **Linux** - `program_path/ms0000.py [options]`
-    + **Windows** - `program_path\\ms0000.exe [options]`
-
-  To find out what the available command line options are, use the -h option.
-
-+ Login using **admin** as the user name and a password if prompted.
-
-+ The first time Tartan is started you will be taken to `Preferences`_ where you will have to set up your preferences regarding database, paths, utilities and various other choices. You will then have to enter the system record using `System Record Maintenance`_ as well as a company record using `Company Records Maintenance`_. For most SOHO installations there will only be one company, however there is provision for up to 999 integrated companies.
-
-+ Once you have created your Company Record you might be required to login again in order to get the new menus for the system modules selected.
-
-+ If you are going to use the `General Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record using `Control Record (GL)`_.
-    + Create the chart of accounts using `Masterfile Records (GL)`_.
-    + Create control accounts using `Control Accounts`_.
-    + Capture the account's opening balances using `Opening Balances (GL)`_.
-    + Print a trial balance using `Trial Balance (GL)`_ and ensure that your accounts balance. If not, recapture the incorrect ones.
-    + Capture the account's budgets using `Budgets (GL)`_ if required.
-
-    The General Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Creditor's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record for the company using `Control Record (CR)`_.
-    + If you elected to integrate with the General Ledger you must create the `crs_ctl` and `dis_rec` control accounts as per above.
-    + Create Creditor's accounts using `Masterfile Records (CR)`_.
-    + Capture the account's opening balances using `Journals` in `Data Capture (CR)`_.
-    + Print an aged analysis using `Age Analysis (CR)`_ and ensure that your totals balance. If not, recapture the incorrect ones.
-
-    Please remember that if you are integrating the Creditors and General Ledger systems, the control account must balance with the age analysis.
-
-    The Creditor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-    Please note that within the Creditor's system all balances are stored as positive even though they are stored as credits in the General Ledger.  Therefore to increase a supplier's balance you would capture a Journal Credit and to decrease a supplier's balance you would capture a Journal Debit.
-
-+ If you are going to use the `Debtor's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record using `Control Record (DR)`_.
-    + If you elected to integrate with the General Ledger you must create the `drs_ctl` and `dis_all` controls as per above.
-    + If you are going to make use of chain stores, i.e. the facility to have separate accounts for branches within a chain with a consolidated statement. You would have to create the necessary chain store records using `Chain Stores (DR)`_.
-    + If you are going to group your accounts by business activity, create the necessary records using `Business Activities (DR)`_.
-    + If you are going to group your accounts by business types, create the necessary records using `Business Types (DR)`_.
-    + If you are going to group your accounts by area, create the necessary records using `Areas (DR)`_.
-    + If you are going to group your accounts by salesman, create the necessary records using `Salesmen (DR)`_.
-    + Create Debtor's accounts using `Masterfile Records (DR)`_.
-    + Capture the account's opening balances using `Journals` in `Data Capture (DR)`_.
-    + Print an aged analysis using `Age Analysis (DR)`_ and ensure that your totals balance. If not, recapture the incorrect ones.
-
-    Please remember that if you are integrating the Debtors and General Ledger systems, the control account must balance with the age analysis.
-
-    The Debtor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Store's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record for the company using `Control Record (ST)`_.
-    + If you elected to integrate with the General Ledger you must create the `stk_soh` and `stk_susp` controls as per above.
-    + Create units of issue records using `Units of Issue (ST)`_.
-    + Create product groups using `Product Groups (ST)`_.
-    + Create stock records for the company by selecting `Masterfile Records (ST)`_.
-    + Enter the current stock on hand for the company by selecting `Stock Take Returns (ST)`_.
-    + Print a variance report using `Stock Take Variance Report (ST)`_ and ensure that all the quantities have been entered correctly. Correct any errors by redoing the previous step for the incorrect ones only.
-    + Update the stock items using `Stock Take Merge (ST)`_.
-    + Print a stock on hand report using `Stock on Hand (ST)`_.
-
-    Please remember that if you are integrating the Stores and General Ledger systems, the control account must balance with the stock on hand report.
-
-    The Store's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use `Sales Invoicing`_ you must perform the following procedures in order:
-
-    + Setup the Debtor's System as in 8) above ensuring that you create at least one salesman's record.
-    + Setup the Store's System as in 9) above.
-    + Create a control record using `Control Record (SI)`_.
-
-    The Sales's Invoicing system is at this stage fully functional and you can capture invoices, credit notes, sales orders and quotations.
-
-+ If you are going to use the `Asset's Register`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (AR)`_.
-    + Create depreciation codes using `Depreciation Codes (AR)`_.
-    + Create group records using `Group Records (AR)`_.
-    + Create masterfile records and take on opening balances for existing assets using `Opening Balances (AR)`_.
-
-    The Asset's Register system is at this stage fully functional and you can capture payments, receipts and journal entries. Please note that new assets are captured via the data capture routines i.e. Payments and/or Journal Entries.
-
-+ If you are going to use the `Member's Ledger`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (ML)`_.
-    + If you elected to integrate with the General Ledger you must create the `mem_ctl` and `mem_pen` controls as per above.
-    + Create category records using `Category Records`_.
-    + Create contact records using `Contact Records`_.
-
-    The Member's Ledger system is at this stage fully functional and you can add members, edit member details, capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Rental's Ledger (Standard)`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (RT)`_.
-    + Create premises records using `Premises Records (RT)`_.
-    + Create masterfile records using `Masterfile Records (RT)`_.
-
-    The Rental's Ledger (Standard) system is at this stage fully functional and you can capture payments, receipts and journal entries.
-
-+ If you are going to use `Salaries and Wages`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (WG)`_.
-    + If you elected to integrate with the General Ledger you must create the `wag_ctl`, `wag_slc` and `wag_sli` controls as per above.
-    + Create at least one branch record using `Branch Records (WG)`_.
-    + Create at least one department record using `Department Records (WG)`_.
-    + Create all necessary earnings and deduction records using `Earning and Deduction Codes (WG)`_.
-    + Create employee records using `Employee Masterfile (WG)`_.
-
-    The Salaries and Wages system is at this stage fully functional and you can capture clock cards and produce payslips etc.
-
-+ If you are going to use `Staff Loans`_ you must first of all set up `Salaries and Wages`_ as in 14) above and then, at least, perform the following procedures in order:
-
-    + Ensure that there is a deduction record, in the salaries system, for loan repayments.
-    + Ensure that all employees with loans have the deduction record included in their masterfile records as a deduction, without values.
-    + Capture existing loans using `New Loans`_.
-
-    The Staff Loans system is at this stage functional.
-
-+ If you are going to use `Bowls Clubs`_ you must first of all ensure that the `System and Company` records have been created.
-
-    + Create a systems record, by selecting `System Record Maintenance`_ from the Control menu.
-    + Create a company/club record, by selecting `Company Records Maintenance`_ from the Control menu.
-    + **Tabs Draw**
-        * Create a Control record by selecting `Control Record (BC)`_ from the File Maintenance menu.
-        * Create Tab records by selecting `TABS Maintenance`_ from the File Maintenance menu.
-        * Do a draw by selecting `New Draw`_ from the menu.
-        * Reprint a draw by selecting `Reprint Draw`_ from the menu.
-    + **League Selections**
-        * Create a league format record by selecting `League Formats`_ from the File Maintenance menu.
-        * Create Tab records by selecting `TABS Maintenance`_ from the File Maintenance menu.
-        * Create side records by selecting `Side's Maintenance`_ from the File Maintenance menu.
-        * Enter team selections by selecting `Capture Selections`_ from the menu.
-        * To print `Assessment Forms`_ select Assessment Forms from the menu.
-        * To print flag `Declaration Forms`_ select Declaration Forms from the menu.
-        * To capture the completed `Assessment Forms` select `Capture Assessments`_ from the menu.
-        * To print the `Match Assessment Report` select Match Assessment Report from the menu.
-        * To print the `Assessment Summary` select `Assessment Summary`_ from the menu.
-        * To clear historical selections select `Clear League History`_ from the toolbox menu.
-    + **Club Competitions**
-        * Create a Competition Type record by selecting `Competition Types`_ from the File Maintenance menu.
-        * Create player's records by selecting `Player's Maintenance`_ from the File Maintenance menu.
-        * Capture Competition Entries by selecting `Capture Entries`_ from the menu.
-        * Print Match Cards and Match Report by selecting `Print Match Cards`_ from the menu.
-        * Print Match Cards Summary by selecting `Print Cards Summary`_ from the menu. This report is a running summary of all draws.
-        * To change Match Cards select `Change Match Cards`_ from the menu. After changing the cards you must reprint them as per above. Please note that to only reprint certain cards you must select `All Cards No`.
-        * After the games have been played enter the results by selecting `Capture Results`_ from the menu.
-        * Print the game and match results by selecting the applicable routines from the menu.

=== modified file 'doc/QS.rst'
--- doc/QS.rst	2014-05-08 17:02:33 +0000
+++ doc/QS.rst	2015-02-04 17:03:33 +0000
@@ -1,5 +1,7 @@
-Quick Start
------------
+==============================
+ Tartan Systems - Quick Start
+==============================
+
 Once Tartan Systems has been installed, the following procedures have to be performed before any meaningful work can be done. These procedures obviously depend on which modules are going to be used but this will be explained as we progress.
 
 + Start Tartan by either clicking on the icon on the desktop or from the command line as follows:
@@ -11,147 +13,173 @@
 
 + Login using **admin** as the user name and a password if prompted.
 
-+ The first time Tartan is started you will be taken to `Preferences`_ where you will have to set up your preferences regarding database, paths, utilities and various other choices. You will then have to enter the system record using `System Record Maintenance`_ as well as a company record using `Company Records Maintenance`_. For most SOHO installations there will only be one company, however there is provision for up to 999 integrated companies.
-
-+ Once you have created your Company Record you might be required to login again in order to get the new menus for the system modules selected.
-
-+ If you are going to use the `General Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record using `Control Record (GL)`_.
-    + Create the chart of accounts using `Masterfile Records (GL)`_.
-    + Create control accounts using `Control Accounts`_.
-    + Capture the account's opening balances using `Opening Balances (GL)`_.
-    + Print a trial balance using `Trial Balance (GL)`_ and ensure that your accounts balance. If not, recapture the incorrect ones.
-    + Capture the account's budgets using `Budgets (GL)`_ if required.
-
-    The General Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Creditor's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record for the company using `Control Record (CR)`_.
-    + If you elected to integrate with the General Ledger you must create the `crs_ctl` and `dis_rec` control accounts as per above.
-    + Create Creditor's accounts using `Masterfile Records (CR)`_.
-    + Capture the account's opening balances using `Journals` in `Data Capture (CR)`_.
-    + Print an aged analysis using `Age Analysis (CR)`_ and ensure that your totals balance. If not, recapture the incorrect ones.
-
-    Please remember that if you are integrating the Creditors and General Ledger systems, the control account must balance with the age analysis.
-
-    The Creditor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-    Please note that within the Creditor's system all balances are stored as positive even though they are stored as credits in the General Ledger.  Therefore to increase a supplier's balance you would capture a Journal Credit and to decrease a supplier's balance you would capture a Journal Debit.
-
-+ If you are going to use the `Debtor's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record using `Control Record (DR)`_.
-    + If you elected to integrate with the General Ledger you must create the `drs_ctl` and `dis_all` controls as per above.
-    + If you are going to make use of chain stores, i.e. the facility to have separate accounts for branches within a chain with a consolidated statement. You would have to create the necessary chain store records using `Chain Stores (DR)`_.
-    + If you are going to group your accounts by business activity, create the necessary records using `Business Activities (DR)`_.
-    + If you are going to group your accounts by business types, create the necessary records using `Business Types (DR)`_.
-    + If you are going to group your accounts by area, create the necessary records using `Areas (DR)`_.
-    + If you are going to group your accounts by salesman, create the necessary records using `Salesmen (DR)`_.
-    + Create Debtor's accounts using `Masterfile Records (DR)`_.
-    + Capture the account's opening balances using `Journals` in `Data Capture (DR)`_.
-    + Print an aged analysis using `Age Analysis (DR)`_ and ensure that your totals balance. If not, recapture the incorrect ones.
-
-    Please remember that if you are integrating the Debtors and General Ledger systems, the control account must balance with the age analysis.
-
-    The Debtor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Store's Ledger`_ you must perform the following procedures in order:
-
-    + Create a control record for the company using `Control Record (ST)`_.
-    + If you elected to integrate with the General Ledger you must create the `stk_soh` and `stk_susp` controls as per above.
-    + Create units of issue records using `Units of Issue (ST)`_.
-    + Create product groups using `Product Groups (ST)`_.
-    + Create stock records for the company by selecting `Masterfile Records (ST)`_.
-    + Enter the current stock on hand for the company by selecting `Stock Take Returns (ST)`_.
-    + Print a variance report using `Stock Take Variance Report (ST)`_ and ensure that all the quantities have been entered correctly. Correct any errors by redoing the previous step for the incorrect ones only.
-    + Update the stock items using `Stock Take Merge (ST)`_.
-    + Print a stock on hand report using `Stock on Hand (ST)`_.
-
-    Please remember that if you are integrating the Stores and General Ledger systems, the control account must balance with the stock on hand report.
-
-    The Store's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use `Sales Invoicing`_ you must perform the following procedures in order:
-
-    + Setup the Debtor's System as in 8) above ensuring that you create at least one salesman's record.
-    + Setup the Store's System as in 9) above.
-    + Create a control record using `Control Record (SI)`_.
-
-    The Sales's Invoicing system is at this stage fully functional and you can capture invoices, credit notes, sales orders and quotations.
-
-+ If you are going to use the `Asset's Register`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (AR)`_.
-    + Create depreciation codes using `Depreciation Codes (AR)`_.
-    + Create group records using `Group Records (AR)`_.
-    + Create masterfile records and take on opening balances for existing assets using `Opening Balances (AR)`_.
-
-    The Asset's Register system is at this stage fully functional and you can capture payments, receipts and journal entries. Please note that new assets are captured via the data capture routines i.e. Payments and/or Journal Entries.
-
-+ If you are going to use the `Member's Ledger`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (ML)`_.
-    + If you elected to integrate with the General Ledger you must create the `mem_ctl` and `mem_pen` controls as per above.
-    + Create category records using `Category Records`_.
-    + Create contact records using `Contact Records`_.
-
-    The Member's Ledger system is at this stage fully functional and you can add members, edit member details, capture postings, produce basic reports and do interrogations etc.
-
-+ If you are going to use the `Rental's Ledger (Standard)`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (RT)`_.
-    + Create premises records using `Premises Records (RT)`_.
-    + Create masterfile records using `Masterfile Records (RT)`_.
-
-    The Rental's Ledger (Standard) system is at this stage fully functional and you can capture payments, receipts and journal entries.
-
-+ If you are going to use `Salaries and Wages`_ you must at least perform the following procedures in order:
-
-    + Create a control record using `Control Record (WG)`_.
-    + If you elected to integrate with the General Ledger you must create the `wag_ctl`, `wag_slc` and `wag_sli` controls as per above.
-    + Create at least one branch record using `Branch Records (WG)`_.
-    + Create at least one department record using `Department Records (WG)`_.
-    + Create all necessary earnings and deduction records using `Earning and Deduction Codes (WG)`_.
-    + Create employee records using `Employee Masterfile (WG)`_.
-
-    The Salaries and Wages system is at this stage fully functional and you can capture clock cards and produce payslips etc.
-
-+ If you are going to use `Staff Loans`_ you must first of all set up `Salaries and Wages`_ as in 14) above and then, at least, perform the following procedures in order:
-
-    + Ensure that there is a deduction record, in the salaries system, for loan repayments.
-    + Ensure that all employees with loans have the deduction record included in their masterfile records as a deduction, without values.
-    + Capture existing loans using `New Loans`_.
-
-    The Staff Loans system is at this stage functional.
-
-+ If you are going to use `Bowls Clubs`_ you must first of all ensure that the `System and Company` records have been created.
-
-    + Create a systems record, by selecting `System Record Maintenance`_ from the Control menu.
-    + Create a company/club record, by selecting `Company Records Maintenance`_ from the Control menu.
-    + **Tabs Draw**
-        * Create a Control record by selecting `Control Record (BC)`_ from the File Maintenance menu.
-        * Create Tab records by selecting `TABS Maintenance`_ from the File Maintenance menu.
-        * Do a draw by selecting `New Draw`_ from the menu.
-        * Reprint a draw by selecting `Reprint Draw`_ from the menu.
-    + **League Selections**
-        * Create a league format record by selecting `League Formats`_ from the File Maintenance menu.
-        * Create Tab records by selecting `TABS Maintenance`_ from the File Maintenance menu.
-        * Create side records by selecting `Side's Maintenance`_ from the File Maintenance menu.
-        * Enter team selections by selecting `Capture Selections`_ from the menu.
-        * To print `Assessment Forms`_ select Assessment Forms from the menu.
-        * To print flag `Declaration Forms`_ select Declaration Forms from the menu.
-        * To capture the completed `Assessment Forms` select `Capture Assessments`_ from the menu.
-        * To print the `Match Assessment Report` select Match Assessment Report from the menu.
-        * To print the `Assessment Summary` select `Assessment Summary`_ from the menu.
-        * To clear historical selections select `Clear League History`_ from the toolbox menu.
-    + **Club Competitions**
-        * Create a Competition Type record by selecting `Competition Types`_ from the File Maintenance menu.
-        * Create player's records by selecting `Player's Maintenance`_ from the File Maintenance menu.
-        * Capture Competition Entries by selecting `Capture Entries`_ from the menu.
-        * Print Match Cards and Match Report by selecting `Print Match Cards`_ from the menu.
-        * Print Match Cards Summary by selecting `Print Cards Summary`_ from the menu. This report is a running summary of all draws.
-        * To change Match Cards select `Change Match Cards`_ from the menu. After changing the cards you must reprint them as per above. Please note that to only reprint certain cards you must select `All Cards No`.
-        * After the games have been played enter the results by selecting `Capture Results`_ from the menu.
-        * Print the game and match results by selecting the applicable routines from the menu.
++ The first time Tartan is started you will be taken to `Preferences` where you will have to set up your preferences regarding database, paths, utilities and various other choices. You will then have to enter the system record using `System Record Maintenance` as well as a company record using `Company Records Maintenance`. For most SOHO installations there will only be one company, however there is provision for up to 999 integrated companies.
+
+General Ledger
+..............
+If you are going to use the `General Ledger` you must perform the following procedures in order:
+
++ Create a control record using `Control Record (GL)`.
++ Create the chart of accounts using `Masterfile Records (GL)`.
++ Create control accounts using `Control Accounts`.
++ Capture the account's opening balances using `Opening Balances (GL)`.
++ Print a trial balance using `Trial Balance (GL)` and ensure that your accounts balance. If not, recapture the incorrect ones.
++ Capture the account's budgets using `Budgets (GL)` if required.
+
+The General Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
+
+Creditor's Ledger
+-----------------
+If you are going to use the `Creditor's Ledger` you must perform the following procedures in order:
+
++ Create a control record for the company using `Control Record (CR)`.
++ If you elected to integrate with the General Ledger you must create the `crs_ctl` and `dis_rec` control accounts as per above.
++ Create Creditor's accounts using `Masterfile Records (CR)`.
++ Capture the account's opening balances using `Journals` in `Data Capture (CR)`.
++ Print an aged analysis using `Age Analysis (CR)` and ensure that your totals balance. If not, recapture the incorrect ones.
+
+Please remember that if you are integrating the Creditors and General Ledger systems, the control account must balance with the age analysis.
+
+The Creditor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
+
+Please also note that within the Creditor's system all balances are stored as positive even though they are stored as credits in the General Ledger.  Therefore to increase a supplier's balance you would capture a Journal Credit and to decrease a supplier's balance you would capture a Journal Debit.
+
+Debtor's Ledger
+---------------
+If you are going to use the `Debtor's Ledger` you must perform the following procedures in order:
+
++ Create a control record using `Control Record (DR)`.
++ If you elected to integrate with the General Ledger you must create the `drs_ctl` and `dis_all` controls as per above.
++ If you are going to make use of chain stores, i.e. the facility to have separate accounts for branches within a chain with a consolidated statement. You would have to create the necessary chain store records using `Chain Stores (DR)`.
++ If you are going to group your accounts by business activity, create the necessary records using `Business Activities (DR)`.
++ If you are going to group your accounts by business types, create the necessary records using `Business Types (DR)`.
++ If you are going to group your accounts by area, create the necessary records using `Areas (DR)`.
++ If you are going to group your accounts by salesman, create the necessary records using `Salesmen (DR)`.
++ Create Debtor's accounts using `Masterfile Records (DR)`.
++ Capture the account's opening balances using `Journals` in `Data Capture (DR)`.
++ Print an aged analysis using `Age Analysis (DR)` and ensure that your totals balance. If not, recapture the incorrect ones.
+
+Please remember that if you are integrating the Debtors and General Ledger systems, the control account must balance with the age analysis.
+
+The Debtor's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
+
+Store's Ledger
+--------------
+If you are going to use the `Store's Ledger` you must perform the following procedures in order:
+
++ Create a control record for the company using `Control Record (ST)`.
++ If you elected to integrate with the General Ledger you must create the `stk_soh` and `stk_susp` controls as per above.
++ Create units of issue records using `Units of Issue (ST)`.
++ Create product groups using `Product Groups (ST)`.
++ Create stock records for the company by selecting `Masterfile Records (ST)`.
++ Enter the current stock on hand for the company by selecting `Stock Take Returns (ST)`.
++ Print a variance report using `Stock Take Variance Report (ST)` and ensure that all the quantities have been entered correctly. Correct any errors by redoing the previous step for the incorrect ones only.
++ Update the stock items using `Stock Take Merge (ST)`.
++ Print a stock on hand report using `Stock on Hand (ST)`.
+
+Please remember that if you are integrating the Stores and General Ledger systems, the control account must balance with the stock on hand report.
+
+The Store's Ledger system is at this stage fully functional and you can capture postings, produce basic reports and do interrogations etc.
+
+Sales Invoicing
+---------------
+If you are going to use `Sales Invoicing` you must perform the following procedures in order:
+
++ Setup the Debtor's System as in 8) above ensuring that you create at least one salesman's record.
++ Setup the Store's System as in 9) above.
++ Create a control record using `Control Record (SI)`.
+
+The Sales's Invoicing system is at this stage fully functional and you can capture invoices, credit notes, sales orders and quotations.
+
+Asset's Ledger
+--------------
+If you are going to use the `Asset's Register` you must at least perform the following procedures in order:
+
++ Create a control record using `Control Record (AR)`.
++ Create depreciation codes using `Depreciation Codes (AR)`.
++ Create group records using `Group Records (AR)`.
++ Create masterfile records and take on opening balances for existing assets using `Opening Balances (AR)`.
+
+The Asset's Register system is at this stage fully functional and you can capture payments, receipts and journal entries. Please note that new assets are captured via the data capture routines i.e. Payments and/or Journal Entries.
+
+Bookings Manager
+----------------
+
+Bowling Clubs
+-------------
+If you are going to use `Bowling Clubs` you must first of all ensure that the `System and Company` records have been created.
+
++ Create a systems record, by selecting `System Record Maintenance` from the Control menu.
++ Create a company/club record, by selecting `Company Records Maintenance` from the Control menu.
++ **Tabs Draw**
+    * Create a Control record by selecting `Control Record (BC)` from the File Maintenance menu.
+    * Create Tab records by selecting `TABS Maintenance` from the File Maintenance menu.
+    * Do a draw by selecting `New Draw` from the menu.
+    * Reprint a draw by selecting `Reprint Draw` from the menu.
++ **League Selections**
+    * Create a league format record by selecting `League Formats` from the File Maintenance menu.
+    * Create Tab records by selecting `TABS Maintenance` from the File Maintenance menu.
+    * Create side records by selecting `Side's Maintenance` from the File Maintenance menu.
+    * Enter team selections by selecting `Capture Selections` from the menu.
+    * To print `Assessment Forms` select Assessment Forms from the menu.
+    * To print flag `Declaration Forms` select Declaration Forms from the menu.
+    * To capture the completed `Assessment Forms` select `Capture Assessments` from the menu.
+    * To print the `Match Assessment Report` select Match Assessment Report from the menu.
+    * To print the `Assessment Summary` select `Assessment Summary` from the menu.
+    * To clear historical selections select `Clear League History` from the toolbox menu.
++ **Club Competitions**
+    * Create a Competition Type record by selecting `Competition Types` from the File Maintenance menu.
+    * Create player's records by selecting `Player's Maintenance` from the File Maintenance menu.
+    * Capture Competition Entries by selecting `Capture Entries` from the menu.
+    * Print Match Cards and Match Report by selecting `Print Match Cards` from the menu.
+    * Print Match Cards Summary by selecting `Print Cards Summary` from the menu. This report is a running summary of all draws.
+    * To change Match Cards select `Change Match Cards` from the menu. After changing the cards you must reprint them as per above. Please note that to only reprint certain cards you must select `All Cards No`.
+    * After the games have been played enter the results by selecting `Capture Results` from the menu.
+    * Print the game and match results by selecting the applicable routines from the menu.
+
+Member's Ledger
+---------------
+If you are going to use the `Member's Ledger` you must at least perform the following procedures in order:
+
++ Create a control record using `Control Record (ML)`.
++ If you elected to integrate with the General Ledger you must create the `mem_ctl` and `mem_pen` controls as per above.
++ Create category records using `Category Records`.
++ Create contact records using `Contact Records`.
+
+The Member's Ledger system is at this stage fully functional and you can add members, edit member details, capture postings, produce basic reports and do interrogations etc.
+
+Rental's Ledger - Standard
+--------------------------
+If you are going to use the `Rental's Ledger (Standard)` you must at least perform the following procedures in order:
+
++ Create a control record using `Control Record (RT)`.
++ Create premises records using `Premises Records (RT)`.
++ Create masterfile records using `Masterfile Records (RT)`.
+
+The Rental's Ledger (Standard) system is at this stage fully functional and you can capture payments, receipts and journal entries.
+
+Rental's Ledger - Extended
+--------------------------
+
+Salaries and Wages
+------------------
+If you are going to use `Salaries and Wages` you must at least perform the following procedures in order:
+
++ Create a control record using `Control Record (WG)`.
++ If you elected to integrate with the General Ledger you must create the `wag_ctl`, `wag_slc` and `wag_sli` controls as per above.
++ Create at least one branch record using `Branch Records (WG)`.
++ Create at least one department record using `Department Records (WG)`.
++ Create all necessary earnings and deduction records using `Earning and Deduction Codes (WG)`.
++ Create employee records using `Employee Masterfile (WG)`.
+
+The Salaries and Wages system is at this stage fully functional and you can capture clock cards and produce payslips etc.
+
+Staff Loans
+-----------
+If you are going to use `Staff Loans` you must first of all set up `Salaries and Wages` as in 14) above and then, at least, perform the following procedures in order:
+
++ Ensure that there is a deduction record, in the salaries system, for loan repayments.
++ Ensure that all employees with loans have the deduction record included in their masterfile records as a deduction, without values.
++ Capture existing loans using `New Loans`. If Salaries are integrated with the general ledger un-integrate salaries to capture loans balances. Once all opening balances have been captured re-integrate salaries.
+
+The Staff Loans system is at this stage functional.

=== modified file 'doc/SC.rst'
--- doc/SC.rst	2014-12-30 15:37:38 +0000
+++ doc/SC.rst	2015-01-20 06:34:03 +0000
@@ -1,20 +1,20 @@
-
-================
- TARTAN SYSTEMS
-================
-
-.. _Home: http://www.tartan.co.za
-
-:Version:   5.0.2
+========================================
+ TARTAN SYSTEMS - Sectional Competitions
+========================================
+
+:Version:   5.0.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
 :Copyright: Paul Malherbe (C) 2004-2015.
+:Licence:   Free use of this software and all it's modules is granted under the terms of the License.
 
 .. contents:: **Table of Contents**
 
-Sectional Competitions
-======================
+.. raw:: pdf
+
+    PageBreak
+
 Installation Procedure
 ----------------------
 Browse to the Seccmp_5.0.x file and double click on it. Accept all defaults and agree to creating an icon on your desktop.
@@ -92,7 +92,7 @@
 
 + **Database**
 
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL, Firebird or MsSQL 2000. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
+    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
     + **Database Name** - This can be any single word name defaulting to **tartan**.
     + **Host Name** - This is the host name of the Server. This is not used with SQLite.
     + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.

=== modified file 'doc/Tartan.rst'
--- doc/Tartan.rst	2014-12-09 16:32:44 +0000
+++ doc/Tartan.rst	2015-01-15 04:31:38 +0000
@@ -13,11 +13,12 @@
 + Store's Ledger (Inventory)
 + Sales Invoicing
 + Asset's Register
++ Booking's Manager
++ Bowls Clubs (Lawn Bowls)
++ Member's Ledger (Clubs)
 + Rental's Ledger
 + Salaries and Wages (ZA)
 + Staff Loans
-+ Member's Ledger (Clubs)
-+ Bowls Clubs (Lawn Bowls)
 
 The modules are written in the Python programming language, licensed under the GPL and copyrighted by Paul Malherbe. Because Python is platform independent, Tartan is equally at home with both the Linux and Windows operating systems.
 
@@ -36,6 +37,10 @@
    :target: http://www.python.org
 .. |pgsql| image:: /images/postgresql.png
    :target: http://www.postgresql.org
+.. |gtk| image:: /images/gtk.png
+   :target: http://www.gtk.org
+.. |pygtk| image:: /images/pygtk.jpg
+   :target: http://www.pygtk.org
 .. |gnu-head| image:: /images/gnu-head.png
    :target: /images/gnugpl.html
 .. |launchpad| image:: /images/launchpad.png
@@ -46,5 +51,9 @@
    :width: 80px
    :height: 40px
    :target: http://sourceforge.net/projects/tartansystems/
+.. |silogo| image:: /images/silogo.png
+   :width: 80px
+   :height: 40px
+   :target: http://tartan.software.informer.com
 
-|python| |gnu-head| |pgsql| |launchpad| |sourceforge|
+|python| |pygtk| |gtk| |gnu-head| |pgsql| |launchpad| |sourceforge| |silogo|

=== modified file 'doc/UD.rst'
--- doc/UD.rst	2014-12-30 15:37:38 +0000
+++ doc/UD.rst	2015-01-31 08:46:53 +0000
@@ -5,7 +5,7 @@
 Use this routine to send bulk MAIL or bulk SMSes. In order to use the MAIL facility you must enter a valid SMTP server in the `System Control Record`. In order to use the SMS facility you must register with www.smsportal.co.za and then enter your username and password in the `System Control Record` using `System Record Maintenance`_.
 
 + **Delivery Type** - The available delivery types will depend on what is entered in the `System Control Record` and can be either E-Mail, SMS or both.
-+ **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number. Please note that Crditors and Debtors do not have sms capabilities.
++ **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number. Please note that Creditors and Debtors do not have SMS capabilities.
     + **Bookings** - This list accesses the tartan booking's contacts.
         + **Individuals** - Allow selection of individual recipients.
     + **Bowls** - This list accesses the tartan bowl's tabs.
@@ -23,7 +23,7 @@
     + **Members** - This list accesses the tartan member's masterfile.
         + **Category** - Allow selection by membership category.
         + **Gender** - Allow selection by gender.
-        + **Personalize** - Allow personalization of the recipient.
+        + **Personalise** - Allow penalisation of the recipient.
         + **Name Detail** - Select whether to use the names or initials.
         + **Individuals** - Allow selection of individual recipients.
     + **Directory** - This list accesses the tartan telephone directory.
@@ -34,7 +34,7 @@
         + **File Name** - The full path of the file to use.
         + **Ignore Invalid Lines** - Select whether to ignore invalid lines.
         + **Mobile/Email Column** - Enter the column of the mobile number or email address.
-        + **Personalize** - Allow personalization of the recipient.
+        + **Personalise** - Allow penalisation of the recipient.
         + **Title** - Select whether or not to use titles.
         + **Title Column** - Enter the column of the title.
         + **Surname Column** - Enter the column of the surname.
@@ -48,6 +48,10 @@
     + **{{name}}** - Use this method if the recipient has separate surname and names fields.
     + **{{surname}}** - Use this method if the recipient has a single name field where the surname and names are comma separated e.g. Malherbe, Paul.
 
+.. raw:: pdf
+
+    PageBreak
+
 Report Generator
 ................
 Use this routine to generate ad hoc SQL reports. It is not necessary to know the SQL language but it is beneficial.
@@ -87,6 +91,10 @@
 + **Exceptions**
 + **Order**
 
+.. raw:: pdf
+
+    PageBreak
+
 Template Manager
 ................
 Use this routine to create, edit or delete templates.
@@ -94,54 +102,40 @@
 + **Name** - The name of the template.
 + **Title** - The title of the template.
 + **TT** - The template type as follows:
-
     + **I** - Sales Document
     + **O** - Purchase Order
     + **P** - Payslip
     + **R** - Remittance Advice
     + **S** - Statement
-
 + **Sys** - The relevant system code relating to the type.
 + **ST** - This only applies to statements and is the type of statement as follows:
-
     + **N** - Normal
     + **O** - Other
-
 + **Size** - The page size i.e. A4, A5 or A6
 + **Orient** - The page orientation i.e. Portrait or Landscape.
-
 + **Sequence**
-
     + **Line Number** - The line number to edit or 0 for the next available number.
     + **Line Type** - The line type as follows:
-
         + **C Merge Code** - Use this code for lines that will be populated with data.
         + **I Image** - Use this code to display an image.
         + **L Line** - Use this code to draw a line.
         + **R Rectangle** - Use this code to draw a rectangle.
         + **T Text** - Use this code to print some fixed text.
-
     + **Placement** - Where to place this line.
-
 + **Rectangle**
-
     + **X1 Co-Ordinate** - The left hand position of the rectangle in mm.
     + **X2 Co-Ordinate** - The right hand position of the rectangle in mm.
     + **Y1 Co-Ordinate** - The top position of the rectangle in mm.
     + **Y2 Co-Ordinate** - The bottom position of the rectangle in mm.
     + **Line Thickness** - The thickness of the line.
-
 + **Image**
-
     + **X1 Co-Ordinate** - The left hand position of the image in mm.
     + **X2 Co-Ordinate** - The right hand position of the image in mm.
     + **Y1 Co-Ordinate** - The top position of the image in mm.
     + **Y2 Co-Ordinate** - The bottom position of the image in mm.
     + **File name** - The full path of the file name of the image.
     + **Merge Code** - The merge code containing the path to the image e.g. ctlmst ctm_logo.
-
 + **Line**
-
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
     + **Colour** - The line colour.
@@ -152,9 +146,7 @@
     + **Y1 Co-Ordinate** - The top position of the line in mm.
     + **Y2 Co-Ordinate** - The bottom position of the line in mm.
     + **Line Thickness** - The thickness of the line.
-
 + **Text**
-
     + **Font Name** - The name of the font to use.
     + **Size** - The font size to use.
     + **Colour** - The text colour.
@@ -170,9 +162,7 @@
     + **Y1 Co-Ordinate** - The top position of the text in mm.
     + **Y2 Co-Ordinate** - The bottom position of the text in mm.
     + **Text Detail** - The text.
-
 + **Code**
-
     + **Text Type** - The text type. Heading, Label of a Column or No text.
     + **Text Detail** - The text.
     + **Font Name** - The name of the font to use.
@@ -207,6 +197,25 @@
     + **Number of Lines** - The number of lines the imported data can contain e.g. a name and address could be 5 lines.
     + **Repeats** - The number of time to repeat the imported data e.g. the number of lines in the body of a statement could be 30.
 
+.. raw:: pdf
+
+    PageBreak
+
 Telephone Directory
 ...................
 Use this routine to manage a telephone directory.
+
+All the fields are self explanatory with the exception of the following:
+
++ **Contact Group** - This is a 3 letter group code. If the code does not exist you will have to also enter the group description. This code is used in the bulk mailing module.
+
++ **Buttons**
+    + **Back** - Select this button to display the previous directory entry.
+    + **Forward** - Select this button to display the next directory entry.
+    + **Import** - Select this button to import all contacts from other sources e.g. Creditors, Debtors, Members, Bookings etc.
+    + **Notes** - Select this button to maintain notes relating to this entry.
+    + **Print** - Select this button to print all entries or the current entry.
+    + **Apply** - Select this button to apply current addition or change.
+    + **Contacts** - Select this button to maintain contacts of the current entry.
+    + **Cancel** - Select this button to cancel any current additions or changes.
+    + **Quit** - Select this button to quit the application.

=== modified file 'doc/WG.rst'
--- doc/WG.rst	2014-03-28 07:32:49 +0000
+++ doc/WG.rst	2015-01-31 07:43:41 +0000
@@ -4,23 +4,15 @@
 .....................
 Control Record (WG)
 +++++++++++++++++++
-Use this routine to create and amend the salary's and wage's control record.
-
-Branch Records (WG)
-+++++++++++++++++++
-Use this routine to create and amend the salary's and wage's branch records.
-
-Department Records (WG)
-+++++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's department records.
+Use this routine to create and amend the control record.
 
 Receiver Codes (WG)
 +++++++++++++++++++
-Use this routine to create and amend the salary's and wage's receiver of revenue irp5 records.
+Use this routine to create and amend the receiver of revenue irp5 codes.
 
 Earning and Deduction Codes (WG)
 ++++++++++++++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's earnings and deduction records.
+Use this routine to create and amend the earnings and deduction records.
 
 The following fields need more explanation:
 
@@ -77,21 +69,81 @@
 
 Payslip Messages (WG)
 +++++++++++++++++++++
-Use this routine to create and amend the salary's and wage's payslip message records.
+Use this routine to create and amend the payslip message records.
+
+PAYE Tables (WG)
+++++++++++++++++
+Use this routine to maintain PAYE tax rates.
+
++ **Tax Year** - The applicable tax year.
++ **Rebate - Primary** - The primary rebate amount.
++ **Rebate - 65 and Older** - The 65-74 rebate amount.
++ **Rebate - 75 and Older** - The 75 and older rebate amount.
++ **Gratuity - Exemption** - The gratuity exemption amount.
++ **SITE Limit** - The SITE limit, if applicable.
++ **UIF Rates - Employee** - The employee's UIF rate.
++ **UIF Rates - Employer** - The employer's UIF rate.
++ **SDL Rates - Employee** - The employee's SDL rate.
++ **SDL Rates - Employer** - The employer's SDL rate.
+
+The following columns refer to the basic tax rates:
+
++ **Inc-Fr** - The starting income bracket e.g. 0.
++ **Inc-To** - The ending income bracket e.g. 174550.
++ **Tax-Amt** - The initial tax amount for the Inc-Fr column e.g. 0.
++ **Rate** - The rate for the income up to the Inc-To column e.g. 18.00.
 
 Employee Masterfile (WG)
 ++++++++++++++++++++++++
 Use this routine to create, amend or delete employee masterfile records.
 
++ **Emp-Num** - The employee number.
++ **Department** - The department number.
++ **Class** - The class of employee.
 + **General**
-
+    + **Surname**
+    + **Names**
+    + **Date of Birth**
+    + **ID Number**
+    + **Spouse Name**
+    + **Spouse ID Number**
+    + **Address Line 1**
+    + **Address Line 2**
+    + **Address Line 3**
+    + **Postal Code**
+    + **Telephone Number**
+    + **E-Mail Address**
+    + **Start Date**
+    + **Salary/Rate**
+    + **Pay Freq**
+    + **Pay Type**
 + **Tax**
-
+    + **P.A.Y.E.**
+    + **Tax Office**
+    + **Tax Number**
+    + **Nature of Employee**
+    + **Reg Number**
+    + **Voluntary Excess**
+    + **Fixed Rate**
+    + **Directive**
 + **Bank**
-
+    + **Account Type**
+    + **Bank Name**
+    + **Branch Code**
+    + **Account Number**
+    + **Account Holder's Name**
+    + **Holder's Relationship**
 + **Earnings**
-
+    + **Cod** - The code of the earning to be automatically raised.
+    + **Amnt/Rate** - The value or rate of the earning to be raised.
 + **Deductions**
+    + **Cod** - The code of the deduction to be automatically raised.
+    + **Amnt/Rate** - The value or rate of the employee's portion of the deduction to be raised.
+    + **Amnt/Rate** - The value or rate of the employer's portion of the deduction to be raised.
++ **Balances**
+    + **Balance-1** - A balance to be deducted linked to the balance field in the deduction records.
+    + **Balance-2** - A 2nd balance to be deducted linked to the balance field in the deduction records.
+    + **Balance-3** - A 3rd balance to be deducted linked to the balance field in the deduction records.
 
 Data Capture (WG)
 .................
@@ -99,14 +151,124 @@
 ++++++++++++++++
 Use this routine to capture daily, weekly or monthly clock cards.
 
++ **EmpNo** - The employee's number.
++ **JobNo** - A job number if applicable.
++ **T** - The type of entry, either `E` for earning or `D` for deduction.
++ **Cde** - The earning or deduction code.
++ **P** - Whether or not to apply this earning or deduction.
++ **Amount** - The quantity or value of the earning or deduction.
+
 Payslips (WG)
 +++++++++++++
 Use this routine to create weekly, fortnightly or monthly payslips.
 
-Integration (WG)
-++++++++++++++++
-Use this routine to generate journal entries.
++ **Template Name** - The template to be used for payslips.
++ **Pay-Run Date** - The actual pay-run date.
++ **Payment Date** - The date on which payment will be made.
++ **Message Code** - The message code to print on the payslips.
++ **Frequency** - The frequency, weekly, fortnightly or monthly, to process.
++ **Whole File** - The records to be processed. Either all records or individuals.
++ **Department** - The department, if applicable, to process.
++ **Ignore Standards** - Whether or not to ignore standard deductions.
++ **Include Monthly** - Whether or not to include once-off monthly deductions in the case of weekly paid employees.
++ **Exclude Minus Balances** - Whether or not to exclude payslips going into minus i.e. where the deductions exceed the earnings.
++ **Preview Only** - Whether or not to only preview the payslips i.e. the payslips will not be saved and the accounts will not be updated.
 
 Terminations (WG)
 +++++++++++++++++
 Use this routine to capture employee terminations.
+
++ **Employee Number** - The employee's number.
++ **Termination Date** - The actual date of the termination.
+
+Reporting (WG)
+..............
+Receiver Codes Listing (WG)
++++++++++++++++++++++++++++
+Use this routine to print the receiver of revenue irp5 codes.
+
++ **Sort Order** - Select the print order of the codes.
+
+Earning and Deduction Codes (WG)
+++++++++++++++++++++++++++++++++
+Use this routine to print earnings and deduction details.
+
++ **Report Type** - Select which codes to print.
++ **Sort Order** - Select the print order of the codes.
+
+Union Records Listing (WG)
+++++++++++++++++++++++++++
+Use this routine to print a union report.
+
++ **Sort Order** - Select the print order of the records.
+
+Payslip Messages Listing (WG)
++++++++++++++++++++++++++++++
+Use this routine to print existing payslip messages.
+
+Employee Master Listing (WG)
+++++++++++++++++++++++++++++
+Use this routine to print an employee master listing.
+
++ **Report Type** - Select the report format, either List or Card.
++ **Department Code** - The department, if applicable, to print.
+
+Data Capture Listing (WG)
++++++++++++++++++++++++++
+Use this routine to print clock cards captured.
+
++ **Reporting Date** - The date of the report.
+
+SARS EMP201 Report (WG)
++++++++++++++++++++++++
+Use this routine to print SARS EMP201 report.
+
++ **Start Date** - The starting pay-run date to use for the report.
++ **End Date** - The ending pay-run date to use for the report.
+
+Earning and Deduction Values (WG)
++++++++++++++++++++++++++++++++++
+Use this routine to list all earnings and deductions for pay-runs.
+
++ **Start Date** - The starting pay-run date to use for the report.
++ **End Date** - The ending pay-run date to use for the report.
++ **Type** - The type to print.
++ **Code per Page** - Select whether to print each code on a separate page.
+
+IRP5 Statements (WG)
+++++++++++++++++++++
+Use this routine to print IRP5's and produce SARS import file.
+
++ **Submission Type** - Select the type of submission.
++ **Tax Year** - Enter the applicable tax year.
++ **Cut Off Date** - The last pay-run date to take into affect.
++ **Reprint** - Whether or not this is a reprint of a previous report.
++ **Preview** - Whether or not this is only a preview.
++ **Whole File** - Select the employees to process.
++ **Include Other Companies** - Whether or not to include other companies in the report.
++ **From Employee** - If range was selected above enter the first number of the range.
++ **To Employee** - If range was selected above enter the last number of the range.
+
+Notes Listing (WG)
+++++++++++++++++++
+Use this routine to print notes.
+
++ **Action Flag** - Normal or Urgent.
++ **From Capture Date** - The starting creation date.
++ **To Capture Date** - The ending creation date.
++ **From Action Date** - The starting action date.
++ **To Action Date** - The ending action date.
+
+Payslips Reprint (WG)
++++++++++++++++++++++
+Use this routine to reprint payslips.
+
++ **Template Name** - The template to be used for payslips.
++ **Pay-Run Date** - The date of the pay-run to be reprinted.
++ **Frequency** - The frequency of the pay-run to be reprinted.
++ **Whole File** - The payslips to be printed. Either all payslips or individuals.
++ **Department** - The department, if applicable, to print.
+
+Interrogation (WG)
+..................
+Use this routine to interrogate employee's details.

=== modified file 'doc/stylesheet'
--- doc/stylesheet	2014-12-09 16:32:44 +0000
+++ doc/stylesheet	2015-01-30 15:09:46 +0000
@@ -582,4 +582,3 @@
             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
             [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
         colWidths: [null,null]
-

=== modified file 'drs/dr1010.py'
--- drs/dr1010.py	2014-12-30 15:37:38 +0000
+++ drs/dr1010.py	2015-01-27 16:24:51 +0000
@@ -483,7 +483,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="drsmst", impskp=["drm_cono"])
         sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Debtor's Accounts", mxs=len(fi.impdat), esc=False)
+            typ="Importing Debtor's Accounts", mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'drs/dr2010.py'
--- drs/dr2010.py	2014-12-30 15:37:38 +0000
+++ drs/dr2010.py	2015-01-20 07:54:36 +0000
@@ -281,6 +281,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):

=== modified file 'drs/dr2020.py'
--- drs/dr2020.py	2014-12-30 15:37:38 +0000
+++ drs/dr2020.py	2015-01-20 07:59:00 +0000
@@ -223,11 +223,9 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
-        if self.bh.multi == "Y":
-            self.curdt = self.trndat / 100
-        else:
-            self.curdt = self.bh.curdt
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):
         self.trnamt = w

=== modified file 'drs/dr3010.py'
--- drs/dr3010.py	2014-12-30 15:37:38 +0000
+++ drs/dr3010.py	2015-01-27 16:31:57 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %58s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.drstrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -147,16 +149,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'drs/dr3020.py'
--- drs/dr3020.py	2014-12-30 15:37:38 +0000
+++ drs/dr3020.py	2015-01-27 13:40:28 +0000
@@ -190,8 +190,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -232,11 +232,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -276,15 +273,14 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         chain = CCD(data[0], "UI", 3)

=== modified file 'drs/dr3030.py'
--- drs/dr3030.py	2014-12-30 15:37:38 +0000
+++ drs/dr3030.py	2015-01-27 16:04:14 +0000
@@ -70,19 +70,14 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(mst), esc=True)
         self.head = ("%03u %-30s %33s %6s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.ctots = [0,0,0]
         self.gtots = [0,0,0]
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(mst):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             chn = CCD(rec[0], "UI", 3)
             acno = CCD(rec[1], "NA", 7)
@@ -120,13 +115,14 @@
             if self.fpdf.page:
                 self.accountTotal()
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, chn, acno, name):
         self.fpdf.add_page()

=== modified file 'drs/dr3040.py'
--- drs/dr3040.py	2014-12-30 15:37:38 +0000
+++ drs/dr3040.py	2015-01-27 13:41:57 +0000
@@ -85,8 +85,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(mst):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 if self.fpdf.page:
                     self.fpdf.drawText()
                     self.fpdf.drawText("Print Job ABORTED")
@@ -134,15 +134,14 @@
             if  self.npag == "Y":
                 self.pglin = 999
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, chn, acno, name):
         self.fpdf.add_page()

=== modified file 'drs/dr3050.py'
--- drs/dr3050.py	2014-12-30 15:37:38 +0000
+++ drs/dr3050.py	2015-01-27 13:42:59 +0000
@@ -191,8 +191,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -229,8 +229,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 if self.fpdf.page:
                     self.fpdf.drawText()
                     self.fpdf.drawText("Print Job ABORTED")
@@ -247,16 +247,16 @@
                     vals[8].disp, vals[9].disp))
                 self.pglin += 1
         p.closeProgress()
-        if self.totsonly == "Y" and can != "yes":
+        if p.quit:
+            return
+        if self.totsonly == "Y":
             self.pageHeading()
+        if self.fpdf.page:
             self.grandTotal()
-        elif self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         chn = CCD(data[0], "UI", 3)

=== modified file 'drs/dr3060.py'
--- drs/dr3060.py	2014-12-30 15:37:38 +0000
+++ drs/dr3060.py	2015-01-27 13:44:01 +0000
@@ -134,18 +134,13 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %145s %6s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
         col = self.sql.drsmst_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             chn = CCD(dat[col.index("drm_chain")], "UI", 3)
             acno = CCD(dat[col.index("drm_acno")], "NA", 7)
@@ -191,10 +186,13 @@
                 self.pglin += 1
             self.pglin += 1
         p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'drs/dr3080.py'
--- drs/dr3080.py	2014-12-30 15:37:38 +0000
+++ drs/dr3080.py	2015-02-05 07:49:43 +0000
@@ -249,17 +249,18 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         self.opts["mf"].closeLoop()
 
@@ -383,7 +384,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'drs/dr3090.py'
--- drs/dr3090.py	2014-12-30 15:37:38 +0000
+++ drs/dr3090.py	2015-01-27 13:47:03 +0000
@@ -109,20 +109,18 @@
             self.fpdf.add_page()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, dat in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(dat)
             p.closeProgress()
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.view, prtnam=self.prtnam,
-                mail=self.emadd)
+            if self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.view,
+                    prtnam=self.prtnam, mail=self.emadd)
         self.closeProcess()
 
     def doProcess(self, dat):

=== modified file 'drs/dr3100.py'
--- drs/dr3100.py	2014-12-30 15:37:38 +0000
+++ drs/dr3100.py	2015-01-27 13:48:02 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -61,7 +61,7 @@
                 else:
                     data.append(["", "", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Debtor's Masterfile Notes Listing"]
             cols = [

=== modified file 'drs/dr3110.py'
--- drs/dr3110.py	2014-12-30 15:37:38 +0000
+++ drs/dr3110.py	2015-01-27 15:33:25 +0000
@@ -138,8 +138,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(acs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -188,11 +188,8 @@
         self.actno = None
         self.typno = None
         for num, dat in enumerate(acs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -217,11 +214,11 @@
                     vals[5].disp, vals[6]))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                if self.rep == "Y" or self.act == "Y" or self.typ == "Y":
-                    self.doTotals(ttype="S")
-                self.doTotals(ttype="G")
+        if not self.fpdf.page or p.quit:
+            return
+        if self.rep == "Y" or self.act == "Y" or self.typ == "Y":
+            self.doTotals(ttype="S")
+        self.doTotals(ttype="G")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
             head=self.tit, view=self.df.repprt[0][1],

=== modified file 'drs/dr3120.py'
--- drs/dr3120.py	2014-12-30 15:37:38 +0000
+++ drs/dr3120.py	2015-01-27 13:50:52 +0000
@@ -85,11 +85,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             chn = CCD(dat[self.col.index("drm_chain")], "UI", 3)
             acno = CCD(dat[self.col.index("drm_acno")], "NA", 7)
@@ -124,15 +121,14 @@
             self.tots[0] = float(ASD(self.tots[0]) + ASD(odu.work))
             self.tots[1] = float(ASD(self.tots[1]) + ASD(amt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'drs/drc620.py'
--- drs/drc620.py	2014-12-30 15:37:38 +0000
+++ drs/drc620.py	2015-01-27 13:52:43 +0000
@@ -78,11 +78,8 @@
         self.pglin = 999
         old_sys = recs[0][0]
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             self.sys = CCD(dat[0], "NA", 3)
             mes = CCD(dat[1], "UI", 3)
@@ -108,13 +105,13 @@
                 fmt.append("")
             self.pglin += 1
         p.closeProgress()
-        old_sys = self.sys.work
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
-            ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
-            view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
+                ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
+                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def pageHeading(self):

=== modified file 'gen/gl1010.py'
--- gen/gl1010.py	2014-12-30 15:37:38 +0000
+++ gen/gl1010.py	2015-01-27 16:24:59 +0000
@@ -191,7 +191,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="genmst", impskp=["glm_cono"])
         sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Chart of Accounts", mxs=len(fi.impdat), esc=False)
+            typ="Importing Chart of Accounts", mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'gen/gl2020.py'
--- gen/gl2020.py	2014-12-30 15:37:38 +0000
+++ gen/gl2020.py	2015-01-27 16:25:09 +0000
@@ -296,7 +296,7 @@
             return
         exc = self.rates.keys()
         p = ProgressBar(self.opts["mf"].body, typ="Populating Budgets",
-            mxs=len(recs), esc=False)
+            mxs=len(recs))
         for num, acc in enumerate(recs):
             p.displayProgress(num)
             self.sql.delRec("genbud", where=[("glb_cono", "=",

=== modified file 'gen/gl2030.py'
--- gen/gl2030.py	2014-12-30 15:37:38 +0000
+++ gen/gl2030.py	2015-01-27 09:26:11 +0000
@@ -606,9 +606,9 @@
                 titl=titl, head=head, data=lines, typs=types, retn="I",
                 mode="S", butt=but)
             #self.df.enableButtonsTags(state=state)
-            if not sc.selection:
+            if sc.selection is None:
                 break
-            index = sc.selection[0]
+            index = sc.selection
             self.recon = False
             self.rctupd = False
             a,b,self.trndat,memo,self.trnref,payee,amount,c,seq = data[index]
@@ -806,8 +806,8 @@
         sc = SChoice(self.opts["mf"], scrn=self.df.mstFrame, titl=titl,
             head=head, data=lines, retn="I", mode="S")
         self.df.enableButtonsTags(state=state)
-        if sc.selection:
-            return sc.selection[0]
+        if sc.selection is not None:
+            return sc.selection
 
     def doUpdateRct(self, seq):
         # Set genrct grt_flag to Y
@@ -913,6 +913,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):

=== modified file 'gen/gl2040.py'
--- gen/gl2040.py	2014-12-30 15:37:38 +0000
+++ gen/gl2040.py	2015-01-27 16:25:17 +0000
@@ -189,7 +189,7 @@
             self.impint = "N"
         fi = FileImport(self.opts["mf"], impcol=impcol, impfld=fld)
         p = ProgressBar(self.opts["mf"].body, typ="Importing Journals",
-            mxs=len(fi.impdat), esc=False)
+            mxs=len(fi.impdat))
         trans = []
         tot = 0
         err = False
@@ -332,6 +332,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
         if self.bh.multi == "Y":
             self.curdt = self.trndat / 100

=== modified file 'gen/gl3010.py'
--- gen/gl3010.py	2014-12-30 15:37:38 +0000
+++ gen/gl3010.py	2015-01-27 16:33:49 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %38s %10s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.gentrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -148,16 +150,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'gen/gl3020.py'
--- gen/gl3020.py	2014-12-30 15:37:38 +0000
+++ gen/gl3020.py	2015-01-27 13:55:08 +0000
@@ -101,7 +101,7 @@
                 "Y","Y",self.doTots,None,None,None)]
         if self.multi == "Y":
             fld.append(
-                (("T",0,8,0),("IRB",r2s),10,"Include Other Companies","",
+                (("T",0,8,0),("IRB",r2s),10,"Other Companies","",
                     "N","N",self.doCoy,None,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
@@ -294,8 +294,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -336,11 +336,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -380,15 +377,14 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         cono = CCD(data[0], "UI", 3)

=== modified file 'gen/gl3030.py'
--- gen/gl3030.py	2014-12-30 15:37:38 +0000
+++ gen/gl3030.py	2015-01-27 14:34:47 +0000
@@ -171,8 +171,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             self.acno, self.desc, acctot = self.getAccValues(dat)
@@ -211,16 +211,11 @@
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %59s %10s" % (self.opts["conum"],
             self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         for seq, dat in enumerate(recs):
             if not self.auto:
-                can = p.displayProgress(seq)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(seq)
+                if p.quit:
                     break
             self.acno, self.desc, acctot = self.getAccValues(dat)
             trn = self.sql.getRec(tables="gentrn", where=[("glt_cono", "=",
@@ -259,11 +254,16 @@
                 self.pglin = 999
         if not self.auto:
             p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        if not self.auto:
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            if p.quit:
+                return
+        if self.fpdf.page:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            if not self.auto:
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                    prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getAccValues(self, data):
         dic = self.sql.genmst_dic

=== modified file 'gen/gl3040.py'
--- gen/gl3040.py	2014-12-30 15:37:38 +0000
+++ gen/gl3040.py	2015-01-27 14:37:59 +0000
@@ -42,7 +42,7 @@
         self.head = ("%03u %-30s %s" % (self.opts["conum"], self.opts["conam"],
             "%s"))
         self.colsh = ["Acc-Num", "T", "Description", "Debit", "Credit"]
-        self.forms = [("UI", 7), ("UA", 1), ("NA", 40)] + [("SD", 13.2)] * 2
+        self.forms = [("UI", 7), ("UA", 1), ("NA", 40)] + [("SD", 14.2)] * 2
         self.s_per = self.opts["period"][1][0] / 100
         self.e_per = self.opts["period"][2][0] / 100
         self.dtot = 0.00
@@ -122,22 +122,22 @@
             self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         if self.opebal == "Y":
-            date = CCD(self.opts["period"][1][0], "D1", 10.0)
+            date = CCD(self.opts["period"][1][0], "D1", 10)
             self.expheads.append("General Ledger Opening Balances as at %s" % \
                 date.disp)
         else:
-            sdate = CCD(self.start, "D1", 10.0).disp
-            edate = CCD(self.end, "D1", 10.0).disp
+            sdate = CCD(self.start, "D2", 7)
+            edate = CCD(self.end, "D2", 7)
             self.expheads.append("General Ledger Trial Balance for Period %s "\
-                "to %s" % (sdate, edate))
+                "to %s" % (sdate.disp, edate.disp))
             self.expheads.append("(Options: Opening Balances Included %s)" % \
                 self.incope)
         self.expcolsh = [self.colsh]
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -166,21 +166,21 @@
             self.head2 = "General Ledger Opening Balances as at %s%s" % \
                 (date.disp, "%s%s")
         else:
-            sdate = CCD(self.start, "D1", 10.0).disp
-            edate = CCD(self.end, "D1", 10.0).disp
+            sdate = CCD(self.start, "D2", 7)
+            edate = CCD(self.end, "D2", 7)
             self.head2 = "General Ledger Trial Balance for Period %s to "\
-                "%s%s" % (sdate, edate, "%s%s")
+                "%s%s" % (sdate.disp, edate.disp, "%s%s")
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if not "args" in self.opts:
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
             self.fpdf = MyFpdf(name=__name__, head=self.head1)
         self.pgnum = 0
         self.pglin = 999
         for num, rec in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             vals = self.getValues(rec)
             if not vals:
                 continue
@@ -190,9 +190,11 @@
                 vals[1].disp, vals[2].disp, vals[3].disp, vals[4].disp))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             self.grandTotal()
             if not "args" in self.opts:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     rep=pdfnam, head=self.tit, view=self.repprt[0][1],
@@ -211,9 +213,9 @@
                 acno.work), ("glo_trdt", "=", self.opts["period"][1][0])],
                 limit=1)
             if o:
-                b = CCD(o[0], "SD", 13.2)
+                b = CCD(o[0], "SD", 14.2)
             else:
-                b = CCD(0, "SD", 13.2)
+                b = CCD(0, "SD", 14.2)
             bal = float(ASD(bal) + ASD(b.work))
         if self.opebal == "N" and self.incope == "Y":
             o = self.sql.getRec(tables="gentrn",
@@ -222,9 +224,9 @@
                 ("glt_curdt", ">", self.s_per), ("glt_curdt", "<",
                 self.start)], limit=1)
             if o and o[0]:
-                b = CCD(float(o[0]), "SD", 13.2)
+                b = CCD(float(o[0]), "SD", 14.2)
             else:
-                b = CCD(0, "SD", 13.2)
+                b = CCD(0, "SD", 14.2)
             bal = float(ASD(bal) + ASD(b.work))
         if self.opebal == "N":
             o = self.sql.getRec(tables="gentrn",
@@ -232,18 +234,18 @@
                 self.opts["conum"]), ("glt_acno", "=", acno.work),
                 ("glt_curdt", "between", self.start, self.end)], limit=1)
             if o and o[0]:
-                b = CCD(float(o[0]), "SD", 13.2)
+                b = CCD(float(o[0]), "SD", 14.2)
             else:
-                b = CCD(0, "SD", 13.2)
+                b = CCD(0, "SD", 14.2)
             bal = float(ASD(bal) + ASD(b.work))
         if bal == 0 and self.zerbal == "Y":
             return
         if bal < 0:
-            cr = CCD(bal, "SD", 13.2)
-            dr = CCD(0.00, "SD", 13.2)
+            cr = CCD(bal, "SD", 14.2)
+            dr = CCD(0.00, "SD", 14.2)
         else:
-            dr = CCD(bal, "SD", 13.2)
-            cr = CCD(0.00, "SD", 13.2)
+            dr = CCD(bal, "SD", 14.2)
+            cr = CCD(0.00, "SD", 14.2)
         self.dtot = float(ASD(self.dtot) + ASD(dr.work))
         self.ctot = float(ASD(self.ctot) + ASD(cr.work))
         if atyp.work == "P":
@@ -262,7 +264,7 @@
             self.fpdf.drawText("(Options: Opening Balances Included %s)" % \
                 (self.incope))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-7s %-1s %-40s %13s %13s" % \
+        self.fpdf.drawText("%-7s %-1s %-40s %14s %14s" % \
             ("Acc-Num", "T", "Description", "Debit ", "Credit "))
         self.fpdf.underLine()
         self.fpdf.setFont()
@@ -278,33 +280,34 @@
                 self.ctot]])
             self.expdatas.append(["ULINED"])
             return
-        d = CCD(self.dtot, "SD", 13.2)
-        c = CCD(self.ctot, "SD", 13.2)
+        d = CCD(self.dtot, "SD", 14.2)
+        c = CCD(self.ctot, "SD", 14.2)
         self.fpdf.setFont(style="B")
-        self.fpdf.underLine()
         if self.fpdf.lpp - self.pglin < 5:
             self.pageHeading()
-        self.fpdf.drawText("%9s %-40s %13s %13s" % \
+        else:
+            self.fpdf.underLine()
+        self.fpdf.drawText("%9s %-40s %14s %14s" % \
             ("", "Grand-Totals", d.disp, c.disp))
         self.pglin += 2
         if self.pglin > self.fpdf.lpp:
             self.pageHeading()
-        gp = CCD(self.gp, "SD", 13.2)
+        gp = CCD(self.gp, "SD", 14.2)
         if gp.work > 0:
             self.fpdf.drawText()
-            self.fpdf.drawText("%9s %-40s %13s %13s" % \
+            self.fpdf.drawText("%9s %-40s %14s %14s" % \
                 ("", "Gross-Loss", gp.disp, ""))
         else:
             self.fpdf.drawText()
-            self.fpdf.drawText("%9s %-40s %13s %13s" % \
+            self.fpdf.drawText("%9s %-40s %14s %14s" % \
                 ("", "Gross-Profit", "", gp.disp))
         self.pglin += 2
-        diff = CCD(float(ASD(d.work) + ASD(c.work)), "SD", 13.2)
+        diff = CCD(float(ASD(d.work) + ASD(c.work)), "SD", 14.2)
         if diff.work:
             if self.pglin > self.fpdf.lpp:
                 self.pageHeading()
             self.fpdf.drawText()
-            self.fpdf.drawText("%9s %-40s %13s %13s" % \
+            self.fpdf.drawText("%9s %-40s %14s %14s" % \
                 ("", "Difference", "", diff.disp))
         self.fpdf.setFont()
 

=== modified file 'gen/gl3050.py'
--- gen/gl3050.py	2014-12-30 15:37:38 +0000
+++ gen/gl3050.py	2015-01-28 11:07:21 +0000
@@ -62,16 +62,16 @@
         self.titles = {
             1: ["Acc-Num", "UI", 7, False, False, True],
             2: ["Description", "NA", 30],
-            3: ["Actual", "SD", 13.2],
-            4: ["Budget", "SL", 10],
-            5: ["Variance", "SL", 10],
+            3: ["Actual", "SD", 14.2],
+            4: ["Budget", "SL", 11],
+            5: ["Variance", "SL", 11],
             6: ["Var-%", "SD", 7.2],
-            7: ["Last-Year", "SD", 13.2],
-            8: ["Open-Bal", "SD", 13.2],
-            9: ["Close-Bal", "SD", 13.2]}
+            7: ["Last-Year", "SD", 14.2],
+            8: ["Open-Bal", "SD", 14.2],
+            9: ["Close-Bal", "SD", 14.2]}
         m = self.s_per % 100
         for x in xrange(0, 12):
-            self.titles[x+10] = [mthnam[m][1], "SD", 13.2]
+            self.titles[x+10] = [mthnam[m][1], "SD", 14.2]
             m += 1
             if  m > 12:
                 m = 1
@@ -383,13 +383,13 @@
         self.opts["mf"].startLoop()
 
     def doAllCoy(self, frt, pag, r, c, p, i, w):
-        self.con = w
-        if self.con == "Y":
+        self.acc = w
+        if self.acc == "Y":
             self.con = []
             for coy in self.coys:
                 self.con.append(coy[0])
             return "nd"
-        if self.con == "I":
+        if self.acc == "I":
             self.cc.topf[pag][1][8]["titl"] = "Select Companies to Include"
         else:
             self.cc.topf[pag][1][8]["titl"] = "Select Companies to Exclude"
@@ -411,9 +411,9 @@
         self.coy = w.split(",")
 
     def doCoyEnd(self):
-        if self.con == "I":
+        if self.acc == "I":
             self.con = self.coy
-        elif self.con == "E":
+        elif self.acc == "E":
             self.con = []
             for co in self.coys:
                 self.con.append(int(co[0]))
@@ -789,8 +789,8 @@
         else:
             self.doPrintReport()
             # For type M and a Manual or Auto Chart is selected
-            if not self.strm and self.gldep == "N" and \
-                    (self.achart or self.mchart):
+            if not "args" in self.opts and not self.strm and \
+                    self.gldep == "N" and (self.achart or self.mchart):
                 CreateChart(self.opts["mf"], self.opts["conum"],
                     self.opts["conam"], [self.s_per, self.end],
                     [self.tit, self.des1], self.achart, self.mchart)
@@ -844,10 +844,7 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(self.allfields),
             esc=True)
         for num, dat in enumerate(self.allfields):
-            can = p.displayProgress(num)
-            if can == "yes":
-                p.closeProgress()
-                return
+            p.displayProgress(num)
             if dat[6] < self.counter:
                 dat[3] = "Y"
             if not num:
@@ -869,8 +866,7 @@
             rcdic=self.opts["mf"].rcdic, view=view)
 
     def doPrintReport(self):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(self.allfields),
-            esc=True)
+        p = ProgressBar(self.opts["mf"].body, mxs=len(self.allfields))
         self.head = []
         self.linb = ""
         self.lind = ""
@@ -879,33 +875,33 @@
         self.linw = ""
         self.last = False
         if self.typ == "S":
-            self.head.append("%03u %-30s %57s" % (self.opts["conum"],
+            self.head.append("%03u %-30s %61s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm))
             self.head.append("")
             self.head.append("")
-            self.head.append("%-13s  %-30s  %-13s  %-10s  %-10s  %-7s" % \
-                ("   Last-Year", "Description", "      Actual", "   Budget",
-                " Variance", " Var-%"))
-            self.linu = "%s  %31s  %s  %s  %s  %s" % (self.ulc*12, "",
-                self.ulc*12, self.ulc*10, self.ulc*10, self.ulc*7)
+            self.head.append("%-14s  %-30s  %-14s  %-11s  %-11s  %-7s" % \
+                ("    Last-Year", "Description", "       Actual", "    Budget",
+                "  Variance", " Var-%"))
+            self.linu = "%s  %31s  %s  %s  %s  %s" % (self.ulc*13, "",
+                self.ulc*13, self.ulc*11, self.ulc*11, self.ulc*7)
             self.width = self.head[0]
         elif self.typ == "L":
             if self.num == "Y":
-                self.head.append("%03u %-30s %114s" % (self.opts["conum"],
+                self.head.append("%03u %-30s %121s" % (self.opts["conum"],
                     self.opts["conam"], self.sysdttm))
             else:
-                self.head.append("%03u %-30s %105s" % (self.opts["conum"],
+                self.head.append("%03u %-30s %112s" % (self.opts["conum"],
                     self.opts["conam"], self.sysdttm))
             self.head.append("")
             self.head.append("")
             if self.num == "Y":
-                self.head.append("%-7s  %-30s  %-45s   %-45s" % ("", "",
-                    "*************** Current-Month ***************",
-                    "*************** Year-to-Date ****************"))
+                self.head.append("%-7s  %-30s  %-48s   %-48s" % ("", "",
+                    "***************** Current-Month ****************",
+                    "***************** Year-to-Date *****************"))
             else:
-                self.head.append("%-30s  %-45s   %-45s" % ("",
-                    "*************** Current-Month ***************",
-                    "*************** Year-to-Date ****************"))
+                self.head.append("%-30s  %-48s   %-48s" % ("",
+                    "***************** Current-Month ****************",
+                    "***************** Year-to-Date *****************"))
             if self.num == "Y":
                 hdr = "%-7s  "
                 hdt = ["Acc-Num"]
@@ -916,27 +912,27 @@
                 hdt = []
                 lin = ""
                 ldt = []
-            hdr = hdr + "%-30s  %-13s  %-10s  %-10s  %-7s  %-13s  %-10s  "\
-                "%-10s  %-7s  %-13s"
+            hdr = hdr + "%-30s  %-14s  %-11s  %-11s  %-7s  %-14s  %-11s  "\
+                "%-11s  %-7s  %-14s"
             hdt.extend(["Description",
-                "      Actual", "   Budget", " Variance", " Var-%",
-                "      Actual", "   Budget", " Variance", " Var-%",
-                "   Last-Year"])
+                "       Actual", "    Budget", "  Variance", " Var-%",
+                "       Actual", "    Budget", "  Variance", " Var-%",
+                "    Last-Year"])
             self.head.append(hdr % tuple(hdt))
             lin = lin + "%30s  %s  %s  %s  %s   %s  %s  %s  %s   %s"
-            self.linu = lin % tuple(ldt + ["", self.ulc*12, self.ulc*10,
-                self.ulc*10, self.ulc*7, self.ulc*12, self.ulc*10, self.ulc*10,
-                self.ulc*7, self.ulc*12])
-            self.linb = lin % tuple(ldt + ["", " "*12, " "*10, " "*10, " "*7,
-                self.ulc*12, self.ulc*10, self.ulc*10, self.ulc*7,
-                self.ulc*12])
+            self.linu = lin % tuple(ldt + ["", self.ulc*13, self.ulc*11,
+                self.ulc*11, self.ulc*7, self.ulc*13, self.ulc*11, self.ulc*11,
+                self.ulc*7, self.ulc*13])
+            self.linb = lin % tuple(ldt + ["", " "*13, " "*11, " "*11, " "*7,
+                self.ulc*13, self.ulc*11, self.ulc*11, self.ulc*7,
+                self.ulc*13])
             self.width = self.head[0]
         elif self.typ == "M":
             if self.num == "Y":
-                self.head.append("%03u %-30s %156s" % (self.opts["conum"],
+                self.head.append("%03u %-30s %170s" % (self.opts["conum"],
                     self.opts["conam"], self.sysdttm))
             else:
-                self.head.append("%03u %-30s %148s" % (self.opts["conum"],
+                self.head.append("%03u %-30s %162s" % (self.opts["conum"],
                     self.opts["conam"], self.sysdttm))
             self.head.append("")
             self.head.append("")
@@ -955,27 +951,27 @@
             self.text = ""
             space = " " * 20
             for _ in xrange(0, 12):
-                self.text = self.text + space[0:(9-len(mthnam[m][1]))] + \
+                self.text = self.text + space[0:(10-len(mthnam[m][1]))] + \
                     mthnam[m][1] + "  "
                 m += 1
                 if  m > 12:
                     m = 1
             if self.num == "Y":
-                self.head.append("%-7s %-30s %-10s%-132s%-10s" % ("Acc-Num",
-                    "Description", " Open-Bal  ", self.text, "Close-Bal  "))
+                self.head.append("%-7s %-30s %-11s%-144s%-11s" % ("Acc-Num",
+                    "Description", "  Open-Bal  ", self.text, " Close-Bal  "))
                 self.linu = "%7s %30s %s  %s  %s  %s  %s  %s  %s  %s  %s  "\
-                    "%s  %s  %s  %s  %s" % ("", "", self.ulc*9, self.ulc*9,
-                    self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9,
-                    self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9,
-                    self.ulc*9, self.ulc*9)
+                    "%s  %s  %s  %s  %s" % ("", "", self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10)
             else:
-                self.head.append("%-30s %-10s%-132s%-10s" % ("Description",
+                self.head.append("%-30s %-11s%-144s%-11s" % ("Description",
                     " Open-Bal  ", self.text, "Close-Bal  "))
                 self.linu = "%30s %s  %s  %s  %s  %s  %s  %s  %s  %s  %s  "\
-                    "%s  %s  %s  %s" % ("",self.ulc*9, self.ulc*9, self.ulc*9,
-                    self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9,
-                    self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9, self.ulc*9,
-                    self.ulc*9)
+                    "%s  %s  %s  %s" % ("",self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10,
+                    self.ulc*10, self.ulc*10, self.ulc*10, self.ulc*10)
             self.width = self.head[0]
         else:
             head = ""
@@ -1036,12 +1032,7 @@
         self.mchart = []
         self.counter = 0
         for num, dat in enumerate(self.allfields):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
-                break
+            p.displayProgress(num)
             if dat[6] < self.counter:
                 dat[3] = "Y"
             if self.pglin > self.fpdf.lpp:
@@ -1054,7 +1045,7 @@
                 self.doUnderline(dat)
             self.counter = dat[6]
         p.closeProgress()
-        if not "args" in self.opts:
+        if not "args" in self.opts and self.fpdf.page:
             self.fpdf.output(self.fnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=self.fnam, head=self.emlhead, view=self.view,
@@ -1083,7 +1074,7 @@
             if line[2] == "Y":
                 self.fpdf.setFont(style="B")
             if self.typ == "S":
-                self.fpdf.drawText("%13s  %s" % ("", line[5]))
+                self.fpdf.drawText("%14s  %s" % ("", line[5]))
             elif self.typ == "L":
                 if self.num == "Y":
                     self.fpdf.drawText("%7s  %s" % ("", line[5]))
@@ -1111,16 +1102,16 @@
             des = CCD(line[5], "NA", 30)
         sgn = line[12]
         if self.typ in ("S", "L", "C"):
-            lyr = CCD(line[8][1], "SD", 13.2)
+            lyr = CCD(line[8][1], "SD", 14.2)
             if self.typ == "L":
-                mth = CCD(line[8][2], "SD", 13.2)
-                bud = CCD(long(line[8][3]), "SL", 10)
+                mth = CCD(line[8][2], "SD", 14.2)
+                bud = CCD(long(line[8][3]), "SL", 11)
                 if typ != "P":
                     if sgn == "N":
                         vmt = long(long(mth.work) - bud.work)
                     else:
                         vmt = long(bud.work - long(mth.work))
-                    vmt = CCD(vmt, "SL", 10)
+                    vmt = CCD(vmt, "SL", 11)
                     if bud.work != 0:
                         vmtper = round(vmt.work * 100.0 / bud.work, 2)
                     else:
@@ -1131,14 +1122,14 @@
                 else:
                     vmt = CCD(0, "NA", 10)
                     vmtper = CCD(0, "NA", 7)
-            ytd = CCD(line[8][4], "SD", 13.2)
-            btd = CCD(long(line[8][5]), "SL", 10)
+            ytd = CCD(line[8][4], "SD", 14.2)
+            btd = CCD(long(line[8][5]), "SL", 11)
             if typ != "P":
                 if sgn == "N":
                     vtd = long(long(ytd.work) - btd.work)
                 else:
                     vtd = long(btd.work - long(ytd.work))
-                vtd = CCD(vtd, "SL", 10)
+                vtd = CCD(vtd, "SL", 11)
                 if btd.work != 0:
                     vtdper = round(vtd.work * 100.0 / btd.work, 2)
                 else:
@@ -1153,8 +1144,8 @@
             for x in xrange(0, 14):
                 if self.val == "X" and sgn == "N":
                     line[9][x] = float(ASD(0) - ASD(line[9][x]))
-                exec "mp%s = CCD(long(line[9][x]), 'SL', 10.0)" % x
-                exec "mx%s = CCD(line[9][x], 'SD', 13.2)" % x
+                exec "mp%s = CCD(long(line[9][x]), 'SL', 11.0)" % x
+                exec "mx%s = CCD(line[9][x], 'SD', 14.2)" % x
         if self.prtnam != "export" and line[2] == "Y":
             self.fpdf.setFont(style="B")
         if self.prtnam == "export":
@@ -1191,12 +1182,12 @@
                             lyr.work]])
                 else:
                     if self.num == "Y":
-                        self.fpdf.drawText("%s  %s  %13s  %-10s  %-10s  "\
+                        self.fpdf.drawText("%s  %s  %14s  %-11s  %-11s  "\
                             "%-7s  %s  %s  %s  %s  %s" % (acc.disp,
                             des.disp, "", "", "", "", ytd.disp, btd.disp,
                             vtd.disp, vtdper.disp, lyr.disp))
                     else:
-                        self.fpdf.drawText("%s  %13s  %-10s  %-10s  %-7s  "\
+                        self.fpdf.drawText("%s  %14s  %-11s  %-11s  %-7s  "\
                             "%s  %s  %s  %s  %s" % (des.disp, "", "", "",
                             "", ytd.disp, btd.disp, vtd.disp, vtdper.disp,
                             lyr.disp))
@@ -1498,9 +1489,9 @@
                 where=[("gdt_cono", "=", self.opts["conum"]), ("gdt_code", "=",
                 self.det), ("gdt_curdt", "=", self.end)], limit=1)
             if not det:
-                mtd = CCD(0, "SD", 13.2).disp
+                mtd = CCD(0, "SD", 14.2).disp
             else:
-                mtd = CCD(det[0], "SD", 13.2).disp
+                mtd = CCD(det[0], "SD", 14.2).disp
             det = self.sql.getRec(tables=["gendtm", "gendtt"],
                 cols=["gdm_desc", "sum(gdt_value)"], where=[("gdm_cono", "=",
                 self.opts["conum"]), ("gdm_code", "=", self.det),
@@ -1508,14 +1499,14 @@
                 ("gdt_code=gdm_code",), ("gdt_curdt", "between", self.s_per,
                 self.end)], group="gdm_desc", limit=1)
             des = det[0]
-            ytd = CCD(det[1], "SD", 13.2).disp
+            ytd = CCD(det[1], "SD", 14.2).disp
             if self.typ in ("C", "M", "S"):
                 txt += "Detail: %s - Y.T.D. %s" % (des, ytd)
             elif self.typ == "L":
                 txt += "Detail: %s - Month %s  Y.T.D. %s" % (des, mtd, ytd)
         if self.con == "N":
             pass
-        elif self.con == "Y":
+        elif self.acc == "Y":
             txt += " Companies: All "
         else:
             con = str(tuple(self.con)).replace("'", "").replace(" ", "")

=== modified file 'gen/gl3070.py'
--- gen/gl3070.py	2014-12-30 15:37:38 +0000
+++ gen/gl3070.py	2015-01-27 16:04:55 +0000
@@ -35,10 +35,10 @@
     def mainProcess(self):
         data = []
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
-            mxs=len(self.notes.data))
+            mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -53,7 +53,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["General Ledger Masterfile Notes Listing"]
             cols = [

=== modified file 'gen/gl3080.py'
--- gen/gl3080.py	2014-12-30 15:37:38 +0000
+++ gen/gl3080.py	2015-01-27 16:06:23 +0000
@@ -129,7 +129,7 @@
 
     def printReport(self):
         p = ProgressBar(self.opts["mf"].body,
-            mxs=(len(self.pays) + len(self.recs) + len(self.imps)), esc=True)
+            mxs=(len(self.pays) + len(self.recs) + len(self.imps)))
         self.head = ("%03u %-30s %39s %10s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -139,7 +139,6 @@
         self.tot_dep = 0
         self.tot_imp = 0
         self.pageHeading()
-        can = "no"
         bal = CCD(self.bal, "SD", 13.2)
         self.fpdf.drawText("%-71s %-13s" % ("Balance as per Cash Book",
             bal.disp))
@@ -150,39 +149,27 @@
             self.pglin += 4
             mxs = len(self.pays) - 1
             for num, pay in enumerate(self.pays):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
-                    break
+                p.displayProgress(num)
                 self.printLine(num, mxs, pay, "C")
             self.pglin += 1
-        if self.recs and can != "yes":
+        if self.recs:
             self.fpdf.drawText()
             self.fpdf.drawText("%-70s" % ("Less: Deposits Not Presented",))
             self.fpdf.drawText()
             self.pglin += 3
             mxs = len(self.recs) - 1
             for num, rec in enumerate(self.recs):
-                can = p.displayProgress(len(self.pays) + num)
-                if can == "yes":
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
-                    break
+                p.displayProgress(len(self.pays) + num)
                 self.printLine(num, mxs, rec, "D")
         # Bank Imports
-        if self.imps and can != "yes":
+        if self.imps:
             self.fpdf.drawText()
             self.fpdf.drawText("%-70s" % ("+-: Imports Not Captured",))
             self.fpdf.drawText()
             self.pglin += 3
             mxs = len(self.imps) - 1
             for num, rec in enumerate(self.imps):
-                can = p.displayProgress(len(self.pays) + len(self.imps) + num)
-                if can == "yes":
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
-                    break
+                p.displayProgress(len(self.pays) + len(self.imps) + num)
                 self.printLine(num, mxs, rec, "I")
         p.closeProgress()
         self.fpdf.underLine(txt="%72s%12s" % ("", 12 * self.fpdf.suc))

=== modified file 'gen/gl3100_rne.py'
--- gen/gl3100_rne.py	2014-12-30 15:37:38 +0000
+++ gen/gl3100_rne.py	2015-01-24 10:00:31 +0000
@@ -14,9 +14,9 @@
     Copyright (C) 2004-2015 Paul Malherbe.
 """
 
+import copy
 from TartanClasses import ASD, CCD, Dbase, MyFpdf, RepPrt, Sql, TartanDialog
 from tartanFunctions import callModule, doPrinter, getModName, getPeriods
-from tartanFunctions import getSingleRecords
 
 class gl3100:
     def __init__(self, **opts):
@@ -57,6 +57,12 @@
                 ("glr_seq", "=", 0),
                 ("glr_type", "in", ("P", "B", "O"))],
             "group": "glr_repno, glr_type, glr_desc"}
+        coy = {
+            "stype": "R",
+            "tables": ("ctlmst",),
+            "cols": (
+                ("ctm_cono", "", 0, "Com"),
+                ("ctm_name", "", 0, "Name", "Y"))}
         r1s = (("Yes","Y"),("No","N"))
         r2s = (("Normal","N"), ("Consolidated","C"))
         r3s = (
@@ -70,51 +76,73 @@
             ("Variances","X"))
         fld = (
             (("T",0,0,0),"IUI",3,"Financial Period","",
-                self.finper,"N",self.doFP,fin,None,("efld",)),
+                self.finper,"N",self.doFP,fin,None,("notzero",)),
             (("T",0,1,0),"ID2",7,"Ending Period","",
                 0,"N",self.doEP,None,None,("efld",)),
             (("T",0,2,0),("IRB",r1s),0,"Trial Balance","",
-                "Y","N",self.doTB,None,None,None),
+                "Y","Y",self.doTB,None,None,None),
             (("T",0,3,0),("IRB",r2s),0,"Format","",
-                "N","N",self.doTBF,None,None,None),
-            (("T",0,4,0),("IRB",r1s),0,"Financials","",
-                "Y","N",self.doFS,None,None,None),
-            (("T",0,5,0),("IRB",r3s),0,"Report Type","",
+                "N","Y",self.doTBF,None,None,None),
+            (("T",0,4,0),"INA",30,"T/B Heading","",
+                "","Y",self.doTBH,None,None,("notblank",)),
+            (("T",0,5,0),("IRB",r1s),0,"Financials","",
+                "Y","Y",self.doFS,None,None,None),
+            (("T",0,6,0),("IRB",r3s),0,"Report Type","",
                 "S","Y",self.doRT,None,None,None),
-            (("T",0,6,0),"IUI",3,"Report Number","",
+            (("T",0,7,0),"IUI",3,"Report Number","",
                 1,"Y",self.doRN,rpt,None,("notzero",)),
-            (("T",0,7,0),("IRB",r4s),0,"Contents","",
+            (("T",0,8,0),("IRB",r4s),0,"Contents","",
                 "V","Y",self.doRV,None,None,None),
-            (("T",0,8,0),("IRB",r1s),0,"Ignore Zeros","",
-                "Y","Y",self.doIZ,None,None,None))
+            (("T",0,9,0),("IRB",r1s),0,"Ignore Zeros","",
+                "Y","Y",self.doIZ,None,None,None),
+            (("C",0,0,0),"IUI",3,"Seq","Sequence Number",
+                "i","N",self.doSeq,None,None,None),
+            (("C",0,0,1),"IUI",3,"Coy","Company Number",
+                0,"Y",self.doCoy,coy,None,None),
+            (("C",0,0,2),"ONA",48,"Name"),
+            (("C",0,0,3),"INA",12,"Heading Name","Heading-Name",
+                0,"N",self.doHed,None,None,("notblank",)))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
+        cnd = ((self.doEnd,"n"),)
+        cxt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            eflds=fld, tend=tnd, txit=txt, view=("N","V"), mail=("Y","N"))
+            rows=[10], eflds=fld, tend=tnd, txit=txt, cend=cnd, cxit=cxt,
+            view=("N","V"), mail=("Y","N"))
 
     def doFP(self, frt, pag, r, c, p, i, w):
-        per = getPeriods(self.opts["mf"], 1, w, check=True)
-        if per == (None, None, None):
-            return "Invalid Financial Period"
-        self.period = (w, (per[0].work,per[0].disp), (per[1].work,per[1].disp))
-        self.s_per = self.period[1][0] / 100
-        self.e_per = self.period[2][0] / 100
-        self.df.loadEntry(frt, pag, p+1, data=self.e_per)
+        f = getPeriods(self.opts["mf"], 1, w, check=True)
+        if f == (None, None, None):
+            return "Invalid Financial Period"
+        self.c_per = (w, (f[0].work, f[0].disp), (f[1].work, f[1].disp))
+        self.s_cfp = f[0].work / 100
+        self.e_cfp = f[1].work / 100
+        f = getPeriods(self.opts["mf"], 1, w - 1, check=True)
+        if f == (None, None, None):
+            return "Invalid Financial Period"
+        self.p_per = (w - 1, (f[0].work, f[0].disp), (f[1].work, f[1].disp))
+        self.s_pfp = f[0].work / 100
+        self.e_pfp = f[1].work / 100
+        self.df.loadEntry(frt, pag, p+1, data=self.e_cfp)
 
     def doEP(self, frt, pag, r, c, p, i, w):
-        if w < self.s_per or w > self.e_per:
+        if w < self.s_cfp or w > self.e_cfp:
             return "Invalid Ending Period"
         self.ep = w
-        self.epd = self.df.t_disp[0][0][1]
+        self.lp = w - 100
+        self.epd = CCD(self.ep, "D2", 7).disp
 
     def doTB(self, frt, pag, r, c, p, i, w):
         self.tb = w
         if self.tb == "N":
-            return "sk1"
+            return "sk2"
 
     def doTBF(self, frt, pag, r, c, p, i, w):
         self.tbf = w
 
+    def doTBH(self, frt, pag, r, c, p, i, w):
+        self.tbh = w
+
     def doFS(self, frt, pag, r, c, p, i, w):
         self.fs = w
         if self.fs == "N":
@@ -145,99 +173,168 @@
     def doIZ(self, frt, pag, r, c, p, i, w):
         self.iz = w
 
+    def doSeq(self, frt, pag, r, c, p, i, w):
+        if not w or w > 10:
+            return "Invalid Sequence Number"
+        self.seq = w
+
+    def doCoy(self, frt, pag, r, c, p, i, w):
+        acc = self.sql.getRec(tables="ctlmst", cols=["ctm_name"],
+            where=[("ctm_cono", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Company Number"
+        self.coy = w
+        self.nam = acc[0]
+        if self.seqdic[self.seq][2]:
+            self.hed = self.seqdic[self.seq][2]
+        else:
+            self.hed = "Company-%03i" % self.coy
+        self.df.loadEntry(frt, pag, p+1, data=self.nam)
+        self.df.loadEntry(frt, pag, p+2, data=self.hed)
+
+    def doHed(self, frt, pag, r, c, p, i, w):
+        self.hed = w
+
     def doEnd(self):
+        if self.df.frt == "T":
+            self.seqdic = {}
+            for x in range(1, 11):
+                self.seqdic[x] = [0, "", ""]
+            self.df.loadEntry("C", 0, 0, data=1)
+            self.df.focusField("C", 0, 1)
+        else:
+            for seq in self.seqdic:
+                if self.seqdic[seq][0] == self.coy:
+                    self.seqdic[seq] = [0, "", ""]
+            self.seqdic[self.seq] = [self.coy, self.nam, self.hed]
+            self.df.clearFrame("C", 0)
+            idx = 0
+            for x in range(1, 11):
+                if not self.seqdic[x][0]:
+                    continue
+                self.df.loadEntry("C", 0, idx, data=x)
+                self.df.loadEntry("C", 0, idx+1, data=self.seqdic[x][0])
+                self.df.loadEntry("C", 0, idx+2, data=self.seqdic[x][1])
+                self.df.loadEntry("C", 0, idx+3, data=self.seqdic[x][2])
+                idx += 4
+            if idx == 40:
+                idx -= 4
+            self.df.focusField("C", 0, idx+1)
+
+    def doExit(self):
         self.df.closeProcess()
-        recs = getSingleRecords(self.opts["mf"], "ctlmst",
-            ("ctm_cono", "ctm_name"))
-        if not recs:
-            self.doExit()
-            return
-        coys = []
-        coyd = ""
-        for rec in recs:
-            cono = rec[self.sql.ctlmst_col.index("ctm_cono")]
-            name = rec[self.sql.ctlmst_col.index("ctm_name")]
-            coys.append([cono, name])
-            if not coyd:
-                coyd = str(cono)
-            else:
-                coyd = "%s, %s" % (coyd, str(cono))
-        if self.tb == "Y":
-            if self.tbf == "N":
-                tit = "Trial Balances as at %s for Companies %s" % (self.epd,
-                    coyd)
+        if self.df.frt == "C":
+            coys = []
+            coyd = ""
+            for x in range(1, 11):
+                if not self.seqdic[x][0]:
+                    continue
+                coys.append(self.seqdic[x])
+                if not coyd:
+                    coyd = str(self.seqdic[x][0])
+                else:
+                    coyd = "%s, %s" % (coyd, str(self.seqdic[x][0]))
+            if self.tb == "Y":
+                if self.tbf == "N":
+                    tit = "Trial Balances as at %s for Companies %s" % \
+                        (self.epd, coyd)
+                    pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
+                        __name__, "trialbalance", ext="pdf")
+                    self.fpdf = MyFpdf(name=__name__, head=77)
+                    for coy in coys:
+                        callModule(self.opts["mf"], None, "gl3040", coy=(coy[0],
+                            coy[1]), period=self.c_per, args=(self.ep, self.iz,
+                            self.df.repprt, self.fpdf))
+                    self.fpdf.output(pdfnam, "F")
+                    doPrinter(mf=self.opts["mf"], rep=pdfnam, head=tit,
+                        view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                        mail=self.df.repprt[1][2])
+                else:
+                    self.doTrialBalance(coys, coyd)
+            if self.fs == "Y":
+                tit = "Financial Statements as at %s for Companies %s" % \
+                    (self.epd, coyd)
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                    "trialbalance", ext="pdf")
-                self.fpdf = MyFpdf(name=__name__, head=77)
+                    "financials", ext="pdf")
+                if self.rt == "S":
+                    hw = 92
+                elif self.rt == "L":
+                    hw = 149
+                else:
+                    hw = 191
+                self.fpdf = MyFpdf(name=__name__, head=hw)
                 for coy in coys:
-                    callModule(self.opts["mf"], None, "gl3040", coy=(coy[0],
-                        coy[1]), period=self.period, args=(self.ep, self.iz,
-                        self.df.repprt, self.fpdf))
+                    callModule(self.opts["mf"], None, "gl3050", coy=(coy[0],
+                        coy[1]), period=self.c_per, args=(self.ep, self.rt,
+                        self.rn, self.rv, self.iz, self.df.repprt, self.fpdf))
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], rep=pdfnam, head=tit,
                     view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
                     mail=self.df.repprt[1][2])
-            else:
-                nums = []
-                for coy in coys:
-                    nums.append(coy[0])
-                self.doTrialBalance(nums, coyd)
-        if self.fs == "Y":
-            tit = "Financial Statements as at %s for Companies %s" % (self.epd,
-                coyd)
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                "financials", ext="pdf")
-            self.fpdf = MyFpdf(name=__name__, head=77)
-            for coy in coys:
-                callModule(self.opts["mf"], None, "gl3050", coy=(coy[0],
-                    coy[1]), period=self.period, args=(self.ep, self.rt,
-                    self.rn, self.rv, self.iz, self.df.repprt, self.fpdf))
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], rep=pdfnam, head=tit,
-                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-                mail=self.df.repprt[1][2])
         self.opts["mf"].closeLoop()
 
     def doTrialBalance(self, coys, coyd):
         pdffl = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             "trialbalance")
         data = []
-        gtot = 0
         sql = Sql(self.opts["mf"].dbm, ["genmst", "genbal", "gentrn"])
+        nums = []
+        for coy in coys:
+            nums.append(coy[0])
         accs = sql.getRec(tables="genmst", cols=["glm_acno", "glm_type"],
-            where=[("glm_cono", "in", coys)], group="glm_acno, glm_type",
+            where=[("glm_cono", "in", nums)], group="glm_acno, glm_type",
             order="glm_type desc, glm_acno")
         for acc in accs:
             zero = True
             dat = [acc[0], acc[1]]
             desc = sql.getRec(tables=["genmst"], cols=["glm_desc"],
-                where=[("glm_acno", "=", acc[0])], limit=1)[0]
+                where=[("glm_cono", "in", nums), ("glm_acno", "=", acc[0])],
+                group="glm_acno, glm_desc", limit=1)[0]
             dat.append(desc)
             dat = dat + [0] * len(coys)
             tot = 0
+            lyr = 0
             for num, coy in enumerate(coys):
                 bal = sql.getRec(tables=["genbal"], cols=["glo_cyr"],
-                    where=[("glo_cono", "=", coy), ("glo_acno", "=", acc[0]),
-                    ("glo_trdt", "=", self.s_per)], limit=1)
+                    where=[("glo_cono", "=", coy[0]), ("glo_acno", "=", acc[0]),
+                    ("glo_trdt", "=", self.c_per[1][0])], limit=1)
                 if not bal or not bal[0]:
                     bal = 0
                 else:
                     bal = bal[0]
                 trn = sql.getRec(tables="gentrn", cols=["sum(glt_tramt)"],
-                    where=[("glt_cono", "=", coy), ("glt_acno", "=", acc[0]),
-                    ("glt_curdt", "between", self.s_per, self.e_per)], limit=1)
+                    where=[("glt_cono", "=", coy[0]), ("glt_acno", "=", acc[0]),
+                    ("glt_curdt", "between", self.s_cfp, self.ep)], limit=1)
                 if not trn or not trn[0]:
                     trn = 0
                 else:
                     trn = trn[0]
-                amt = CCD(float(ASD(bal) + ASD(trn)), "SD", 13.2)
+                amt = CCD(float(ASD(bal) + ASD(trn)), "SD", 14.2)
                 tot = float(ASD(tot) + ASD(amt.work))
-                gtot = float(ASD(gtot) + ASD(amt.work))
                 if amt.work:
                     zero = False
                 dat[num+3] = amt.work
-            dat.append(tot)
+                # Previous year
+                bal = sql.getRec(tables=["genbal"], cols=["glo_cyr"],
+                    where=[("glo_cono", "=", coy[0]), ("glo_acno", "=", acc[0]),
+                    ("glo_trdt", "=", self.p_per[1][0])], limit=1)
+                if not bal or not bal[0]:
+                    bal = 0
+                else:
+                    bal = bal[0]
+                trn = sql.getRec(tables="gentrn", cols=["sum(glt_tramt)"],
+                    where=[("glt_cono", "=", coy[0]), ("glt_acno", "=", acc[0]),
+                    ("glt_curdt", "between", self.s_pfp, self.lp)], limit=1)
+                if not trn or not trn[0]:
+                    trn = 0
+                else:
+                    trn = trn[0]
+                amt = CCD(float(ASD(bal) + ASD(trn)), "SD", 14.2)
+                lyr = float(ASD(lyr) + ASD(amt.work))
+                if amt.work:
+                    zero = False
             if not zero:
+                dat.extend([tot, lyr])
                 data.append(dat)
         cols = [
             ("acno", "UI", 7, "Acc-Num", "y"),
@@ -245,20 +342,18 @@
             ("desc", "NA", 30, "Description", "y")]
         gtot = []
         for coy in coys:
-            cols.append(("c%s" % coy, "SD", 13.2, " Company-%03i" % coy, "y"))
-            gtot.append("c%s" % coy)
-        cols.append(("total", "SD", 13.2, "Tot-Balance", "y"))
+            cols.append(("c%s" % coy[0], "SD", 14.2, "%12s" % coy[2], "y"))
+            gtot.append("c%s" % coy[0])
+        cols.append(("total", "SD", 14.2, "Tot-Balance", "y"))
+        cols.append(("lyear", "SD", 14.2, "LYR-Balance", "y"))
         gtot.append("total")
+        gtot.append("lyear")
+        view, pnam = self.df.repprt[0][1:3]
+        mail = self.df.repprt[1][2]
         RepPrt(self.opts["mf"], **{"name": "gl3100", "tables": data,
-            "heads": ["Trial Balance as at %s for Companies %s" % (self.epd,
-            coyd)], "cols": cols, "stots": [["type", "Total of Type", "Y"]],
-            "gtots": gtot, "pdffl": pdffl, "ttype": "D", "view":
-            self.df.repprt[0][1], "prtnam": self.df.repprt[0][2],
-            "mail": self.df.repprt[1][2]})
-
-    def doExit(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
+            "heads": ["Trial Balance as at %s for %s" % (self.epd, self.tbh)],
+            "cols": cols, "stots": [["type", "Total of Type", "Y"]],
+            "gtots": gtot, "pdffl": pdffl, "ttype": "D",
+            "view": view, "prtnam": pnam, "mail": mail})
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'gen/gl4020.py'
--- gen/gl4020.py	2014-12-30 15:37:38 +0000
+++ gen/gl4020.py	2015-01-31 10:49:03 +0000
@@ -170,6 +170,7 @@
             "Generating and Formatting the Report\n\nPlease Wait ...")
         self.doGenerateReport()
         self.storeTrans()
+        self.sp.closeSplash()
         self.doDisplayReport()
         self.opts["mf"].closeLoop()
 
@@ -783,13 +784,10 @@
             elif fld[0] == "U":
                 self.doDisplayUnderline(fld)
             self.count += 1
-        self.sp.closeSplash()
         self.opts["mf"].window.withdraw()
         grid = ScrollGrid(**{"mf": self.opts["mf"], "titl": head,
             "tags": tags, "labs": labs, "cols": cols, "data": self.data,
-            "bcmd": self.doTrans, "bwth": 0})
-        #self.opts["mf"].startLoop()
-        #grid.window.destroy()
+            "cmds": (("<Double-1>", self.doTrans),), "bwth": 0})
         self.opts["mf"].window.deiconify()
 
     def doHeading(self, line):
@@ -833,10 +831,6 @@
             txt = ""
         else:
             return
-        #elif line[1] == "Single":
-        #    txt = "------------ "
-        #else:
-        #    txt = "============ "
         col = []
         for x in xrange(1, 14):
             col.append((txt, "label"))
@@ -889,7 +883,7 @@
                 curdt = (y * 100) + m
 
     def doTrans(self, *args):
-        row, col = args[0][0]
+        row, col = args[0]
         des = self.data[row][0][0][0]
         try:
             trans = self.trn[des][(col / 3) + 1]
@@ -908,7 +902,7 @@
             ("glt_tramt", "", 0, "       Debit"),
             ("glt_tramt", "", 0, "      Credit"),
             ("balance", "SD", 13.2, "     Balance"),
-            ("glt_desc", "", 0, "Remarks"))
+            ("glt_desc", "", 30, "Remarks"))
         data = []
         acctot = 0
         for rec in trans:
@@ -928,8 +922,10 @@
                 rec[col.index("glt_batch")],
                 dr, cr, acctot,
                 rec[col.index("glt_desc")]])
+        args[3].withdraw()
         rec = SRec(self.opts["mf"], screen=None, title=tit, tables=gtt,
             cols=gtc, where=data, wtype="D", sort=False, rows=15)
+        args[3].deiconify()
 
     def doMainExit(self):
         self.df.closeProcess()

=== modified file 'gen/gl6010.py'
--- gen/gl6010.py	2014-12-30 15:37:38 +0000
+++ gen/gl6010.py	2015-01-29 11:25:32 +0000
@@ -31,6 +31,7 @@
             ("assgrp", "asg_cono", "asg_assacc"),
             ("assgrp", "asg_cono", "asg_depacc"),
             ("assgrp", "asg_cono", "asg_expacc"),
+            ("bkmunm", "bum_cono", "bum_slsa"),
             ("crsctl", "ctc_cono", "ctc_bankac"),
             ("crsmst", "crm_cono", "crm_glac"),
             ("ctlctl", "ctl_cono", "ctl_conacc"),

=== modified file 'mem/ml1010.py'
--- mem/ml1010.py	2014-12-30 15:37:38 +0000
+++ mem/ml1010.py	2015-02-05 07:50:23 +0000
@@ -1517,6 +1517,7 @@
             jpg = None
         if jpg:
             self.image = ShowImage(self.df.nb.Page7, jpg,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"],
                 msiz=int(self.opts["mf"].bh*.75))
 
     def doPrint(self, widget=None):
@@ -1640,7 +1641,8 @@
         if self.ss.selection[0] == "S":
             self.opts["mf"].closeLoop()
             return
-        form = DrawForm(self.opts["mf"].dbm, self.tnamef)
+        form = DrawForm(self.opts["mf"].dbm, self.tnamef,
+            wrkdir=self.opts["mf"].rcdic["wrkdir"])
         if self.logo and "club_logo" in form.tptp:
             form.tptp["club_logo"][1] = self.logo
         form.tptp["mlm_memno"][1] = self.memno
@@ -1661,6 +1663,7 @@
             self.df.nb.select(6)
             self.df.setWidget(self.df.mstFrame, state="show")
             img = ShowImage(self.df.nb.Page7, jpg,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"],
                 msiz=int(self.opts["mf"].bh*.75), crop=True)
             tmp = os.path.join(self.opts["mf"].rcdic["wrkdir"], "temp.jpg")
             siz = img.roi.size
@@ -1697,7 +1700,8 @@
             prtnam=self.pf.repprt[0][2], splash=False)
         if self.tnameb:
             doprint = False
-            form = DrawForm(self.opts["mf"].dbm, self.tnameb)
+            form = DrawForm(self.opts["mf"].dbm, self.tnameb,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             if "debenture" in form.tptp:
                 # Debentures
                 debs = []

=== modified file 'mem/ml2010.py'
--- mem/ml2010.py	2014-12-30 15:37:38 +0000
+++ mem/ml2010.py	2015-01-20 08:02:24 +0000
@@ -197,6 +197,8 @@
             return "Invalid Date, Not in Financial Period"
         if w > mthendDate(self.bh.curdt * 100):
             return "Invalid Date, After Batch Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):

=== modified file 'mem/ml2020.py'
--- mem/ml2020.py	2014-12-30 15:37:38 +0000
+++ mem/ml2020.py	2015-01-20 08:02:54 +0000
@@ -149,11 +149,9 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
-        if self.bh.multi == "Y":
-            self.curdt = self.trndat / 100
-        else:
-            self.curdt = self.bh.curdt
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):
         self.trnamt = w

=== modified file 'mem/ml3010.py'
--- mem/ml3010.py	2014-12-30 15:37:38 +0000
+++ mem/ml3010.py	2015-01-27 16:33:55 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %43s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.memtrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -144,16 +146,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'mem/ml3020.py'
--- mem/ml3020.py	2014-12-30 15:37:38 +0000
+++ mem/ml3020.py	2015-01-27 14:45:50 +0000
@@ -219,8 +219,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -261,11 +261,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -304,14 +301,14 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.view, prtnam=self.prtnam, mail=self.mail)
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.view,
+                prtnam=self.prtnam, mail=self.mail)
 
     def getValues(self, data):
         memno = CCD(data[0], "UI", 6)

=== modified file 'mem/ml3030.py'
--- mem/ml3030.py	2014-12-30 15:37:38 +0000
+++ mem/ml3030.py	2015-01-27 14:47:58 +0000
@@ -253,8 +253,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -291,11 +291,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -309,16 +306,16 @@
                     vals[5].disp, vals[6].disp, vals[7].disp, vals[8].disp))
                 self.pglin += 1
         p.closeProgress()
-        if self.totsonly == "Y" and can != "yes":
+        if p.quit:
+            return
+        if self.totsonly == "Y":
             self.pageHeading()
+        if self.fpdf.page:
             self.grandTotal()
-        elif self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         acc = CCD(data[0], "UI", 6)

=== modified file 'mem/ml3040.py'
--- mem/ml3040.py	2014-12-30 15:37:38 +0000
+++ mem/ml3040.py	2015-02-05 07:50:55 +0000
@@ -298,7 +298,8 @@
                 if lnk and lnk[1] in nos:
                     recs.remove(acc)
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             if self.email == "N":
@@ -308,8 +309,8 @@
             p = ProgressBar(self.opts["mf"].body, typ=mess, mxs=len(recs),
                 esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 if self.pro:
                     self.doProForma(rec)
@@ -317,7 +318,7 @@
             p.closeProgress()
             if self.pro:
                 self.opts["mf"].dbm.rollbackDbase()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         if not "args" in self.opts:
             self.opts["mf"].closeLoop()
@@ -733,7 +734,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'mem/ml3050.py'
--- mem/ml3050.py	2014-12-30 15:37:38 +0000
+++ mem/ml3050.py	2015-01-27 16:07:01 +0000
@@ -35,10 +35,10 @@
     def mainProcess(self):
         data = []
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
-            mxs=len(self.notes.data))
+            mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -53,7 +53,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Member's Ledger Notes Listing"]
             cols = [

=== modified file 'mem/ml3060.py'
--- mem/ml3060.py	2014-12-30 15:37:38 +0000
+++ mem/ml3060.py	2015-01-27 14:51:41 +0000
@@ -223,8 +223,8 @@
         self.expdatas = []
         lmemno = 0
         for num, dat in enumerate(chg):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -246,8 +246,6 @@
             datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
 
     def printReport(self, chg):
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         p = ProgressBar(self.opts["mf"].body, mxs=len(chg), esc=True)
         self.head = ("%03u %-30s %27s %33s %46s %10s" % (self.opts["conum"],
             self.opts["conam"], "", self.sysdttm, "", __name__))
@@ -255,11 +253,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(chg):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -279,9 +274,13 @@
             lmemno = vals[0].work
             self.pglin += 1
         p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.view, prtnam=self.prtnam, mail=self.mail)
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.view,
+                prtnam=self.prtnam, mail=self.mail)
 
     def getValues(self, data):
         key = data[self.sql.chglog_col.index("chg_key")]

=== modified file 'mem/ml3070.py'
--- mem/ml3070.py	2014-12-30 15:37:38 +0000
+++ mem/ml3070.py	2015-01-27 14:52:38 +0000
@@ -283,12 +283,12 @@
         typ = "Generating the Report ... Please Wait"
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), typ=typ, esc=True)
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             data.append(self.getValues(dat))
         p.closeProgress()
-        if not can == "yes":
+        if not p.quit:
             head = ["Member's Master Report as at %s" % self.repdtd]
             colsh = []
             for n1 in self.cnums:

=== modified file 'mem/ml3080.py'
--- mem/ml3080.py	2014-12-30 15:37:38 +0000
+++ mem/ml3080.py	2015-01-27 16:25:27 +0000
@@ -103,8 +103,8 @@
             mxs=len(recs), esc=True)
         data = []
         for num, rec in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             whr = [
                 ("mlt_cono", "=", self.opts["conum"]),
@@ -133,7 +133,7 @@
             rec.append(bl1)
             data.append(rec)
         p.closeProgress()
-        if can == "yes":
+        if p.quit:
             self.opts["mf"].closeLoop()
             return
         name = __name__
@@ -167,7 +167,7 @@
                         where=newd, ttype="D", dic=dics)
                 if data:
                     p = ProgressBar(self.opts["mf"].body,
-                        typ="Suspending Members", mxs=len(data), esc=False)
+                        typ="Suspending Members", mxs=len(data))
                     for num, rec in enumerate(data):
                         p.displayProgress(num)
                         self.sql.updRec("memmst", cols=["mlm_state",

=== modified file 'mem/ml3110.py'
--- mem/ml3110.py	2014-12-30 15:37:38 +0000
+++ mem/ml3110.py	2015-01-27 14:54:27 +0000
@@ -174,20 +174,18 @@
             self.fpdf.add_page()
             p = ProgressBar(self.opts["mf"].body, mxs=len(rec), esc=True)
             for num, dat in enumerate(rec):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(dat)
             p.closeProgress()
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.view, prtnam=self.prtnam,
-                mail=self.emadd)
+            if self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.view,
+                    prtnam=self.prtnam, mail=self.emadd)
         self.closeProcess()
 
     def doProcess(self, mlm):

=== modified file 'mem/ml6020.py'
--- mem/ml6020.py	2014-12-30 15:37:38 +0000
+++ mem/ml6020.py	2015-01-31 10:52:03 +0000
@@ -169,37 +169,4 @@
         else:
             self.dba.commitDbase()
 
-if __name__ == "__main__":
-    import getopt, sys
-    from TartanClasses import MainFrame
-    from tartanFunctions import loadRcFile
-    try:
-        opts, args = getopt.getopt(sys.argv[1:],"c:d:r:")
-    except:
-        print
-        print "Usage: -c conum -m memno -r rcfile"
-        print
-        sys.exit()
-    coy = 1
-    dte = 0
-    rcf = None
-    for o, v in opts:
-        if o == "-c":
-            coy = int(v)
-        elif o == "-d":
-            dte = int(v)
-        elif o == "-r":
-            rcf = v
-    mf = MainFrame(xdisplay=False)
-    mf.window = None
-    mf.body = None
-    mf.dbm = Dbase(rcdic=loadRcFile(rcfile=rcf))
-    if not mf.dbm.err:
-        mf.dbm.openDbase()
-        if dte:
-            ex = ml6020(**{"mf": mf, "conum": coy, "args": dte})
-        else:
-            ex = ml6020(**{"mf": mf, "conum": coy})
-        mf.dbm.closeDbase()
-
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'mem/ml6030.py'
--- mem/ml6030.py	2014-12-30 15:37:38 +0000
+++ mem/ml6030.py	2015-01-27 14:55:40 +0000
@@ -75,14 +75,11 @@
             self.opts["conum"]), ("mlm_state", "=", "A")], order="mlm_memno")
         if self.opts["mf"].window:
             txt = "Generating %s" % flenam
-            p = ProgressBar(self.opts["mf"].body, typ=txt, mxs=len(recs),
-                esc=True)
+            p = ProgressBar(self.opts["mf"].body, typ=txt, mxs=len(recs))
             can = None
         for num, mem in enumerate(recs):
             if self.opts["mf"].window:
-                can = p.displayProgress(num)
-                if can == "yes":
-                    break
+                p.displayProgress(num)
             memn = mem[self.sql.memmst_col.index("mlm_memno")]
             snam = mem[self.sql.memmst_col.index("mlm_surname")]
             fnam = mem[self.sql.memmst_col.index("mlm_names")]

=== modified file 'mem/mlm010.py'
--- mem/mlm010.py	2014-12-30 15:37:38 +0000
+++ mem/mlm010.py	2015-01-27 16:25:50 +0000
@@ -182,7 +182,7 @@
             "A")])
         if self.ynd:
             p = ProgressBar(self.opts["mf"].body,
-                typ="Checking Member Categories", mxs=len(recs), esc=False)
+                typ="Checking Member Categories", mxs=len(recs))
             for num, acc in enumerate(recs):
                 p.displayProgress(num)
                 self.memno = acc[0]
@@ -220,8 +220,7 @@
                 if ok == "no":
                     self.opts["mf"].closeLoop()
                     return
-        p = ProgressBar(self.opts["mf"].body, typ="F", mxs=len(recs),
-            esc=False)
+        p = ProgressBar(self.opts["mf"].body, typ="F", mxs=len(recs))
         for num, acc in enumerate(recs):
             p.displayProgress(num)
             self.memno = acc[0]

=== modified file 'men/bwlmen.py'
--- men/bwlmen.py	2014-12-09 16:32:44 +0000
+++ men/bwlmen.py	2015-01-01 16:41:17 +0000
@@ -28,6 +28,7 @@
 # Systems
 systems = [
     ["ms", "Control Routines"],
+    ["gl", "General Ledger"],
     ["ml", "Member's Ledger"],
     ["bc", "Bowling Clubs"],
     ["rp", "Reporting Tools"]]
@@ -36,6 +37,7 @@
 msmen = [
     ["MM","mm_sy","System"],
     ["MM","mm_ms","Control"],
+    ["MM","mm_gl","General Ledger"],
     ["MM","mm_ml","Member's Ledger"],
     ["MM","mm_bc","Bowling Clubs"],
     ["MM","mm_uy","Utilities"],
@@ -71,6 +73,49 @@
     ["F","mm_hp","doAbout",0,"About"],
     ["F","mm_hp","doManual",0,"Manual"]]
 
+# General Ledger Routines
+glmen = [
+    ["CM","mm_gl","gl_fm","File Maintenance"],
+    ["CM","mm_gl","gl_dc","Data Capture"],
+    ["CM","mm_gl","gl_rp","Reporting"],
+    ["CM","mm_gl","gl_tb","Toolbox"],
+    ["CM","mm_gl","gl_qy","Interrogation"]]
+glmod = [
+    ["PYNY","gl_fm","gl1010",3,"Masterfile Records"],
+    ["PYNN","gl_fm","glc110",5,"Control Accounts"],
+    ["PYNN","gl_fm","glc210",5,"Inter Company Records"],
+    ["PYYN","gl_fm","gl1020",3,"Standard Journals"],
+    ["PYNN","gl_fm","gl1030",3,"Report Generator"],
+    ["PYYN","gl_fm","gl1040",3,"Detail Records"],
+    ["PYNN","gl_fm","gl1050",3,"Stream Records"],
+    ["PYNN","gl_fm","gl1060",3,"Bank Import Control"],
+    ["PYNN","gl_dc","gl2010",2,"Opening Balances",0],
+    ["PYYN","gl_dc","gl2020",2,"Budgets",0],
+    ["PYYY","gl_dc","gl2030",2,"Sales",1],
+    ["PYYY","gl_dc","gl2030",2,"Payments",2],
+    ["PYYY","gl_dc","gl2030",2,"Petty Cash",3],
+    ["PYYY","gl_dc","gl2040",2,"Manual Journals",1],
+    ["PYYY","gl_dc","gl2040",2,"Standard Journals",2],
+    ["PYYY","gl_dc","gl2030",2,"Purchases",5],
+    ["PYYY","gl_dc","gl2030",2,"Receipts",6],
+    ["PYYY","gl_dc","gl2030",2,"Bank Statements",7],
+    ["PYNN","gl_rp","gl3010",1,"Batch Error Listing"],
+    ["PYYN","gl_rp","gl3020",1,"Transaction Audit Trail"],
+    ["PYYN","gl_rp","gl3030",1,"Account Statements"],
+    ["PYYN","gl_rp","gl3040",1,"Trial Balance"],
+    ["PYYN","gl_rp","gl3050",1,"Financial Statements"],
+    ["PYNN","gl_rp","gl3060",1,"Chart of Accounts"],
+    ["PYNN","gl_rp","gl3070",1,"Notes Listing"],
+    ["PYYN","gl_rp","gl3080",1,"Bank Reconciliation"],
+    ["PYNN","gl_rp","gl3090",1,"Imported Bank Statements"],
+    ["PYNN","gl_tb","gl6010",5,"Change Account Numbers"],
+    ["PYNN","gl_tb","gl6020",5,"Copy Masterfile Records"],
+    ["PYYN","gl_tb","gl6030",1,"Integrated Controls Report"],
+    ["PYYN","gl_tb","gl6040",1,"Intercompany Accounts Report"],
+    ["PYNN","gl_tb","gl6050",2,"Initialise Bank Reconciliation"],
+    ["PYYY","gl_qy","gl4010",0,"Interrogation (Normal)"],
+    ["PYYN","gl_qy","gl4020",1,"Interrogation (Financials)"]]
+
 # Member's Ledger
 mlmen = [
     ["CM","mm_ml","ml_fm","File Maintenance"],
@@ -115,7 +160,7 @@
 bcmod = [
     ["PYNY","bc_fm","bcc110",0,"Control Record"],
     ["PYNN","bc_fm","bcc210",0,"Club's Records"],
-    ["PYNN","bc_fm","bc1010",1,"Tabs Maintenance"],
+    ["PYNN","bc_fm","bc1010",0,"Tabs Maintenance"],
     ["PYNN","bc_fm","bc1020",0,"League Formats"],
     ["PYNN","bc_fm","bc1030",0,"Side's Maintenance"],
     ["PYNN","bc_fm","bc1040",0,"Competition Types"],

=== modified file 'men/stdmen.py'
--- men/stdmen.py	2014-12-30 15:37:38 +0000
+++ men/stdmen.py	2015-01-31 12:24:11 +0000
@@ -92,7 +92,8 @@
     ["PNNY","mm_uy","td1010",0,"Telephone Directory"],
     ["PNNN","mm_uy","tp1010",5,"Template Manager"],
     ["F","mm_hp","doAbout",0,"About"],
-    ["F","mm_hp","doManual",0,"Manual"]]
+    ["F","mm_hp","doManual",0,"Reference Manual"],
+    ["F","mm_hp","doQuick",0,"Quick Start Manual"]]
 
 # General Ledger Routines
 glmen = [

=== modified file 'mst/ms0000.py'
--- mst/ms0000.py	2015-01-01 12:48:11 +0000
+++ mst/ms0000.py	2015-02-07 06:31:07 +0000
@@ -37,16 +37,17 @@
     temp = tuple(os.environ["TARVER"].split("."))
     VERSION = (int(temp[0]), int(temp[1]), int(temp[2]))
 else:
-    VERSION = (5, 0, 3)
+    VERSION = (5, 0, 4)
 if __name__ == "__main__":
     # Run Tartan
     try:
-        opts, args = getopt.getopt(sys.argv[1:],
-            "b:c:de:f:ghilm:nop:q:R:r:s:t:u:vx",
+        opts, args = getopt.getopt(
+            sys.argv[1:],
+            "b:c:de:f:ghilm:nop:q:R:r:s:t:u:vxz",
             ["bpwd=", "conum=", "debug", "exclude=", "finper=", "gui", "help",
             "image", "loader", "menu=", "nocheck", "output", "program=",
             "query=", "rcfdir=", "rcfile=", "script=", "sysfle=", "tcode=",
-            "user=", "version", "xdisplay"])
+            "user=", "version", "xdisplay", "zerobar"])
     except:
         opts, args = [("-h", "")], []
     import msc000

=== modified file 'mst/ms1010.py'
--- mst/ms1010.py	2014-12-30 15:37:38 +0000
+++ mst/ms1010.py	2015-02-05 07:33:19 +0000
@@ -276,7 +276,7 @@
             if self.img:
                 self.img.destroyImage()
         else:
-            self.logo = os.path.abspath(w)
+            self.logo = os.path.normpath(w)
             if self.displayLogo(self.logo):
                 return "Invalid Logo Image"
             self.df.loadEntry(frt, pag, p, data=self.logo)
@@ -284,8 +284,12 @@
     def displayLogo(self, logo):
         try:
             if self.img:
-                self.img.destroyImage()
-            self.img = ShowImage(self.df.nb.Page4, logo, msiz=640)
+                try:
+                    self.img.destroyImage()
+                except:
+                    pass
+            self.img = ShowImage(self.df.nb.Page4, logo,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"], msiz=640)
         except:
             return "error"
 

=== modified file 'mst/ms1010_rne.py'
--- mst/ms1010_rne.py	2014-12-30 15:37:38 +0000
+++ mst/ms1010_rne.py	2015-02-05 07:33:58 +0000
@@ -268,7 +268,8 @@
         try:
             if self.img:
                 self.img.destroyImage()
-            self.img = ShowImage(self.df.nb.Page4, logo, msiz=640)
+            self.img = ShowImage(self.df.nb.Page4, logo,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"], msiz=640)
         except:
             return "error"
 

=== modified file 'mst/ms1040.py'
--- mst/ms1040.py	2014-12-30 15:37:38 +0000
+++ mst/ms1040.py	2015-01-30 08:57:13 +0000
@@ -15,6 +15,7 @@
 
 import time
 from TartanClasses import GetCtl, RepPrt, Sql, TartanDialog
+from tartanFunctions import askQuestion
 
 class ms1040:
     def __init__(self, **opts):
@@ -83,7 +84,7 @@
             (("T",0,3,0),"ID1",10,"Date","",
                 "","N",self.doStart,vtr,None,("efld",)),
             (("T",0,4,0),"IUD",6.2,"Rate","",
-                "","N",None,None,None,("efld",)))
+                "","N",self.doRate,None,None,("efld",)))
         but = (
             ("Print",None,self.doPrint,0,("T",0,1),(("T",0,2),("T",0,4))),
             ("Exit",None,self.doExit,1,None,None))
@@ -143,6 +144,13 @@
             if self.doCheckTrn(self.start):
                 return "Transactions Exist For this Starting Date"
 
+    def doRate(self, frt, pag, r, c, p, i, w):
+        if not w:
+            yes = askQuestion(self.opts["mf"].body, "Zero Rate",
+                "Are You Sure That This Rate is Correct?", default="no")
+            if not yes == "yes":
+                return "Invalid Rate"
+
     def doDelete(self):
         if self.doCheckTrn():
             return "Transactions Exist, Not Deleted"

=== modified file 'mst/ms3010.py'
--- mst/ms3010.py	2014-12-30 15:37:38 +0000
+++ mst/ms3010.py	2015-01-27 16:08:34 +0000
@@ -242,10 +242,7 @@
         self.pcat = None
         self.pcode = None
         for n1, dat in enumerate(recs):
-            can = p1.displayProgress(n1)
-            if can == "yes":
-                p1.closeProgress()
-                return
+            p1.displayProgress(n1)
             vals = self.getValues1(dat)
             if not vals:
                 continue
@@ -313,12 +310,7 @@
         self.pcat = None
         self.pcode = None
         for n1, dat in enumerate(recs):
-            can = p1.displayProgress(n1)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
-                break
+            p1.displayProgress(n1)
             vals = self.getValues1(dat)
             if not vals:
                 continue
@@ -380,12 +372,11 @@
             p2.closeProgress()
         p1.closeProgress()
         if self.fpdf.page:
-            if can != "yes":
-                self.doPrintCodeTotal()
-                self.doPrintCatTotal()
-                if self.cat in ("A", "B"):
-                    self.doPrintHeading("S")
-                    self.doPrintSummary()
+            self.doPrintCodeTotal()
+            self.doPrintCatTotal()
+            if self.cat in ("A", "B"):
+                self.doPrintHeading("S")
+                self.doPrintSummary()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")

=== modified file 'mst/msc000.py'
--- mst/msc000.py	2014-12-30 15:37:38 +0000
+++ mst/msc000.py	2015-01-31 08:55:13 +0000
@@ -36,7 +36,8 @@
             ("tcode", None),
             ("user", {}),
             ("version", False),
-            ("xdisplay", True)]
+            ("xdisplay", True),
+            ("zerobar", False)]
         if sys.platform == "win32":
             default.append(("output", True))
         else:
@@ -110,6 +111,8 @@
                 self.version = True
             elif o in ("-x", "--xdisplay"):
                 self.xdisplay = False
+            elif o in ("-z", "--zerobar"):
+                self.zerobar = True
         if self.output:
             # Redirect stdout
             for pid in xrange(1000):
@@ -151,6 +154,7 @@
             -u, --user=             User name and password e.g. name:password
             -v, --version           Display Version Details
             -x, --xdisplay          Do not have a mainframe with -ptarBck
+            -z, --zerobar           Do not have a progressbar
 """
             self.doExit(dbm=False)
         if not self.xdisplay:
@@ -162,7 +166,7 @@
                 print "xdisplay False but no User Name"
                 self.doExit(dbm=False)
         if self.xdisplay and not GUI:
-            print "Tkinter/ttk not Installed or Available"
+            print "Tkinter/ttk not Available or Installed"
             self.doExit(dbm=False)
         if self.version:
             print "Tartan Version: %s" % self.current[1]
@@ -263,7 +267,7 @@
 
 or
 
-email info@tartan.co.za with your current version number and I will reply with full upgrade instructions.""" % self.oldver)
+Email info@tartan.co.za, with your current version number, for assistance.""" % self.oldver)
             self.doExit()
         if not self.nocheck:
             # Check for ctlsys and if missing call msc110
@@ -307,6 +311,8 @@
                         found = True
                         break
             if found:
+                if self.xdisplay:
+                    self.mf.window.deiconify()
                 self.execCommand(mod[0], self.program, mod[4], rtn=self.tcode,
                     menu=False)
             self.doExit()
@@ -375,7 +381,7 @@
         but = (("Quit", None, self.noUser, 1, None, None),)
         self.li = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
             butt=but, tend=((self.endUser, "n"),), txit=(self.noUser,))
-        self.mf.startLoop("userLogin")
+        self.mf.startLoop()
 
     def usrNam(self, frt, pag, r, c, p, i, w):
         self.userReadCheck(w)
@@ -401,7 +407,7 @@
 
     def endUser(self):
         self.li.closeProcess()
-        self.mf.closeLoop("endUser")
+        self.mf.closeLoop()
 
     def userReadCheck(self, user=None, userchk=False, pwd=None, pwdchk=False):
         if not self.db.dbopen:
@@ -546,10 +552,6 @@
     def execCommand(self, typ, prg, tit="", rtn=None, opendb=True, menu=True, password=True):
         if menu:
             self.tarmen.closeMenu()
-        if rtn is None:
-            self.rtn = 0
-        else:
-            self.rtn = rtn
         if not prg == "sysEnd":
             if prg =="tarUpd":
                 vtype = "upd"
@@ -623,13 +625,15 @@
                     text = "%-s for %s (%s)" % (text, self.conam, prg)
             else:
                 text = "%-s for All Companies (%s)" % (text, prg)
-            if not error and typ[3] == "Y":
-                popt["capnm"] = self.user["name"]
-            if not error and prg == "ml1010":
-                popt["level"] = self.user["lvl"]
-            if not error and not rtn is None:
-                popt["rtn"] = rtn
             if not error:
+                if typ[3] == "Y":
+                    popt["capnm"] = self.user["name"]
+                if prg == "ml1010":
+                    popt["level"] = self.user["lvl"]
+                try:
+                    popt["rtn"] = int(rtn)
+                except:
+                    pass
                 if self.xdisplay:
                     self.mf.head.configure(text=text)
                     self.mf.updateStatus("")
@@ -758,7 +762,7 @@
             except:
                 pass
         self.cp.focusField("T", 0, 1)
-        self.mf.startLoop("getCompany")
+        self.mf.startLoop()
 
     def coNum(self, frt, pag, r, c, p, i, w):
         err = self.conoCheck(w)
@@ -793,26 +797,39 @@
 
     def coEnd(self):
         self.cp.closeProcess()
-        self.mf.closeLoop("coEnd")
+        self.mf.closeLoop()
 
     def doRunModule(self, *prg, **popt):
         if self.loader and prg[0] in sys.modules:
             del(sys.modules[prg[0]])
             gc.collect()
         try:
-            logd = [getpass.getuser(), self.user["name"], prg[0], self.rtn]
-            if self.conum:
-                logd.append(self.conum)
-            else:
-                logd.append(0)
-            if self.finper is None:
-                logd.append(0)
-            else:
-                logd.append(self.finper)
-            logd.append(long("%04i%02i%02i%02i%02i%02i"%time.localtime()[:-3]))
-            sql = Sql(self.mf.dbm, "ctllog", prog="msc000")
+            if "rtn" in popt:
+                rtn = popt["rtn"]
+            else:
+                rtn = 0
+            sql = Sql(self.mf.dbm, ["ffield", "ctllog"], prog="msc000",
+                errs=False)
             if not sql.error:
-                sql.insRec("ctllog", data=logd)
+                chk = sql.getRec(tables="ffield", where=[("ff_tabl", "=",
+                    "ctllog")])
+            if not sql.error and len(chk) == 7:
+                if not self.user:
+                    name = "admin"
+                else:
+                    name = self.user["name"]
+                logd = [getpass.getuser(), name, prg[0], rtn]
+                if self.conum:
+                    logd.append(self.conum)
+                else:
+                    logd.append(0)
+                if self.finper is None:
+                    logd.append(0)
+                else:
+                    logd.append(self.finper)
+                logd.append(long(
+                    "%04i%02i%02i%02i%02i%02i"%time.localtime()[:-3]))
+                sql.insRec("ctllog", data=logd, excp=False)
                 self.mf.dbm.commitDbase()
             mod = runModule(prg[0], **popt)
         except:
@@ -833,7 +850,8 @@
         self.sql = Sql(self.db, ["ctlnot", "ctlpwu"], prog="msc000")
         chk = self.sql.getRec(tables="ctlnot", where=[("(", "not_user", "=",
             self.user["name"], "or", "not_auser", "=", self.user["name"],
-            ")"), ("not_adate", "<=", self.cdate), ("not_aflag", "<>", "C")])
+            ")"), ("not_adate", ">", 0), ("not_adate", "<=", self.cdate),
+            ("not_aflag", "<>", "C")])
         if chk:
             ok = askQuestion(self.mf.window, "Notes", "There are Notes "\
                 "Flagged for Action Still Outstanding, do You want to "\
@@ -907,7 +925,7 @@
             self.nf.setWidget(self.nf.B1, "normal")
         else:
             self.nf.focusField("T", 0, 4)
-        self.mf.startLoop("selectNote")
+        self.mf.startLoop()
 
     def doChgFlag(self, frt, pag, r, c, p, i, w):
         self.chgflag = w
@@ -934,7 +952,7 @@
 
     def doNExit(self, widget=None):
         self.nf.closeProcess()
-        self.mf.closeLoop("doNExit")
+        self.mf.closeLoop()
 
     def chgUsr(self):
         self.userLogout()
@@ -966,7 +984,7 @@
         if not self.pwd:
             self.np.skip[self.np.pag].append(1)
             self.np.focusField(self.np.frt, self.np.pag, col=2)
-        self.mf.startLoop("chgPwd")
+        self.mf.startLoop()
 
     def doOldPwd(self, frt, pag, r, c, p, i, pwd):
         if pwd == self.pwd or pwd == base64.decodestring(self.pwd):
@@ -1009,12 +1027,12 @@
         self.user["pwd"] = self.pwd
         self.user["last"] = dte
         self.np.closeProcess()
-        self.mf.closeLoop("doPwdEnd")
+        self.mf.closeLoop()
 
     def doPwdExit(self, widget=None):
         self.new = None
         self.np.closeProcess()
-        self.mf.closeLoop("doPwdExit")
+        self.mf.closeLoop()
 
     def tarUsr(self):
         sys = []
@@ -1047,7 +1065,7 @@
             ("Cancel", None, self.doSysUpdXit, 1, None, None))
         self.su = TartanDialog(self.mf, title=tit, eflds=fld, butt=but,
             tend=None, txit=(self.doSysUpdXit,))
-        self.mf.startLoop("tarUsr")
+        self.mf.startLoop()
 
     def doSysLoc(self, frt, pag, r, c, p, i, w):
         self.updtyp = w
@@ -1129,7 +1147,7 @@
     def doSysUpgrade(self, widget=None):
         self.su.closeProcess()
         self.mf.updateStatus("")
-        self.mf.closeLoop("doSysUpgrade")
+        self.mf.closeLoop()
         ScrollText(scrn=self.mf.body, mess="""
                         Performing the Upgrade
 
@@ -1178,7 +1196,7 @@
 
     def doSysUpdXit(self, widget=None):
         self.su.closeProcess()
-        self.mf.closeLoop("doSysUpdXit")
+        self.mf.closeLoop()
 
     def tarUpd(self, dbcreate=False):
         if not dbcreate:
@@ -1199,12 +1217,12 @@
             "mf": self.mf,
             "bar": True,
             "cln": True,
-            "fmt": False,
             "pth": os.path.join(self.mf.rcdic["prgdir"], "csv"),
             "pwd": self.mf.rcdic["dbpwd"],
             "rcf": self.rcfile,
             "sys": self.sysfle,
             "tab": [],
+            "upd": False,
             "usr": self.mf.rcdic["dbuser"],
             "ver": self.current[1]}
         self.doRunModule("tb1020", **popt)
@@ -1287,23 +1305,23 @@
         cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarBck",
             passwd=self.bpwd)
         if cf.flag == "ok":
-            if not self.program:
-                try:
-                    sql = Sql(self.db, ["ctlmst", "ctlsys"], prog="msc000",
-                        errs=False)
-                    if sql.error:
-                        raise Exception
-                    csys = sql.getRec(tables="ctlsys", cols=["sys_budays",
-                        "sys_msvr", "sys_mprt", "sys_msec", "sys_maut",
-                        "sys_mnam", "sys_mpwd"], limit=1,
-                        excp=True)
-                    if csys == "Exception":
-                        raise Exception
-                except:
-                    csys = None
-            else:
+            try:
+                sql = Sql(self.db, ["ctlmst", "ctlsys"], prog="msc000",
+                    errs=False)
+                if sql.error:
+                    raise Exception
+                csys = sql.getRec(tables="ctlsys", cols=["sys_budays",
+                    "sys_msvr", "sys_mprt", "sys_msec", "sys_maut",
+                    "sys_mnam", "sys_mpwd"], limit=1,
+                    excp=self.xdisplay)
+                if csys == "Exception":
+                    raise Exception
+            except:
                 csys = None
-            TarBckRes(self.mf, mode="B", csys=csys)
+            if self.zerobar:
+                TarBckRes(self.mf, mode="B", csys=csys, bar=False)
+            else:
+                TarBckRes(self.mf, mode="B", csys=csys)
 
     def tarRes(self):
         cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarRes",
@@ -1331,6 +1349,13 @@
 
     def doManual(self):
         doc = os.path.join(self.rcdic["prgdir"], "doc", "Manual.pdf")
+        self.doBrowser(doc)
+
+    def doQuick(self):
+        doc = os.path.join(self.rcdic["prgdir"], "doc", "QuickStart.pdf")
+        self.doBrowser(doc)
+
+    def doBrowser(self, doc):
         if os.path.exists(doc):
             exe, cmd = parsePrg(self.rcdic["vwr"])
             cmd.append(doc)

=== modified file 'rca/rc3010.py'
--- rca/rc3010.py	2014-12-30 15:37:38 +0000
+++ rca/rc3010.py	2015-01-27 16:34:47 +0000
@@ -165,7 +165,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if self.totsonly == "Y":
             self.head = ("%03u %-30s %33s %6s" % \
                 (self.opts["conum"], self.opts["conam"], self.sysdttm,
@@ -191,6 +191,8 @@
         self.pglin = 999
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             acno = CCD(dat[self.col.index("rot_acno")], "NA", 7)
             name = CCD(dat[self.col.index("rom_name")], "NA", 30)
             trtp = CCD(dat[self.col.index("rot_type")], "UI", 2)
@@ -234,7 +236,7 @@
             self.gvt[trtp.work -1] = float(ASD(self.gvt[trtp.work -1]) + \
                 ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             self.batchTotal()
             self.typeTotal()
             self.grandTotal()
@@ -244,9 +246,6 @@
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
                 head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'rca/rc3020.py'
--- rca/rc3020.py	2014-12-30 15:37:38 +0000
+++ rca/rc3020.py	2015-01-27 14:56:13 +0000
@@ -189,11 +189,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             owner = CCD(dat[self.col.index("rtu_owner")], "NA", 7)
             code = CCD(dat[self.col.index("rtu_code")], "NA", 7)
@@ -242,17 +239,16 @@
             self.gvt[trtp.work -1] = float(ASD(self.gvt[trtp.work -1]) + \
                 ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'rca/rc3030.py'
--- rca/rc3030.py	2014-12-30 15:37:38 +0000
+++ rca/rc3030.py	2015-01-27 14:57:00 +0000
@@ -90,11 +90,8 @@
         self.pgnum = 0
         self.pglin = 999
         for x in xrange(0, len(recs)):
-            can = p.displayProgress(x)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(x)
+            if p.quit:
                 break
             acc = CCD(recs[x][0], "NA", 7)
             name = CCD(recs[x][1], "NA", 30)
@@ -112,18 +109,18 @@
                 self.pglin += 1
             self.tots = float(ASD(self.tots) + ASD(bal.work))
         p.closeProgress()
-        if self.totsonly == "Y" and can != "yes":
+        if p.quit:
+            return
+        if self.totsonly == "Y":
             self.pageHeading()
+        if self.fpdf.page:
             self.grandTotal()
-        elif self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'rca/rc3040.py'
--- rca/rc3040.py	2014-12-30 15:37:38 +0000
+++ rca/rc3040.py	2015-01-27 14:57:41 +0000
@@ -117,10 +117,8 @@
         con = self.sql.rcacon_col
         self.tots = [0, 0, 0, 0, 0, 0]
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                self.fpdf.drawText()
-                self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             ownr = CCD(dat[con.index("rcc_owner")], "NA", 7)
             code = CCD(dat[con.index("rcc_code")], "NA", 7)
@@ -228,7 +226,7 @@
         self.fpdf.drawText("%27s %-30s %29s %-13s %-13s %-13s %-13s %-13s "\
             "%-13s" % ("", "Grand Totals", "", t0, t1, t2, t3, t4, t5))
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")

=== modified file 'rca/rc3050.py'
--- rca/rc3050.py	2014-12-30 15:37:38 +0000
+++ rca/rc3050.py	2015-02-05 07:51:34 +0000
@@ -34,7 +34,8 @@
                     ("rom_cono", "=", self.opts["conum"]),
                     ("rom_acno", "=", self.acc)]
                 rom = self.sql.getRec(tables="rcaowm", where=whr, limit=1)
-                self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+                self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                    wrkdir=self.opts["mf"].rcdic["wrkdir"])
                 self.doLoadStatic()
                 self.form.doNewDetail()
                 self.doProcess(rom)
@@ -145,17 +146,18 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         self.opts["mf"].closeLoop()
 
@@ -267,7 +269,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'rca/rc3060.py'
--- rca/rc3060.py	2014-12-30 15:37:38 +0000
+++ rca/rc3060.py	2015-02-05 07:51:58 +0000
@@ -36,7 +36,8 @@
                     ("rtn_code", "=", self.prm),
                     ("rtn_acno", "=", self.acc)]
                 rtn = self.sql.getRec(tables="rcatnm", where=whr, limit=1)
-                self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+                self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                    wrkdir=self.opts["mf"].rcdic["wrkdir"])
                 self.doLoadStatic()
                 self.form.doNewDetail()
                 self.doProcess(rtn)
@@ -147,17 +148,18 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         self.opts["mf"].closeLoop()
 
@@ -320,7 +322,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'rca/rc3070.py'
--- rca/rc3070.py	2014-12-30 15:37:38 +0000
+++ rca/rc3070.py	2015-01-27 14:58:53 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             if len(dat[2].strip()) > 7:
                 continue
@@ -61,7 +61,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Rental's Masterfile Notes Listing"]
             cols = [

=== modified file 'rca/rc3080.py'
--- rca/rc3080.py	2014-12-30 15:37:38 +0000
+++ rca/rc3080.py	2015-01-27 14:59:09 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             if len(dat[2].strip()) < 14:
                 continue
@@ -64,7 +64,7 @@
                 else:
                     data.append(["", "", "", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Rental's Masterfile Notes Listing"]
             cols = [

=== modified file 'rca/rc3090.py'
--- rca/rc3090.py	2014-12-30 15:37:38 +0000
+++ rca/rc3090.py	2015-01-27 14:59:26 +0000
@@ -68,8 +68,8 @@
         con = self.sql.rcacon_col
         data = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             owner = dat[con.index("rcc_owner")]
             code = dat[con.index("rcc_code")]
@@ -93,7 +93,7 @@
             if dept:
                 data.append([code, acno, name, dept, intr, balance, admn])
         p.closeProgress()
-        if not can == "yes":
+        if not p.quit:
             head = ["Rental Tenants Outstanding Deposits as at %s" %
                 self.datep]
             cols = [

=== modified file 'rca/rcc220.py'
--- rca/rcc220.py	2014-12-30 15:37:38 +0000
+++ rca/rcc220.py	2015-01-27 14:59:54 +0000
@@ -64,8 +64,8 @@
         self.pglin = 999
         old_sys = recs[0][0]
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 if self.fpdf.page:
                     self.fpdf.drawText()
                     self.fpdf.drawText("Print Job ABORTED")
@@ -94,13 +94,13 @@
                 fmt.append("")
             self.pglin += 1
         p.closeProgress()
-        old_sys = self.sys.work
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
-            ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
-            view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
+                ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
+                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'rtl/rt2010.py'
--- rtl/rt2010.py	2014-12-30 15:37:38 +0000
+++ rtl/rt2010.py	2015-01-20 08:20:58 +0000
@@ -212,6 +212,8 @@
     def doTrnDat(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.trndat = w
 
     def doTrnAmt(self, frt, pag, r, c, p, i, w):

=== modified file 'rtl/rt3010.py'
--- rtl/rt3010.py	2014-12-30 15:37:38 +0000
+++ rtl/rt3010.py	2015-01-27 16:35:14 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %55s %10s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.rtltrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -149,16 +151,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'rtl/rt3020.py'
--- rtl/rt3020.py	2014-12-30 15:37:38 +0000
+++ rtl/rt3020.py	2015-01-27 15:00:28 +0000
@@ -190,8 +190,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -232,11 +232,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -276,15 +273,14 @@
             self.tcrs = float(ASD(self.tcrs) + ASD(credit.work))
             self.tvat = float(ASD(self.tvat) + ASD(taxamt.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         code = CCD(data[0], "NA", 7)

=== modified file 'rtl/rt3030.py'
--- rtl/rt3030.py	2014-12-30 15:37:38 +0000
+++ rtl/rt3030.py	2015-01-27 15:21:25 +0000
@@ -125,10 +125,8 @@
         con = self.sql.rtlcon_col
         self.tots = [0, 0, 0, 0, 0]
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                self.fpdf.drawText()
-                self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             code = CCD(dat[con.index("rtc_code")], "NA", 7)
             acno = CCD(dat[con.index("rtc_acno")], "NA", 7)
@@ -224,7 +222,7 @@
         self.fpdf.drawText("%19s %-30s %29s %-13s %-13s %-13s %-13s %-13s" % \
             ("", "Grand Totals", "", t0, t1, t2, t3, t4))
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")

=== modified file 'rtl/rt3040.py'
--- rtl/rt3040.py	2014-12-30 15:37:38 +0000
+++ rtl/rt3040.py	2015-02-05 07:52:16 +0000
@@ -128,17 +128,18 @@
                 showError(self.opts["mf"].body, "Error",
                     "No Accounts Selected")
         if recs:
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
             p.closeProgress()
-            if self.email == "N" and self.form.page:
+            if self.email == "N" and self.form.page and not p.quit:
                 self.doPrint()
         self.opts["mf"].closeLoop()
 
@@ -355,7 +356,8 @@
             head=self.tit, view=view, prtnam=self.prtnam, mail=mail,
             printm=self.printm)
         if self.email == "Y":
-            self.form = DrawForm(self.opts["mf"].dbm, self.tname)
+            self.form = DrawForm(self.opts["mf"].dbm, self.tname,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
             self.doLoadStatic()
             self.form.doNewDetail()
 

=== modified file 'rtl/rt3050.py'
--- rtl/rt3050.py	2014-12-30 15:37:38 +0000
+++ rtl/rt3050.py	2015-01-27 15:22:05 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -59,7 +59,7 @@
                 else:
                     data.append(["", "", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Rentals's Masterfile Notes Listing"]
             cols = [

=== modified file 'scp/sc1010.py'
--- scp/sc1010.py	2014-12-30 15:37:38 +0000
+++ scp/sc1010.py	2015-01-27 16:25:59 +0000
@@ -191,7 +191,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="scpmem", impskp=["scm_cono"])
         sp = ProgressBar(self.opts["mf"].body,
-            typ="Importing Member's Records", mxs=len(fi.impdat), esc=False)
+            typ="Importing Member's Records", mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'scp/sc2010.py'
--- scp/sc2010.py	2014-12-30 15:37:38 +0000
+++ scp/sc2010.py	2015-02-05 07:34:16 +0000
@@ -192,7 +192,8 @@
         try:
             if self.img:
                 self.img.destroyImage()
-            self.img = ShowImage(self.df.topPage0, self.logo, msiz=100)
+            self.img = ShowImage(self.df.topPage0, self.logo,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"], msiz=100)
         except:
             pass
 

=== modified file 'scp/sc2030.py'
--- scp/sc2030.py	2014-12-30 15:37:38 +0000
+++ scp/sc2030.py	2015-01-27 16:26:09 +0000
@@ -238,7 +238,7 @@
             impdlg=impdlg)
         if fi.impdat:
             sp = ProgressBar(self.opts["mf"].body, typ="Importing Results",
-                mxs=len(fi.impdat), esc=False)
+                mxs=len(fi.impdat))
             err = None
             for num, line in enumerate(fi.impdat):
                 sp.displayProgress(num)

=== modified file 'scp/scc210.py'
--- scp/scc210.py	2014-12-30 15:37:38 +0000
+++ scp/scc210.py	2015-01-27 16:26:19 +0000
@@ -90,7 +90,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         fi = FileImport(self.opts["mf"], imptab="scpclb", impskp=[])
         sp = ProgressBar(self.opts["mf"].body, typ="Importing Club Records",
-            mxs=len(fi.impdat), esc=False)
+            mxs=len(fi.impdat))
         err = None
         for num, line in enumerate(fi.impdat):
             sp.displayProgress(num)

=== modified file 'sls/si3010.py'
--- sls/si3010.py	2014-12-30 15:37:38 +0000
+++ sls/si3010.py	2015-01-27 15:27:03 +0000
@@ -125,12 +125,6 @@
             self.exportReport(recs)
         else:
             self.printReport(recs)
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
-                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def exportReport(self, recs):
@@ -151,8 +145,8 @@
             ("SD", 13.2), ("SD", 13.2), ("SD", 13.2)]
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             if not self.getValues(dat):
@@ -170,7 +164,7 @@
             datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
 
     def printReport(self, recs):
-        self.p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if self.rtype == "L":
             self.head = ("%03u %-30s %115s %10s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, __name__))
@@ -181,11 +175,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = self.p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             if not self.getValues(dat):
                 continue
@@ -200,7 +191,14 @@
             self.fpdf.drawText()
             self.fpdf.drawText("%106s %s %s %s %s" % ("", t1.disp, t2.disp,
                 t3.disp, t4.disp))
-        self.p.closeProgress()
+        p.closeProgress()
+        if not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         col = self.sql.slsiv1_col

=== modified file 'sls/si3020.py'
--- sls/si3020.py	2014-12-30 15:37:38 +0000
+++ sls/si3020.py	2015-01-27 15:28:11 +0000
@@ -138,8 +138,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -164,11 +164,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -191,16 +188,15 @@
             self.pglin += 1
             lstgrp = self.grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.groupTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         self.grp = CCD(data[0], "UA", 3)

=== modified file 'sls/si3030.py'
--- sls/si3030.py	2014-12-30 15:37:38 +0000
+++ sls/si3030.py	2015-01-27 15:28:40 +0000
@@ -126,11 +126,8 @@
         self.pgnum = 0
         self.pglin = 999
         for x in xrange(0, len(recs)):
-            can = p.displayProgress(x)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(x)
+            if p.quit:
                 break
             self.grp = CCD(recs[x][0], "UA", 3)
             code = CCD(recs[x][1], "NA", 20)
@@ -177,16 +174,15 @@
             self.pglin += 1
             lstgrp = self.grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.groupTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'sls/si3040.py'
--- sls/si3040.py	2014-12-30 15:37:38 +0000
+++ sls/si3040.py	2015-01-27 15:31:59 +0000
@@ -184,8 +184,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -211,11 +211,8 @@
         self.pglin = 999
         self.lstgrp = ""
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -228,10 +225,10 @@
             self.pglin += 1
             self.lstgrp = self.grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                self.grandTotal()
+        if not self.fpdf.page or p.quit:
+            return
+        self.groupTotal()
+        self.grandTotal()
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
             head=self.tit, view=self.df.repprt[0][1],

=== modified file 'sls/si3050.py'
--- sls/si3050.py	2014-12-30 15:37:38 +0000
+++ sls/si3050.py	2015-01-27 15:36:20 +0000
@@ -193,11 +193,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             self.chn = CCD(dat[8], "UI", 3)
             self.drs = CCD(dat[9], "UA", 7)
@@ -238,16 +235,15 @@
             old_chn = self.chn.work
             old_drs = self.drs.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.drsTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.drsTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'sls/si3060.py'
--- sls/si3060.py	2014-12-30 15:37:38 +0000
+++ sls/si3060.py	2015-01-27 15:36:51 +0000
@@ -110,11 +110,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             self.rep = CCD(dat[0], "Na", 3)
             grp = CCD(dat[1], "NA", 3)
@@ -148,16 +145,15 @@
             self.gtot[1] = float(ASD(self.gtot[1]) + ASD(cst.work))
             old_rep = self.rep.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.repTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.repTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'sls/si3070.py'
--- sls/si3070.py	2014-12-30 15:37:38 +0000
+++ sls/si3070.py	2015-01-27 15:37:34 +0000
@@ -109,11 +109,8 @@
         self.pgnum = 0
         self.pglin = 999
         for x in xrange(0, len(recs)):
-            can = p.displayProgress(x)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(x)
+            if p.quit:
                 break
             rep = CCD(recs[x][0], "Na", 3)
             name = CCD(recs[x][1], "NA", 30)
@@ -162,17 +159,16 @@
             self.fpdf.underLine(txt=self.head)
             self.pglin += 4
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        CreateChart(self.opts["mf"], self.opts["conum"], self.opts["conam"],
-            [self.start, self.end], [self.tit, "Values"], None, self.mchart)
+        if self.fpdf.page and not p.quit:
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            CreateChart(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+                [self.start, self.end], [self.tit, "Values"], None, self.mchart)
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'std/TartanClasses.py'
--- std/TartanClasses.py	2015-01-01 12:48:11 +0000
+++ std/TartanClasses.py	2015-02-05 07:55:16 +0000
@@ -18,7 +18,8 @@
 # Then insert the following line before the function to profile
 #   @profile(entries=40, immediate=True)
 import base64, calendar, copy, csv, datetime, functools, getpass, glob, gzip
-import os, re, shutil, sys, tarfile, textwrap, time, urllib2, webbrowser
+import inspect, os, re, shutil, sys, tarfile, textwrap, threading, time
+import urllib2, webbrowser
 #========================================================
 # TARTAN Standard Functions and Variables e.g. showError
 #========================================================
@@ -27,7 +28,13 @@
 #========================================================
 # PyFPDF
 #========================================================
-from fpdf import FPDF
+try:
+    import fpdf
+    if not fpdf.Image:
+        raise Exception
+except:
+    print "Missing fpdf or python-imaging module"
+    sys.exit()
 #========================================================
 # Excel import and export modules
 #========================================================
@@ -84,8 +91,10 @@
 
     # Stock images and icons and others
     tkinter_umlauts=[
-        "odiaeresis", "adiaeresis", "udiaeresis", "Odiaeresis",
-        "Adiaeresis", "Udiaeresis", "ssharp"]
+        "adiaeresis", "Adiaeresis",
+        "odiaeresis", "Odiaeresis",
+        "udiaeresis", "Udiaeresis",
+        "ssharp"]
     imgdir = os.path.join(getPrgPath(), "img")
     images = {}
     for img in glob.glob(os.path.join(imgdir, "*.png")):
@@ -108,6 +117,7 @@
         "deposits": os.path.join(imgdir, "print.png"),
         "doabout": os.path.join(imgdir, "about.png"),
         "domanual": os.path.join(imgdir, "info.png"),
+        "doquick": os.path.join(imgdir, "info.png"),
         "drsmaint": os.path.join(imgdir, "edit.png"),
         "drsquery": os.path.join(imgdir, "question.png"),
         "edi": os.path.join(imgdir, "import.png"),
@@ -334,19 +344,19 @@
             self.setLabel(kwargs["text"], kwargs["underline"], img=img)
             if cmd:
                 self.cmd = cmd
-                self.bind("<Return>", self.execCmd)
-                self.bind("<KP_Enter>", self.execCmd)
-                self.bind("<ButtonRelease-1>", self.execCmd)
+                self.bind("<Return>", self.execButCmd)
+                self.bind("<KP_Enter>", self.execButCmd)
+                self.bind("<ButtonRelease-1>", self.execButCmd)
                 if "underline" in kwargs and not kwargs["underline"] == -1:
                     self.bind("<Alt_L><%s>" % kwargs["text"]
-                        [kwargs["underline"]].upper(), self.execCmd)
+                        [kwargs["underline"]].upper(), self.execButCmd)
                     self.bind("<Alt_L><%s>" % kwargs["text"]
-                        [kwargs["underline"]].lower(), self.execCmd)
+                        [kwargs["underline"]].lower(), self.execButCmd)
                     toplevel = parent.winfo_toplevel()
                     toplevel.bind("<Alt_L><%s>" % kwargs["text"]
-                        [kwargs["underline"]].upper(), self.execCmd)
+                        [kwargs["underline"]].upper(), self.execButCmd)
                     toplevel.bind("<Alt_L><%s>" % kwargs["text"]
-                        [kwargs["underline"]].lower(), self.execCmd)
+                        [kwargs["underline"]].lower(), self.execButCmd)
 
         def setLabel(self, text, underline=-1, img=True):
             self.configure(text=text, underline=underline)
@@ -372,7 +382,7 @@
             except:
                 pass
 
-        def execCmd(self, event):
+        def execButCmd(self, event):
             try:
                 self.event_generate("<Leave>")
                 self.update_idletasks()
@@ -670,19 +680,20 @@
                     return
                 self.lf = tk.Toplevel(self, bd=2, relief="raised")
                 self.lf.overrideredirect(1)
-                yScroll = tk.Scrollbar(self.lf, orient="vertical")
-                yScroll.grid(row=0, column=1, sticky="ns")
-                height = len(words)
-                if height > 10:
-                    height = 10
-                self.lb = tk.Listbox(self.lf, height=height,
-                    yscrollcommand=yScroll.set)
+                if len(words) > 10:
+                    yScroll = tk.Scrollbar(self.lf, orient="vertical")
+                    yScroll.grid(row=0, column=1, sticky="ns")
+                    self.lb = tk.Listbox(self.lf, width=self.cget("width"),
+                        height=10, yscrollcommand=yScroll.set)
+                    yScroll["command"] = self.lb.yview
+                else:
+                    self.lb = tk.Listbox(self.lf, width=self.cget("width"),
+                        height=len(words))
                 self.lb.bind("<Double-Button-1>", self.list_aut)
                 self.lb.bind("<KP_Enter>", self.list_aut)
                 self.lb.bind("<Return>", self.list_aut)
                 self.lb.bind("<Escape>", self.escape)
                 self.lb.grid(row=0, column=0, sticky="nsew")
-                yScroll["command"] = self.lb.yview
                 self.lf.wm_geometry("+%d+%d" % (self.winfo_rootx(),
                     self.winfo_rooty()+self.winfo_height()))
                 self.lb.delete(0, "end")
@@ -756,18 +767,15 @@
             self.event_generate("<Leave>")
 
     class MyMessageBox:
-        def __init__(self, parent, dtype, title, mess, butt=None, dflt=None):
+        def __init__(self, parent, dtype, title, mess, butt=None, dflt=None, plc=True):
             style = ttk.Style()
             style.configure("MFrame.TFrame", background="black")
-            self.parent = parent
-            if not self.parent:
-                self.window = MkWindow(tk=True, decor=False).newwin
-                self.frame = MyFrame(self.window, borderwidth=4,
-                    relief="ridge", style="MFrame.TFrame")
-            else:
-                self.frame = MyFrame(parent, borderwidth=4,
-                    relief="ridge", style="MFrame.TFrame")
-            self.frame.place(anchor="center", relx=0.5, rely=0.5)
+            self.frame = MyFrame(parent, bg="black", borderwidth=5,
+                relief="ridge", style="MFrame.TFrame")
+            if plc:
+                #self.frame.place(x=plc[0], y=plc[1])
+            #else:
+                self.frame.place(anchor="center", relx=0.5, rely=0.5)
             # Save and clear toplevel bindings
             self.topbinds = unbindAllWidgets(self.frame)
             tit = MyLabel(self.frame, text=title, anchor="center",
@@ -821,8 +829,9 @@
             if self.frame.winfo_toplevel().state() == "withdrawn":
                 self.frame.winfo_toplevel().deiconify()
             self.frame.update_idletasks()
-            self.frame.grab_set()
-            self.frame.mainloop()
+            if plc:
+                self.frame.grab_set()
+                self.frame.mainloop()
 
         def choice(self, answer=None):
             self.answer = answer
@@ -834,8 +843,6 @@
                 self.frame.winfo_toplevel().bind(bind[0], bind[1])
             self.frame.destroy()
             self.frame.update()
-            if not self.parent:
-                self.window.destroy()
             self.frame.quit()
 
         def navigate(self, event, num):
@@ -865,13 +872,21 @@
                 self.configure(command=ecmd)
 
         def goLeft(self, event):
-            if self.focus_get() == self.parent.winfo_children()[0]:
+            childs = self.parent.winfo_children()
+            for x in range(0, len(childs)):
+                if childs[x].winfo_class() == "TRadiobutton":
+                    break
+            if self.focus_get() == childs[x]:
                 return
             self.tk_focusPrev().focus_set()
             return "break"
 
         def goRight(self, event):
-            if self.focus_get() == self.parent.winfo_children()[-1]:
+            childs = self.parent.winfo_children()
+            for x in range(len(childs) - 1, -1, -1):
+                if childs[x].winfo_class() == "TRadiobutton":
+                    break
+            if self.focus_get() == childs[x]:
                 return
             self.tk_focusNext().focus_set()
             return "break"
@@ -891,11 +906,11 @@
             cut_pasteMenu(event)
 
     class MyTextView_v(tk.Text):
-        def __init__(self, parent, bg=None, fg=None, **kwargs):
+        def __init__(self, parent, bg=None, fg=None, bd=1, **kwargs):
             tk.Text.__init__(self, parent, **kwargs)
             self.configure(bg="white", fg="black", selectforeground="black",
                 selectbackground="light gray", highlightbackground="gray",
-                bd=1, relief="flat")
+                bd=bd, relief="flat")
             self.bind("<Key>", self.checkHeight)
             self.bind("<FocusIn>", self.checkHeight)
             self.bind("<Button-3><ButtonRelease-3>", self.show_menu)
@@ -923,11 +938,11 @@
             event.widget["height"] = len(line)
 
     class MyTextView_V(tk.Text):
-        def __init__(self, parent, bg=None, fg=None, **kwargs):
+        def __init__(self, parent, bg=None, fg=None, bd=1, **kwargs):
             tk.Text.__init__(self, parent, **kwargs)
             self.configure(bg="white", fg="black", selectforeground="black",
                 selectbackground="light gray", highlightbackground="gray",
-                bd=1, relief="flat")
+                bd=bd, relief="flat")
             self.bind("<Button-3><ButtonRelease-3>", self.show_menu)
             self.event_add("<<mytxtvV>>", "<F1>", "<F5>", "<F9>", "<Escape>")
 
@@ -954,225 +969,251 @@
             [(text, ('SD',10.2)), or (text, 10), ..... ]]
         data = [
             (((label, tag) (label, tag) (label, tag)),
-            ((text, tag), (text, tag), (text, tag), (text, tag)),)]
+            ((text, tag, span), (text, tag), (text, tag), (text, tag)),)]
         butt = A list of additional buttons e.g. [("hello", cmd)]
-        bcmd = A browse command
-        hcmd = A hover command
+        cmds = A list of bind commands
         font = (family, size)
         loop = Mainloop, True or False
+        mess = The SplashScreen message
+        minc = Minimum columns to show
         """
         def __init__(self, **opts):
             if not "chgt" in opts:
                 opts["chgt"] = 1
-            if not "splash" in opts:
-                opts["splash"] = False
             if not "loop" in opts:
                 opts["loop"] = True
             self.opts = opts
             self.drawGrid()
             if self.opts["loop"]:
-                self.window.mainloop()
+                self.opts["mf"].startLoop(self.__name__)
 
         def drawGrid(self):
-            # Splash screen
-            if self.opts["splash"]:
-                sp = SplashScreen(None, self.opts["splash"])
+            if "mess" in self.opts:
+                self.sp = SplashScreen(None, self.opts["mess"])
             # Draw main window
-            self.quit = False
             self.window = MkWindow(modal=True, remov=True).newwin
             ww = int(self.window.winfo_screenwidth())
             wh = int(self.window.winfo_screenheight())
-            try:
-                self.window.wm_state("zoomed")
-            except:
-                geom_string = "%dx%d+0+0" % (ww, wh)
-                self.window.wm_geometry(geom_string)
             self.window.maxsize(width=ww, height=wh)
             # Style and fonts
             style = ttk.Style()
             style.configure("TScrollbar", arrowsize=30)
             if "font" in self.opts:
                 ft = self.opts["font"][0]
-                self.fs = self.opts["font"][1]
+                fs = self.opts["font"][1]
             elif "mf" in self.opts:
                 ft = self.opts["mf"].rcdic["dft"]
-                self.fs = self.opts["mf"].rcdic["mfs"]
+                fs = self.opts["mf"].rcdic["mfs"]
             else:
                 ft = "Arial"
-                self.fs = 14
-            # pixbuf size limitation of 32767
-            if len(self.opts["cols"]) == 1:
-                cqty = len(self.opts["cols"][0])
-            else:
-                cqty = len(self.opts["cols"][1])
-            size = 32768
-            while size > 32767:
-                font = tkFont.Font(font=(ft, self.fs))
-                bold = tkFont.Font(font=(ft, self.fs, "bold"))
-                cell = MyLabel(None, borderwidth=0, width=10, font=bold)
-                size = cqty * (cell.winfo_reqwidth() + 2)
-                self.fs -= 1
+                fs = 14
+            twidth = ww + 1
+            while twidth > ww:
+                font = tkFont.Font(font=(ft, fs))
+                bold = tkFont.Font(font=(ft, fs, "bold"))
+                default_font = tkFont.nametofont("TkDefaultFont")
+                default_font.configure(size=fs)
+                # Calculate label widths
+                lwdth = [1, []]
+                for lab in self.opts["labs"]:
+                    txt = "X" * int(lab[1])
+                    lab = MyLabel(self.window, text=txt, font=bold)
+                    self.window.update_idletasks()
+                    lwdth[0] += lab.winfo_reqwidth()
+                    lwdth[1].append(lab.winfo_reqwidth())
+                    lab.destroy()
+                # Calculate column width and height
+                col = self.opts["cols"][len(self.opts["cols"])-1][0]
+                if type(col[1]) in (list, tuple):
+                    tw = int(col[1][1])
+                else:
+                    tw = int(col[1])
+                txt = "X" * tw
+                for _ in range(1, self.opts["chgt"]):
+                    txt += "\n"
+                lab = MyLabel(self.window, text=txt, font=bold)
+                self.window.update_idletasks()
+                cw, ch = (lab.winfo_reqwidth(), lab.winfo_reqheight())
+                pw = cw / tw
+                lab.destroy()
+                if "minc" in self.opts:
+                    twidth = lwdth[0] + (cw * self.opts["minc"])
+                else:
+                    twidth = ww
+                fs -= 1
+                if fs < 6:
+                    break
             # Draw widgets
             # Main Heading
+            if type(self.opts["titl"]) in (list, tuple):
+                txt = self.opts["titl"][0]
+                for t in self.opts["titl"][1:]:
+                    txt = "%s\n%s" % (txt, t)
+            else:
+                txt = self.opts["titl"]
             lb1 = MyLabel(self.window, justify="center", anchor="center",
-                padding=2, font=bold)
+                padding=2, font=bold, text=txt)
             lb1.pack(fill="x")
-            # Main frame
-            mframe = MyFrame(self.window)
-            # Left frame
-            lframe = MyFrame(mframe)
+            # Container frame
+            self.cframe = MyFrame(self.window)
+            # Left frames
+            lframe = MyFrame(self.cframe)
             lframe.pack(fill="y", side="left")
-            lframe.grid_rowconfigure(0, weight=1)
-            # Right frame
-            rframe = MyFrame(mframe)
-            rframe.pack(fill="both", expand="yes", side="left")
-            rframe.grid_rowconfigure(0, weight=1)
-            # Scollbars
             spc = ttk.Scrollbar(lframe, orient="horizontal")
             spc.pack(fill="x", side="bottom", expand=False)
+            lframeh = MyFrame(lframe)
+            lframeh.pack(fill="x")
+            lframed = MyFrame(lframe)
+            lframed.pack(fill="both", expand="yes")
+            # Right frames
+            rframe = MyFrame(self.cframe)
+            rframe.pack(fill="both", expand="yes", side="left")
             hsb = ttk.Scrollbar(rframe, orient="horizontal",
                 command=self._xview)
             hsb.pack(fill="x", side="bottom", expand=False)
             vsb = ttk.Scrollbar(rframe, orient="vertical",
                 command=self._yview)
             vsb.pack(fill="y", side="right", expand=False)
-            # Label headings frame
-            labh = MyFrame(lframe, bg="black")
-            labh.pack(fill="x", anchor="nw")
-            # Label details frame
-            self.cv1 = tk.Canvas(lframe, bd=0, highlightthickness=0,
-                yscrollcommand=vsb.set)
-            self.cv1.pack(fill="both", expand="yes", side="bottom")
-            labd = MyFrame(self.cv1, bg="black")
-            self.cv1.create_window(0, 0, window=labd, anchor="nw")
-            labd.bind("<Configure>",
-                functools.partial(self.set_scrollregion, self.cv1, "cv1"))
-            # Column headings frame
-            self.cv2 = tk.Canvas(rframe, bd=0, highlightthickness=0,
-                xscrollcommand=hsb.set)
-            self.cv2.pack(fill="x", anchor="nw")
-            colh = MyFrame(self.cv2, bg="black")
-            self.cv2.create_window(0, 0, window=colh, anchor="nw")
-            colh.bind("<Configure>",
-                functools.partial(self.set_scrollregion, self.cv2, "cv2"))
-            # Column details frame
-            self.cv3 = tk.Canvas(rframe, bd=0, highlightthickness=0,
+            rframeh = MyFrame(rframe)
+            rframeh.pack(fill="x")
+            self.rframed = MyFrame(rframe)
+            self.rframed.pack(fill="both", expand="yes")
+            # Label headings canvas
+            if len(self.opts["cols"]) == 1:
+                hgt = ch
+            else:
+                hgt = ch * len(self.opts["cols"])
+            self.cv1 = tk.Canvas(lframeh, bd=0, highlightthickness=0,
+                height=hgt, width=lwdth[0])
+            self.cv1.pack(fill="x", anchor="nw")
+            # Label details canvas
+            self.cv2 = tk.Canvas(lframed, bd=0, highlightthickness=0,
+                width=lwdth[0], yscrollcommand=vsb.set)
+            self.cv2.pack(fill="both", expand="yes", side="bottom")
+            # Column headings canvas
+            if len(self.opts["cols"]) == 1:
+                self.cv3 = tk.Canvas(rframeh, bd=0, highlightthickness=0,
+                    height=ch, xscrollcommand=hsb.set)
+            else:
+                self.cv3 = tk.Canvas(rframeh, bd=0, highlightthickness=0,
+                    height=(ch * 2), xscrollcommand=hsb.set)
+            self.cv3.pack(fill="x", anchor="nw")
+            # Column details canvas
+            self.cv4 = tk.Canvas(self.rframed, bd=0, highlightthickness=0,
                 xscrollcommand=hsb.set, yscrollcommand=vsb.set)
-            self.cv3.pack(fill="both", expand="yes", anchor="nw")
-            cold = MyFrame(self.cv3, bg="black")
-            self.cv3.create_window(0, 0, window=cold, anchor="nw")
-            cold.bind("<Configure>",
-                functools.partial(self.set_scrollregion, self.cv3, "cv3"))
-            # Populate widgets
-            # Color tags
+            self.cv4.pack(fill="both", expand="yes", anchor="nw")
+            self.window.bind("<Configure>", self.set_scrollregion)
+            # Populate cells
+            tags = {}
             for tag in self.opts["tags"]:
-                style.configure("%s.TLabel" % tag[0],
-                    foreground=tag[1][0], background=tag[1][1])
-            # Title
-            if type(self.opts["titl"]) in (list, tuple):
-                txt = self.opts["titl"][0]
-                for t in self.opts["titl"][1:]:
-                    txt = "%s\n%s" % (txt, t)
-            else:
-                txt = self.opts["titl"]
-            lb1.configure(text=txt)
-            # Labels
-            if len(self.opts["cols"]) == 2:
-                # Extra label for extra column heading
-                lbd = MyLabel(labh, text="", anchor="nw", font=font,
-                    borderwidth=2)
-                lbd.grid(row=0, column=0, columnspan=len(self.opts["labs"]),
-                    sticky="ew", padx=1, pady=1)
-                r = 1
-            else:
-                r = 0
-            cw = 0
+                tags[tag[0]] = tag[1]
+            # Label headings
+            x1 = 0
+            y1 = 0
             for num, lab in enumerate(self.opts["labs"]):
-                if self.opts["chgt"] == 2 and not lab[0].count("\n"):
-                    txt = "\n%s" % lab[0]
+                x2 = x1 + lwdth[1][num]
+                if len(self.opts["cols"]) == 1:
+                    y2 = y1 + ch
                 else:
-                    txt = lab[0]
-                lbd = MyLabel(labh, text=txt, anchor="nw", font=bold,
-                    borderwidth=2, justify="left", width=lab[1])
-                lbd.grid(row=r, column=num, padx=1, pady=1)
-                cw += lab[1]
-            labh.update()
-            self.cv1.configure(width=labh.winfo_reqwidth())
-            self.cv2.configure(height=labh.winfo_reqheight())
+                    y2 = y1 + (ch * 2)
+                rect = self.cv1.create_rectangle(x1, y1, x2, y2, width=2,
+                    fill=self.opts["mf"].rcdic["nbg"])
+                text = self.cv1.create_text(x1+10, y1+(ch/2), text=lab[0],
+                    anchor="w", font=bold, fill=self.opts["mf"].rcdic["nfg"])
+                x1 = x2
             # Column headings
-            if len(self.opts["cols"]) == 1:
-                self.opts["cols"].insert(0, [])
-                r = 0
-            else:
-                c = 0
-                for t in self.opts["cols"][0]:
-                    cel = MyLabel(colh, text=t[0], borderwidth=2, font=bold,
-                        anchor="center", justify="center")
-                    cel.grid(row=0, column=c, columnspan=t[1], sticky="ew",
-                        padx=1, pady=1)
-                    c += t[1]
-                r = 1
-            for c, t in enumerate(self.opts["cols"][1]):
-                if type(t[1]) in (list, tuple):
-                    w = t[1][1]
-                else:
-                    w = t[1]
-                cel = MyLabel(colh, text=t[0], borderwidth=2, width=w,
-                    font=bold, anchor="center", justify="center")
-                cel.grid(row=r, column=c, padx=1, pady=1)
+            x1 = 0
+            y1 = 0
+            idx = 0
+            if len(self.opts["cols"]) == 2:
+                for col in self.opts["cols"][idx]:
+                    cc = col[1] * tw            # total width
+                    x2 = x1 + (col[1] * cw)     # column span
+                    y2 = y1 + ch
+                    rect = self.cv3.create_rectangle(x1, y1, x2, y2, width=2,
+                        fill=self.opts["mf"].rcdic["nbg"])
+                    txt = "{:^%i}" % cc
+                    txt = txt.format(col[0])
+                    text = self.cv3.create_text(x1+10, y1+(ch/2), text=txt,
+                        font=bold, fill=self.opts["mf"].rcdic["nfg"],
+                        anchor="w")
+                    x1 = x2
+                x1 = 0
+                y1 = y2
+                idx = 1
+            for col in self.opts["cols"][idx]:
+                x2 = x1 + cw
+                y2 = y1 + ch
+                rect = self.cv3.create_rectangle(x1, y1, x2, y2, width=2,
+                    fill=self.opts["mf"].rcdic["nbg"])
+                text = self.cv3.create_text(x1+10, y1+(ch/2), text=col[0],
+                    anchor="w", font=bold, fill=self.opts["mf"].rcdic["nfg"])
+                x1 = x2
+            y1 = 0
             # Label and Column data
-            for row, dat in enumerate(self.opts["data"]):
-                for n, l in enumerate(dat[0]):
+            for row, rdat in enumerate(self.opts["data"]):
+                x1 = 0
+                for num, lab in enumerate(rdat[0]):
                     # Label data
-                    if self.opts["chgt"] == 2 and not l[0].count("\n"):
-                        txt = "\n%s" % l[0]
-                    else:
-                        txt = l[0]
-                    if not l[1]:
-                        cl = True
-                        st = "TLabel"
-                    else:
-                        cl = False
-                        st = "%s.TLabel" % l[1]
-                    w = self.opts["labs"][n][1]
-                    lbl = MyLabel(labd, text=txt, borderwidth=2, width=w,
-                        font=font, color=cl, style=st)
-                    lbl.grid(row=row, column=n, sticky="ew", padx=1, pady=1)
-                    labd.grid_columnconfigure(n, weight=1)
-                for n, c in enumerate(dat[1]):
+                    x2 = x1 + lwdth[1][num]
+                    y2 = y1 + ch
+                    if self.opts["chgt"] == 2 and not lab[0].count("\n"):
+                        txt = "\n%s" % lab[0]
+                    else:
+                        txt = lab[0]
+                    if lab[1]:
+                        tfill, rfill = tags[lab[1]]
+                    else:
+                        tfill, rfill = None, None
+                    rect = self.cv2.create_rectangle(x1, y1, x2, y2, width=2,
+                        fill=rfill)
+                    text = self.cv2.create_text(x1+10, y1+(ch/2), text=txt,
+                        font=bold, fill=tfill, anchor="w")
+                    x1 = x2
+                x1 = 0
+                if len(self.opts["cols"]) == 1:
+                    idx = 0
+                else:
+                    idx = 1
+                for col, cdat in enumerate(rdat[1]):
                     # Column data
-                    if type(self.opts["cols"][1][n][1]) in (list, tuple):
-                        f, w = self.opts["cols"][1][n][1]
-                        if type(c[0]) == str and f[1] in ("D", "I"):
+                    if len(cdat) == 3:
+                        x2 = x1 + (cdat[2] * cw)
+                    else:
+                        x2 = x1 + cw
+                    y2 = y1 + ch
+                    if cdat[1]:
+                        tfill, rfill = tags[cdat[1]]
+                    else:
+                        tfill, rfill = None, None
+                    rect = self.cv4.create_rectangle(x1, y1, x2, y2, width=2,
+                        fill=rfill)
+                    fmt = self.opts["cols"][idx][num][1]
+                    if type(fmt) in (list, tuple):
+                        f, w = fmt
+                        if type(cdat[0]) == str and f[1] in ("D", "I"):
                             f = "TX"
-                        txt = CCD(c[0], f, w)
+                        txt = CCD(cdat[0], f, w)
                         if txt.err:
-                            txt = c[0]
+                            txt = cdat[0]
                         else:
                             txt = txt.disp
                     else:
-                        w = self.opts["cols"][1][n][1]
-                        txt = c[0]
+                        txt = cdat[0]
                     if self.opts["chgt"] == 2 and not txt.count("\n"):
                         txt = "\n%s" % t
-                    if not c[1]:
-                        cl = True
-                        st = "TLabel"
-                    else:
-                        cl = False
-                        st = "%s.TLabel" % c[1]
-                    bod = MyLabel(cold, text=txt, borderwidth=2, font=font,
-                        anchor="center", justify="center", width=w, color=cl,
-                        style=st)
-                    if "bcmd" in self.opts:
-                        bod.bind("<ButtonRelease-1>",
-                            functools.partial(self._get_cell, (row, n), c[0]))
-                    if "hcmd" in self.opts:
-                        bod.bind("<Enter>",
-                            functools.partial(self._hover, (row, n), c[0]))
-                        bod.bind("<Leave>",
-                            functools.partial(self._hover, None))
-                    bod.grid(row=row, column=n, padx=1, pady=1)
+                    text = self.cv4.create_text(x1+10, y1+(ch/2), text=txt,
+                        anchor="w", font=bold, fill=tfill)
+                    if "cmds" in self.opts:
+                        for cmd in self.opts["cmds"]:
+                            self.cv4.tag_bind(rect, cmd[0],
+                                functools.partial(self._get_cell, cmd[1],
+                                    (row, col), txt))
+                            self.cv4.tag_bind(text, cmd[0],
+                                functools.partial(self._get_cell, cmd[1],
+                                    (row, col), txt))
+                    x1 = x2
+                y1 = y2
             # Arrow keys
             self.window.bind("<Left>", self._scroll)
             self.window.bind("<Right>", self._scroll)
@@ -1184,57 +1225,67 @@
             if "butt" in self.opts:
                 for but in self.opts["butt"]:
                     box.addButton(but[0], but[1])
-                    if but[0] in ("Close", "Exit"):
+                    if but[0] == "Exit":
                         close = False
                         self.window.bind("<Escape>", but[1])
             if close:
                 box.addButton("Close", self._quit)
                 self.window.bind("<Escape>", self._quit)
-            # Splash screen
-            if self.opts["splash"]:
-                sp.closeSplash()
+            if "mess" in self.opts:
+                self.sp.closeSplash()
             # Pack frame
-            mframe.pack(fill="both", expand="yes")
+            self.cframe.pack(fill="both", expand="yes")
+            self.cframe.update_idletasks()
+            height = lb1.winfo_reqheight()
+            height += self.cv3.bbox("all")[3]
+            height += self.cv4.bbox("all")[3]
+            height += hsb.winfo_reqheight()
+            height += box.bbox.winfo_reqheight()
+            if wh > height:
+                self.window.configure(height=height)
+                self.window.maxsize(width=ww, height=height)
+                self.window.update()
             # Place window
-            if "mf" in self.opts:
-                placeWindow(self.window, self.opts["mf"].window, expose=True)
-            else:
-                placeWindow(self.window, expose=True)
-
-        def _get_cell(self, *args):
-            if not args[0] or args[0][1] == "blank":
-                return
-            self.opts["bcmd"](args[:2])
-
-        def _hover(self, *args):
-            self.opts["hcmd"](args)
+            self.window.wm_geometry("%dx%d+0+0" % (ww, height))
+            self.window.geometry("+0+0")
+            self.window.deiconify()
+
+        def set_scrollregion(self, *args):
+            self.cv2.configure(scrollregion=self.cv2.bbox("all"))
+            b = self.cv3.bbox("all")
+            w = self.cv4.bbox("all")[2]
+            bbox = (b[0], b[1], w, b[3])
+            self.cv3.configure(scrollregion=bbox)
+            self.cv4.configure(scrollregion=self.cv4.bbox("all"))
+
+        def _scroll(self, event):
+            if event.keysym == "Left":
+                self._xview("scroll", -1, "units")
+            elif event.keysym == "Right":
+                self._xview("scroll", 1, "units")
+            elif event.keysym == "Up":
+                self._yview("scroll", -1, "units")
+            elif event.keysym == "Down":
+                self._yview("scroll", 1, "units")
 
         def _xview(self, *args):
-            apply(self.cv2.xview, args)
             apply(self.cv3.xview, args)
+            apply(self.cv4.xview, args)
 
         def _yview(self, *args):
-            apply(self.cv1.yview, args)
-            apply(self.cv3.yview, args)
-
-        def set_scrollregion(self, *args):
-            args[0].configure(scrollregion=args[0].bbox("all"))
-
-        def _scroll(self, event):
-            if event.keysym == "Left":
-                self._xview(tk.SCROLL, -1, tk.UNITS)
-            elif event.keysym == "Right":
-                self._xview(tk.SCROLL, 1, tk.UNITS)
-            elif event.keysym == "Up":
-                self._yview(tk.SCROLL, -1, tk.UNITS)
-            elif event.keysym == "Down":
-                self._yview(tk.SCROLL, 1, tk.UNITS)
+            apply(self.cv2.yview, args)
+            apply(self.cv4.yview, args)
+
+        def _get_cell(self, *args):
+            # execute command with following arguments:
+            #   ((row, col), text, (rframed, (x, y)), window)
+            plc = (args[3].x, args[3].y)
+            args[0](args[1], args[2], (self.rframed, plc), self.window)
 
         def _quit(self, *args):
-            self.quit = True
-            self.window.withdraw()
             self.window.destroy()
-            self.window.quit()
+            if self.opts["loop"]:
+                self.opts["mf"].closeLoop()
 
     class ScrollWindow(MyFrame):
         """
@@ -1463,12 +1514,10 @@
             self.status.configure(background=bg, foreground=fg, text=text)
             self.window.update_idletasks()
 
-    def startLoop(self, where=None):
-        #print "OPEN", where
+    def startLoop(self):
         self.window.mainloop()
 
-    def closeLoop(self, where=None):
-        #print "CLOSE", where
+    def closeLoop(self):
         self.window.update_idletasks()
         self.window.quit()
 
@@ -1508,6 +1557,7 @@
                 setattr(self, arg, None)
         self.drawWindow()
         self.setAttributes()
+        self.newwin.withdraw()
 
     def drawWindow(self):
         if self.tk:
@@ -1516,7 +1566,6 @@
             self.newwin = tk.Toplevel(self.trans.winfo_toplevel())
         else:
             self.newwin = tk.Toplevel()
-        self.newwin.withdraw()
         self.newwin.protocol("WM_DELETE_WINDOW", self.doDestroyYes)
         self.newwin.bind_all("<Tab>", lambda event: "break")
         if self.size:
@@ -1538,6 +1587,7 @@
         if self.trans:
             self.newwin.transient(self.trans)
         if self.modal:
+            #self.newwin.wait_visibility()
             self.newwin.grab_set()
 
     def doDestroyNo(self, widget=None):
@@ -1768,13 +1818,13 @@
         if self.mf.window.state() == "withdrawn":
             self.mf.window.deiconify()
         self.menubar.focus_force()
-        self.mf.startLoop("drawMenu")
+        self.mf.startLoop()
 
     def closeMenu(self, children=True):
         self.menubar.destroy()
         self.image.destroy()
         self.mf.head.configure(style="CLabel.TLabel")
-        self.mf.closeLoop("closeMenu")
+        self.mf.closeLoop()
 
 class FileDialog:
     def __init__(self, **opts):
@@ -1938,10 +1988,6 @@
                     dbmod = "kinterbasdb"
                     import kinterbasdb as engine
                 self.dbf = "?"
-            elif self.dbase == "MsSQL":
-                dbmod = "adodbapi"
-                import adodbapi as engine
-                self.dbf = "?"
             elif self.dbase == "MySQL":
                 dbmod = "MySQLdb"
                 import MySQLdb as engine
@@ -1977,17 +2023,6 @@
             self.flt = "numeric"
             self.ser = "bigint"
             self.blb = "blob"
-        elif self.dbase == "MsSQL":
-            self.dtm = "varchar"
-            self.key = "varchar"
-            self.var = "varchar"
-            self.txt = "ntext"
-            self.itg = "int"
-            self.lng = "bigint"
-            self.dec = "decimal"
-            self.flt = "float"
-            self.ser = "integer not null identity(1, 1) primary key"
-            self.blb = "sql_variant"
         elif self.dbase == "MySQL":
             self.dtm = "date"
             self.key = "varchar"
@@ -2032,13 +2067,6 @@
             self.openDbase(err=False)
             if self.db:
                 exists = True
-        elif self.dbase == "MsSQL":
-            self.openDbase(dbname="master", err=False)
-            if self.db:
-                self.cu.execute("Select count(*) from sysdatabases "\
-                    "where name='%s'" % self.dbname)
-                if self.cu.fetchone()[0]:
-                    exists = True
         elif self.dbase == "MySQL":
             self.openDbase(dbname="mysql", err=False)
             if self.db:
@@ -2076,10 +2104,6 @@
                 db = self.engine.create_database("Create database '%s' "\
                     "user '%s' password '%s'" % (dsn, self.dbuser, self.dbpwd))
                 db.close()
-            elif self.dbase == "MsSQL":
-                self.openDbase(dbname="master")
-                self.cu.execute("Create database %s" % self.dbname)
-                self.closeDbase()
             elif self.dbase == "MySQL":
                 self.openDbase(dbname="mysql")
                 self.cu.execute("Create database %s character set utf8 "\
@@ -2131,12 +2155,6 @@
                 self.db = self.engine.connect(host=self.dbhost,
                     port=self.dbport, database=self.dbdsn, user=self.dbuser,
                     password=self.dbpwd)  # charset="UTF8")
-            elif self.dbase == "MsSQL" and sys.platform == "win32":
-                cs = "Provider=sqloledb;Data Source=%s;Initial Catalog=%s;"\
-                    "User Id=%s;" % (self.dbhost, dbname, self.dbuser)
-                if self.dbpwd:
-                    cs = "%sPassword=%s;" % (cs, self.dbpwd)
-                self.db = self.engine.connect(cs)
             elif self.dbase == "MySQL":
                 if not int(self.dbport):
                     self.dbport = 3306
@@ -2262,10 +2280,6 @@
                 self.cu.close()
                 self.db.drop_database()
                 self.closeDbase()
-            elif self.dbase == "MsSQL":
-                self.openDbase(dbname="master")
-                self.cu.execute("Drop database %s" % self.dbname)
-                self.closeDbase()
             elif self.dbase == "MySQL":
                 self.openDbase(dbname="mysql")
                 self.cu.execute("Drop database %s" % self.dbname)
@@ -2285,9 +2299,6 @@
             self.cu.execute("Select rdb$relation_name from rdb$relations "\
                 "where rdb$relation_name in ('%s', '%s')" % (table.lower(),
                 table.upper()))
-        elif self.dbase == "MsSQL":
-            self.cu.execute("Select name from %s.dbo.sysobjects where "\
-                "name = '%s'" % (self.dbname, table))
         elif self.dbase == "MySQL":
             self.cu.execute("Select table_name from information_schema.tables "\
                 "where table_schema = '%s' and table_name = '%s'" % \
@@ -2300,7 +2311,7 @@
                 "name = '%s' and type = 'table'" % table)
         return self.cu.fetchone()
 
-    def createTable(self, table, drop=False):
+    def createTable(self, table, drop=False, index=True):
         try:
             fld = open(os.path.join(self.csvdir, "%s_fld.csv" % table), "rb")
             idx = open(os.path.join(self.csvdir, "%s_idx.csv" % table), "rb")
@@ -2358,30 +2369,31 @@
         self.cu.execute(qry)
         if self.dbase == "FBird":
             self.db.commit()
-        # Create the indexes
-        ky = []
-        data = csv.reader(idx, quoting=csv.QUOTE_MINIMAL)
-        for dat in data:
-            ky.append([table] + dat)
-        for key in ky:
-            if sys.platform == "win32" or self.dbase in ("FBird", "MySQL"):
-                if table in ("memkon", "emllog"):
-                    continue
-            kk = ""
-            for f in key[4:]:
-                if not f:
-                    continue
-                if not kk:
-                    kk = f
-                else:
-                    kk += ",%s" % f
-            if key[3] == "U":
-                qry = "Create unique index %s_key%s on %s (%s)" % \
-                    (table, str(key[2]), table, kk)
-            elif key[3] == "N":
-                qry = "Create index %s_key%s on %s (%s)" % \
-                    (table, str(key[2]), table, kk)
-            self.cu.execute(qry)
+        if index:
+            # Create the indexes
+            ky = []
+            data = csv.reader(idx, quoting=csv.QUOTE_MINIMAL)
+            for dat in data:
+                ky.append([table] + dat)
+            for key in ky:
+                if sys.platform == "win32" or self.dbase in ("FBird", "MySQL"):
+                    if table in ("memkon", "emllog"):
+                        continue
+                kk = ""
+                for f in key[4:]:
+                    if not f:
+                        continue
+                    if not kk:
+                        kk = f
+                    else:
+                        kk += ",%s" % f
+                if key[3] == "U":
+                    qry = "Create unique index %s_key%s on %s (%s)" % \
+                        (table, str(key[2]), table, kk)
+                elif key[3] == "N":
+                    qry = "Create index %s_key%s on %s (%s)" % \
+                        (table, str(key[2]), table, kk)
+                self.cu.execute(qry)
         # Set permissions
         if self.dbase == "FBird":
             self.cu.execute("Grant ALL on %s to PUBLIC" % table)
@@ -2432,9 +2444,14 @@
             self.cu.execute(qry, k)
         self.db.commit()
 
-    def dropTable(self, table):
+    def dropTable(self, table, frecs=False):
         if self.checkTable(table):
             self.cu.execute("Drop table %s" % table)
+            if frecs:
+                self.cu.execute(
+                    "Delete from ffield where ff_tabl = '%s'" % table)
+                self.cu.execute(
+                    "Delete from ftable where ft_tabl = '%s'" % table)
             if self.dbase == "FBird":
                 try:
                     self.cu.execute("Drop generator gen_%s_id" % table)
@@ -2494,7 +2511,7 @@
                 mess = """
 The ffield record for %s Does Not Exist
 
-Please Contact Your IT Manager A.S.A.P.
+Please Inform Your IT Manager A.S.A.P.
 """ % table
                 showError(None, "ffield Error", mess)
                 self.error.append(table)
@@ -2544,24 +2561,25 @@
                     ret = self.dbm.cu.fetchall()
                 return retList(ret)
         except:
+            try:
+                self.dbm.rollbackDbase()
+            except:
+                pass
             if excp and not "TARTANDB" in os.environ:
                 return "Exception"
             showException(None, self.dbm.wrkdir,
                 "Error Executing SQL Statement\n\n%s\n\nIn module %s" % \
                 (str(state), self.prog), dbm=self.dbm)
-            try:
-                self.dbm.rollbackDbase()
-            except:
-                pass
             os._exit(0)
 
-    def insRec(self, table, data=[], unique=None, format=True, excp=False):
+    def insRec(self, table, data=[], unique=None, dofmt=True, excp=False, pbar=None):
         """
         table   = The table to insert into
-        data    = A list of all the column's data
+        data    = A list or a list of lists of all the column's data
         unique  = Any column which must be unique e.g. drt_ref1
-        format  = Whether or not to format the data before inserting
+        dofmt   = Whether or not to format the data before inserting
         excp    = Whether or not to show exceptions or just return 'Exception'
+        pbar    = ProgressBar object
         """
         if table not in self.tables:
             showError(None, "insRec Error",
@@ -2571,98 +2589,123 @@
             sys.exit()
         dic = getattr(self, "%s_dic" % table)
         col = getattr(self, "%s_col" % table)
-        temp = list(data[:])
-        if not len(temp) == len(col):
-            showError(None, "insRec Error",
-                """Data and CSV Formats Differ
+        # Generate column fields
+        nfld = ""
+        nfmt = ""
+        tfmt = ""
+        nrem = []
+        for num, nam in enumerate(col):
+            # Column Names
+            if dic[nam][2] == "US":
+                nrem.append(num)
+                continue
+            if not nfld:
+                nfld = "%s" % nam
+                nfmt = self.dbm.dbf
+            else:
+                nfld = "%s, %s" % (nfld, nam)
+                nfmt = "%s, %s" % (nfmt, self.dbm.dbf)
+        # Format data
+        if not type(data[0]) in (list, tuple):
+            # Single record
+            data = [data]
+        else:
+            # Cannot test for unique with multple records
+            unique = None
+        ndat = []
+        for onum, odat in enumerate(data):
+            if pbar:
+                pbar.displayProgress(onum)
+            tdat = list(odat[:])
+            if not len(tdat) == len(col):
+                showError(None, "insRec Error",
+                    """Data and CSV Formats Differ
 
 Table %s in Program %s
 
-Length of Data %s, of CSV %s""" % (table, self.prog, len(temp), len(col)))
-            self.dbm.rollbackDbase()
-            os._exit(0)
-        ##############################################################
-        # Test and Correct for a Column in Unique Keys (e.g. drt_ref1)
-        ##############################################################
-        if unique:
-            cols = self.sqlRec(state=("Select * from ftable where ft_tabl=%s "\
-                "and ft_type = 'U' order by ft_seq" % self.dbm.dbf, (table,)))
-            if cols:
-                for key in cols:
-                    k = []
-                    d = []
-                    q = False
-                    for c in key[4:]:
-                        if c:
-                            k.append(c)
-                            d.append(data[col.index(c)])
-                            if c == unique:
-                                q = True
-                    if q:
-                        typ = dic[unique][2]
-                        siz = dic[unique][3]
-                        wrk = CCD(d[k.index(unique)], typ, siz).work
-                        quo = int((str(siz).split(".")[0]))
-                        ok = False
-                        while not ok:
-                            s = "Select count(*) from %s where" % table
-                            for x in k:
-                                s = "%s %s=%s and" % (s, x, self.dbm.dbf)
-                            get = self.sqlRec((s[:-4], tuple(d)), limit=1)
-                            if get[0]:
-                                if typ[1].upper() == "A":
-                                    try:
-                                        wrk = int(wrk) + 1
-                                    except:
-                                        if len(wrk) == quo:
-                                            if wrk[:1] == " ":
+Length of Data %s, of CSV %s""" % (table, self.prog, len(tdat), len(col)))
+                self.dbm.rollbackDbase()
+                os._exit(0)
+            # Test and Correct for a Column in Unique Keys (e.g. drt_ref1)
+            if unique:
+                cols = self.sqlRec(state=("Select * from ftable where "\
+                    "ft_tabl=%s and ft_type = 'U' order by ft_seq" % \
+                    self.dbm.dbf, (table,)))
+                if cols:
+                    for key in cols:
+                        k = []
+                        d = []
+                        q = False
+                        for c in key[4:]:
+                            if c:
+                                k.append(c)
+                                d.append(odat[col.index(c)])
+                                if c == unique:
+                                    q = True
+                        if q:
+                            typ = dic[unique][2]
+                            siz = dic[unique][3]
+                            wrk = CCD(d[k.index(unique)], typ, siz).work
+                            quo = int((str(siz).split(".")[0]))
+                            ok = False
+                            while not ok:
+                                s = "Select count(*) from %s where" % table
+                                for x in k:
+                                    s = "%s %s=%s and" % (s, x, self.dbm.dbf)
+                                get = self.sqlRec((s[:-4], tuple(d)), limit=1)
+                                if get[0]:
+                                    if typ[1].upper() == "A":
+                                        try:
+                                            wrk = int(wrk) + 1
+                                        except:
+                                            if len(wrk) == quo:
+                                                if wrk[:1] == " ":
+                                                    dgt = "A"
+                                                else:
+                                                    dgt = chr(ord(wrk[:1]) + 1)
+                                                dat = wrk[1:]
+                                            else:
                                                 dgt = "A"
-                                            else:
-                                                dgt = chr(ord(wrk[:1]) + 1)
-                                            dat = wrk[1:]
-                                        else:
-                                            dgt = "A"
-                                            dat = wrk
-                                        fmt = "%1s%" + str((quo - 1)) + "s"
-                                        wrk = fmt % (dgt, dat)
-                                        if typ == "Na":
-                                            wrk = wrk.replace(" ", "0")
+                                                dat = wrk
+                                            fmt = "%1s%" + str((quo - 1)) + "s"
+                                            wrk = fmt % (dgt, dat)
+                                            if typ == "Na":
+                                                wrk = wrk.replace(" ", "0")
+                                    else:
+                                        wrk = wrk + (10**(quo - 1))
+                                    wrk = CCD(wrk, typ, siz).work
+                                    d[k.index(unique)] = wrk
+                                    tdat[col.index(unique)] = wrk
                                 else:
-                                    wrk = wrk + (10**(quo - 1))
-                                wrk = CCD(wrk, typ, siz).work
-                                d[k.index(unique)] = wrk
-                                temp[col.index(unique)] = wrk
-                            else:
-                                ok = True
-        ##############################################################
-        fmt = ""
-        fld = ""
-        skp = 0
-        for num, nam in enumerate(col):
-            idx = num - skp
-            if dic[nam][2] == "US":
-                del temp[idx]
-                skp += 1
+                                    ok = True
+            # Insert records
+            for seq, nam in enumerate(col):
+                # Check for None in data
+                if seq in nrem:
+                    continue
+                if tdat[seq] is None:
+                    if dic[nam][2][1].lower() in ("a", "m", "x"):
+                        tdat[seq] = ""
+                    else:
+                        tdat[seq] = 0
+                if dofmt:
+                    fd = CCD(tdat[seq], dic[nam][2], dic[nam][3])
+                    if not fd.err:
+                        tdat[seq] = fd.work
+                ndat.append(tdat[seq])
+            if not tfmt:
+                tfmt = "(%s)" % nfmt
             else:
-                if not fld:
-                    fld = "%s" % nam
-                else:
-                    fld = "%s, %s" % (fld, nam)
-                if not fmt:
-                    fmt = "%s" % self.dbm.dbf
-                else:
-                    fmt = "%s, %s" % (fmt, self.dbm.dbf)
-                if format:
-                    if temp[num] is None:
-                        if dic[nam][2][1].lower() in ("a", "x"):
-                            temp[num] = ""
-                        else:
-                            temp[num] = 0
-                    dat = CCD(temp[num], dic[nam][2], dic[nam][3])
-                    if not dat.err:
-                        temp[num] = dat.work
-        self.sqlRec(("Insert into %s (%s) values (%s)" % (table, fld, fmt),
-            tuple(temp)), excp=excp)
+                tfmt = "%s, (%s)" % (tfmt, nfmt)
+            if onum and not onum % 499:
+                # Limit write to a maximum of 500 records at a time
+                self.sqlRec(("Insert into %s (%s) values %s" % (table, nfld,
+                    tfmt), ndat), excp=excp)
+                tfmt = ""
+                ndat = []
+        if ndat:
+            self.sqlRec(("Insert into %s (%s) values %s" % (table, nfld,
+                tfmt), ndat), excp=excp)
 
     def getRec(self, tables=None, join=None, cols=None, where=None, data=None, group=None, order=None, fetch=False, limit=None, excp=False):
         """
@@ -2774,13 +2817,13 @@
         else:
             return self.sqlRec((get, dat), fetch=fetch, limit=limit, excp=excp)
 
-    def updRec(self, table, where=None, data=None, cols=None, format=True):
+    def updRec(self, table, where=None, data=None, cols=None, dofmt=True):
         """
         table   = The table to update
         where   = A where statement like the getRec one
         data    = A list of data matching the columns in cols or all if no cols
         cols    = A list of columns matching 'data' else None for all
-        format  = Whether or not to format the data before updating
+        dofmt   = Whether or not to format the data before updating
         """
         cmd = ""
         if not where and not data:
@@ -2798,7 +2841,7 @@
                 cmd = "Update %s set %s = %s" % (table, col, self.dbm.dbf)
             else:
                 cmd = "%s, %s = %s" % (cmd, col, self.dbm.dbf)
-            if format:
+            if dofmt:
                 dat = CCD(data[num], dic[col][2], dic[col][3])
                 if not dat.err:
                     data[num] = dat.work
@@ -3428,6 +3471,7 @@
             g = Grant Privileges to group for all tables.
             u = Create Database User Only
     -d  = The path where the '.csv' and '.sys' files reside
+    -i  = Create indexes, defaults to True
     -l  = Display a splash screen on this frame
     -p  = Admin Password
     -s  = System Name e.g. parlor referring to a '.sys' file
@@ -3453,6 +3497,8 @@
                     self.put = v.lower()
                 elif o == "-d":
                     self.csv = v
+                elif o == "-i":
+                    self.idx = v
                 elif o == "-l":
                     self.spl = v
                 elif o == "-p":
@@ -3492,17 +3538,6 @@
             self.flt = "numeric"
             self.ser = "bigint"
             self.blb = "blob"
-        elif self.dbm.dbase == "MsSQL":
-            self.dtm = "varchar"
-            self.key = "varchar"
-            self.var = "varchar"
-            self.txt = "ntext"
-            self.int = "int"
-            self.lng = "bigint"
-            self.dec = "decimal"
-            self.flt = "float"
-            self.ser = "integer not null identity(1, 1) primary key"
-            self.blb = "sql_variant"
         elif self.dbm.dbase == "MySQL":
             self.dtm = "date"
             self.key = "varchar"
@@ -3618,8 +3653,6 @@
                     fbuser.password = pwd
                 conn.add_user(fbuser)
                 conn.close()
-            elif self.dbm.dbase == "MsSQL":
-                pass
             elif self.dbm.dbase == "MySQL":
                 self.sql.sqlRec("Use mysql")
                 use = self.sql.sqlRec(("Select User from user where "\
@@ -3655,7 +3688,7 @@
             sys.exit()
 
     def createDBTable(self, table):
-        self.dbm.createTable(table, drop=True)
+        self.dbm.createTable(table, drop=True, index=self.idx)
         if table == "ctlpwu" and self.put == "i":
             sql = Sql(self.dbm, table, prog=__name__)
             sql.insRec(table, data=["admin", "System Administrator",
@@ -3872,7 +3905,7 @@
     view   =  An entry field asking whether you would like to view the report
               It is a tuple (csv, "D") where:
                 csv is whether to have an export facility
-                "D" is the default e.g. ("View", "Print" or "Xport")
+                "D" is the default e.g. ("(V)iew", "(P)rint" or "(X)port")
               A list self.repprt[0] is created having 3 fields as follows:
                 1) "Y" or "N" view widget created
                 2) query widget contents
@@ -3884,7 +3917,7 @@
                    "Y" = Address Field (noblank)
                    "B" = Address Field (efld)
                    "N" = No Address Field (default N)
-                prt  is "Y" or "N" to choose to view/print emailed docs or not
+                prnt  is "Y" or "N" to choose to view/print emailed docs or not
                 dflt is the default answer
                 desc is the description to replace the default
               A list self.repprt[1] is created having 3 fields as follows:
@@ -4629,7 +4662,7 @@
                 b.bind("<<myradio>>", self.doKeys)
                 if self.clicks and typ[0] == "I":
                     b.bind("<ButtonRelease-1>",
-                        functools.partial(self.clicks, (pag, col)))
+                        functools.partial(self.clicks, (pag, col, b)))
                 b.grid(row=0, column=num)
                 e_dic[col].append([b, var, (val[1], cr)])
             if self.mf.rcdic["ttip"] == "Y" and len(fld) == 13 and fld[12]:
@@ -4639,11 +4672,11 @@
             if typ[1:] == "Tv":
                 e_dic[col] = MyTextView_v(self.ttabl, width=siz, height=hgt,
                     wrap="word", fg=self.mf.rcdic["nfg"],
-                    bg=self.mf.rcdic["nbg"])
+                    bg=self.mf.rcdic["nbg"], bd=3)
             else:
                 e_dic[col] = MyTextView_V(self.ttabl, width=siz, height=hgt,
                     wrap="word", fg=self.mf.rcdic["nfg"],
-                    bg=self.mf.rcdic["nbg"])
+                    bg=self.mf.rcdic["nbg"], bd=3)
             if typ[0] == "I":
                 if typ[1:] == "TV":
                     e_dic[col].bind("<<mytxtvV>>", self.doKeys)
@@ -5968,7 +6001,7 @@
             wrk = wrk.split(",")
             err = False
             for w in wrk:
-                if not os.path.isfile(w):
+                if not getFileName(w, check=True):
                     err = True
                     break
             if not err:
@@ -6647,18 +6680,14 @@
                     if self.retn == "D":
                         self.selection = sc.selection[1:]
                     elif self.retn == "I":
-                        self.selection = sc.selection[:1]
+                        self.selection = sc.selection[0]
                 elif self.mode == "M":
                     self.selection = []
                     for sel in sc.selection:
-                        if self.selc:
-                            idx = self.selc
-                        else:
-                            idx = 0
                         if self.retn == "D":
-                            self.selection.append(sel[idx + 1])
+                            self.selection.append(sel[1:])
                         elif self.retn == "I":
-                            self.selection.append(sel[idx])
+                            self.selection.append(sel[0])
 
 class SelectChoice:
     """
@@ -6731,14 +6760,6 @@
                 self.cols.append(col[0])
                 self.cdet[col[0]] = [col[2], col[3], col[4]]
         self.data = data
-        self.lines = lines
-        if not self.lines:
-            if len(self.data) < 10:
-                self.lines = 10
-            elif len(self.data) > 30:
-                self.lines = 30
-            else:
-                self.lines = len(self.data)
         if self.chek:
             self.srch -= 1
             self.sort = False
@@ -6760,9 +6781,18 @@
         self.fltr = fltr
         self.scrl = scrl
         self.styl = styl
-        self.font = font
+        self.font = tkFont.Font(font=font)
         self.addh = addh
         self.selection = None
+        if not lines:
+            if len(self.data) < 10:
+                self.lines = 10
+            elif len(self.data) > 30:
+                self.lines = 30
+            else:
+                self.lines = len(self.data)
+        else:
+            self.lines = lines
         self.setupWidgets()
         ok = self.buildTree()
         if self.loop:
@@ -6782,6 +6812,13 @@
             self.mstFrame.grid(column=0, sticky="nsew")
         self.mstFrame.grid_columnconfigure(0, weight=1)
         self.mstFrame.grid_rowconfigure(0, weight=1)
+        chgt = self.font.cget("size")
+        if self.scrn:
+            tlin = int((self.scrn.winfo_reqheight() / chgt) * .80)
+        else:
+            tlin = int((self.window.winfo_screenheight() / chgt) * .8)
+            if self.lines > tlin:
+                self.lines = tlin
         if self.headings:
             show = ["headings"]
         else:
@@ -6880,8 +6917,7 @@
                         command=lambda c=nam: self.doSort(c, False))
                 else:
                     self.tree.heading(nam, text=text, anchor=anchor)
-            width = tkFont.Font(font=self.font).measure(
-                "X" * (int(self.cdet[col][0]) + 1))
+            width = self.font.measure("X" * (int(self.cdet[col][0]) + 1))
             self.tree.column(nam, width=width, minwidth=width, stretch=True)
         self.iids = {}
         start = None
@@ -7229,9 +7265,9 @@
 
     def setVariables(self):
         if self.butt:
-            self.butt.insert(0, ("Continue", self.execCmd))
+            self.butt.insert(0, ("Continue", self.execStCmd))
         else:
-            self.butt = [("Continue", self.execCmd)]
+            self.butt = [("Continue", self.execStCmd)]
 
     def doProcess(self):
         if self.scrn:
@@ -7283,7 +7319,7 @@
             self.scrn.update_idletasks()
         self.text.focus_set()
 
-    def execCmd(self, *args):
+    def execStCmd(self, *args):
         if args and self.butt[args[0]][1]:
             self.butt[args[0]][1]()
         else:
@@ -7344,7 +7380,7 @@
                     F = Updating Files
                     or a tuple of (typ and text)
         mxs  -  With typ P and F this is the maximum number of records.
-        esc  -  Whether to allow the escape key to stop the action.
+        esc  -  Create a Quit button to terminate the job
     """
     def __init__(self, scrn, **args):
         self.scrn = scrn
@@ -7370,11 +7406,6 @@
                     text = ""
         if not self.mxs:
             self.typ = "G"
-        if self.inn:
-            self.esc = False
-        # Must work out how to thread this
-        self.esc = False
-        self.can = None
         if self.typ == "G":
             mode = "indeterminate"
             if not text:
@@ -7382,7 +7413,7 @@
         elif self.typ == "P":
             mode = "determinate"
             if not text:
-                text = "Printing the Report ... Please Wait"
+                text = "Generating the Report ... Please Wait"
         elif self.typ == "F":
             mode = "determinate"
             if not text:
@@ -7391,9 +7422,9 @@
             mode = "determinate"
             text = self.typ
             self.typ = "P"
-        if self.esc:
-            text += ", <Esc> to Abort"
+        self.quit = False
         if self.inn:
+            self.esc = False
             self.pbframe = MyFrame(self.inn.pbframe, padding=2, relief="raised")
             self.pbframe.pack(fill="x", expand="yes")
         else:
@@ -7406,32 +7437,39 @@
         self.txtlab = MyLabel(self.pbframe,text=text,anchor="center",width=60)
         self.txtlab.pack(anchor="n", fill="x", expand="yes")
         self.pbar = ttk.Progressbar(self.pbframe, mode=mode,
-            takefocus=self.esc, length=self.txtlab.winfo_width())
+            length=self.txtlab.winfo_width())
         self.pbar.pack(fill="x", expand="yes", pady=0)
-        if self.typ == "G":
+        if self.esc:
+            self.pbt = threading.Thread()
+            if self.typ == "G":
+                self.pbt.__init__(target=self.pbar.start, args=())
+            else:
+                self.pbar.configure(maximum=self.mxs)
+            self.pbt.start()
+            but = MyButton(self.pbframe, cmd=self.quitProgress, text="Quit",
+                underline=0)
+            but.pack(anchor="n", fill="x", expand="yes")
+        elif self.typ == "G":
             self.pbar.start()
         else:
             self.pbar.configure(maximum=self.mxs)
-        if self.esc:
-            self.pbframe.bind_all("<Escape>", self.quitProgress)
 
     def displayProgress(self, value=0):
         if self.typ == "G":
             self.pbar.step()
         else:
             self.pbar.configure(value=value + 1)
-        self.scrn.update_idletasks()
-        #if self.esc:
-        #    return self.can
+        self.scrn.update()
 
     def closeProgress(self):
-        if self.esc:
-            self.pbframe.unbind_all("<Escape>")
+        if self.esc and self.pbt.isAlive() is False:
+            self.pbt.join()
         self.pbframe.destroy()
         self.pbframe.update()
 
-    def quitProgress(self, event):
-        self.can = "yes"
+    def quitProgress(self):
+        self.quit = True
+        self.closeProgress()
 
 class ShowEmail:
     def __init__(self, window=False, message=None, embed=None, attach=None):
@@ -7481,53 +7519,55 @@
         self.window.quit()
 
 class ShowImage:
-    def __init__(self, vbox, flenam, msiz=400, crop=False):
+    def __init__(self, vbox, flenam, wrkdir=None, msiz=400, crop=False):
         self.vbox = vbox
         self.crop = crop
-        pilimg = Image.open(flenam)
-        width = int(pilimg.size[0])
-        height = int(pilimg.size[1])
-        relate = float(height / (width * 1.0))
-        if width > height:
-            width = msiz
-            height = int(width * relate)
-        else:
-            height = msiz
-            width = int(height / relate)
-        self.currentImage = {}
-        image = pilimg.resize((width, height), 0)
-        self.currentImage["data"] = image
-        self.frm = MyFrame(self.vbox, borderwidth=5, relief="raised",
-            width=width, height=height)
-        if self.vbox:
-            mgr = getManager(self.vbox)
-            if mgr == "grid":
-                self.frm.grid(column=0, sticky="nsew")
-                self.frm.grid_propagate(False)
+        flenam = getFileName(flenam, wrkdir=wrkdir, check=False)
+        if flenam:
+            pilimg = Image.open(flenam)
+            width = int(pilimg.size[0])
+            height = int(pilimg.size[1])
+            relate = float(height / (width * 1.0))
+            if width > height:
+                width = msiz
+                height = int(width * relate)
+            else:
+                height = msiz
+                width = int(height / relate)
+            self.currentImage = {}
+            image = pilimg.resize((width, height), 0)
+            self.currentImage["data"] = image
+            self.frm = MyFrame(self.vbox, borderwidth=5, relief="raised",
+                width=width, height=height)
+            if self.vbox:
+                mgr = getManager(self.vbox)
+                if mgr == "grid":
+                    self.frm.grid(column=0, sticky="nsew")
+                    self.frm.grid_propagate(False)
+                else:
+                    self.frm.pack(fill="both", expand="yes")
+                    self.frm.pack_propagate(False)
             else:
                 self.frm.pack(fill="both", expand="yes")
                 self.frm.pack_propagate(False)
-        else:
-            self.frm.pack(fill="both", expand="yes")
-            self.frm.pack_propagate(False)
-        self.cnv = tk.Canvas(self.frm)
-        if self.crop:
-            self.cnv.bind("<ButtonPress-1>", self.on_mouse_down)
-            self.cnv.bind("<B1-Motion>", self.on_mouse_drag)
-            self.cnv.bind("<Button-3>", self.on_right_click)
-            self.but = MyButton(self.vbox, text="Crop/Print")
-            self.but.bind("<ButtonRelease-1>", self.doCrop)
-            image = image.convert("L")
-        image = ImageTk.PhotoImage(image=image)
-        self.currentImage["photo"] = image
-        self.cnv.xview_moveto(0)
-        self.cnv.yview_moveto(0)
-        self.cnv.create_image(0, 0, image=image, anchor="nw", tags="img")
-        self.cnv.pack(side="left", fill="both", expand="yes")
-        if self.crop:
-            self.but.pack(fill="x", expand="yes")
-            self.item = None
-            self.frm.mainloop()
+            self.cnv = tk.Canvas(self.frm)
+            if self.crop:
+                self.cnv.bind("<ButtonPress-1>", self.on_mouse_down)
+                self.cnv.bind("<B1-Motion>", self.on_mouse_drag)
+                self.cnv.bind("<Button-3>", self.on_right_click)
+                self.but = MyButton(self.vbox, text="Crop/Print")
+                self.but.bind("<ButtonRelease-1>", self.doCrop)
+                image = image.convert("L")
+            image = ImageTk.PhotoImage(image=image)
+            self.currentImage["photo"] = image
+            self.cnv.xview_moveto(0)
+            self.cnv.yview_moveto(0)
+            self.cnv.create_image(0, 0, image=image, anchor="nw", tags="img")
+            self.cnv.pack(side="left", fill="both", expand="yes")
+            if self.crop:
+                self.but.pack(fill="x", expand="yes")
+                self.item = None
+                self.frm.mainloop()
 
     def on_mouse_down(self, event):
         if self.item is None:
@@ -7585,6 +7625,28 @@
         if not self.rcdic:
             self.rcdic = loadRcFile(rcfile=self.rcfile, default=True)
             self.rcfile = os.path.normpath(self.rcdic["name"])
+        self.color = {
+            "R": (
+                ("#ffffff", "#a40204"),
+                ("#ffffff", "#044e1c"),
+                ("#000000", "#ffffff"),
+                ("#000000", "#ffc0cb"),
+                ("#000000", "#add8e6"),
+                ("#ffffff", "#0000ff")),
+            "G": (
+                ("#ffffff", "#00883b"),
+                ("#000000", "#19f913"),
+                ("#000000", "#ffffff"),
+                ("#000000", "#ffc0cb"),
+                ("#000000", "#add8e6"),
+                ("#ffffff", "#0000ff")),
+            "B": (
+                ("#ffffff", "#0058ff"),
+                ("#000000", "#ade9e6"),
+                ("#000000", "#ffffff"),
+                ("#000000", "#ffc0cb"),
+                ("#000000", "#add8e6"),
+                ("#ffffff", "#0000ff"))}
         self.edit = False
         self.click = []
 
@@ -7630,13 +7692,12 @@
             ("PostgreSQL", "P"),
             ("SQLite", "S"),
             ("MySQL", "M"),
-            ("Firebird", "F"),
-            ("MsSQL 2000", "Q"))
+            ("Firebird", "F"))
         r2s = (("Left", "L"), ("Centre", "C"), ("Right", "R"))
         r3s = (("Yes", "Y"), ("No", "N"))
         r4s = (("In-Line", "I"), ("List", "L"), ("No", "N"))
         r5s = (("Yes", "Y"), ("No", "N"), ("Multimedia", "M"))
-        r6s = (("No", "N"), ("Tops", "T"), ("Both", "B"))
+        r6s = (("Red", "R"), ("Green", "G"), ("Blue", "B"), ("Custom", "C"))
         tag = (
             ("DataBase",None,("T",1,1),("T",3,0)),
             ("General",None,("T",1,1),("T",3,0)),
@@ -7722,27 +7783,51 @@
             (("T",3,2,0),"INA",30,"Theme","",
                 self.rcdic["theme"],"N",self.doTheme,thm,None,("in",self.thm),
                 None,"The Theme to be used"),
-            (("T",3,3,0),"INA",15,"Normal  FG","",
+            (("T",3,3,0),("IRB",r6s),0,"Colour Scheme","",
+                self.rcdic["dcs"],"N",self.doScheme,None,None,None,
+                None,"The Colour Scheme to be used"),
+            (("T",3,4,0),"INA",20,"Normal  FG","",
                 self.rcdic["nfg"],"N",self.doColour,fgc,None,("notblank",),
                 None,"Normal Label and Button Foreground Colour"),
-            (("T",3,3,0),"INA",15,"BG","",
+            (("T",3,4,0),"INA",20,"BG","",
                 self.rcdic["nbg"],"N",self.doColour,bgc,None,("notblank",),
                 None,"Normal Label and Button Background Colour"),
-            (("T",3,3,0),"OTv",10," "),
-            (("T",3,4,0),"INA",15,"Focus   FG","",
+            (("T",3,4,0),"OTv",10," "),
+            (("T",3,5,0),"INA",20,"Focus   FG","",
                 self.rcdic["ffg"],"N",self.doColour,fgc,None,("notblank",),
                 None,"Focussed Button Foreground Colour"),
-            (("T",3,4,0),"INA",15,"BG","",
+            (("T",3,5,0),"INA",20,"BG","",
                 self.rcdic["fbg"],"N",self.doColour,bgc,None,("notblank",),
                 None,"Focussed Button Background Colour"),
-            (("T",3,4,0),"OTv",10," "),
-            (("T",3,5,0),"INA",15,"Disable FG","",
+            (("T",3,5,0),"OTv",10," "),
+            (("T",3,6,0),"INA",20,"Disable FG","",
                 self.rcdic["dfg"],"N",self.doColour,fgc,None,("notblank",),
                 None,"Disabled Button Foreground Colour"),
-            (("T",3,5,0),"INA",15,"BG","",
+            (("T",3,6,0),"INA",20,"BG","",
                 self.rcdic["dbg"],"N",self.doColour,bgc,None,("notblank",),
                 None,"Disabled Button Background Colour"),
-            (("T",3,5,0),"OTv",10," "))
+            (("T",3,6,0),"OTv",10," "),
+            (("T",3,7,0),"INA",20,"Booking Query FG","",
+                self.rcdic["qfg"],"N",self.doColour,fgc,None,("notblank",),
+                None,"Booking Query Foreground Colour"),
+            (("T",3,7,0),"INA",20,"BG","",
+                self.rcdic["qbg"],"N",self.doColour,bgc,None,("notblank",),
+                None,"Booking Query Background Colour"),
+            (("T",3,7,0),"OTv",10," "),
+            (("T",3,8,0),"INA",20,"Booking Confirmed FG","",
+                self.rcdic["cfg"],"N",self.doColour,fgc,None,("notblank",),
+                None,"Booking Confirm Foreground Colour"),
+            (("T",3,8,0),"INA",20,"BG","",
+                self.rcdic["cbg"],"N",self.doColour,bgc,None,("notblank",),
+                None,"Booking Confirmed Background Colour"),
+            (("T",3,8,0),"OTv",10," "),
+            (("T",3,9,0),"INA",20,"Booking Settled FG","",
+                self.rcdic["sfg"],"N",self.doColour,fgc,None,("notblank",),
+                None,"Booking Settled Foreground Colour"),
+            (("T",3,9,0),"INA",20,"BG","",
+                self.rcdic["sbg"],"N",self.doColour,bgc,None,("notblank",),
+                None,"Booking Settled Background Colour"),
+            (("T",3,9,0),"OTv",10," "))
         but = (
             ("Save", None, self.doSave, 1, ("T",1,1), ("T",0,1)),
             ("Cancel", None, self.doCancel, 1, None, None))
@@ -7853,6 +7938,15 @@
         self.rcdic["theme"] = self.mf.rcdic["theme"] = w
         self.mf.setThemeFont()
 
+    def doScheme(self, frt, pag, r, c, p, i, w):
+        if w in ("R", "G", "B"):
+            for x in range(3):
+                idx = (x * 3) + 1
+                for y in range(2):
+                    self.df.doKeyPressed(frt, pag, p+idx+y,
+                        data=self.color[w][x][y])
+            return "ff16"
+
     def doColour(self, frt, pag, r, c, p, i, w):
         if not w:
             return "rf"
@@ -7860,18 +7954,30 @@
             self.df.window.winfo_rgb(w)
         except:
             return "Invalid Colour"
-        if p == 5:
+        if p == 6:
             self.rcdic["nfg"] = self.mf.rcdic["nfg"] = w
-        elif p == 6:
+        elif p == 7:
             self.rcdic["nbg"] = self.mf.rcdic["nbg"] = w
-        elif p == 8:
+        elif p == 9:
             self.rcdic["ffg"] = self.mf.rcdic["ffg"] = w
-        elif p == 9:
+        elif p == 10:
             self.rcdic["fbg"] = self.mf.rcdic["fbg"] = w
-        elif p == 11:
+        elif p == 12:
             self.rcdic["dfg"] = self.mf.rcdic["dfg"] = w
-        elif p == 12:
+        elif p == 13:
             self.rcdic["dbg"] = self.mf.rcdic["dbg"] = w
+        elif p == 15:
+            self.rcdic["qfg"] = self.mf.rcdic["qfg"] = w
+        elif p == 16:
+            self.rcdic["qbg"] = self.mf.rcdic["qbg"] = w
+        elif p == 18:
+            self.rcdic["cfg"] = self.mf.rcdic["cfg"] = w
+        elif p == 19:
+            self.rcdic["cbg"] = self.mf.rcdic["cbg"] = w
+        elif p == 21:
+            self.rcdic["sfg"] = self.mf.rcdic["sfg"] = w
+        elif p == 22:
+            self.rcdic["sbg"] = self.mf.rcdic["sbg"] = w
         self.mf.setThemeFont()
         self.setColours()
 
@@ -7897,14 +8003,12 @@
         #DataBase
         if self.rcdic["dbase"] == "FBird":
             dbase = "F"
-        elif self.rcdic["dbase"] == "MsSQL":
-            dbase = "Q"
         elif self.rcdic["dbase"] == "MySQL":
             dbase = "M"
+        elif self.rcdic["dbase"] == "PgSQL":
+            dbase = "P"
         elif self.rcdic["dbase"] == "SQLite":
             dbase = "S"
-        elif self.rcdic["dbase"] == "PgSQL":
-            dbase = "P"
         self.df.loadEntry("T",1,0,dbase)
         self.df.loadEntry("T",1,1,self.rcdic["dbname"])
         self.df.loadEntry("T",1,2,self.rcdic["dbhost"])
@@ -7934,19 +8038,29 @@
         self.df.loadEntry("T",3,2,self.rcdic["dft"])
         self.df.loadEntry("T",3,3,self.rcdic["dfs"])
         self.df.loadEntry("T",3,4,self.rcdic["theme"])
-        self.df.loadEntry("T",3,5,self.rcdic["nfg"])
-        self.df.loadEntry("T",3,6,self.rcdic["nbg"])
-        self.df.loadEntry("T",3,7,"PREVIEW")
-        self.df.loadEntry("T",3,8,self.rcdic["ffg"])
-        self.df.loadEntry("T",3,9,self.rcdic["fbg"])
-        self.df.loadEntry("T",3,10,"PREVIEW")
-        self.df.loadEntry("T",3,11,self.rcdic["dfg"])
-        self.df.loadEntry("T",3,12,self.rcdic["dbg"])
-        self.df.loadEntry("T",3,13,"PREVIEW")
+        self.df.loadEntry("T",3,5,self.rcdic["dcs"])
+        self.df.loadEntry("T",3,6,self.rcdic["nfg"])
+        self.df.loadEntry("T",3,7,self.rcdic["nbg"])
+        self.df.loadEntry("T",3,8,"PREVIEW")
+        self.df.loadEntry("T",3,9,self.rcdic["ffg"])
+        self.df.loadEntry("T",3,10,self.rcdic["fbg"])
+        self.df.loadEntry("T",3,11,"PREVIEW")
+        self.df.loadEntry("T",3,12,self.rcdic["dfg"])
+        self.df.loadEntry("T",3,13,self.rcdic["dbg"])
+        self.df.loadEntry("T",3,14,"PREVIEW")
+        self.df.loadEntry("T",3,15,self.rcdic["qfg"])
+        self.df.loadEntry("T",3,16,self.rcdic["qbg"])
+        self.df.loadEntry("T",3,17,"PREVIEW")
+        self.df.loadEntry("T",3,18,self.rcdic["cfg"])
+        self.df.loadEntry("T",3,19,self.rcdic["cbg"])
+        self.df.loadEntry("T",3,20,"PREVIEW")
+        self.df.loadEntry("T",3,21,self.rcdic["sfg"])
+        self.df.loadEntry("T",3,22,self.rcdic["sbg"])
+        self.df.loadEntry("T",3,23,"PREVIEW")
         self.setColours()
 
     def setColours(self):
-        for pos in xrange(5, 14, 3):
+        for pos in xrange(6, 24, 3):
             fg, bg = self.df.t_work[3][0][pos], self.df.t_work[3][0][pos+1]
             self.df.topEntry[3][pos+2].configure(foreground=fg, background=bg)
         self.df.window.update_idletasks()
@@ -7971,8 +8085,6 @@
         cc = []
         if self.df.t_work[1][0][0] == "F":
             cc.append(["dbase", "FBird"])
-        elif self.df.t_work[1][0][0] == "Q":
-            cc.append(["dbase", "MsSQL"])
         elif self.df.t_work[1][0][0] == "M":
             cc.append(["dbase", "MySQL"])
         elif self.df.t_work[1][0][0] == "P":
@@ -8010,12 +8122,19 @@
             ["dft", self.df.t_work[3][0][2]],
             ["dfs", self.df.t_work[3][0][3]],
             ["theme", self.df.t_work[3][0][4]],
-            ["nfg", self.df.t_work[3][0][5]],
-            ["nbg", self.df.t_work[3][0][6]],
-            ["ffg", self.df.t_work[3][0][8]],
-            ["fbg", self.df.t_work[3][0][9]],
-            ["dfg", self.df.t_work[3][0][11]],
-            ["dbg", self.df.t_work[3][0][12]]])
+            ["dcs", self.df.t_work[3][0][5]],
+            ["nfg", self.df.t_work[3][0][6]],
+            ["nbg", self.df.t_work[3][0][7]],
+            ["ffg", self.df.t_work[3][0][9]],
+            ["fbg", self.df.t_work[3][0][10]],
+            ["dfg", self.df.t_work[3][0][12]],
+            ["dbg", self.df.t_work[3][0][13]],
+            ["qfg", self.df.t_work[3][0][15]],
+            ["qbg", self.df.t_work[3][0][16]],
+            ["cfg", self.df.t_work[3][0][18]],
+            ["cbg", self.df.t_work[3][0][19]],
+            ["sfg", self.df.t_work[3][0][21]],
+            ["sbg", self.df.t_work[3][0][22]]])
         f = open(self.rcfile, "w")
         for a, b in cc:
             d = "['%s'] = '%s'" % (a, b)
@@ -9721,8 +9840,8 @@
                 if not accs:
                     accs = []
         else:
+            accs = []
             if self.sysdp[0] == "Y":
-                accs = []
                 for dep in deps:
                     glf = (dep * (10 ** (7 - self.sysdp[1]))) + glfrom
                     if glto:
@@ -11105,18 +11224,18 @@
         tdc = self.form.sql.tpldet_col
         self.doLoadStatic()
         self.form.doNewDetail()
-        for doc in self.docs:
-            self.docno = CCD(doc, "UI", 9.0)
+        for ivno in self.docs:
+            self.docno = CCD(ivno, "UI", 9)
             inv = self.sql.getRec(tables="bkmtrn", cols=["bkt_number",
                 "bkt_date"], where=[("bkt_cono", "=", self.conum),
-                ("bkt_type", "=", 2), ("bkt_refno", "=", "%9s" % doc)],
-                group="bkt_number, bkt_date", limit=1)
+                ("bkt_type", "=", 2), ("bkt_refno", "=", "%9s" % ivno)],
+                group="bkt_number, bkt_refno, bkt_date", limit=1)
             bkno, ivdt = inv
             mst = self.sql.getRec(tables="bkmmst", where=[("bkm_cono", "=",
                 self.conum), ("bkm_number", "=", bkno)], limit=1)
             bal = self.sql.getRec(tables="bkmtrn", cols=["sum(bkt_tramt)"],
                 where=[("bkt_cono", "=", self.conum), ("bkt_number", "=",
-                bkno), ("bkt_type", "<>", 1)], limit=1)
+                bkno)], limit=1)
             self.total_balance = CCD(bal[0], "SD", 13.2).work
             self.cod = mst[self.sql.bkmmst_col.index("bkm_ccode")]
             # bkmcon
@@ -11126,6 +11245,7 @@
                 if fld in self.form.tptp:
                     d = "%s_C00" % fld
                     self.form.newdic[d][txt] = con[ccc.index(fld)]
+                    self.form.tptp[fld][1] = con[ccc.index(fld)]
             # Account details
             if "contact_details" in self.form.tptp:
                 dat = "%s %s %s" % (
@@ -11137,20 +11257,22 @@
                 dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_addr3")])
                 dat = "%1s\n%1s" % (dat, con[ccc.index("bkc_pcode")])
                 self.form.tptp["contact_details"][1] = dat
+            # Document details
             self.eml = con[ccc.index("bkc_email")]
+            self.form.document_number(ivno)
             self.form.document_date(ivdt)
             for fld in mcc:
                 if fld in self.form.tptp:
                     self.form.tptp[fld][1] = mst[mcc.index(fld)]
             if "message" in self.form.tptp:
-                if mst[mcc.index("bkm_special")]:
+                if mst[mcc.index("bkm_remarks")]:
                     self.message = True
-                    self.form.tptp["message"][1] = mst[mcc.index("bkm_special")]
+                    self.form.tptp["message"][1] = mst[mcc.index("bkm_remarks")]
                 else:
                     self.message = False
             rtt = self.sql.getRec("bkmrtt", where=[("brt_cono", "=",
-                self.conum), ("brt_number", "=", bkno), ("brt_invno", "=",
-                doc)])
+                self.conum), ("brt_number", "=", bkno), ("brt_invno",
+                "=", self.docno.work)])
             self.doBody(ttc, rtt, tdc)
             self.total_movements = float(ASD(self.total_balance) - \
                 ASD(self.total_value))
@@ -11226,6 +11348,8 @@
                 else:
                     self.form.doDrawDetail(self.form.newdic[seq])
             count += 1
+        if not rtt:
+            count = self.doHeader(str(page), tdc)
         for x in xrange(count, self.form.maxlines):
             for cod in self.form.body:
                 seq = "%s_C%02i" % (cod, x)
@@ -11447,7 +11571,7 @@
         for emp in self.empnos:
             self.doPayslip(emp)
         sp.closeSplash()
-        if self.emadd or self.email.lower() == "n":
+        if self.emadd or self.email.lower() == "n" and self.form.page:
             key = "%s_all" % self.conum
             self.pdfnam = getModName(self.mf.rcdic["wrkdir"], "payslip", key,
                 ext="pdf")
@@ -11553,11 +11677,12 @@
                 value, self.bname, "", self.conam[:15], ""))
             self.etotal = float(ASD(self.etotal) + ASD(self.total))
         if not self.emadd and self.email.lower() == "y":
-            key = "%s_%s" % (self.conum, self.empno)
-            self.pdfnam = getModName(self.mf.rcdic["wrkdir"], "payslip",
-                key, ext="pdf")
-            self.form.output(self.pdfnam, "F")
-            self.doPrint()
+            if self.form.page:
+                key = "%s_%s" % (self.conum, self.empno)
+                self.pdfnam = getModName(self.mf.rcdic["wrkdir"], "payslip",
+                    key, ext="pdf")
+                self.form.output(self.pdfnam, "F")
+                self.doPrint()
             self.form = DrawForm(self.mf.dbm, self.tname)
             self.doLoadStatic()
             self.form.doNewDetail()
@@ -12784,11 +12909,9 @@
                     self.fpdf.lpp = lpp
         for x in xrange(0, len(recs)):
             if self.pbar:
-                can = pb.displayProgress(x)
-                if can == "yes":
+                pb.displayProgress(x)
+                if pb.quit:
                     break
-            else:
-                can = "no"
             if self.ttype == "D" and recs[x] == ["BLANK"]:
                 if not self.prtnam == "export":
                     self.fpdf.drawText()
@@ -12872,8 +12995,8 @@
                 self.expdatas.append(["BODY", cld])
         if self.pbar:
             pb.closeProgress()
-        if can == "yes":
-            return
+            if pb.quit:
+                return
         self.grandTotal()
         try:
             if self.prtnam == "export":
@@ -13551,17 +13674,19 @@
         mode - B(ackup), (R)store.
         csys - The ctlsys detail.
         ver  - The tartan version.
+        bar  - Whether to display a progressbar,
     """
-    def __init__(self, mf, mode="B", csys=None, ver=None):
+    def __init__(self, mf, mode="B", csys=None, ver=None, bar=True):
         self.mf = mf
         self.mode = mode
-        if self.mf.window and csys:
+        if csys:
             self.budays = csys[0]
             self.smtp = csys[1:]
         else:
             self.budays = 0
             self.smtp = None
         self.ver = ver
+        self.bar = bar
         if self.setVariables():
             if self.mode == "B":
                 if self.mf.window and self.smtp and self.smtp[1]:
@@ -13932,16 +14057,16 @@
             if self.mf.window:
                 p1.txtlab.configure(text="Backing Up Company %s" % coy[0])
                 p1.displayProgress(cn)
-            elif TBAR:
+            elif self.bar and TBAR:
                 print
-                p2 = TextBar(widgets=["%s: " % coy[0], Percentage(),
+                p2 = TextBar(widgets=["Company %s: " % coy[0], Percentage(),
                     Bar()], maxval=len(tabs)-1).start()
             for tn, tab in enumerate(tabs):
                 sql = Sql(self.mf.dbm, ["ffield", tab], prog=__name__)
                 if self.mf.window:
                     p2.txtlab.configure(text="Backing Up Table %s" % tab)
                     p2.displayProgress(tn)
-                elif TBAR:
+                elif self.bar and TBAR:
                     time.sleep(0.01)
                     p2.update(tn)
                 fld = sql.getRec(tables="ffield", cols=["ff_name"],
@@ -13976,27 +14101,11 @@
         if self.mf.window:
             p1.closeProgress()
             p2.closeProgress()
+        elif self.bar:
+            p2.finish()
+            print
 
     def doFullRestore(self):
-        # Create Database
-        #self.mf.dbm.closeDbase()
-        #opts = [
-        #    ("-c", "i"),
-        #    ("-d", "%s" % os.path.join(self.mf.rcdic["prgdir"], "csv")),
-        #    ("-l", self.mf.body),
-        #    ("-p", self.mf.rcdic["dbpwd"]),
-        #    ("-u", self.mf.rcdic["dbuser"]),
-        #    ("-w", False),
-        #    ("-x", True)]
-        #if self.sys:
-        #    opts.append(("-s", self.sys))
-        #else:
-        #    opts.append(("-s", "tartan"))
-        #create = DBCreate(dbm=self.mf.dbm, opts=opts)
-        #if not create.put:
-        #    return
-        # Open the database
-        #self.mf.dbm.openDbase()
         # Restore the Files
         files = glob.glob(os.path.join(self.tmpdir, "??????_*.dat"))
         files.sort()
@@ -14017,11 +14126,9 @@
             zipfle.close()
             if data:
                 newd = self.extractData(data)
-                p2 = ProgressBar(self.mf.body, mxs=len(newd),
-                    typ="Restoring Table (%s)" % base, inn=p1)
-                for num2, dat in enumerate(newd):
-                    p2.displayProgress(num2)
-                    sql.insRec(name, data=dat, format=False)
+                p2 = ProgressBar(self.mf.body, inn=p1, mxs=len(newd),
+                    typ="Restoring Table (%s)" % base)
+                sql.insRec(name, data=newd, dofmt=False, pbar=p2)
                 p2.closeProgress()
         p1.closeProgress()
         self.mf.dbm.commitDbase()
@@ -14056,11 +14163,9 @@
                     zipfle.close()
                     if data:
                         newd = self.extractData(data)
-                        p2 = ProgressBar(self.mf.body, mxs=len(newd),
-                            typ="Restoring Table (%s)" % tab, inn=p1)
-                        for num, dat in enumerate(newd):
-                            p2.displayProgress(num)
-                            sql.insRec(tab, data=dat, format=False)
+                        p2 = ProgressBar(self.mf.body, inn=p1, mxs=len(newd),
+                            typ="Restoring Table (%s)" % tab)
+                        sql.insRec(tab, data=newd, dofmt=False, pbar=p2)
                         p2.closeProgress()
         p1.closeProgress()
         self.mf.dbm.commitDbase()
@@ -14892,7 +14997,7 @@
             self.ip.closeProcess()
             self.mf.closeLoop()
 
-class MyFpdf(FPDF):
+class MyFpdf(fpdf.FPDF):
     """
     head - String or List / Tuple as folows:
                 Text - Heading or
@@ -14906,7 +15011,7 @@
         self.suc = chr(151)
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
-        FPDF.__init__(self, orientation, self.unit, self.fmat)
+        fpdf.FPDF.__init__(self, orientation, self.unit, self.fmat)
         if name and head and type(head) not in (list, tuple):
             self.setValues(name, head, font)
         else:
@@ -15094,9 +15199,10 @@
         self._out("/PageLayout /OneColumn")
 
 class DrawForm(MyFpdf):
-    def __init__(self, dbm, tname):
+    def __init__(self, dbm, tname, wrkdir=None):
         self.dbm = dbm
         self.tname = tname
+        self.wrkdir = wrkdir
         if self.setVariables():
             MyFpdf.__init__(self, orientation=self.ortn, fmat=self.pgsz)
             self.set_title(self.titl)
@@ -15457,7 +15563,8 @@
             if "LETTERHEAD" in os.environ:
                 img = os.environ["LETTERHEAD"]
             else:
-                img = ctm[cmc.index("ctm_logo")]
+                img = getFileName(ctm[cmc.index("ctm_logo")],
+                    wrkdir=self.wrkdir)
             if not img or not os.path.isfile(img):
                 del self.tptp[fld]
                 for col in ("ctm_regno", "ctm_taxno", "ctm_tel", "ctm_fax"):
@@ -15474,6 +15581,10 @@
             if col in self.tptp:
                 del self.tptp[col]
 
+    def document_number(self, number):
+        if "document_number" in self.tptp:
+            self.tptp["document_number"][1] = number
+
     def document_date(self, date):
         if "document_date" in self.tptp:
             self.tptp["document_date"][1] = date

=== modified file 'std/tartanFunctions.py'
--- std/tartanFunctions.py	2014-12-30 15:37:38 +0000
+++ std/tartanFunctions.py	2015-02-05 08:21:19 +0000
@@ -147,17 +147,24 @@
         "acnf": ["L"],
         "ttip": ["Y"],
         "errs": ["Y"],
-        "mft": ["Arial", "Arial"],
+        "mft": ["DejaVu Serif", "Arial"],
         "mfs": [0],
-        "dft": ["Courier New", "Courier New"],
+        "dft": ["DejaVu Sans Mono", "Courier New"],
         "dfs": [0],
-        "theme": ["clam", "clam"],
+        "theme": ["clam"],
+        "dcs": ["R"],
         "nfg": ["#ffffff"],
         "nbg": ["#a40204"],
         "ffg": ["#ffffff"],
         "fbg": ["#044e1c"],
         "dfg": ["#000000"],
-        "dbg": ["#ffffff"]}
+        "dbg": ["#ffffff"],
+        "qfg": ["#000000"],
+        "qbg": ["#ffc0cb"],
+        "cfg": ["#000000"],
+        "cbg": ["#add8e6"],
+        "sfg": ["#000000"],
+        "sbg": ["#90ee90"]}
     pths = ("dbdir", "prgdir", "bupdir", "wrkdir", "upgdir")
     # Read and load rcfile
     if not rcfile:
@@ -222,6 +229,8 @@
     rcdic["geo"] = "%sx%s" % (w, h)
     rcdic["mfs"] = m
     rcdic["dfs"] = f
+    if rcdic["theme"] not in ("alt", "clam", "classic", "default"):
+        rcdic["theme"] = "clam"
     if os.path.exists(rcfile):
         # Create missing directories
         check = []
@@ -504,7 +513,7 @@
                     sp = SplashScreen(mf.body,
                         "E-Mailing the Report to:\n\n%s\n\nPlease Wait....." %
                         mail[0])
-                if not attach:
+                if not attach or not attach[0]:
                     att = [rep]
                 else:
                     att = [rep] + attach[:]
@@ -1012,16 +1021,16 @@
     import sys
     data = ["None", "Default"]
     if sys.platform == "win32":
-        import win32print
         try:
+            import win32print
             lst = win32print.EnumPrinters(2)
             for l in lst:
                 data.append(l[2].strip())
         except:
-            pass
+            showException(None, ".", "Show Printer Error")
     else:
-        import subprocess
         try:
+            import subprocess
             proc = subprocess.Popen("lpstat -a", shell=True, bufsize=0,
                 stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
             lst = proc.stdout.readlines()
@@ -1031,7 +1040,7 @@
                     p = l.split()
                     data.append(p[0].strip())
         except:
-            pass
+            showException(None, ".", "Show Printer Error")
     return data
 
 def deepList(data):
@@ -2046,5 +2055,52 @@
     com = name.split(".")[-1]
     mod = getattr(mod, com)
     return mod(**popt)
+
+def getFileName(path, wrkdir=None, check=False):
+    import os, sys
+    if sys.platform == "win32" or not path[:2] in ("\\\\", "\\", "//"):
+        # Normal path
+        if os.path.isfile(path):
+            if check:
+                return True
+            else:
+                return path
+        else:
+            return
+    # UNC path
+    try:
+        from smb.SMBConnection import SMBConnection
+        con = None
+        fle = None
+        pth = None
+        svr = path.replace("/", "|").replace("\\", "|")
+        svr = svr.split("|")
+        con = SMBConnection("", "", "", svr[2])
+        con.connect(svr[2])
+        for p in svr[4:]:
+            if not pth:
+                pth = p
+            else:
+                pth = os.path.join(pth, p)
+        con.getAttributes(svr[3], pth)
+        if check:
+            con.close()
+            return True
+        if wrkdir:
+            nam = os.path.join(wrkdir, os.path.basename(pth))
+        else:
+            nam = os.path.basename(pth)
+        if not os.path.exists(nam):
+            fle = open(nam, "wb")
+            con.retrieveFileFromOffset(svr[3], pth, fle)
+            fle.close()
+        con.close()
+        return nam
+    except:
+        if fle:
+            fle.close()
+        if con:
+            con.close()
+        return
 # END
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'std/tartanWork.py'
--- std/tartanWork.py	2014-12-30 15:37:38 +0000
+++ std/tartanWork.py	2015-01-03 13:17:10 +0000
@@ -184,6 +184,7 @@
         "tables": ["ctlmst"],
         "codes": {
             "bank_details": [["", "RW", 30, "Bank Details"], []],
+            "document_number": [["", "UI", 9, "Document Number"], []],
             "document_date": [["", "D1", 10, "Document Date"], []],
             "document_type": [["", "RW", 0, "Document Type"], []],
             "letterhead": [["", "RW", 0, "Company Letterhead"], []],

=== modified file 'str/st3010.py'
--- str/st3010.py	2014-12-30 15:37:38 +0000
+++ str/st3010.py	2015-01-27 16:35:40 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %43s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.strtrn_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 1)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -147,16 +149,13 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
                 prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
-        else:
-            showError(self.opts["mf"].body, "Batch Errors",
-                "No Batch Transactions")
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'str/st3020.py'
--- str/st3020.py	2014-12-30 15:37:38 +0000
+++ str/st3020.py	2015-01-27 15:42:26 +0000
@@ -181,11 +181,8 @@
         self.pglin = 999
         col = self.sql.strtrn_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             trtp = CCD(dat[col.index("stt_type")], "UI", 2)
             batch = CCD(dat[col.index("stt_batch")], "Na", 7)
@@ -236,17 +233,16 @@
             self.gsel[trtp.work -1] = float(ASD(self.gsel[trtp.work -1]) + \
                 ASD(sell.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'str/st3030.py'
--- str/st3030.py	2014-12-30 15:37:38 +0000
+++ str/st3030.py	2015-01-27 15:44:38 +0000
@@ -202,8 +202,8 @@
                 ("SD", 10.2), ("SD", 10.2), ("SD", 10.2)]
         expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -239,11 +239,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -271,10 +268,11 @@
             self.pglin += 1
             old_grp = grp.work
         p.closeProgress()
-        self.fpdf.output(self.pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=self.pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.fpdf.output(self.pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=self.pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def printCost(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
@@ -285,11 +283,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -304,10 +299,11 @@
             self.pglin += 1
             old_grp = grp.work
         p.closeProgress()
-        self.fpdf.output(self.pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            rep=self.pdfnam, head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.fpdf.output(self.pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=self.pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         grp = CCD(data[0], "UA", 3)

=== modified file 'str/st3040.py'
--- str/st3040.py	2014-12-30 15:37:38 +0000
+++ str/st3040.py	2015-01-27 15:45:45 +0000
@@ -105,11 +105,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[0], "UA", 3)
             self.groupd = grp.disp
@@ -127,12 +124,13 @@
             self.pglin += 1
             old_grp = grp.work
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'str/st3050.py'
--- str/st3050.py	2014-12-30 15:37:38 +0000
+++ str/st3050.py	2015-01-27 15:46:08 +0000
@@ -142,11 +142,8 @@
         st1 = self.sql.strmf1_col
         srr = self.sql.strrcp_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[st1.index("st1_group")], "UA", 3)
             cod = CCD(dat[st1.index("st1_code")], "NA", 20)
@@ -180,12 +177,13 @@
                 self.pglin += 1
                 oldrec = newrec
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, grp, cod, chg=False):
         if self.pgnum and self.page == "N" and chg and \

=== modified file 'str/st3060.py'
--- str/st3060.py	2014-12-30 15:37:38 +0000
+++ str/st3060.py	2015-01-27 15:46:37 +0000
@@ -146,8 +146,8 @@
             ("SD", 12,2), ("SD", 12.2), ("SD", 12.2), ("SD", 12.2)]
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -172,11 +172,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -193,17 +190,16 @@
             self.pglin += 1
             old_grp = grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit,
-            view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.groupTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit,
+                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def getValues(self, data):

=== modified file 'str/st3070.py'
--- str/st3070.py	2014-12-30 15:37:38 +0000
+++ str/st3070.py	2015-01-27 15:47:53 +0000
@@ -133,12 +133,13 @@
         else:
             self.printSetup(recs)
             self.processRecords(recs)
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.df.repprt[0][1],
-                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+            if self.fpdf.page and not self.p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.df.repprt[0][1],
+                    prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def printSetup(self, recs):
@@ -152,10 +153,7 @@
     def processRecords(self, recs):
         for num, dat in enumerate(recs):
             can = self.p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            if self.p.quit:
                 break
             self.ord = CCD(dat[0], "Na", 9)
             self.pot = self.sql.getRec(tables="strpot", cols=["pot_group",

=== modified file 'str/st3080.py'
--- str/st3080.py	2014-12-30 15:37:38 +0000
+++ str/st3080.py	2015-01-27 15:49:03 +0000
@@ -154,8 +154,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -179,11 +179,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -200,16 +197,15 @@
             self.stot = float(ASD(self.stot) + ASD(vbal.work))
             old_grp = grp.work
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.groupTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.groupTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def getValues(self, data):
         grp = CCD(data[0], "UA", 3)

=== modified file 'str/st3090.py'
--- str/st3090.py	2014-12-30 15:37:38 +0000
+++ str/st3090.py	2015-01-27 15:49:25 +0000
@@ -146,11 +146,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[0], "UA", 3)
             cod = CCD(dat[1], "NA", 20)
@@ -190,12 +187,13 @@
                         dt.disp, qt.disp, cs.disp, qb.disp, vb.disp))
                     self.pglin += 1
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self, grp, cod, desc):
         self.fpdf.add_page()

=== modified file 'str/st3100.py'
--- str/st3100.py	2014-12-30 15:37:38 +0000
+++ str/st3100.py	2015-01-27 15:49:44 +0000
@@ -41,8 +41,8 @@
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
             mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -59,7 +59,7 @@
                 else:
                     data.append(["", "", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Debtor's Masterfile Notes Listing"]
             cols = [

=== modified file 'str/st3110.py'
--- str/st3110.py	2014-12-30 15:37:38 +0000
+++ str/st3110.py	2015-01-27 15:50:24 +0000
@@ -201,20 +201,18 @@
             self.fpdf.add_page()
             p = ProgressBar(self.opts["mf"].body, mxs=len(rec), esc=True)
             for num, dat in enumerate(rec):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(dat)
             p.closeProgress()
-            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-                self.opts["conum"], ext="pdf")
-            self.fpdf.output(pdfnam, "F")
-            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-                head=self.tit, view=self.view, prtnam=self.prtnam,
-                mail=self.emadd)
+            if self.fpdf.page and not p.quit:
+                pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                    self.opts["conum"], ext="pdf")
+                self.fpdf.output(pdfnam, "F")
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    rep=pdfnam, head=self.tit, view=self.view,
+                    prtnam=self.prtnam, mail=self.emadd)
         self.closeProcess()
 
     def doProcess(self, dat):

=== modified file 'str/st3120.py'
--- str/st3120.py	2014-12-30 15:37:38 +0000
+++ str/st3120.py	2015-01-27 15:50:51 +0000
@@ -140,8 +140,8 @@
         self.expforms = self.forms
         self.expdatas = []
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
@@ -175,11 +175,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             vals = self.getValues(dat)
             if not vals:
@@ -191,14 +188,13 @@
                 vals[5].disp, vals[6].disp, vals[7].disp))
             self.pglin += 1
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                if self.pglin > (self.fpdf.lpp - 2):
-                    self.pageHeading()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            if self.pglin > (self.fpdf.lpp - 2):
+                self.pageHeading()
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def getValues(self, data):

=== modified file 'str/st4010.py'
--- str/st4010.py	2014-12-30 15:37:38 +0000
+++ str/st4010.py	2015-01-12 13:04:35 +0000
@@ -289,7 +289,6 @@
             self.opts["period"][0])))
         m_ob, m_mv, m_cb, y_ob, y_mv, y_cb, ac, lc, = bals.doStrBals()
         cb, oo, bo = bals.doStrOrds()
-        print cb.work, oo.work, bo.work
         this, hist = bals.doStrHist()
         rec = hist[0]
         rec.append(this[0])

=== modified file 'str/st5010.py'
--- str/st5010.py	2014-12-30 15:37:38 +0000
+++ str/st5010.py	2015-01-27 15:51:09 +0000
@@ -181,11 +181,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[0], "UA", 3)
             self.groupd = grp.disp
@@ -213,12 +210,13 @@
             if self.qty and count >= self.qty:
                 break
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'str/st5030.py'
--- str/st5030.py	2014-12-30 15:37:38 +0000
+++ str/st5030.py	2015-01-27 15:51:29 +0000
@@ -77,11 +77,8 @@
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             grp = CCD(dat[self.sql.strvar_col.index("stv_group")], "UA", 3)
             code = CCD(dat[self.sql.strvar_col.index("stv_code")], "NA", 20)
@@ -113,12 +110,13 @@
                 fprice.disp, prc1.disp, fqbal.disp, qty1.disp, diff.disp))
             self.pglin += 1
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
         self.closeProcess()
 
     def pageHeading(self):

=== modified file 'str/st6010.py'
--- str/st6010.py	2014-12-30 15:37:38 +0000
+++ str/st6010.py	2015-01-27 16:26:27 +0000
@@ -107,7 +107,7 @@
         fi = FileImport(self.opts["mf"], impcol=impcol)
         if fi.impdat:
             p = ProgressBar(self.opts["mf"].body, typ="Importing Changes",
-                mxs=len(fi.impdat), esc=False)
+                mxs=len(fi.impdat))
             for num, line in enumerate(fi.impdat):
                 p.displayProgress(num)
                 self.oldgrp, self.newgrp, self.oldcod = line[:3]

=== modified file 'tab/tb1020.py'
--- tab/tb1020.py	2015-01-01 12:48:11 +0000
+++ tab/tb1020.py	2015-01-24 12:45:27 +0000
@@ -10,17 +10,17 @@
 
     CLI Usage: python tb1020.py [options]
 
-    -b              = Show a progress bar
-    -c              = Clean the DataBase i.e. remove unwanted tables etc
-    -d [directory]  = Directory where .csv files are, defaults to "~/prg/csv"
-    -f              = Force reformat of all fields
-    -h              = Display Usage
-    -p [password]   = Database Admin Password
-    -r [file]       = tartanrc file to use, defaults to ~/.tartanrc
-    -s [system]     = system file to use, defaults to tartan
-    -t [table]      = String of comma separated Table Names e.g. strmf1,strmf2
-    -u [user]       = Database Admin User Name
-    -v [x.x.x]      = The New version number
+    mf               = The MainFrame object
+    bar [True/False] = Show a progress bar
+    cln [True/False] = Clean the DataBase i.e. remove unwanted tables etc
+    pth [directory]  = Directory where .csv files are, defaults to "~/prg/csv"
+    pwd [password]   = Database Admin Password
+    rcf [file]       = tartanrc file to use, defaults to ~/.tartanrc
+    sys [system]     = system file to use, defaults to tartan
+    tab [table]      = String of comma separated Table Names e.g. strmf1,strmf2
+    upd [True/False] = Force Update of all records, True or False
+    usr [user]       = Database Admin User Name
+    ver [x.x.x]      = The New version number
 
 AUTHOR
     Written by Paul Malherbe, <paul@tartan.co.za>
@@ -29,12 +29,8 @@
     Copyright (C) 2004-2015 Paul Malherbe.
 """
 
-TIMER = False
-
 import csv, os, sys, time
 try:
-    if TIMER:
-        raise Exception
     from progressbar import Bar, Percentage
     from progressbar import ProgressBar as TextBar
     TBAR = True
@@ -51,6 +47,7 @@
         self.tab = opts["tab"]
         if self.setVariables():
             if not self.part and self.oldver[0] and self.oldver[0] < 5:
+                self.doDelLog()
                 self.doCvtVat()
             if "ctlbat" in self.tab:
                 self.doDelBatch()
@@ -155,6 +152,12 @@
             "wagtf1": ["wt1_capdt", "wt1_seq"]}
         return True
 
+    def doDelLog(self):
+        self.dbm.dropTable("ctllog", frecs=True)
+        if "ctllog" in self.tab:
+            self.tab.remove("ctllog")
+        self.dbm.commitDbase()
+
     def doCvtVat(self):
         sql = Sql(self.dbm, "ftable", prog=__name__)
         if not sql.getRec(tables="ftable", where=[("ft_tabl", "=", "ctlvmf")]):
@@ -177,8 +180,9 @@
         chk = sql.getRec(tables="ftable", cols=["ft_type"],
             where=[("ft_tabl", "=", "ctlbat"), ("ft_seq", "=", 1)], limit=1)
         if chk[0] == "N":
-            sql.delRec("ctlbat")
-            sql.sqlRec("Drop index ctlbat_key1")
+            self.dbm.dropTable("ctlbat", frecs=True)
+            if "ctlbat" in self.tab:
+                self.tab.remove("ctlbat")
             self.dbm.commitDbase()
 
     def doProcessTables(self):
@@ -197,11 +201,11 @@
             if not chk:
                 chk = self.doReadTables("fld")
             if chk:
-                if chk == "new":
+                if chk == "csv":
                     continue
                 recs = True
                 self.doNewTable()
-            elif self.opts["fmt"]:
+            elif self.opts["upd"]:
                 recs = True
                 self.doNewTable()
             elif self.oldfld != self.newfld:
@@ -272,7 +276,7 @@
                     "Csv file for %s Table Not Found" % csf)
             else:
                 print "Csv file for %s Table Not Found" % csf
-            return "new"
+            return "csv"
         new = []
         of = open(csf, "rb")
         ot = csv.reader(of, quoting=csv.QUOTE_MINIMAL)
@@ -300,7 +304,7 @@
 
     def doNewTable(self):
         if self.table == "ctlvtf":
-            # Delete old VAT Transaction records
+            # Delete old VAT transaction records (Period 0)
             sql = Sql(self.dbm, ["ctlynd", self.table], prog=__name__)
             ynd = sql.getRec(tables="ctlynd", cols=["cye_cono", "cye_start"],
                 where=[("cye_period", "=", 0)], order="cye_cono")
@@ -311,9 +315,6 @@
         else:
             sql = Sql(self.dbm, self.table, prog=__name__)
         # Read Existing Table
-        if TIMER:
-            print self.table
-            start_time = time.time()
         order = ""
         if self.table in self.tabord:
             exec "cols = sql.%s_col" % self.table
@@ -325,8 +326,6 @@
                     else:
                         order = "%s, %s" % (order, fld)
         data = sql.getRec(tables=self.table, order=order)
-        if TIMER:
-            print "Read Table", time.time() - start_time
         # New sys_smtp and sys_sms fields 5.0.0
         if self.table == "ctlsys" and "sys_smtp" in sql.ctlsys_col:
             if data:
@@ -372,15 +371,12 @@
                 self.snam = ""
                 self.spwd = ""
         # Create New Table
-        if TIMER:
-            start_time = time.time()
         opts = self.topts[:]
-        opts.append(("-i", False))
+        #opts.extend([("-t", self.table), ("-i", False)])
         opts.append(("-t", self.table))
         DBCreate(dbm=self.dbm, opts=opts)
-        if TIMER:
-            print "Create Table", time.time() - start_time
-        if data not in (None, Exception, "Exception"):
+        ndata = []
+        if data and data not in (Exception, "Exception"):
             sql = Sql(self.dbm, self.table, prog=__name__)
             # Create Dictionaries
             olddic = {}
@@ -390,32 +386,36 @@
             for f in self.newfld:
                 newdic[f[2]] = f[1:]
             # Populate New Table
-            if TIMER:
-                timer = False
-                start_time = time.time()
-            if self.table in ("genrpc", "genstr"):
-                seq = 0
             if self.opts["bar"] and self.opts["mf"] and self.opts["mf"].window:
-                self.p2 = ProgressBar(self.opts["mf"].body, inn=self.p1,
+                pbar = "w"
+                p2 = ProgressBar(self.opts["mf"].body, inn=self.p1,
                     typ="Updating Table %s" % self.table, mxs=len(data))
             elif self.opts["bar"] and TBAR:
-                self.p2 = TextBar(widgets=["%s: " % self.table, Percentage(),
+                pbar = "t"
+                p2 = TextBar(widgets=["%s: " % self.table, Percentage(),
                     Bar()], maxval=len(data)+1).start()
+            else:
+                pbar = None
             for num, old in enumerate(data):
-                if self.opts["bar"] and self.opts["mf"] and \
-                                    self.opts["mf"].window:
-                    self.p2.displayProgress(num)
-                elif self.opts["bar"] and TBAR:
+                if pbar == "w":
+                    p2.displayProgress(num)
+                elif pbar == "t":
                     time.sleep(0.001)
-                    self.p2.update(num + 1)
+                    p2.update(num + 1)
                 dat = []
                 for ind, csf in enumerate(self.newfld):
                     typ = newdic[csf[2]][2]
                     siz = newdic[csf[2]][3]
                     if csf[2] in olddic:
                         new = old[olddic[csf[2]][0]]
+                        if self.table == "telmst" and "tdm_telcd" in olddic:
+                            cod = old[olddic["tdm_telcd"][0]]
+                            if cod and csf[2] in ("tdm_telno", "tdm_faxno"):
+                                new = "%s %s" % (cod, new)
                     elif self.table == "asstrn" and csf[2] == "ast_capnm":
                         new = "Unknown"
+                    elif self.table == "bkmmst" and csf[2] == "bkm_remarks":
+                        new = old[olddic["bkm_special"][0]]
                     elif self.table == "bkmrtt" and csf[2] == "brt_uroom":
                         new = 0
                     elif self.table == "bkmunm" and csf[2] == "bum_btyp":
@@ -427,11 +427,13 @@
                             new = old[olddic["bum_guests"][0]]
                     elif self.table == "bkmunm" and csf[2] == "bum_room":
                         if old[olddic["bum_multi"][0]] == "Y":
-                            new = 999
+                            new = 1
                         elif old[olddic["bum_type"][0]] == "A":
                             new = old[olddic["bum_guests"][0]] / 2
                         else:
                             new = 0
+                    elif self.table == "bkmunm" and csf[2] == "bum_dflt":
+                        new = 1
                     elif self.table == "bwlctl" and csf[2] == "ctb_dbase":
                         new = "C"
                     elif self.table == "bwlctl" and csf[2] == "ctb_order":
@@ -551,26 +553,20 @@
                         new = 0
                     new = CCD(new, typ, siz)
                     dat.append(new.work)
-                if TIMER and not timer:
-                    print "Format Record", time.time() - start_time
-                ### Work around unique keys
-                if self.table == "drstrn":
-                    unique = "drt_ref1"
-                elif self.table == "crstrn":
-                    unique = "crt_ref1"
-                else:
-                    unique = None
-                sql.insRec(self.table, data=dat, unique=unique, format=False)
-                ###
-                if TIMER and not timer:
-                    print "Write Record", time.time() - start_time
-                    timer = True
-            if TIMER:
-                print "Write Table", time.time() - start_time
-            if self.opts["bar"] and self.opts["mf"] and self.opts["mf"].window:
-                self.p2.closeProgress()
-            elif self.opts["bar"] and TBAR:
-                self.p2.finish()
+                ndata.append(dat)
+            if pbar == "t":
+                p2.finish()
+                p2 = None
+            if ndata:
+                txt = "Populating Table (%s)" % self.table
+                if pbar == "w":
+                    p2.mxs = len(ndata)
+                    p2.txtlab.configure(text=txt)
+                elif pbar == "t":
+                    print txt
+                sql.insRec(self.table, data=ndata, dofmt=False, pbar=p2)
+            if pbar == "w":
+                p2.closeProgress()
         self.dbm.commitDbase()
 
     def doWagCal(self):
@@ -682,6 +678,7 @@
             if l in ("ftable", "ffield"):
                 continue
             csf.append(l)
+        # Removing unused tables
         tot = len(self.tab) + len(csf)
         if self.opts["bar"] and self.opts["mf"] and  self.opts["mf"].window:
             pb = ProgressBar(self.opts["mf"].body, mxs=tot, typ=txt)
@@ -690,12 +687,14 @@
                 self.opts["mf"].updateStatus(t)
                 if self.opts["bar"]:
                     pb.displayProgress(n1)
-            sql = Sql(self.dbm, t, prog=__name__)
             if t not in csf:
+                sql = Sql(self.dbm, t, prog=__name__)
                 sql.sqlRec("Drop table %s" % t, excp=True)
                 self.doRemoveTable(t)
             elif not self.dbm.checkTable(t):
                 self.doRemoveTable(t)
+        self.dbm.commitDbase()
+        # Creating new tables and/or indexes
         if self.opts["mf"] and  self.opts["mf"].window:
             self.opts["mf"].updateStatus("")
         for n2, t in enumerate(csf):
@@ -710,10 +709,12 @@
                 self.tab.append(t)
             else:
                 self.doCreateIndexes(t)
+        self.dbm.commitDbase()
         if self.opts["mf"] and  self.opts["mf"].window:
             self.opts["mf"].updateStatus("")
             if self.opts["bar"]:
                 pb.closeProgress()
+        # Standard Records
         if self.opts["mf"] and  self.opts["mf"].window:
             spl = SplashScreen(self.opts["mf"].body,
                 "Creating Standard Records\n\nPlease Wait")
@@ -801,65 +802,58 @@
                     l[0] = int(l[0])
                 sql.insRec(table, data=l)
 
-    def doCreateIndexes(self, table, check=True, commit=True):
-        if sys.platform=="win32" or self.rcdic["dbase"] in ("FBird", "MySQL"):
-            if table in ("memkon", "emllog"):
-                return
-        keys = self.sql.getRec(tables="ftable", where=[("ft_tabl","=", table)])
-        if not keys:
-            return
-        if self.opts["mf"] and  self.opts["mf"].window:
-            self.opts["mf"].updateStatus("Creating New Indexes for %s" % table)
-        for key in keys:
-            nam = "%s_key%s" % (table, str(key[2]))
-            if check and self.doCheckIndex(table, nam):
-                continue
-            idx = ""
-            for k in key[4:]:
-                if k:
-                    if idx:
-                        idx = "%s,%s" % (idx, k)
-                    else:
-                        idx = k
-            if key[3] == "N":
-                sql = "Create index"
-            else:
-                sql = "Create unique index"
-            try:
-                self.sql.sqlRec("%s %s on %s (%s)" % (sql, nam, table, idx))
-            except:
-                pass
-        if commit:
-            self.dbm.commitDbase()
-
     def doCheckIndex(self, table, index):
         if self.rcdic["dbase"] == "PgSQL":
             sel = "Select * from pg_indexes where schemaname='public' "\
                 "and tablename='%s' and indexname='%s'" % (table, index)
-            return self.sql.sqlRec(sel, limit=1)
         elif self.rcdic["dbase"] == "SQLite":
             sel = "Select * from sqlite_master where type='index' "\
                 "and tbl_name='%s' and name='%s'" % (table, index)
-            return self.sql.sqlRec(sel, limit=1)
         elif self.rcdic["dbase"] == "FBird":
             sel = "Select * from rdb$indices where rdb$relation_name in "\
                 "('%s', '%s') and rdb$index_name in ('%s', '%s')" % \
                 (table.lower(), table.upper(), index.lower(), index.upper())
-            return self.sql.sqlRec(sel, limit=1)
         elif self.opts["mf"].rcdic["dbase"] == "MySQL":
             sel = "Show indexes from %s where key_name = '%s'" % (table, index)
-            return self.sql.sqlRec(sel, limit=1)
+        return self.sql.sqlRec(sel, limit=1)
+
+    def doCreateIndexes(self, table):
+        if sys.platform=="win32" or self.rcdic["dbase"] in ("FBird", "MySQL"):
+            if table in ("memkon", "emllog"):
+                return
+        keys = self.sql.getRec(tables="ftable", where=[("ft_tabl","=", table)])
+        if not keys:
+            return
+        if self.opts["mf"] and  self.opts["mf"].window:
+            self.opts["mf"].updateStatus("Creating New Indexes for %s" % table)
+        for key in keys:
+            nam = "%s_key%s" % (table, str(key[2]))
+            if not self.doCheckIndex(table, nam):
+                idx = ""
+                for k in key[4:]:
+                    if k:
+                        if idx:
+                            idx = "%s,%s" % (idx, k)
+                        else:
+                            idx = k
+                if key[3] == "N":
+                    sql = "Create index"
+                else:
+                    sql = "Create unique index"
+                try:
+                    self.sql.sqlRec("%s %s on %s (%s)" % (sql, nam, table, idx))
+                except:
+                    pass
 
     def doRemoveTable(self, t):
         self.sql.delRec("ftable", cols=["ft_tabl"], data=[t])
         self.sql.delRec("ffield", cols=["ff_tabl"], data=[t])
-        self.dbm.commitDbase()
 
 if __name__ == "__main__":
     import getopt
-    opts, args = getopt.getopt(sys.argv[1:], "bcd:fhp:r:s:t:u:v:")
-    parg = {"mf": None, "bar": False, "cln": False, "pth": None,
-        "fmt": False, "pwd": "", "rcf": None, "sys": "tartan",
+    opts, args = getopt.getopt(sys.argv[1:], "b:c:d:f:hp:r:s:t:u:v:")
+    parg = {"mf": None, "bar": False, "cln": True, "pth": None,
+        "upd": False, "pwd": "", "rcf": None, "sys": "tartan",
         "tab": [], "usr": "", "ver": None}
     for o, v in opts:
         if o == "-h":
@@ -871,7 +865,7 @@
     -b              = Show a progress bar
     -c              = Clean the DataBase i.e. remove unwanted tables etc
     -d [directory]  = Directory where .csv files are, defaults to "~/prg/csv"
-    -f              = Force reformat of all fields
+    -f              = Force update of all records
     -h              = Display Usage
     -p [password]   = Database Admin Password
     -r [file]       = tartanrc file to use, defaults to ~/.tartanrc
@@ -882,13 +876,13 @@
 """
             sys.exit()
         elif o == "-b":
-            parg["bar"] = True
+            parg["bar"] = v
         elif o == "-c":
-            parg["cln"] = True
+            parg["cln"] = v
         elif o == "-d":
             parg["pth"] = v
         elif o == "-f":
-            parg["fmt"] = True
+            parg["upd"] = v
         elif o == "-p":
             parg["pwd"] = v
         elif o == "-r":
@@ -907,6 +901,9 @@
             parg["usr"] = v
         elif o == "-v":
             parg["ver"] = v
-    tb1020(**parg)
+    if not "ver" in parg:
+        print "Invalid -v version_number"
+    else:
+        tb1020(**parg)
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'tab/tb1030.py'
--- tab/tb1030.py	2014-12-30 15:37:38 +0000
+++ tab/tb1030.py	2015-01-27 09:27:09 +0000
@@ -175,9 +175,9 @@
             sc = SChoice(self.opts["mf"], scrn=self.opts["mf"].body, titl=titl,
                 head=hed, data=dat, retn="I", mode="S")
             self.df.enableButtonsTags(state=state)
-            if sc.selection:
+            if sc.selection is not None:
                 self.read = "Y"
-                self.olddata = recs[sc.selection[0]]
+                self.olddata = recs[sc.selection]
                 for num, dat in enumerate(self.olddata):
                     if self.pgs == 1:
                         pag = 0

=== modified file 'tab/tb1040.py'
--- tab/tb1040.py	2014-12-30 15:37:38 +0000
+++ tab/tb1040.py	2015-01-24 13:56:09 +0000
@@ -164,12 +164,10 @@
             if dat:
                 p2 = ProgressBar(self.opts["mf"].body, inn=p1, mxs=len(dat),
                     typ="Populating Table %s" % tab[0])
-                for n, d in enumerate(dat):
-                    p2.displayProgress(n)
-                    err = sqt.insRec(tab[0], data=d)
-                    if err:
-                        showError(self.opts["mf"].body, "Table Error", err)
+                err = sqt.insRec(tab[0], data=dat, dofmt=False, pbar=p2)
                 p2.closeProgress()
+                if err:
+                    showError(self.opts["mf"].body, "Table Error", err)
                 if not err:
                     self.opts["mf"].dbm.commitDbase()
         p1.closeProgress()

=== modified file 'tab/tb3010.py'
--- tab/tb3010.py	2014-12-30 15:37:38 +0000
+++ tab/tb3010.py	2015-01-27 15:52:24 +0000
@@ -99,11 +99,8 @@
         self.pgnum = 0
         p = ProgressBar(self.opts["mf"].body, mxs=len(tabs), esc=True)
         for num, tab in enumerate(tabs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             recs = self.sql.getRec(tables="ffield", where=[("ff_tabl", "=",
                 tab[0])], order="ff_seq")
@@ -137,13 +134,14 @@
                 j = CCD(rec[10], "NA", 10).disp
                 self.fpdf.drawText("%-20s %2s %1s %-10s %-10s %-10s %-10s "\
                     "%-10s %-10s %-10s" % (a, b, c, d, e, f, g, h, i, j))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
-            ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=1, rep=pdfnam,
-            head="Table Fields and Indexes", view=self.view,
-            prtnam=self.prtnam, mail=self.mail)
         p.closeProgress()
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
+                ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=1, rep=pdfnam,
+                head="Table Fields and Indexes", view=self.view,
+                prtnam=self.prtnam, mail=self.mail)
 
     def doHeading(self, htyp, table):
         self.fpdf.setFont(style="B")

=== modified file 'uty/td1010.py'
--- uty/td1010.py	2014-12-30 15:37:38 +0000
+++ uty/td1010.py	2015-01-27 16:09:44 +0000
@@ -589,10 +589,11 @@
                 else:
                     data = []
                     p = ProgressBar(self.opts["mf"].body,
-                        typ="Generating the Report", mxs=len(self.notes.data))
+                        typ="Generating the Report",
+                        mxs=len(self.notes.data), esc=True)
                     for num, dat in enumerate(self.notes.data):
-                        can = p.displayProgress(num)
-                        if can == "yes":
+                        p.displayProgress(num)
+                        if p.quit:
                             break
                         desc = textFormat(dat[5], width=50)
                         for n, d in enumerate(desc):
@@ -603,7 +604,7 @@
                             else:
                                 data.append(["", "", "", "", "", d])
                     p.closeProgress()
-                    if can != "yes":
+                    if not p.quit:
                         name = __name__
                         head = ["Telephone Directory Notes Listing"]
                         cols = [

=== modified file 'uty/tp1010.py'
--- uty/tp1010.py	2014-12-30 15:37:38 +0000
+++ uty/tp1010.py	2015-02-05 07:52:47 +0000
@@ -838,7 +838,8 @@
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doView(self, widget=None):
-        self.frm = DrawForm(self.opts["mf"].dbm, self.template)
+        self.frm = DrawForm(self.opts["mf"].dbm, self.template,
+            wrkdir=self.opts["mf"].rcdic["wrkdir"])
         self.frm.doNewDetail()
         self.frm.add_page()
         for key in self.frm.newkey:

=== modified file 'wag/sl2010.py'
--- wag/sl2010.py	2014-12-30 15:37:38 +0000
+++ wag/sl2010.py	2015-01-20 08:32:13 +0000
@@ -125,6 +125,8 @@
     def doSdate(self, frt, pag, r, c, p, i, w):
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
         self.sdate = w
 
     def doRef(self, frt, pag, r, c, p, i, w):

=== modified file 'wag/sl2020.py'
--- wag/sl2020.py	2014-12-30 15:37:38 +0000
+++ wag/sl2020.py	2015-01-20 08:32:42 +0000
@@ -170,9 +170,11 @@
         self.df.loadEntry("C", pag, p+1, data=desc)
 
     def doTrdate(self, frt, pag, r, c, p, i, w):
-        self.trdate = w
         if w < self.opts["period"][1][0] or w > self.opts["period"][2][0]:
             return "Invalid Date, Not in Financial Period"
+        if self.bh.multi == "N" and w / 100 > self.bh.curdt:
+            return "Invalid Date, After Batch Period"
+        self.trdate = w
 
     def doTyp(self, frt, pag, r, c, p, i, w):
         self.typ = w

=== modified file 'wag/sl3010.py'
--- wag/sl3010.py	2014-12-30 15:37:38 +0000
+++ wag/sl3010.py	2015-01-27 16:36:11 +0000
@@ -98,7 +98,7 @@
         self.closeProcess()
 
     def printReport(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs))
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %39s %6s" %
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
@@ -109,6 +109,8 @@
         tc = self.sql.wagltf_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
+            if p.quit:
+                break
             self.rtyp = CCD(dat[bc.index("btm_rtyp")], "UI", 2)
             self.batno = CCD(dat[bc.index("btm_batno")], "Na", 7)
             self.trno = CCD(dat[bc.index("btm_trno")], "UI", 7)
@@ -147,7 +149,7 @@
                 self.pglin += 1
             self.batchTotal()
         p.closeProgress()
-        if self.fpdf.page:
+        if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
                 self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")

=== modified file 'wag/sl3020.py'
--- wag/sl3020.py	2014-12-30 15:37:38 +0000
+++ wag/sl3020.py	2015-01-27 15:52:57 +0000
@@ -168,11 +168,8 @@
         self.pglin = 999
         col = self.sql.wagltf_col
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             empno = CCD(dat[col.index("wlt_empno")], "UI", 5)
             loan = CCD(dat[col.index("wlt_loan")], "UI", 2)
@@ -217,17 +214,16 @@
             self.gdd[trtp.work -1] = float(ASD(self.gdd[trtp.work -1]) + \
                 ASD(ded.work))
         p.closeProgress()
-        if self.fpdf.page:
-            if can != "yes":
-                self.batchTotal()
-                self.typeTotal()
-                self.grandTotal()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            self.batchTotal()
+            self.typeTotal()
+            self.grandTotal()
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'wag/sl3030.py'
--- wag/sl3030.py	2014-12-30 15:37:38 +0000
+++ wag/sl3030.py	2015-01-27 15:53:29 +0000
@@ -79,17 +79,12 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %63s %6s" % \
             (self.opts["conum"], self.opts["conam"], self.sysdttm, __name__))
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             emp = CCD(dat[0], "UI", 5)
             nam = CCD(dat[1], "NA", 30)
@@ -105,10 +100,13 @@
                 lon.disp, des.disp, cod.disp, dte.disp, per.disp, ded.disp))
             self.pglin += 1
         p.closeProgress()
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

=== modified file 'wag/sl3040.py'
--- wag/sl3040.py	2014-12-30 15:37:38 +0000
+++ wag/sl3040.py	2015-01-27 15:54:00 +0000
@@ -87,15 +87,13 @@
         if recs:
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, emp in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                         break
                 self.doProcess(emp)
             p.closeProgress()
-            self.doPrint()
+            if self.fpdf.page and not p.quit:
+                self.doPrint()
         self.opts["mf"].closeLoop()
 
     def doProcess(self, emp):

=== modified file 'wag/wg1010.py'
--- wag/wg1010.py	2014-12-30 15:37:38 +0000
+++ wag/wg1010.py	2015-02-02 06:46:41 +0000
@@ -41,6 +41,7 @@
                 ("wgm_empno", "", 0, "EmpNo"),
                 ("wgm_sname", "", 0, "Surname", "Y"),
                 ("wgm_fname", "", 0, "Names"),
+                ("wgm_freq", "", 0, "F"),
                 ("wgm_start", "", 0, "Start-Date"),
                 ("wgm_term", "", 0, "Term-Date")),
             "where": [("wgm_cono", "=", self.opts["conum"])]}
@@ -106,7 +107,7 @@
                 "","N",None,None,None,("email",)),
             (("T",1,12,0),"ID1",10,"Start Date","",
                 "","N",None,None,None,("efld",)),
-            (("T",1,13,0),"IUD",10.2,"Salary","",
+            (("T",1,13,0),"IUD",10.2,"Salary/Rate","",
                 "","N",None,None,None,("efld",)),
             (("T",1,14,0),("IRB",r1s),0,"Pay Freq","Pay Frequency",
                 "M","N",None,None,None,None),

=== modified file 'wag/wg2010.py'
--- wag/wg2010.py	2014-12-30 15:37:38 +0000
+++ wag/wg2010.py	2015-01-30 16:48:40 +0000
@@ -25,8 +25,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["wagedc", "wagmst", "wagcap"],
-            prog=__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["wagedc", "wagmst", "wagcap",
+            "wagcod"], prog=__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -105,7 +105,13 @@
             return "Invalid Code"
         self.df.loadEntry(frt, pag, p+1, rec[0])
         if self.rtyp == "E" and self.code == 1:
-            if self.freq == "M":
+            std = self.sql.getRec(tables="wagcod", cols=["wcd_eamt"],
+                where=[("wcd_cono", "=", self.opts["conum"]), ("wcd_empno",
+                "=", self.empno), ("wcd_type", "=", "E"), ("wcd_code", "=",
+                self.code)], limit=1)
+            if std and std[0]:
+                hrs = std[0]
+            elif self.freq == "M":
                 hrs = self.m_hrs
             elif self.freq == "W":
                 hrs = self.w_hrs

=== modified file 'wag/wg2020.py'
--- wag/wg2020.py	2014-12-30 15:37:38 +0000
+++ wag/wg2020.py	2015-02-02 07:27:44 +0000
@@ -185,6 +185,8 @@
 
     def doIgnore(self, frt, pag, r, c, p, i, w):
         self.ignore = w
+        if not self.freq == "M":
+            self.df.loadEntry(frt, pag, p+1, data="N")
 
     def doMthly(self, frt, pag, r, c, p, i, w):
         self.mthly = w
@@ -378,7 +380,7 @@
                         self.ern[cod][0] = amt
                     else:
                         self.ern[cod][0] = float(ASD(self.ern[cod][0]) + \
-                        ASD(amt))
+                            ASD(amt))
                 else:
                     self.ern[cod] = [amt, 0]
             else:
@@ -389,7 +391,7 @@
                         self.ded[cod] = amt
                     else:
                         self.ded[cod][0] = float(ASD(self.ded[cod][0]) + \
-                        ASD(amt))
+                            ASD(amt))
                 else:
                     self.ded[cod] = [amt, 0]
         for n in no:

=== modified file 'wag/wg3010.py'
--- wag/wg3010.py	2014-12-30 15:37:38 +0000
+++ wag/wg3010.py	2015-02-02 08:50:50 +0000
@@ -14,7 +14,8 @@
 """
 
 import time
-from TartanClasses import RepPrt, TartanDialog
+from TartanClasses import CCD, MyFpdf, RepPrt, Sql, TartanDialog
+from tartanFunctions import doPrinter, getModName
 
 class wg3010:
     def __init__(self, **opts):
@@ -39,48 +40,115 @@
                 ("dep_code", "", 0, "Cod"),
                 ("dep_name", "", 0, "Name", "Y")),
             "where": [("dep_cono", "=", self.opts["conum"])]}
+        r1s = (("List","L"), ("Card","C"))
         fld = (
-            (("T",0,0,0),"I@dep_code",0,"Department Code","",
+            (("T",0,0,0),("IRB",r1s),0,"Report Type","",
+                "L","N",self.doRptTyp,None,None,None,None),
+            (("T",0,1,0),"I@dep_code",0,"Department Code","",
                 "","N",self.doDepCod,dep,None,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld, tend=tnd,
             txit=txt, view=("N","V"), mail=("Y","N"))
 
+    def doRptTyp(self, frt, pag, r, c, p, i, w):
+        self.typ = w
+
     def doDepCod(self, frt, pag, r, c, p, i, w):
         self.dep = w
 
     def doEnd(self):
         self.df.closeProcess()
-        name = __name__
-        tables = ["wagmst"]
-        heads = ["Salaries and Wages Employee Master Report"]
-        cols = [
-            ["wgm_empno",  "UI",  5, "EmpNo", "y"],
-            ["wgm_sname",  "NA", 30, "Surname", "y"],
-            ["wgm_fname",  "NA", 30, "Names", "y"],
-            ["wgm_start",  "D1", 10, "Comm-Date", "y"],
-            ["wgm_term",   "d1", 10, "Term-Date", "y"]]
+        tabs = ["wagmst"]
+        self.head = "Salaries and Wages - Employee Master Report"
         whr = [("wgm_cono", "=", self.opts["conum"])]
-        opts = ""
         if self.dep:
             whr.append(("wgm_dept", "=", self.dep))
-            if not opts:
-                opts = "Dept: %s" % self.dep
-            else:
-                opts = "%s Dept: %s" % (opts, self.dep)
+            opts = "Dept: %s" % self.dep
+        else:
+            opts = None
         odr = "wgm_empno"
-        if not opts:
-            opts = None
-        state = self.df.disableButtonsTags()
-        RepPrt(self.opts["mf"], conum=self.opts["conum"],
-            conam=self.opts["conam"], name=name, tables=tables, heads=heads,
-            cols=cols, where=whr, order=odr, opts=opts,
-            view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
-        self.df.enableButtonsTags(state=state)
+        if self.typ == "C":
+            sql = Sql(self.opts["mf"].dbm, "wagmst", prog=__name__)
+            recs = sql.getRec(tables=tabs, where=whr)
+            if not recs:
+                self.closeProcess()
+                return
+            col = sql.wagmst_col
+            dic = sql.wagmst_dic
+            self.fpdf = MyFpdf(name=__name__, prog=__name__, head=80)
+            self.fpdf.header = self.header
+            self.fpdf.alias_nb_pages()
+            self.fpdf.set_font("Courier", "B", 12)
+            cwth = self.fpdf.get_string_width("X")
+            for rec in recs:
+                self.fpdf.add_page()
+                max1, max2 = 0, 0
+                fld = []
+                for c in col:
+                    if max1 < len(dic[c][4]):
+                        max1 = len(dic[c][4])
+                    if max2 < int(dic[c][3]):
+                        max2 = int(dic[c][3])
+                    self.fpdf.set_font("Courier", "B", 12)
+                    self.fpdf.drawText(h=5, txt="%-20s" % dic[c][4], ln=0)
+                    self.fpdf.set_font("Courier", "", 12)
+                    if dic[c][4] == "Pay Frequency":
+                        if rec[col.index(c)] == "F":
+                            txt = "Fortnightly"
+                        elif rec[col.index(c)] == "M":
+                            txt = "Monthly"
+                        else:
+                            txt = "Weekly"
+                        self.fpdf.drawText(h=5, x=cwth*40, txt=txt)
+                    elif dic[c][4] == "Pay Type":
+                        if rec[col.index(c)] == "C":
+                            txt = "Cash"
+                        elif rec[col.index(c)] == "Q":
+                            txt = "Cheque"
+                        else:
+                            txt = "Electronic"
+                        self.fpdf.drawText(h=5, x=cwth*40, txt=txt)
+                    elif dic[c][4] == "Account Type":
+                        if rec[col.index(c)] == "1":
+                            txt = "Current"
+                        elif rec[col.index(c)] == "2":
+                            txt = "Transmission"
+                        else:
+                            txt = "Savings"
+                        self.fpdf.drawText(h=5, x=cwth*40, txt=txt)
+                    else:
+                        self.fpdf.drawText(h=5, x=cwth*40,
+                            txt=CCD(rec[col.index(c)],
+                            dic[c][2], dic[c][3]).disp)
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                rep=pdfnam, head=self.head, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2])
+        else:
+            cols = [
+                ["wgm_empno",  "UI",  5, "EmpNo", "y"],
+                ["wgm_sname",  "NA", 30, "Surname", "y"],
+                ["wgm_fname",  "NA", 30, "Names", "y"],
+                ["wgm_freq",  "UA", 1, "F", "y"],
+                ["wgm_start",  "D1", 10, "Comm-Date", "y"],
+                ["wgm_term",   "d1", 10, "Term-Date", "y"]]
+            RepPrt(self.opts["mf"], conum=self.opts["conum"],
+                conam=self.opts["conam"], name=__name__, tables=tabs,
+                heads=[self.head], cols=cols, where=whr, order=odr, opts=opts,
+                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                mail=self.df.repprt[1][2])
         self.closeProcess()
 
+    def header(self):
+        cdes = "%-30s" % self.opts["conam"]
+        self.fpdf.drawText(cdes, font=["courier", "B", 24])
+        self.fpdf.drawText(font=["courier", "B", 14])
+        self.fpdf.drawText(self.head, font=["courier", "B", 16])
+        self.fpdf.drawText()
+
     def doExit(self):
         self.df.closeProcess()
         self.closeProcess()

=== modified file 'wag/wg3020.py'
--- wag/wg3020.py	2014-12-30 15:37:38 +0000
+++ wag/wg3020.py	2015-02-02 07:13:11 +0000
@@ -52,9 +52,9 @@
     def doEnd(self):
         self.df.closeProcess()
         recs = self.sql.getRec(tables=["wagcap", "wagmst", "wagedc"],
-            cols=["wcp_empno", "wcp_branch", "wcp_dept", "wcp_job",
-            "wcp_type", "wcp_code", "wcp_ind", "wcp_amt", "wgm_sname",
-            "ced_desc"], where=[("wcp_cono", "=", self.opts["conum"]),
+            cols=["wcp_empno", "wcp_dept", "wcp_job", "wcp_type", "wcp_code",
+            "wcp_ind", "wcp_amt", "wgm_sname", "wgm_fname", "ced_desc"],
+            where=[("wcp_cono", "=", self.opts["conum"]),
             ("wcp_cono=wgm_cono",), ("wcp_empno=wgm_empno",),
             ("ced_cono=wcp_cono",), ("ced_type=wcp_type",),
             ("ced_code=wcp_code",), ("wcp_paid", "=", "N")],
@@ -68,46 +68,43 @@
 
     def doPrintReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%03u %-30s %10s %33s %10s %10s" % (self.opts["conum"],
+        self.head = ("%03u %-30s %10s %47s %10s %10s" % (self.opts["conum"],
             self.opts["conam"], "", self.sysdttm, "", __name__))
         self.fpdf = MyFpdf(name=__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
         old_empno = 0
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             emp = CCD(dat[0], "UI", 5)
-            nam = CCD(dat[8], "NA", 30)
-            brn = CCD(dat[1], "NA", 3)
-            dep = CCD(dat[2], "UI", 1)
-            job = CCD(dat[3], "UI", 5)
-            typ = CCD(dat[4], "UA", 1)
-            cod = CCD(dat[5], "UI", 3)
+            nam = CCD("%s, %s" % (dat[7].strip(), dat[8].strip()), "NA", 50)
+            dep = CCD(dat[1], "UI", 1)
+            job = CCD(dat[2], "UI", 5)
+            typ = CCD(dat[3], "UA", 1)
+            cod = CCD(dat[4], "UI", 3)
             des = CCD(dat[9], "NA", 30)
-            ind = CCD(dat[6], "UA", 1)
-            amt = CCD(dat[7], "SD", 14.2)
+            ind = CCD(dat[5], "UA", 1)
+            amt = CCD(dat[6], "SD", 11.2)
             if old_empno and old_empno != emp.work:
                 self.fpdf.drawText()
                 self.pglin += 1
             if self.pglin > self.fpdf.lpp:
                 self.doPageHeading()
-            self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s" % \
-                (emp.disp, nam.disp, brn.disp, dep.disp, job.disp,
-                typ.disp, cod.disp, des.disp, ind.disp, amt.disp))
+            self.fpdf.drawText("%s %s %s %s %s %s %s %s  %s" % (emp.disp,
+                nam.disp, dep.disp, job.disp, typ.disp, cod.disp,
+                des.disp, ind.disp, amt.disp))
             old_empno = emp.work
             self.pglin += 1
         p.closeProgress()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
-            self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
-            head=self.tit, view=self.df.repprt[0][1],
-            prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], rep=pdfnam,
+                head=self.tit, view=self.df.repprt[0][1],
+                prtnam=self.df.repprt[0][2], mail=self.df.repprt[1][2])
 
     def doPageHeading(self):
         self.fpdf.add_page()
@@ -115,13 +112,13 @@
         self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-35s %-10s %48s %5s" % \
-            ("Salaries Data Capture Report as at",
-            self.date, "Page", self.pgnum))
+        self.fpdf.drawText("%-35s %-10s %62s %5s" % (
+            "Salaries Data Capture Report as at", self.date,
+            "Page", self.pgnum))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-5s %-30s %-3s %-1s %-5s %-1s %-3s %-30s %-1s " \
-            "%-11s" % ("EmpNo", "Surname", "Brn", "D", "JobNo",
-                "T", "Cod", "Description", "I", "       Amount"))
+        self.fpdf.drawText(
+            "%-5s %-50s %-1s %-5s %-1s %-3s %-30s %-1s %11s" % ("EmpNo",
+            "Name", "D", "JobNo", "T", "Cod", "Description", "I", "Amount"))
         self.fpdf.underLine(txt=self.head)
         self.fpdf.setFont()
         self.pglin = 6

=== modified file 'wag/wg3050.py'
--- wag/wg3050.py	2014-12-30 15:37:38 +0000
+++ wag/wg3050.py	2015-01-27 15:55:12 +0000
@@ -233,17 +233,14 @@
         if recs:
             p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
             for num, rec in enumerate(recs):
-                can = p.displayProgress(num)
-                if can == "yes":
-                    if self.fpdf.page:
-                        self.fpdf.drawText()
-                        self.fpdf.drawText("Print Job ABORTED")
+                p.displayProgress(num)
+                if p.quit:
                     break
                 self.doProcess(rec)
                 if self.error:
                     break
             p.closeProgress()
-            if self.error:
+            if p.quit or self.error:
                 self.opts["mf"].dbm.rollbackDbase()
             else:
                 #Employer Total

=== modified file 'wag/wg3060.py'
--- wag/wg3060.py	2014-12-30 15:37:38 +0000
+++ wag/wg3060.py	2015-01-27 16:10:17 +0000
@@ -39,10 +39,10 @@
     def mainProcess(self):
         data = []
         p = ProgressBar(self.opts["mf"].body, typ="Generating the Report",
-            mxs=len(self.notes.data))
+            mxs=len(self.notes.data), esc=True)
         for num, dat in enumerate(self.notes.data):
-            can = p.displayProgress(num)
-            if can == "yes":
+            p.displayProgress(num)
+            if p.quit:
                 break
             desc = textFormat(dat[5], width=50)
             for n, d in enumerate(desc):
@@ -57,7 +57,7 @@
                 else:
                     data.append(["", "", "", "", "", "", d])
         p.closeProgress()
-        if can != "yes":
+        if not p.quit:
             name = __name__
             head = ["Salaries Masterfile Notes Listing"]
             cols = [

=== modified file 'wag/wg3070.py'
--- wag/wg3070.py	2014-12-30 15:37:38 +0000
+++ wag/wg3070.py	2015-01-31 07:04:53 +0000
@@ -74,9 +74,7 @@
                 "M","N",self.doFreq,None,None,None),
             (("T",0,3,0),("IRB",r2s),0,"Whole File","",
                 "N","N",self.doWhole,None,None,None),
-            (("T",0,4,0),"INA",3,"Branch","",
-                "","N",self.doBranch,None,None,None),
-            (("T",0,5,0),"IUI",1,"Department","",
+            (("T",0,4,0),"IUI",1,"Department","",
                 "","N",self.doDept,None,None,None))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
@@ -106,12 +104,8 @@
     def doWhole(self, frt, pag, r, c, p, i, w):
         self.whole = w
         if self.whole == "Y":
-            self.branch = ""
             self.dept = ""
-            return "sk2"
-
-    def doBranch(self, frt, pag, r, c, p, i, w):
-        self.branch = w
+            return "sk1"
 
     def doDept(self, frt, pag, r, c, p, i, w):
         self.dept = w
@@ -138,8 +132,6 @@
             ("wgm_cono", "=", self.opts["conum"]),
             ("wgm_freq", "=", self.freq),
             ("wgm_term", "=", 0, "or", "wgm_term", ">=", self.rundt)]
-        if self.branch:
-            whr.append(("wgm_branch", "=", self.branch))
         if self.dept:
             whr.append(("wgm_dept", "=", self.dept))
         if self.whole == "N":

=== modified file 'wag/wgc310.py'
--- wag/wgc310.py	2014-12-30 15:37:38 +0000
+++ wag/wgc310.py	2015-01-29 19:36:17 +0000
@@ -139,7 +139,7 @@
             (("T",2,4,0),"IUD",5.2,"Hourly Limit","",
                 "","N",self.doLimit,None,None,("efld",)),
             (("T",2,5,0),("IRB",r6s),0,"Monthly Deduction","",
-                "N","N",None,None,None,None),
+                "N","N",self.doMthly,None,None,None),
             (("T",2,6,0),"IUD",6.2,"UIF Percentage","",
                 "","N",None,None,None,("efld",)),
             (("T",2,7,0),"IUD",6.2,"SDL Percentage","",
@@ -358,14 +358,19 @@
         return "sk1"
 
     def doBalNo(self, frt, pag, r, c, p, i, w):
-        self.df.loadEntry(frt, pag, p+1, data=0)
-        self.df.loadEntry(frt, pag, p+2, data="N")
-        self.df.loadEntry(frt, pag, p+3, data="N")
-        return "sk3"
+        if self.rtype == "E":
+            self.df.loadEntry(frt, pag, p+1, data=0)
+            self.df.loadEntry(frt, pag, p+2, data="N")
+            self.df.loadEntry(frt, pag, p+3, data="N")
+            return "sk3"
 
     def doLimit(self, frt, pag, r, c, p, i, w):
         pass
 
+    def doMthly(self, frt, pag, r, c, p, i, w):
+        self.df.loadEntry(frt, pag, p+1, data=0)
+        return "sk1"
+
     def doEnd0(self):
         self.df.focusField("T", 1, 1, clr=self.new)
 

=== modified file 'wag/wgc520.py'
--- wag/wgc520.py	2014-12-30 15:37:38 +0000
+++ wag/wgc520.py	2015-01-27 15:55:52 +0000
@@ -65,11 +65,8 @@
         self.pglin = 999
         old_sys = recs[0][0]
         for num, dat in enumerate(recs):
-            can = p.displayProgress(num)
-            if can == "yes":
-                if self.fpdf.page:
-                    self.fpdf.drawText()
-                    self.fpdf.drawText("Print Job ABORTED")
+            p.displayProgress(num)
+            if p.quit:
                 break
             self.sys = CCD(dat[0], "NA", 3)
             mes = CCD(dat[1], "UI", 3)
@@ -95,13 +92,13 @@
                 fmt.append("")
             self.pglin += 1
         p.closeProgress()
-        old_sys = self.sys.work
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
-            ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
-            view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
-            mail=self.df.repprt[1][2])
+        if self.fpdf.page and not p.quit:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__, 0,
+                ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], rep=pdfnam, head=self.tit,
+                view=self.df.repprt[0][1], prtnam=self.df.repprt[0][2],
+                mail=self.df.repprt[1][2])
 
     def pageHeading(self):
         self.fpdf.add_page()

