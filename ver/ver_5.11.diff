=== modified file 'ass/ar2030.py'
--- ass/ar2030.py	2020-03-01 12:48:20 +0000
+++ ass/ar2030.py	2020-03-14 07:39:37 +0000
@@ -54,11 +54,19 @@
             return
         self.glint = assctl["cta_glint"]
         self.rordp = assctl["cta_rordp"]
+        self.lastp = assctl["cta_lastp"]
+        self.sper = int(self.opts["period"][1][0] / 100)
+        self.eper = int(self.opts["period"][2][0] / 100)
+        yr = self.lastp / 100
+        mt = (self.lastp % 100) + 1
+        if mt > 12:
+            yr += 1
+            mt = 1
+        self.curdt = (yr * 100) + mt
+        if self.curdt > self.eper:
+            self.curdt = self.eper
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
-        self.curdt = int(self.sysdtw / 100)
-        self.sper = int(self.opts["period"][1][0] / 100)
-        self.eper = int(self.opts["period"][2][0] / 100)
         tabs = ["assctl", "assgrp", "assmst", "assdep", "asstrn", "gentrn"]
         self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
         if self.sql.error:
@@ -84,9 +92,14 @@
             txit=txt)
 
     def doTrdate(self, frt, pag, r, c, p, i, w):
-        self.curdt = w
         if w < self.sper or w > self.eper:
             return "Invalid Date, Not in Financial Period"
+        if self.lastp and self.lastp < self.sper:
+            dte1 = mthendDate(self.lastp * 100)
+            dte2 = mthendDate(self.sper * 100)
+            if dateDiff(dte1, dte2, "months") > 1:
+                return "Missing Depreciation for Previous Period"
+        self.curdt = w
 
     def endPage0(self):
         if self.args:

=== modified file 'ass/arc110.py'
--- ass/arc110.py	2020-03-01 12:48:20 +0000
+++ ass/arc110.py	2020-03-24 13:59:17 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -59,6 +61,8 @@
         if self.genleg:
             self.ctl = [["ass_sls", "Sale of Assets", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'bkm/bkc110.py'
--- bkm/bkc110.py	2020-03-01 12:48:20 +0000
+++ bkm/bkc110.py	2020-03-24 14:00:27 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -64,6 +66,8 @@
                 ["bkm_csh", "Cash Received", 0],
                 ["bkm_ccg", "Cancellation Fee", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'bwl/bc2050.py'
--- bwl/bc2050.py	2020-03-01 12:48:20 +0000
+++ bwl/bc2050.py	2020-03-12 08:16:55 +0000
@@ -381,7 +381,8 @@
                 ("bcg_aflag", "in", ("", "D"))])
             res = self.sql.getRec(tables="bwlgme", cols=col, where=wer, limit=1)
             if res[0]:
-                return "%s Results of Previous Game Not Entered" % (res[0] / 2)
+                mis = int(res[0] / 2)
+                return "%s Results of Previous Game Not Entered" % mis
         self.game = chk[0]
         self.gtyp = chk[1]
         if self.reprint:

=== modified file 'crs/cr2010.py'
--- crs/cr2010.py	2020-03-01 12:48:20 +0000
+++ crs/cr2010.py	2020-03-24 14:03:26 +0000
@@ -579,11 +579,15 @@
             return "rf"
         if self.lonmod:
             lonctl = self.gc.getCtl("lonctl", self.allcoy)
+            if not lonctl:
+                return "Missing Loans Control"
             self.lon_gl = lonctl["cln_glint"]
         else:
             self.lon_gl = "N"
         if self.slnmod:
             slnctl = self.gc.getCtl("wagctl", self.allcoy)
+            if not slnctl:
+                return "Missing Staff Loans Control"
             self.sln_gl = slnctl["ctw_glint"]
         else:
             self.sln_gl = "N"

=== modified file 'crs/cr6030.py'
--- crs/cr6030.py	2020-03-01 12:48:20 +0000
+++ crs/cr6030.py	2020-03-12 08:18:25 +0000
@@ -120,7 +120,7 @@
                 "sum(crt_tramt)"], where=whr, limit=1)
             if rec[0] and rec[0] < self.startp and not rec[1]:
                 chgs.append(mst[0])
-            elif not rec[0] and mst[1] / 100 < self.startp:
+            elif not rec[0] and int(mst[1] / 100) < self.startp:
                 chgs.append(mst[0])
         if not chgs:
             showError(self.opts["mf"].body, "Processing Error",

=== modified file 'crs/crc110.py'
--- crs/crc110.py	2020-03-01 12:48:20 +0000
+++ crs/crc110.py	2020-03-24 14:04:38 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -62,6 +64,8 @@
                 ["crs_ctl", "Creditors Control", 0],
                 ["dis_rec", "Discount Received", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'doc/BKSMST.rst'
--- doc/BKSMST.rst	2020-03-01 12:48:20 +0000
+++ doc/BKSMST.rst	2020-03-25 07:24:59 +0000
@@ -3,7 +3,7 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.10
+:Version:   5.11
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/BWLMST.rst'
--- doc/BWLMST.rst	2020-03-01 12:48:20 +0000
+++ doc/BWLMST.rst	2020-03-25 07:24:59 +0000
@@ -3,7 +3,7 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.10
+:Version:   5.11
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/CSHMST.rst'
--- doc/CSHMST.rst	2020-03-01 12:48:20 +0000
+++ doc/CSHMST.rst	2020-03-25 07:24:59 +0000
@@ -3,7 +3,7 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.10
+:Version:   5.11
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/Downloads.rst'
--- doc/Downloads.rst	2020-03-01 12:48:20 +0000
+++ doc/Downloads.rst	2020-03-25 07:24:59 +0000
@@ -11,41 +11,41 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.10 and was released on the 1st March, 2020.
+The latest version of Tartan is 5.11 and was released on the 25th March, 2020.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Manual: http://www.tartan.co.za/cgi-bin/simple_web.py/Manual
-.. _Tartan-5.10-lnx: ftp://tartan.co.za/Tartan_5.10.tgz
+.. _Tartan-5.11-lnx: ftp://tartan.co.za/Tartan_5.11.tgz
 .. _Tartan-5.5-lnx: ftp://tartan.co.za/Tartan_5.5.tgz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.14.tgz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tgz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tgz
-.. _Tartan-5.10-win: ftp://tartan.co.za/Tartan_5.10.exe
+.. _Tartan-5.11-win: ftp://tartan.co.za/Tartan_5.11.exe
 .. _Tartan-5.5-win: ftp://tartan.co.za/Tartan_5.5.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.14.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
 .. _Tartan-2-win: ftp://tartan.co.za/Tartan_2.5.29.exe
-.. _Bksclb-5-lnx: ftp://tartan.co.za/Bksclb_5.10.tgz
-.. _Bksclb-5-win: ftp://tartan.co.za/Bksclb_5.10.exe
-.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.10.tgz
-.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.10.exe
-.. _Cshana-5-lnx: ftp://tartan.co.za/Cshana_5.10.tgz
-.. _Cshana-5-win: ftp://tartan.co.za/Cshana_5.10.exe
-.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.10.tgz
-.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.10.exe
+.. _Bksclb-5-lnx: ftp://tartan.co.za/Bksclb_5.11.tgz
+.. _Bksclb-5-win: ftp://tartan.co.za/Bksclb_5.11.exe
+.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.11.tgz
+.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.11.exe
+.. _Cshana-5-lnx: ftp://tartan.co.za/Cshana_5.11.tgz
+.. _Cshana-5-win: ftp://tartan.co.za/Cshana_5.11.exe
+.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.11.tgz
+.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.11.exe
 
 |linux| Linux
 =============
 New Installation
 ----------------
-Download the latest version of Tartan, Tartan-5.10-lnx_, and then follow the installation instructions in the Manual_.
+Download the latest version of Tartan, Tartan-5.11-lnx_, and then follow the installation instructions in the Manual_.
 
 Upgrade Existing Installation
 -----------------------------
 If your current version is less than 4.1.10 you must upgrade as follows:
 
-    * If your current version is less than 2.5.10
+    * If your current version is less than 2.5.11
         - Make a backup.
         - Download the last release of version 2, Tartan-2-lnx_
         - Extract the downloaded version into your Tartan/prg directory.
@@ -65,7 +65,7 @@
         - Download version 5.5, Tartan-5.5-lnx_
         - Extract the downloaded version into your Tartan/prg directory.
         - Login to Tartan and run `Update File Formats`
-    * Download the latest version, Tartan-5.10-lnx_
+    * Download the latest version, Tartan-5.11-lnx_
         - Make a backup.
         - Extract the downloaded version into your Tartan/prg directory.
         - Login to Tartan and run `Update File Formats`
@@ -73,7 +73,7 @@
 otherwise:
 
     * Make a backup.
-    * Execute `Upgrade System` from the System menu or download the latest version of Tartan, Tartan-5.10-lnx_, and extract it into your Tartan/prg directory.
+    * Execute `Upgrade System` from the System menu or download the latest version of Tartan, Tartan-5.11-lnx_, and extract it into your Tartan/prg directory.
     * Login to Tartan and run `Update File Formats`
 
 Special Versions
@@ -98,13 +98,13 @@
 
 New Installation
 ----------------
-Download the latest version of Tartan, Tartan-5.10-win_, and then follow the installation instructions in the Manual_.
+Download the latest version of Tartan, Tartan-5.11-win_, and then follow the installation instructions in the Manual_.
 
 Upgrade Existing Installation
 -----------------------------
 If your current version is less than 5.0.0 you must upgrade as follows:
 
-    * If your current version is less than 2.5.10
+    * If your current version is less than 2.5.11
         - Make a backup.
         - Download the last release of version 2, Tartan-2-win_
         - Execute the downloaded version by double clicking on it.
@@ -124,7 +124,7 @@
         - Download version 5.5, Tartan-5.5-win_
         - Execute the downloaded version by double clicking on it.
         - Login to Tartan and run `Update File Formats`
-    * Download the latest version, Tartan-5.10-win_
+    * Download the latest version, Tartan-5.11-win_
         - Make a backup.
         - Execute the downloaded version by double clicking on it.
         - Login to Tartan and run `Update File Formats`
@@ -132,7 +132,7 @@
 otherwise:
 
     * Make a backup.
-    * Execute `Upgrade System` from the System menu or download the latest update of Tartan, Tartan-5.10-win_, and run it.
+    * Execute `Upgrade System` from the System menu or download the latest update of Tartan, Tartan-5.11-win_, and run it.
     * Login to Tartan and run `Update File Formats`
 
 Special Versions

=== modified file 'doc/MST.rst'
--- doc/MST.rst	2020-03-01 12:48:20 +0000
+++ doc/MST.rst	2020-03-25 07:24:59 +0000
@@ -3,7 +3,7 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.10
+:Version:   5.11
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
@@ -310,6 +310,19 @@
 
 If you are doing a full restore and the database already exists you will be asked whether to drop it first. Unless you are sure of what you are doing select No.
 
+Export Database
+...............
+Select this routine to export a company's data to an external database in a chosen directory. The database will be named *tartan001.db* for company 1. The word tartan will be replaced by the name of the source database.
+
++ **Company Number** - Enter the company number to export. If the company is a linked company you will be asked if it and the other companies should be exported.
++ **Directory** - Enter the directory where the exported file must be placed.
+
+Merge Database
+..............
+Select this routine to merge a database, that has been exported and worked on, back into the original database.
+
++ **Merge File** - Enter the full file path to the database file to be merged.
+
 Preferences
 ...........
 Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.

=== modified file 'doc/SECMST.rst'
--- doc/SECMST.rst	2020-03-01 12:48:20 +0000
+++ doc/SECMST.rst	2020-03-25 07:24:59 +0000
@@ -3,7 +3,7 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.10
+:Version:   5.11
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'drs/dr1020.py'
--- drs/dr1020.py	2020-03-01 12:48:20 +0000
+++ drs/dr1020.py	2020-03-24 14:05:57 +0000
@@ -41,6 +41,8 @@
             return
         self.gc = GetCtl(self.opts["mf"])
         ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         self.taxdf = ctlmst["ctm_taxdf"]
         if not self.taxdf:
             self.taxdf = "N"

=== modified file 'drs/dr2010.py'
--- drs/dr2010.py	2020-03-01 12:48:20 +0000
+++ drs/dr2010.py	2020-03-24 14:08:54 +0000
@@ -83,7 +83,10 @@
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.allcoy = self.opts["conum"]
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         if self.chains == "N":
             self.chain = 0
         if self.opts["rtn"] == 1:

=== modified file 'drs/dr2020.py'
--- drs/dr2020.py	2020-03-01 12:48:20 +0000
+++ drs/dr2020.py	2020-03-24 14:09:57 +0000
@@ -81,7 +81,10 @@
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.allcoy = self.opts["conum"]
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         if self.chains == "N":
             self.chain = 0
         self.glt = 6

=== modified file 'drs/dr3020.py'
--- drs/dr3020.py	2020-03-01 12:48:20 +0000
+++ drs/dr3020.py	2020-03-24 14:10:38 +0000
@@ -51,6 +51,8 @@
             return
         self.fromad = drsctl["ctd_emadd"]
         self.slsctl = gc.getCtl("slsctl", self.opts["conum"])
+        if not self.slsctl:
+            return
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i) %6s" % (t[0],
@@ -248,9 +250,9 @@
                 if chk:
                     continue
                 dat = [self.opts["conum"], chain, acno, rtyp, ref1]
-                dat.append("S%s" % (date / 100))
-                dat.extend([date, "", 0, 0, date / 100, "Cancelled", "", "",
-                    capnm, capdt, 0])
+                dat.append("S%s" % int(date / 100))
+                dat.extend([date, "", 0, 0, int(date / 100), "Cancelled",
+                    "", "", capnm, capdt, 0])
                 self.sql.insRec("drstrn", data=dat)
 
     def exportReport(self, recs):

=== modified file 'drs/dr6030.py'
--- drs/dr6030.py	2020-03-01 12:48:20 +0000
+++ drs/dr6030.py	2020-03-12 08:20:00 +0000
@@ -136,7 +136,7 @@
                 "sum(drt_tramt)"], where=whr, limit=1)
             if rec[0] and rec[0] < self.startp and not rec[1]:
                 chgs.append(mst[:2])
-            elif not rec[0] and mst[2] / 100 < self.startp:
+            elif not rec[0] and int(mst[2] / 100) < self.startp:
                 chgs.append(mst[:2])
         if not chgs:
             showError(self.opts["mf"].body, "Processing Error",

=== modified file 'drs/drc110.py'
--- drs/drc110.py	2020-03-01 12:48:20 +0000
+++ drs/drc110.py	2020-03-24 14:11:27 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -62,6 +64,8 @@
                 ["drs_ctl", "Debtors Control", 0],
                 ["dis_all", "Discount Allowed", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'gen/gl3130_rne.py'
--- gen/gl3130_rne.py	2020-03-01 12:48:20 +0000
+++ gen/gl3130_rne.py	2020-03-19 07:00:57 +0000
@@ -829,8 +829,8 @@
                                 self.dat2[bnm][1][dep][1] += sls
                                 self.dat2[bnm][1][dep][2] += lgp
                     # Net Profit
-                    if not cst:
-                        npr = float(ASD(npr) + ASD(stk))
+                    #if not cst:
+                    #    npr = float(ASD(npr) + ASD(stk))
                     if dep not in self.dat3[bnm][1]:
                         self.dat3[bnm][1][dep] = [npr, sls, lnp]
                     else:

=== modified file 'lon/ln2010.py'
--- lon/ln2010.py	2020-03-01 12:48:20 +0000
+++ lon/ln2010.py	2020-03-24 14:16:24 +0000
@@ -78,7 +78,10 @@
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.allcoy = self.opts["conum"]
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         return True
 
     def batchHeader(self):

=== modified file 'lon/lnc110.py'
--- lon/lnc110.py	2020-03-01 12:48:20 +0000
+++ lon/lnc110.py	2020-03-24 14:18:25 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -63,6 +65,8 @@
                 ["int_rec", "Interest Received", 0],
                 ["int_pay", "Interest Paid", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'mem/ml1010.py'
--- mem/ml1010.py	2020-03-01 12:48:20 +0000
+++ mem/ml1010.py	2020-03-18 05:49:14 +0000
@@ -852,24 +852,26 @@
     def doID(self, frt, pag, r, c, p, i, w):
         if not w and self.nation == "ZA":
             return "Invalid Identity Number 1"
-        if w and self.dob % 1000000 != int(w / 10000000):
-            return "Invalid Identity Number 2"
-        if w and not luhnFunc(w):
-            return "Invalid Identity Number 3"
-        whr = [("mlm_cono", "=", self.opts["conum"])]
-        if not self.new:
-            whr.append(("mlm_memno", "<>", self.memno))
-        whr.append(("mlm_idnum", "=", w))
-        chk = self.sql.getRec(tables="memmst", where=whr, limit=1)
-        if chk:
-            showError(self.opts["mf"].body, "ID Number",
-                """A Member with this ID Number already Exists:
+        if w:
+            if self.dob % 1000000 != int(w / 10000000):
+                return "Invalid Identity Number 2"
+            if not luhnFunc(w):
+                return "Invalid Identity Number 3"
+            whr = [("mlm_cono", "=", self.opts["conum"])]
+            if not self.new:
+                whr.append(("mlm_memno", "<>", self.memno))
+            whr.append(("mlm_nation", "=", self.nation))
+            whr.append(("mlm_idnum", "=", w))
+            chk = self.sql.getRec(tables="memmst", where=whr, limit=1)
+            if chk:
+                showError(self.opts["mf"].body, "ID Number",
+                    """A Member with this ID Number already Exists:
 
 Number:  %s
 Surname: %s
 Names:   %s
 """ % (chk[1], chk[4], chk[5]))
-            return "rf"
+                return "rf"
         self.idnum = w
 
     def doOccCode(self, frt, pag, r, c, p, i, w):

=== modified file 'mem/ml2010.py'
--- mem/ml2010.py	2020-03-01 12:48:20 +0000
+++ mem/ml2010.py	2020-03-24 14:19:33 +0000
@@ -71,7 +71,10 @@
             return
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         if self.opts["rtn"] == 1:
             self.glt = 1
         elif self.opts["rtn"] == 2:

=== modified file 'mem/ml2020.py'
--- mem/ml2020.py	2020-03-01 12:48:20 +0000
+++ mem/ml2020.py	2020-03-24 14:35:36 +0000
@@ -70,7 +70,10 @@
         self.bh.batval = float(ASD(0) - ASD(self.bh.batval))
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         self.glt = 4
         self.agevar = tk.BooleanVar()
         self.agevar.set(False)

=== modified file 'mem/mlc110.py'
--- mem/mlc110.py	2020-03-01 12:48:20 +0000
+++ mem/mlc110.py	2020-03-24 14:20:57 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -63,6 +65,8 @@
                 ["mem_ctl", "Members Control", 0],
                 ["mem_pen", "Members Penalties", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'mem/mlm010.py'
--- mem/mlm010.py	2020-03-01 12:48:20 +0000
+++ mem/mlm010.py	2020-03-24 14:22:12 +0000
@@ -39,7 +39,10 @@
 
     def setVariables(self):
         mc = GetCtl(self.opts["mf"])
-        self.taxdf = mc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = mc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         memctl = mc.getCtl("memctl", self.opts["conum"])
         if not memctl:
             return

=== modified file 'mst/ms0000.py'
--- mst/ms0000.py	2020-03-01 12:48:20 +0000
+++ mst/ms0000.py	2020-03-25 07:24:59 +0000
@@ -1,5 +1,4 @@
 #! /usr/bin/env python
-
 """
 SYNOPSIS
     This file is part of Tartan Systems (TARTAN).
@@ -23,42 +22,1913 @@
     You should have received a copy of the GNU General Public License
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
-import getopt, os, sys
-
-# Add the program path to the PATH variable if possible
-ppath = os.path.realpath(sys.path[0])
-if os.path.isfile(ppath):
-    ppath = os.path.normpath(os.path.dirname(ppath))
-if ppath not in os.environ["PATH"].split(os.pathsep):
-    epath = "%s%s%s" % (os.environ["PATH"], os.pathsep, ppath)
-    os.environ["PATH"] = epath
-# Ubuntu Unity uses the Global Menu which breaks Tartan's Menu
-if sys.platform == "linux2":
-    os.environ["UBUNTU_MENUPROXY"] = "0"
+
+import getpass, gc, glob, io, os, platform, sys, time
+from TartanClasses import AboutTartan, DBCreate, Dbase, ExportDbase, FileDialog
+from TartanClasses import GUI, GetCtl, ImportDbase, MainFrame, MkWindow
+from TartanClasses import PwdConfirm, ScrollText, SelectChoice, Sql
+from TartanClasses import TarBckRes, TartanConfig, TartanDialog, TartanMenu
+from TartanClasses import TartanUser
+from tartanFunctions import askQuestion, askChoice, b64Convert, chkMod, copyList
+from tartanFunctions import dateDiff, ftpDownload, getPeriods, getPrgPath
+from tartanFunctions import internetConnect, loadRcFile, parsePrg, projectDate
+from tartanFunctions import runModule, showError, showException
+from tartanWork import allsys, tabdic, tarmen
+try:
+    from send2trash import send2trash
+    TRASH = True
+except:
+    TRASH = False
+
 # Set the version of Tartan
 if "TARVER" in os.environ:
     # Allow override
     temp = tuple(os.environ["TARVER"].split("."))
     VERSION = (int(temp[0]), int(temp[1].rstrip()))
 else:
-    VERSION = (5, 10)
+    VERSION = (5, 11)
     os.environ["TARVER"] = "%s.%s" % VERSION
+
+class ms0000(object):
+    def __init__(self, opts, args):
+        self.cv = [VERSION, "%s.%s" % VERSION]
+        default = [
+            ("altered", False),
+            ("bpwd", ""),
+            ("conum", None),
+            ("debug", False),
+            ("exclude", []),
+            ("finper", None),
+            ("help", False),
+            ("itoggle", False),
+            ("loader", False),
+            ("nocheck", False),
+            ("program", None),
+            ("query", None),
+            ("rcfdir", None),
+            ("rcfile", None),
+            ("tcode", 0),
+            ("user", {}),
+            ("version", False),
+            ("xdisplay", True),
+            ("zerobar", False)]
+        if sys.platform == "win32":
+            default.append(("output", True))
+        else:
+            default.append(("output", False))
+        for arg, val in default:
+            setattr(self, arg, val)
+        for o, v in opts:
+            if o in ("-a", "--altered"):
+                self.altered = True
+            if o in ("-b", "--bpwd"):
+                self.bpwd = v
+            elif o in ("-c", "--conum"):
+                self.conum = int(v)
+            elif o in ("-d", "--debug"):
+                self.debug = True
+            elif o in ("-e", "--exclude"):
+                self.exclude = v.split(",")
+            elif o in ("-f", "--finper"):
+                self.finper = int(v)
+            elif o in ("-h", "--help"):
+                self.help = True
+            elif o in ("-i", "--image"):
+                self.itoggle = True
+            elif o in ("-l", "--loader"):
+                self.loader = True
+            elif o in ("-n", "--nocheck"):
+                self.nocheck = True
+            elif o in ("-o", "--output"):
+                if sys.platform == "win32":
+                    self.output = False
+                else:
+                    self.output = True
+            elif o in ("-p", "--program"):
+                self.program = v
+            elif o in ("-q", "--query"):
+                if not args:
+                    if len(v.split()) == 1:
+                        # Execute sql commands in a file
+                        self.query = v
+                    else:
+                        self.query = [v.replace("\\", "")]
+                else:
+                    self.query = []
+                    for a in args:
+                        if a.count(";"):
+                            b = a.split(";")
+                            v = "%s %s" % (v, b[0].replace("\\", ""))
+                            self.query.append(v)
+                            v = b[1]
+                            continue
+                        if not v:
+                            v = a
+                        else:
+                            v = "%s %s" % (v, a.replace("\\", ""))
+                    self.query.append(v)
+            elif o in ("-R", "--rcfdir"):
+                self.rcfdir = v
+            elif o in ("-r", "--rcfile"):
+                self.rcfile = v
+            elif o in ("-t", "--tcode"):
+                self.tcode = int(v)
+            elif o in ("-u", "--user"):
+                user = v.split(":")
+                self.user["name"] = user[0]
+                if len(user) == 2:
+                    self.user["pwd"] = user[1]
+                else:
+                    self.user["pwd"] = ""
+            elif o in ("-v", "--version"):
+                self.version = True
+            elif o in ("-x", "--xdisplay"):
+                self.xdisplay = False
+            elif o in ("-z", "--zerobar"):
+                self.zerobar = True
+        if self.output:
+            # Redirect stdout
+            for pid in xrange(1000):
+                if self.debug:
+                    name = "tracer_%s.txt" % pid
+                else:
+                    name = "stdout_%s.txt" % pid
+                self.stdout = os.path.join(getPrgPath(), name)
+                try:
+                    if not os.path.exists(self.stdout):
+                        sys.stdout = open(self.stdout, "w")
+                        os.chmod(self.stdout, 0o777)
+                        break
+                except:
+                    pass
+        if self.help:
+            print("""
+Tartan Systems Help
+
+Usage:      python ms0000.py [options]
+
+Options:
+            -a, --altered           Check for Altered Tables
+            -b, --bpwd=             The backup password
+            -c, --conum=            The company number
+            -d, --debug             Enter debug/trace mode
+            -e, --exclude=          Modules to ignore in debug/trace mode
+            -f, --finper=           The financial period
+            -h, --help              This Help Message
+            -i, --image             Toggle the Tartan image option.
+            -l, --loader            Try and remove module before importing
+            -n, --nocheck           Do not check for system records
+            -o, --output            Toggle stdout redirection to stdout.txt
+                                        Linux   defaults to False
+                                        Windows defaults to True
+            -p, --program=          Execute program directly bypassing the menu
+            -q, --query=            Execute a sql query
+            -R, --rcfdir=           Directory of Available Tartan RC Files
+            -r, --rcfile=           Path of Tartan RC File to use
+            -t, --tcode=            Transaction code
+            -u, --user=             User name and password e.g. name:password
+            -v, --version           Display Version Details
+            -x, --xdisplay          Do not have a mainframe with -ptarBck
+            -z, --zerobar           Do not have a progressbar with -ptarBck
+""")
+            self.doExit(dbm=False)
+        if not self.version and not self.xdisplay:
+            nodisp = ("tarBck", "tarUpd", "ml6030")
+            if not self.query and self.program not in nodisp:
+                print("xdisplay False but module not in %s" % str(nodisp))
+                self.doExit(dbm=False)
+            elif not self.user:
+                print("xdisplay False but No User Name")
+                self.doExit(dbm=False)
+        if not self.version and self.xdisplay and not GUI:
+            print("Tkinter/ttk not Available or Installed")
+            self.doExit(dbm=False)
+        if self.version:
+            nm = platform.uname()
+            print("%-16s: %s" % ("Tartan", self.cv[1]))
+            print("%-16s: %s, %s, %s" % ("O/System", nm[0], nm[2], nm[4]))
+            print("%-16s: %s" % ("python", sys.version.split()[0]))
+            try:
+                from TartanClasses import tk
+                print("%-16s: %s" % ("tcl/tk",
+                    tk.Tcl().eval("info patchlevel")))
+            except:
+                print("%-16s: %s" % ("Tcl/Tk", "Not Installed"))
+            mods = (
+                ("fpdf", "fpdf", "__version__"),
+                ("PIL", "pillow", "__version__"),
+                ("fdb", "fdb", "__version__"),
+                ("ghostscript", "ghostscript", "__version__"),
+                ("markdown", "markdown", "__version__"),
+                ("ofxtools", "ofxtools", "__version__"),
+                ("psycopg2", "psycopg2", "__version__"),
+                ("pyaes", "pyaes", "VERSION"),
+                ("pychart", "python-chart", None),
+                ("Crypto", "pycryptodome", "__version__"),
+                ("pyexcel_ods", "pyexcel-ods", None),
+                ("pygal", "pygal", "__version__"),
+                ("pymysql", "pymysql", "__version__"),
+                ("smb", "pysmb", None),
+                ("sqlite3", "pysqlite", "version"),
+                ("sqlite3", "sqlite3", "sqlite_version"),
+                ("escpos", "python-escpos", ("version", "version")),
+                ("requests", "requests", "__version__"),
+                ("send2trash", "send2trash", None),
+                ("tkcolorpicker", "tkcolorpicker", None),
+                ("tkinterhtml", "tkinterhtml", None),
+                ("tqdm", "tqdm", None),
+                ("xlrd", "xlrd", "__VERSION__"),
+                ("xlwt", "xlwt", "__VERSION__"))
+            for mod in mods:
+                ver = chkMod(mod[0])
+                if not ver:
+                    print("%-16s: Not Installed" % mod[1])
+                else:
+                    try:
+                        if not mod[2]:
+                            raise Exception
+                        if type(mod[2]) == tuple:
+                            ver = getattr(ver, mod[2][0])
+                            ver = getattr(ver, mod[2][1])
+                        else:
+                            ver = getattr(ver, mod[2])
+                        if type(ver) == list:
+                            ver = "%s.%s.%s" % tuple(ver)
+                        ver = ver.split()[0]
+                        print("%-16s: %s" % (mod[1], ver))
+                    except:
+                        print("%-16s: Installed" % mod[1])
+            self.doExit(dbm=False)
+        if self.debug:
+            # Set trace mode
+            import trace
+            igm = ["__init__"]
+            if self.exclude:
+                igm.extend(self.exclude)
+            if sys.platform == "win32" and \
+                    os.path.basename(sys.path[0]) == "library.zip":
+                igd = []
+                for mod in sys.modules:
+                    igm.append(mod)
+            else:
+                igd = [sys.prefix, sys.exec_prefix]
+            os.environ["TARTANDB"] = "1"
+            self.tracer = trace.Trace(ignoredirs=igd, ignoremods=igm,
+                trace=1, count=0)
+        self.setVariables()
+        if self.rcfdir:
+            if not os.path.isdir(self.rcfdir):
+                showError(None, "Directory Error",
+                    "Invalid -R Directory: %s" % self.rcfdir)
+                self.doExit(dbm=False)
+            icon = os.path.join(getPrgPath(), "img", "tartan.png")
+            scrn = MkWindow(tk=True, icon=icon).newwin
+            dialog = FileDialog(**{"parent": scrn, "initd": self.rcfdir})
+            self.rcfile = dialog.askopenfilename()
+            scrn.destroy()
+            if not self.rcfile:
+                self.doExit(dbm=False)
+        self.mf = None
+        self.loop = False
+        self.rcdic = None
+        main = "Tartan Systems - Copyright %s 2004-2020 Paul Malherbe" % \
+            unichr(0xa9)
+        while not self.rcdic:
+            self.rcdic = loadRcFile(self.rcfile, default=True)
+            if self.rcdic == "error":
+                self.doExit(dbm=False)
+            elif not os.path.isfile(self.rcdic["name"]):
+                self.mf = MainFrame(title=main, rcdic=self.rcdic)
+                if self.mf.rcdic == "error":
+                    self.doExit(dbm=False)
+                self.mf.dbm = None
+                self.mf.window.deiconify()
+                cfg = TartanConfig(self.mf, rcfile=self.rcfile,
+                    rcdic=self.rcdic, level=9)
+                if not cfg.rcfile:
+                    self.doExit(dbm=False)
+                self.rcfile = self.mf.rcfile = cfg.rcfile
+                self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
+        titl = "%s - (%s - %s@%s)" % (main, self.rcdic["dbase"],
+            self.rcdic["dbname"], self.rcdic["dbhost"])
+        if not self.mf:
+            # Create MainFrame if not already existing
+            self.mf = MainFrame(title=titl, rcdic=self.rcdic,
+                xdisplay=self.xdisplay)
+            if self.mf.rcdic == "error":
+                self.doExit(dbm=False)
+        else:
+            self.mf.window.title(titl)
+        if self.xdisplay:
+            self.mf.head.configure(text="Tartan Systems")
+        # Try connecting to the database and create if missing
+        self.db = Dbase(rcdic=self.rcdic, screen=self.mf.body)
+        if self.db.err:
+            self.doExit(dbm=False)
+        self.mf.dbm = self.db
+        err = self.db.checkDbase()
+        if err not in (True, False):
+            self.doExit()
+        elif err is False:
+            ok = askQuestion(self.mf.window, "Database",
+                "Create the Database Now?")
+            if ok == "no":
+                self.doExit()
+            else:
+                opts = [
+                    ("-c", "i"),
+                    ("-l", self.mf.body),
+                    ("-u", self.rcdic["dbuser"]),
+                    ("-p", self.rcdic["dbpwd"]),
+                    ("-v", self.cv[1]),
+                    ("-x", True)]
+                DBCreate(dbm=self.db, opts=opts)
+                self.tarUpd(True)
+        if not self.nocheck:
+            # Open the database
+            self.db.openDbase()
+            # Check for ctlsys and if missing call msc110
+            err = self.doCheckSys()
+            if not err:
+                # Check for ctlmst and if missing call ms1010
+                err = self.doCheckMst()
+            if err:
+                # If error, exit
+                self.doExit()
+            # List of financial modules
+            self.fmod = ["ms1020", "ms1040", "ms3010", "msy010", "msy020"]
+            # Close dbase
+            self.db.closeDbase()
+        if self.user:
+            # Check if user details supplied are valid
+            self.userReadCheck(user=self.user["name"], pwd=self.user["pwd"],
+                pwdchk=True)
+            if not self.user:
+                if self.xdisplay:
+                    scrn = self.mf.window
+                else:
+                    scrn = "text"
+                showError(scrn, "Error", "Invalid User or User Password")
+        else:
+            # Login user
+            self.userLogin()
+        if not self.user:
+            # Exit if not valid user
+            self.doExit()
+        if not self.program or self.program != "tarUpd":
+            # Check tartan version
+            self.doVersionCheck()
+        if self.query:
+            # Excecute sql query
+            if self.user["lvl"] == 9:
+                err = self.doSqlCmd()
+            else:
+                err = "Invalid Security Level"
+            if err:
+                if self.xdisplay:
+                    showError(self.mf.body, "Data Base Error",
+                        "\nDbCommand Error: %s\n" % err)
+                else:
+                    print("Data Base Error", "DbCommand Error: %s\n" % err)
+            self.doExit()
+        if self.program:
+            # Excecute module without the menu
+            mods = copyList(self.usrmod)
+            mods.append(["PNNN", "mm_sy", "tb1010", 9, "Amend Tables"])
+            mods.append(["PNNN", "mm_sy", "tb1030", 9, "Edit Tables"])
+            mods.append(["PNNN", "mm_sy", "tb3010", 9, "Print Tables"])
+            found = False
+            for mod in mods:
+                if mod[2] == self.program:
+                    if len(mod) == 5:
+                        found = True
+                        break
+                    elif len(mod) == 6 and mod[5] == self.tcode:
+                        found = True
+                        break
+            if found:
+                if self.xdisplay and self.program != "ps2010":
+                    self.mf.window.deiconify()
+                self.execCommand(mod[0], self.program, mod[4], rtn=self.tcode,
+                    menu=False)
+            else:
+                print("Invalid Module (%s) or Missing Options e,g, "\
+                    "(-c, -f or -t)" % self.program)
+            self.doExit()
+        if self.itoggle:
+            # Toggle the display of the tartan image
+            if self.mf.rcdic["img"].lower() == "y":
+                self.image = False
+            else:
+                self.image = True
+        elif self.mf.rcdic["img"].lower() == "y":
+            # Display the tartan image
+            self.image = True
+        else:
+            # Do not display the tartan image
+            self.image = False
+        if self.image:
+            image = os.path.join(self.rcdic["prgdir"], "img", "tartan.png")
+        else:
+            image = None
+        # Create the tartan menu
+        self.tarmen = TartanMenu(mf=self.mf, usr=self.user["name"],
+            men=self.usrmen, mod=self.usrmod, lvl=self.user["lvl"],
+            cmd=self.execCommand, img=image)
+        if not self.doVersionCheck():
+            # Check for notes
+            self.checkNotes()
+        # Display the tartan menu
+        self.tarmen.drawMenu()
+
+    def setVariables(self):
+        self.vop = []
+        self.sss = {}
+        self.men = []
+        self.mod = []
+        self.acoy = []
+        self.dcoy = []
+        self.fsys = ("ms1020", "ms1040", "ms3010", "msy010", "msy020")
+        for s in sorted(list(allsys.items()), key=lambda kv: kv[1][3]):
+            try:
+                self.men.extend(tarmen["%2smen" % s[1][1].lower()])
+                self.mod.extend(tarmen["%2smod" % s[1][1].lower()])
+                self.sss[s[1][1].lower()] = s[1][0]
+            except:
+                pass
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        self.direct = False
+        self.tarmen = None
+        self.email = None
+
+    def userLogin(self):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        if not self.user:
+            self.userReadCheck()
+            if self.user and not self.user["pwd"]:
+                if dbopend:
+                    self.db.closeDbase()
+                return
+        if self.user:
+            login = self.user["name"]
+        else:
+            try:
+                login = getpass.getuser()
+                if not self.userReadCheck(login, userchk=True):
+                    raise Exception
+            except:
+                login = ""
+        tit = ("User Login and Validation",)
+        fld = (
+            (("T",0,0,0),"INA",30,"Name","Your User Name",
+                login,"N",self.usrNam,None,None,None,None,
+                "Your log-in Name"),
+            (("T",0,1,0),"IHA",30,"Password","Your Password",
+                "","N",self.usrPwd,None,None,None,None,
+                "Your password. You are allowed a Maximum of 3 attempts."))
+        but = (("Quit", None, self.noUser, 1, None, None),)
+        self.li = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.endUser, "n"),), txit=(self.noUser,))
+        self.loop = True
+        self.mf.startLoop()
+        if dbopend:
+            self.db.closeDbase()
+
+    def usrNam(self, frt, pag, r, c, p, i, w):
+        self.userReadCheck(w)
+        if not self.user:
+            return "Invalid User"
+        if not self.user["pwd"]:
+            return "sk1"
+        self.times = 0
+
+    def usrPwd(self, frt, pag, r, c, p, i, w):
+        err = self.userCheckPwd(w)
+        if not err:
+            return "nc"
+        elif err == "Expired Password" or self.times == 2:
+            return "xt"
+        else:
+            self.times += 1
+            return "Invalid Password"
+
+    def noUser(self):
+        self.user = {}
+        self.endUser()
+
+    def endUser(self):
+        self.loop = False
+        self.li.closeProcess()
+        self.mf.closeLoop()
+
+    def userReadCheck(self, user=None, userchk=False, pwd=None, pwdchk=False):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        sql = Sql(self.db, ["ctlmst", "ctlpwu", "ctlpwm"], prog="ms0000")
+        if not user:
+            chk = sql.getRec(tables="ctlpwu")
+            if len(chk) == 1:
+                user = chk[0][sql.ctlpwu_col.index("usr_name")]
+        usr = sql.getRec(tables="ctlpwu", where=[("usr_name", "=", user)],
+            limit=1)
+        if userchk:
+            if dbopend:
+                self.db.closeDbase()
+            return usr
+        if not usr:
+            self.user = {}
+        else:
+            self.user = {
+                "name": user,
+                "pwd":  usr[sql.ctlpwu_col.index("usr_pwd")]}
+            if "usr_last" in sql.ctlpwu_col:
+                self.user["last"] = usr[sql.ctlpwu_col.index("usr_last")]
+            else:
+                self.user["last"] = 0
+            if "usr_coy" in sql.ctlpwu_dic:
+                self.user["acoy"] = usr[sql.ctlpwu_col.index("usr_coy")]
+                self.user["dcoy"] = ""
+            else:
+                self.user["acoy"] = usr[sql.ctlpwu_col.index("usr_acoy")]
+                self.user["dcoy"] = usr[sql.ctlpwu_col.index("usr_dcoy")]
+            self.user["lvl"] = usr[sql.ctlpwu_col.index("usr_lvl")]
+            if pwdchk and self.user["pwd"] and self.userCheckPwd(pwd):
+                self.user = {}
+            if self.user:
+                self.acoy = []
+                self.dcoy = []
+                self.usrnam = self.user["name"]
+                self.pwd = self.user["pwd"]
+                acoy = self.user["acoy"]
+                dcoy = self.user["dcoy"]
+                self.lvl = self.user["lvl"]
+                if acoy:
+                    acoy = acoy.split(",")
+                else:
+                    acoy = []
+                for co in acoy:
+                    if int(co):
+                        self.acoy.append(int(co))
+                if dcoy:
+                    dcoy = dcoy.split(",")
+                else:
+                    dcoy = []
+                for co in dcoy:
+                    if int(co):
+                        self.dcoy.append(int(co))
+                nos = []
+                # All systems not in the company and phone modules - nos
+                for sss in self.sss:
+                    if sss not in ("ms", "td"):
+                        nos.append(sss)
+                # Remove enabled systems
+                self.mods = sql.getRec(tables="ctlmst", cols=["ctm_modules"],
+                    group="ctm_modules")
+                for mod in self.mods:
+                    for x in xrange(0, len(mod[0]), 2):
+                        m = mod[0][x:x+2]
+                        if m.lower() in nos:
+                            nos.remove(m.lower())
+                # All systems excluded for the user - ctlpwm - nos
+                tmp = sql.getRec(tables="ctlpwm", cols=["mpw_sys"],
+                    where=[("mpw_usr", "=", self.user["name"]),
+                    ("mpw_prg", "=", "")])
+                if tmp:
+                    for s in tmp:
+                        if s not in nos:
+                            nos.append(s[0])
+                # All modules excluded for the user - ctlpwm - nop
+                nop = sql.getRec(tables="ctlpwm", cols=["mpw_sys",
+                    "mpw_prg"], where=[("mpw_usr", "=", self.user["name"]),
+                    ("mpw_prg", "<>", ""), ("mpw_pwd", "=", "")])
+                # All modules enabled for the user - self.vop
+                self.vop = sql.getRec(tables="ctlpwm", cols=["mpw_sys",
+                    "mpw_prg", "mpw_coy", "mpw_pwd"], where=[("mpw_usr",
+                    "=", self.user["name"]), ("mpw_prg", "<>", ""),
+                    ("mpw_pwd", "<>", "")])
+                if self.vop:
+                    for sss, mod, coy, pwd in self.vop:
+                        if sss in nos:
+                            # System in nos, remove system from nos
+                            nos.remove(sss)
+                            for prg in self.mod:
+                                # Add all modules in sss to nop
+                                if prg[2][:2] == sss:
+                                    nop.append([prg[2][:2], prg[2][2:]])
+                    for sss, mod, coy, pwd in self.vop:
+                        # Remove all enabled modules from nop
+                        if [sss, mod] in nop:
+                            nop.remove([sss, mod])
+            # Generate dictionary of financial companies
+            self.fcoy = {}
+            sql = Sql(self.db, ["ctlmst", "ctlynd"], prog="ms0000")
+            jon = "Left outer join ctlynd on cye_cono=ctm_cono"
+            col = ["ctm_cono", "max(cye_period)"]
+            grp = "ctm_cono"
+            chk = sql.getRec(tables="ctlmst", join=jon, cols=col, group=grp)
+            for coy in chk:
+                self.fcoy[coy[0]] = coy[1]
+            # Create usrmen and usrmod
+            self.usrmen = []
+            self.usrmod = []
+            for men in self.men:
+                if not men:
+                    continue
+                add = True
+                for sss in nos:
+                    if men[1][3:] == sss:
+                        add = False
+                if add:
+                    self.usrmen.append(men)
+            mods = copyList(self.mod)
+            for mod in mods:
+                add = True
+                if len(self.fcoy) == 1 and not self.fcoy[1]:
+                    if mod[0][0] == "P" and mod[2] in self.fmod:
+                        continue
+                    if mod[2] == "ms1010":
+                        mod[4] = "Club Record Maintenance"
+                for sss in nos:
+                    if mod[1][3:] == sss:
+                        add = False
+                    elif mod[2][:2] == sss:
+                        add = False
+                for sss, prg in nop:
+                    if mod[2] == "%s%s" % (sss, prg):
+                        add = False
+                if add:
+                    self.usrmod.append(mod)
+        if dbopend:
+            self.db.closeDbase()
+
+    def userCheckPwd(self, pwd):
+        try:
+            crypt = b64Convert("decode", self.user["pwd"])
+        except:
+            crypt = self.user["pwd"]
+        if pwd == self.mf.override:
+            return
+        elif pwd in (self.user["pwd"], crypt):
+            pwlife = self.getCtlSys(["sys_pwlife"])
+            if not pwlife or not self.user["last"]:
+                return
+            t = time.localtime()
+            dte = (t[0] * 10000) + (t[1] * 100) + t[2]
+            chk = projectDate(self.user["last"], pwlife)
+            dif = dateDiff(dte, chk, ptype="days")
+            if not dif:
+                chg = askQuestion(self.mf.window, "Password Expired",
+                    "Your Password Has Expired.\n\nDo You Want to Renew It?")
+                tx = "Expired Password"
+            elif dif < 8:
+                chg = askQuestion(self.mf.window, "Password Expiring",
+                    "Your Password Expires in %s Day(s)!!!\n\nDo You Want "\
+                    "to Renew It Now?" % dif)
+                tx = None
+            else:
+                chg = "no"
+                tx = None
+            if chg == "yes":
+                self.chgPwd()
+                if self.new:
+                    return self.userCheckPwd(self.new)
+                else:
+                    return self.userCheckPwd(self.user["pwd"])
+            else:
+                return tx
+        else:
+            return "Invalid Password"
+
+    def userLogout(self):
+        self.user = {}
+
+    def execCommand(self, typ, prg, tit="", rtn=None, menu=True, password=True):
+        if menu:
+            if self.program and prg == "ps2010":
+                self.mf.window.iconify()
+            self.tarmen.closeMenu()
+        if prg not in ("sysUpd", "sysEnd"):
+            if prg == "tarUpd":
+                vtype = "upd"
+            else:
+                vtype = "chk"
+            if self.doVersionCheck(vtype):
+                if menu:
+                    self.tarmen.drawMenu()
+                return
+        if rtn is not None:
+            try:
+                rtn = int(rtn)
+            except:
+                rtn = None
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        if password and self.getCtlSys(["sys_pwmust"]) == "Y" and not \
+                self.user["pwd"] and prg not in ("chgPwd", "chgUsr", "sysEnd"):
+            showError(self.mf.window, "Missing Password",
+                """Passwords are Enforced.
+
+Please Create a Password by going to:
+
+System --> Change Password""")
+        elif typ[0] == "F":
+            if self.xdisplay:
+                self.mf.head.configure(text="%s (%s)" % (tit, prg))
+                self.mf.updateStatus("")
+            try:
+                if prg == "doManual":
+                    getattr(self, prg)(tit)
+                else:
+                    getattr(self, prg)()
+            except SystemExit:
+                os._exit(0)
+            except:
+                if self.xdisplay:
+                    for wgt in self.mf.window.winfo_children():
+                        if wgt not in (
+                                self.mf.head, self.mf.body, self.mf.status):
+                            wgt.destroy()
+                    showException(self.mf.body, self.rcdic["wrkdir"],
+                        "Function %s Error" % prg, dbm=self.db)
+                else:
+                    showException(None, self.rcdic["wrkdir"],
+                        "Function %s Error" % prg, dbm=self.db)
+                if dbopend:
+                    self.db.closeDbase()
+                self.doExit()
+        elif typ[0] == "P":
+            self.mf.updateStatus("")
+            mcoy = None
+            error = False
+            if self.vop:
+                sss = prg[:2]
+                mmm = prg[2:]
+                if rtn:
+                    mmm = mmm[:3] + str(rtn)
+                for vvv in self.vop:
+                    if vvv[0] == sss and vvv[1] == mmm:
+                        mcoy, self.mpwd = vvv[2:]
+                        error = self.pwdCheck()
+            if not error:
+                popt = {"mf": self.mf}
+                if typ[1] == "Y":
+                    if typ[2] in ("L", "Y"):
+                        if self.program and self.conum:
+                            error = self.conoCheck(self.conum, prg=prg)
+                            if not error and typ[2] == "L":
+                                self.getLastPeriod()
+                        else:
+                            self.getCompany(prg=prg, period=typ[2])
+                        if not self.conum:
+                            error = True
+                        if not error:
+                            if prg in (
+                                    "gl3030", "gl3040", "gl3050", "gl3080",
+                                    "gl4010", "gl4020", "gl6030", "gl6040",
+                                    "gl6070"):
+                                # Check if period is up to date
+                                check = True
+                            else:
+                                check = False
+                            per = getPeriods(self.mf, self.conum, self.finper,
+                                check=check)
+                            if per == (None, None, None):
+                                error = True
+                            elif rtn and per[2] == "Y":
+                                showError(self.mf.body, "Period Error",
+                                    "This Period Has Already Been Finalised")
+                                error = True
+                            else:
+                                popt["period"] = (self.finper, (per[0].work,
+                                    per[0].disp), (per[1].work, per[1].disp))
+                    else:
+                        if self.program and self.conum:
+                            error = self.conoCheck(self.conum, prg=prg)
+                        else:
+                            self.getCompany(prg=prg, period=False)
+                        if not self.conum:
+                            error = True
+                    if mcoy and self.conum != mcoy:
+                        showError(self.mf.body, "Company Error",
+                            "This Company, Module Combination "\
+                            "is Not Allowed for This User")
+                        error = True
+                    if not error:
+                        popt["conum"] = self.conum
+                        popt["conam"] = self.conam
+                        text = "%-s for %s (%s)" % (tit, self.conam, prg)
+                else:
+                    text = "%-s for All Companies (%s)" % (tit, prg)
+            if not error:
+                if typ[3] == "Y":
+                    popt["capnm"] = self.user["name"]
+                if prg == "ml1010":
+                    popt["level"] = self.user["lvl"]
+                if rtn:
+                    popt["rtn"] = int(rtn)
+                if self.xdisplay:
+                    self.mf.head.configure(text=text)
+                    self.mf.updateStatus("")
+                if self.debug:
+                    self.tracer.runfunc(self.doRunModule, prg, **popt)
+                else:
+                    self.doRunModule(prg, **popt)
+        if self.xdisplay:
+            self.mf.head.configure(text="Tartan Systems")
+        if dbopend:
+            try:
+                # Rollback any uncommitted transactions
+                self.db.rollbackDbase()
+            except:
+                pass
+            try:
+                # Close the database
+                self.db.closeDbase()
+            except:
+                pass
+        if menu:
+            # Display the menu
+            if prg == "ms1010":
+                self.userReadCheck(user=self.user["name"])
+                self.tarmen.lvl = self.user["lvl"]
+                self.tarmen.men = self.usrmen
+                self.tarmen.mod = self.usrmod
+                self.tarmen.setVariables()
+            if not self.doVersionCheck():
+                self.checkNotes()
+            self.tarmen.drawMenu()
+
+    def pwdCheck(self):
+        tit = ("Password Validation",)
+        fld = ((("T",0,0,0),"IHA",30,"Password","Password",
+            "","N", self.doPGet,None,None,None,None),)
+        but = (("Cancel", None, self.doPCancel, 1, None, None),)
+        self.df = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.doPEnd, "n"),), txit=(self.doPCancel,))
+        self.mf.startLoop()
+        return self.pwderr
+
+    def doPGet(self, frt, pag, r, c, p, i, w):
+        if w != b64Convert("decode", self.mpwd):
+            return "Invalid Password"
+        self.pwderr = False
+
+    def doPCancel(self):
+        self.pwderr = True
+        self.doPEnd()
+
+    def doPEnd(self):
+        self.df.closeProcess()
+        self.mf.closeLoop()
+
+    def getCompany(self, prg=None, period=None):
+        self.prg = prg
+        self.pertyp = period
+        sql = Sql(self.db, "ctlmst", prog="ms0000")
+        if self.acoy:
+            whr = [("ctm_cono", "in", tuple(self.acoy))]
+        else:
+            whr = None
+        coy = sql.getRec(tables="ctlmst", where=whr, order="ctm_cono")
+        if not coy:
+            showError(self.mf.window, "Error", "No Valid Company Records.")
+            return
+        self.coys = len(coy)
+        if self.coys == 1:
+            # Single Company
+            if prg in self.fsys and not self.fcoy[1]:
+                return
+            self.conum = coy[0][sql.ctlmst_col.index("ctm_cono")]
+            self.conam = coy[0][sql.ctlmst_col.index("ctm_name")].rstrip()
+            self.email = coy[0][sql.ctlmst_col.index("ctm_email")].rstrip()
+            self.modul = coy[0][sql.ctlmst_col.index("ctm_modules")].rstrip()
+            if not self.pertyp:
+                self.finper = None
+                return
+        if not self.conum:
+            if self.acoy:
+                self.conum = self.acoy[0]
+            else:
+                self.conum = 1
+        csel = {
+            "stype": "R",
+            "tables": ("ctlmst",),
+            "cols": (
+                ("ctm_cono", "", 0, "Com"),
+                ("ctm_name", "", 0, "Name", "Y")),
+            "order": "ctm_cono"}
+        if self.acoy:
+            csel["where"] = [("ctm_cono", "in", tuple(self.acoy))]
+        if self.coys == 1:
+            # Single Company
+            tit = ("Period Details",)
+            fld = []
+        else:
+            tit = ("Company Details",)
+            fld = [
+                [("T",0,0,0),"IUI",3,"Company Number","",
+                    self.conum,"N",self.coNum,csel,None,("notzero",)],
+                [("T",0,1,0),"ONA",30,"Company Name","",
+                    "","N",None,None,None,None]]
+        if self.pertyp == "Y":
+            self.psel = {
+                "stype": "R",
+                "tables": ("ctlynd",),
+                "cols": (
+                    ("cye_period", "", 0, "Prd"),
+                    ("cye_start", "", 0, "Start"),
+                    ("cye_end", "", 0, "End"),
+                    ("cye_final", "", 0, "F")),
+                "where": []}
+            fld.append(
+                [["T",0,2,0],"IUI",3,"Financial Period","",
+                    0,"N",self.finPeriod,self.psel,None,None])
+            if self.coys == 1:
+                self.psel["where"] = [("cye_cono", "=", self.conum)]
+                fld[0][0][2] = 0
+                self.getLastPeriod()
+                fld[0][5] = self.finper
+        elif self.pertyp == "L":
+            self.getLastPeriod()
+            if self.coys == 1:
+                return
+        else:
+            self.finper = None
+            if self.coys == 1:
+                return
+        but = (("Cancel", None, self.coExit, 1, ("T",0,1), ("T",0,0)),)
+        self.cp = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.coEnd, "y"),), txit=(self.coExit,))
+        if self.conum:
+            try:
+                self.cp.loadEntry("T", 0, 0, data=self.conum)
+                self.cp.loadEntry("T", 0, 1, data=self.conam)
+                if self.pertyp == "Y" and self.finper is not None:
+                    self.cp.topf[0][2][5] = self.finper
+                    self.cp.loadEntry("T", 0, 2, data=self.finper)
+            except:
+                pass
+        self.cp.focusField("T", 0, 1)
+        self.mf.startLoop()
+
+    def coNum(self, frt, pag, r, c, p, i, w):
+        err = self.conoCheck(w, prg=self.prg)
+        if err:
+            return err
+        self.cp.loadEntry("T", pag, p+1, data=self.conam)
+        if not self.pertyp or self.pertyp == "L":
+            return "ok"
+        self.psel["where"] = [("cye_cono", "=", self.conum)]
+        if self.finper is None:
+            self.getLastPeriod()
+        self.cp.topf[0][2][5] = self.finper
+
+    def getLastPeriod(self):
+        sql = Sql(self.db, "ctlynd", prog="ms0000")
+        p = sql.getRec(tables="ctlynd", cols=["max(cye_period)"],
+            where=[("cye_cono", "=", self.conum)])
+        self.finper = int(p[0][0])
+
+    def finPeriod(self, frt, pag, r, c, p, i, w):
+        sql = Sql(self.db, "ctlynd", prog="ms0000")
+        r = sql.getRec(tables="ctlynd", cols=["cye_period"],
+            where=[("cye_cono", "=", self.conum), ("cye_period", "=", w)],
+            limit=1)
+        if not r:
+            return "Invalid Financial Period"
+        self.finper = w
+
+    def coExit(self):
+        self.conum = None
+        self.coEnd()
+
+    def coEnd(self):
+        self.cp.closeProcess()
+        self.mf.closeLoop()
+
+    def doRunModule(self, *prg, **popt):
+        if self.loader:
+            try:
+                for mod in sys.modules:
+                    if mod.count(prg[0]):
+                        del(sys.modules[mod])
+                        gc.collect()
+            except:
+                pass
+        try:
+            if "rtn" in popt:
+                rtn = popt["rtn"]
+            else:
+                rtn = 0
+            sql = Sql(self.db, ["ffield", "ctllog"], prog="ms0000")
+            if not sql.error:
+                chk = sql.getRec(tables="ffield",
+                    where=[("ff_tabl", "=", "ctllog")])
+            if not sql.error and len(chk) == 7:
+                if not self.user:
+                    name = "admin"
+                else:
+                    name = self.user["name"]
+                logd = [getpass.getuser(), name, prg[0], rtn]
+                if "conum" in popt:
+                    logd.append(popt["conum"])
+                else:
+                    logd.append(0)
+                if "period" in popt:
+                    logd.append(popt["period"][0])
+                else:
+                    logd.append(0)
+                logd.append(long(
+                    "%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3]))
+                sql.insRec("ctllog", data=logd)
+                self.db.commitDbase()
+            if not runModule(prg[0], **popt):
+                raise Exception
+        except:
+            if self.xdisplay:
+                for wgt in self.mf.window.winfo_children():
+                    if wgt not in (self.mf.head, self.mf.body, self.mf.status):
+                        wgt.destroy()
+                showException(self.mf.body, self.rcdic["wrkdir"],
+                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+            else:
+                showException(None, self.rcdic["wrkdir"],
+                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+
+    def checkNotes(self):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        t = time.localtime()
+        self.cdate = ((t[0] * 10000) + (t[1] * 100) + t[2])
+        self.sql = Sql(self.db, ["ctlnot", "ctlpwu"], prog="ms0000")
+        chk = self.sql.getRec(tables="ctlnot", where=[("(", "not_user", "=",
+            self.user["name"], "or", "not_auser", "=", self.user["name"],
+            ")"), ("not_adate", ">", 0), ("not_adate", "<=", self.cdate),
+            ("not_aflag", "<>", "C")])
+        if chk:
+            ok = askQuestion(self.mf.window, "Notes", "There are Notes "\
+                "Flagged for Action Still Outstanding, do You want to "\
+                "View them?")
+            if ok == "yes":
+                self.showNotes(chk)
+        if dbopend:
+            self.db.closeDbase()
+
+    def showNotes(self, notes):
+        data = []
+        for note in notes:
+            nte = note[:4]
+            nte.append(note[6])
+            nte.append(note[7])
+            nte.append(note[8])
+            nte.append(note[5])
+            nte.append(note[9])
+            data.append(nte)
+        tits = "Today's Notes"
+        cols = [
+            ("not_cono", "Coy", 3, "UI", "N"),
+            ("not_sys", "Sys", 3, "UA", "N"),
+            ("not_key", "Key", 30, "NA", "N"),
+            ("not_date", "Entry-Date", 10, "D1", "N"),
+            ("not_aflag", "F", 1, "UA", "N"),
+            ("not_adate", "Action-Dte", 10, "d1", "N"),
+            ("not_auser", "Action-User", 20, "NA", "N"),
+            ("not_desc", "Description", 50, "TX", "N"),
+            ("not_seq", "Sequence", 10, "US", "N")]
+        sr = SelectChoice(self.mf.body, tits, cols, data)
+        if sr.selection:
+            self.selectNote(sr.selection)
+            self.checkNotes()
+
+    def selectNote(self, note):
+        self.chgflag = note[5]
+        self.chgdate = note[6]
+        self.chguser = note[7]
+        self.nseq = note[-1:][0]
+        tit = ("Notes Editing",)
+        r1s = (("Normal","N"),("Urgent","U"),("Completed","C"))
+        fld = (
+            (("T",0,0,0),"O@not_date",0,""),
+            (("T",0,1,0),"O@not_user",0,""),
+            (("T",0,2,0),"OTV",(50,10),"Details"),
+            (("T",0,3,0),("IRB",r1s),0,"Action Flag (C/N/U)","Action Flag",
+                "N","N",self.doChgFlag,None,None,None),
+            (("T",0,4,0),"I@not_adate",0,"","",
+                "","N",self.doChgDate,None,None,("efld",)),
+            (("T",0,5,0),"I@not_auser",0,"","",
+                "","N",self.doChgUser,None,None,("efld",)))
+        but = (
+            ("Accept",None,self.doNEnd,1,None,None),
+            ("Cancel",None,self.doNExit,1,None, None))
+        tnd = ((self.doNEnd, "n"), )
+        txt = (self.doNExit, )
+        self.nf = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=tnd, txit=txt, focus=False)
+        self.nf.loadEntry("T", 0, 0, data=note[4])
+        self.nf.loadEntry("T", 0, 1, data=self.user["name"])
+        self.nf.loadEntry("T", 0, 2, data=note[8])
+        self.nf.loadEntry("T", 0, 3, data=note[5])
+        self.nf.loadEntry("T", 0, 4, data=note[6])
+        self.nf.loadEntry("T", 0, 5, data=note[7])
+        if self.chgflag == "C":
+            self.nf.setWidget(self.nf.B0, "normal")
+            self.nf.setWidget(self.nf.B1, "normal")
+        else:
+            self.nf.focusField("T", 0, 4)
+        self.mf.startLoop()
+
+    def doChgFlag(self, frt, pag, r, c, p, i, w):
+        self.chgflag = w
+        if self.chgflag == "C":
+            return "nd"
+
+    def doChgDate(self, frt, pag, r, c, p, i, w):
+        self.chgdate = w
+
+    def doChgUser(self, frt, pag, r, c, p, i, w):
+        usr = self.sql.getRec(tables="ctlpwu", where=[("usr_name", "=", w)],
+            limit=1)
+        if not usr:
+            return "Invalid User Name"
+        self.chguser = w
+        return "nd"
+
+    def doNEnd(self):
+        self.sql.updRec("ctlnot", cols=["not_aflag", "not_adate", "not_auser"],
+            data=[self.chgflag, self.chgdate, self.chguser], where=[("not_seq",
+            "=", self.nseq)])
+        self.db.commitDbase()
+        self.doNExit()
+
+    def doNExit(self):
+        self.nf.closeProcess()
+        self.mf.closeLoop()
+
+    def chgUsr(self):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        sql = Sql(self.db, "ctlpwu", prog=self.__class__.__name__)
+        cnt = sql.getRec(tables="ctlpwu", cols=["count(*)"],
+            where=[("usr_name", "<>", self.user["name"])], limit=1)
+        if not cnt[0]:
+            showError(self.mf.window, "Change", "There are No Other Users")
+            if dbopend:
+                self.db.closeDbase()
+            return
+        self.userLogout()
+        self.userLogin()
+        if dbopend:
+            self.db.closeDbase()
+        if not self.user:
+            self.doExit()
+        self.tarmen.usr = self.user["name"]
+        self.tarmen.lvl = self.user["lvl"]
+        self.tarmen.men = self.usrmen
+        self.tarmen.mod = self.usrmod
+        self.tarmen.setVariables()
+
+    def chgPwd(self):
+        tit = ("Change Password",)
+        fld = (
+            (("T",0,0,0),"IHA",30,"Old Password","",
+                "","N",self.doOldPwd,None,None,None,None),
+            (("T",0,1,0),"IHA",30,"New Password","",
+                "","N",self.doNewP1,None,None,None,None),
+            (("T",0,2,0),"IHA",30,"New Password","New Password Again",
+                "","N",self.doNewP2,None,None,None,None))
+        but = (("Cancel", None, self.doPwdExit, 1, None, None),)
+        self.np = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.doPwdEnd, "n"),), txit=(self.doPwdExit,))
+        if not self.pwd:
+            self.np.skip[self.np.pag].append(1)
+            self.np.focusField(self.np.frt, self.np.pag, col=2)
+        if self.loop:
+            self.np.mstFrame.wait_window()
+        else:
+            self.mf.startLoop()
+
+    def doOldPwd(self, frt, pag, r, c, p, i, w):
+        if w == self.pwd or w == b64Convert("decode", self.pwd):
+            pass
+        else:
+            return "Invalid Old Password"
+
+    def doNewP1(self, frt, pag, r, c, p, i, w):
+        if w == self.pwd or w == b64Convert("decode", self.pwd):
+            return "Same Password"
+        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
+        if not w and pwmust == "Y":
+            return "You Must Have a Password"
+        if pwsize and len(w) < pwsize:
+            return "Minimum of %s Characters Required" % pwsize
+        self.new = w
+
+    def doNewP2(self, frt, pag, r, c, p, i, w):
+        if w != self.new:
+            return "Invalid New Password"
+        self.pwd = b64Convert("encode", w)
+
+    def doPwdEnd(self):
+        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
+        if not self.pwd and pwmust == "Y":
+            if not self.pwd:
+                self.np.skip[self.np.pag].append(1)
+                self.np.focusField(self.np.frt, self.np.pag, col=2)
+            else:
+                self.np.focusField(self.np.frt, self.np.pag, col=1)
+            self.mf.updateStatus("You Must Have a Password",
+                bg="white", fg="red")
+            return
+        t = time.localtime()
+        dte = (t[0] * 10000) + (t[1] * 100) + t[2]
+        sql = Sql(self.db, "ctlpwu", prog="ms0000")
+        sql.updRec("ctlpwu", cols=["usr_pwd", "usr_last"], data=[self.pwd,
+            dte], where=[("usr_name", "=", self.user["name"])])
+        self.db.commitDbase()
+        self.user["pwd"] = self.pwd
+        self.user["last"] = dte
+        self.np.closeProcess()
+        if not self.loop:
+            self.mf.closeLoop()
+
+    def doPwdExit(self):
+        self.new = None
+        self.np.closeProcess()
+        if not self.loop:
+            self.mf.closeLoop()
+
+    def tarUsr(self):
+        sss = []
+        prg = {}
+        keys = list(self.sss.keys())
+        keys.sort()
+        for s in keys:
+            sm = []
+            sss.append((self.sss[s], s))
+            for mod in self.mod:
+                if mod[0][0] == "P" and mod[2][:2] == s:
+                    if len(mod) == 6:
+                        mod[2] = "%s%s" % (mod[2][:5], mod[5])
+                    sm.append((mod[3], mod[2][2:], mod[4]))
+            prg[s] = sm
+        TartanUser(self.mf, sss, prg)
+
+    def sysUpd(self):
+        tit = ("System Upgrade",)
+        typ = (("Internet", "I"), ("Local", "L"))
+        fld = (
+            (("T",0,0,0),("IRB",typ),0,"Upgrade Type","",
+                "I","N",self.doSysLoc,None,None,None,None),
+            (("T",0,1,0),"ONA",9,"Current Version","",
+                "","N",None,None,None,None,None),
+            (("T",0,2,0),"ONA",9,"Upgrade Version","",
+                "","N",None,None,None,None,None))
+        but = (
+            ("Upgrade", None, self.doSysUpgrade, 0, ("T",0,0), ("T",0,1)),
+            ("Cancel", None, self.doSysUpdXit, 1, None, None))
+        self.su = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=None, txit=(self.doSysUpdXit,))
+        self.mf.startLoop()
+
+    def doSysLoc(self, frt, pag, r, c, p, i, w):
+        self.updtyp = w
+        self.upgsys = ""
+        for mod in self.mods:
+            if mod == ["BC"] and self.upgsys != "Tartan":
+                self.upgsys = "Bwlclb"
+            elif mod == ["BS"] and self.upgsys != "Tartan":
+                self.upgsys = "Bksclb"
+            elif mod == ["CS"] and self.upgsys != "Tartan":
+                self.upgsys = "Cshana"
+            elif mod == ["SC"] and self.upgsys != "Tartan":
+                self.upgsys = "Seccmp"
+            else:
+                self.upgsys = "Tartan"
+        if self.updtyp == "I":
+            err = self.doSysChkUpgrade()
+            if err:
+                showError(self.mf.window, err[0], err[1])
+                return "Upgrade Error"
+            else:
+                self.su.loadEntry("T", 0, 1, data=self.cv[1])
+                self.su.loadEntry("T", 0, 2, data=self.nt)
+                return
+        self.su.setWidget(self.su.mstFrame, "hide")
+        if sys.platform == "win32":
+            ftype = [("Upgrade Files", "%s_%s.*.exe" %
+                (self.upgsys, self.cv[0][0]))]
+        else:
+            ftype = [("Upgrade Files", "%s_%s.*.tgz" %
+                (self.upgsys, self.cv[0][0]))]
+        dialog = FileDialog(**{
+            "parent": self.mf.body,
+            "title": "Select Upgrade File",
+            "initd": self.rcdic["upgdir"],
+            "ftype": ftype})
+        self.updfle = dialog.askopenfilename()
+        self.su.setWidget(self.su.mstFrame, "show")
+        if not self.updfle:
+            return "Invalid File"
+        self.su.loadEntry("T", 0, 1, data=self.cv[1])
+        nv = os.path.basename(self.updfle).split("_")[1].split(".")
+        self.nv = (int(nv[0]), int(nv[1]))
+        self.nt = "%s.%s" % self.nv
+        self.su.loadEntry("T", 0, 2, data=self.nt)
+        self.su.setWidget(self.su.B0, "focus")
+        if int(nv[0]) > self.cv[0][0]:
+            return
+        if int(nv[0]) == self.cv[0][0] and int(nv[1]) > self.cv[0][1]:
+            return
+        self.updfle = None
+        showError(self.mf.window, "Invalid Version",
+            "Not Later Than Current Version.")
+        return "Version Error"
+
+    def doSysChkUpgrade(self):
+        try:
+            flenam = io.BytesIO()
+            error = ftpDownload("ftp.tartan.co.za", "current", dest=flenam)
+            if error:
+                raise Exception
+            v = flenam.getvalue().strip().split(".")
+            flenam.close()
+            self.nv = (int(v[0]), int(v[1]))
+            self.nt = "%s.%s" % self.nv
+            if self.nv[0] > self.cv[0][0]:
+                return
+            elif self.nv[0] == self.cv[0][0] and self.nv[1] > self.cv[0][1]:
+                return
+            return ("Upgrade Error", "No Upgrade Available")
+        except:
+            return ("Connection Error", """Please Ensure that You Are Connected to the Internet.
+
+
+If Not, Please Connect and then Try Again!""")
+
+    def doSysUpgrade(self):
+        self.su.closeProcess()
+        self.mf.updateStatus("")
+        self.mf.closeLoop()
+        ScrollText(scrn=self.mf.body, mess="""
+                        Performing the Upgrade
+
+  After the update has completed you must perform the following:
+
+  1) If you are running Linux the downloaded file will be in your
+     '~/upg' directory. The file's name will be something like
+     '%s_5.x.tgz'.
+
+                                 or
+
+  1) If you are running Windows the downloaded file will be in your
+     'C:\\Tartan\\upg' directory. The file's name will be something like
+     '%s_5.x.exe'.
+  2) Restart Tartan.
+  3) Execute the 'Update File Formats' routine on the 'System' menu.
+  4) If Tartan is installed on other workstations, copy the downloaded
+     file to those other workstations and either, in the case of linux,
+     extract the file into the ~/prg directory or, in the case of
+     Windows, execute the file.""" % (self.upgsys, self.upgsys))
+        try:
+            if self.updtyp == "I":
+                if sys.platform == "win32":
+                    nam = self.upgsys + "_%s.%s_upd.exe" % self.nv
+                    fle = os.path.join(self.mf.rcdic["upgdir"], nam)
+                    error = ftpDownload("ftp.tartan.co.za", nam,
+                        word=self.email, dest=fle, close=True)
+                    if error:
+                        nam = nam.replace("_upd", "")
+                        fle = os.path.join(self.mf.rcdic["upgdir"], nam)
+                        error = ftpDownload("ftp.tartan.co.za", nam,
+                            word=self.email, dest=fle, close=True)
+                else:
+                    nam = self.upgsys + "_%s.%s.%s.tgz" % self.nv
+                    fle = os.path.join(self.mf.rcdic["upgdir"], nam)
+                    error = ftpDownload("ftp.tartan.co.za", nam,
+                        word=self.email, dest=fle, close=True)
+                if error:
+                    raise Exception
+            else:
+                fle = self.updfle
+            if sys.platform == "win32":
+                os.spawnv(os.P_NOWAIT, fle, (fle,))
+            else:
+                os.spawnv(os.P_NOWAIT, "/bin/tar",
+                    ("tar", "-xzf", fle, "-C", self.mf.rcdic["prgdir"]))
+            os._exit(0)
+        except:
+            showError(self.mf.window, "Get Error",
+                "Upgrade File Could Not be Retrieved.\n\n"\
+                "Your System Has Not Been Upgraded.\n\n"\
+                "Please Contact Your IT Manager.")
+            self.doSysUpdXit()
+
+    def doSysUpdXit(self):
+        self.su.closeProcess()
+        self.mf.closeLoop()
+
+    def tarUpd(self, dbcreate=False):
+        if not dbcreate:
+            # Check on status of Database
+            if self.mf.window:
+                ok = askQuestion(self.mf.window, "Backup",
+                    "Have You Backed Up the Database?", default="no")
+            else:
+                ok = raw_input("Have You Backed Up the Database? (yes/no) ")
+            if ok != "yes":
+                return
+        else:
+            if self.xdisplay:
+                self.mf.head.configure(text="Update File Formats (tarUpd)")
+                self.mf.updateStatus("")
+        dbopen = self.db.dbopen
+        if not dbopen:
+            self.db.openDbase()
+        popt = {
+            "mf": self.mf,
+            "bar": True,
+            "cln": True,
+            "pwd": self.mf.rcdic["dbpwd"],
+            "rcf": self.rcfile,
+            "upd": False,
+            "usr": self.mf.rcdic["dbuser"],
+            "ver": self.cv[1]}
+        self.doRunModule("tb1020", **popt)
+        if not dbopen:
+            self.db.closeDbase()
+
+    def doVersionCheck(self, vtype="chk"):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        if self.xdisplay:
+            scrn = self.mf.window
+        else:
+            scrn = "text"
+        sql = Sql(self.db, ["ftable", "ffield", "verupd"])
+        chk = sql.getRec(tables="verupd", limit=1)
+        if not chk:
+            showError(scrn, "Version Error", "Missing verupd Table")
+            self.doExit()
+        v = chk[0].split(".")
+        ov = (int(v[0]), int(v[1].rstrip()))
+        if ov < (5, 5):
+            showError(scrn, "Version Error",
+                """The Version of the Data, %s.%s, is too Old.
+
+Please follow the upgrade instructions at http://www.tartan.co.za/Downloads
+
+or
+
+Email paul@tartan.co.za, with your version number, for assistance.""" % ov)
+            self.doExit()
+        if ov > self.cv[0]:
+            if dbopend:
+                self.db.closeDbase()
+            ok = askQuestion(scrn, "Version Error",
+                """Your Version of TARTAN (%s) Is Older than the File Formats!
+
+Do You Want to Upgrade TARTAN Now?""" % self.cv[1], default="yes")
+            if ok == "yes":
+                self.sysUpd()
+            self.doExit()
+        if vtype == "upd":
+            if dbopend:
+                self.db.closeDbase()
+            return
+        if ov != self.cv[0]:
+            err = True
+        else:
+            err = False
+        chg = False
+        if self.altered:
+            for tb in tabdic:
+                for ext in ("fld", "idx"):
+                    lines = tabdic[tb][ext]
+                    f1 = []
+                    for line in lines:
+                        f1.append(line)
+                    if ext == "fld":
+                        fle = sql.getRec(tables="ffield", where=[("ff_tabl",
+                            "=", tb)], order="ff_seq")
+                        f2 = []
+                        for f in fle:
+                            tp = [int(f[1]), f[2], f[3], float(f[4])]
+                            tp.extend(f[5:])
+                            f2.append(tp)
+                    else:
+                        fle = sql.getRec(tables="ftable", where=[("ft_tabl",
+                            "=", tb)], order="ft_seq")
+                        f2 = []
+                        for f in fle:
+                            tp = [f[1], int(f[2]), f[3]]
+                            for t in f[4:]:
+                                if t:
+                                    tp.append(t)
+                            f2.append(tp)
+                    if not f1 == f2:
+                        chg = True
+                        break
+        if dbopend:
+            self.db.closeDbase()
+        if chg or err:
+            ok = askQuestion(scrn, "Version Error",
+                """Your File Formats Need Updating,
+
+Do You Want to Update Your Files?""", default="yes")
+            if ok == "yes":
+                self.tarUpd(True)
+            else:
+                self.doExit()
+
+    def tarBck(self):
+        self.db.openDbase()
+        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarBck",
+            passwd=self.bpwd)
+        if cf.flag == "ok":
+            try:
+                sql = Sql(self.db, ["ctlmst", "ctlsys"], prog="ms0000")
+                if sql.error:
+                    raise Exception
+                csys = sql.getRec(tables="ctlsys", cols=["sys_budays",
+                    "sys_msvr", "sys_mprt", "sys_msec", "sys_maut",
+                    "sys_mnam", "sys_mpwd"], limit=1)
+                if not csys:
+                    raise Exception
+            except:
+                csys = None
+            if self.zerobar:
+                TarBckRes(self.mf, mode="B", csys=csys, bar=False)
+            else:
+                TarBckRes(self.mf, mode="B", csys=csys)
+        else:
+            if self.xdisplay:
+                scrn = self.mf.window
+            else:
+                scrn = "text"
+            showError(scrn, "Error", "Invalid Backup Password")
+
+    def tarRes(self):
+        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarRes",
+            passwd=self.bpwd)
+        if cf.flag == "ok":
+            TarBckRes(self.mf, mode="R", ver=self.cv[1])
+
+    def tarExp(self):
+        ExportDbase(**{"mf": self.mf})
+
+    def tarImp(self):
+        ImportDbase(**{"mf": self.mf})
+
+    def tarCfg(self):
+        cfg = TartanConfig(self.mf, rcdic=self.rcdic, level=self.lvl)
+        if cfg.rcfile:
+            self.rcfile = cfg.rcfile
+        self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
+        geo = self.rcdic["geo"].split("x")
+        self.mf.geo = [int(geo[0]), int(geo[1])]
+        self.mf.resizeChildren()
+
+    def sysEnd(self):
+        self.userLogout()
+        self.doHousekeeping()
+        self.doExit()
+
+    def doAbout(self, event=None):
+        AboutTartan(self.mf, self.cv[1])
+
+    def doManual(self, tit):
+        sss = tit.split("(")[1].split(")")[0]
+        if sss in allsys:
+            self.doBrowser(sss)
+        else:
+            self.doBrowser("Manual")
+
+    def doQuick(self):
+        self.doBrowser("QuickStart")
+
+    def doBrowser(self, doc):
+        pdf = os.path.join(self.rcdic["prgdir"], "doc", "%s.pdf" % doc)
+        if os.path.exists(pdf):
+            exe, cmd = parsePrg(self.rcdic["vwr"])
+            cmd.append(pdf)
+            os.spawnv(os.P_NOWAIT, exe, tuple(cmd))
+            return
+        rst = os.path.join(self.rcdic["prgdir"], "doc", "%s.rst" % doc)
+        if os.path.exists(rst):
+            import webbrowser
+            from docutils.core import publish_file
+            fle = open(rst, "r")
+            if len(doc) == 3:
+                dat = ""
+                for n, f in enumerate(fle.readlines()):
+                    dat += f
+                    if n == 1 and f.count("----"):
+                        dat += """
+.. contents:: **Table of Contents**
+
+.. raw:: pdf
+
+   PageBreak
+
+"""
+                fle.close()
+            else:
+                dat = fle.read()
+            fle = io.StringIO(dat)
+            htm = rst.replace("rst", "html")
+            publish_file(fle, source_path = fle,
+                destination_path = htm, writer_name ="html",
+                settings_overrides={"embed_stylesheet": False})
+            webbrowser.open(htm)
+            return
+        if internetConnect():
+            try:
+                import webbrowser
+                web = "http://tartan.co.za/cgi-bin/simple_web.py/%s" % doc
+                webbrowser.open(web)
+            except:
+                showError(self.mf.window, "Error", "Browser Not Found.")
+        else:
+            showError(self.mf.window, "Error", "No Internet Connection.")
+
+    def doHousekeeping(self):
+        fles = []
+        for tp in ("csv","gif","jpg","odt","pdf","png","ps","svg","xls"):
+            fles.extend(glob.glob(os.path.join(self.rcdic["wrkdir"],
+                "*.%s" % tp)))
+        if fles:
+            dft = None
+            if "wrkf" in self.mf.rcdic:
+                if self.mf.rcdic["wrkf"] == "T":
+                    dft = "Trash"
+                elif self.mf.rcdic["wrkf"] == "D":
+                    dft = "Delete"
+                else:
+                    dft = "Keep"
+            if TRASH:
+                but = [("Trash", "T", "Send files to Recycle Bin")]
+                if not dft:
+                    dft = "Trash"
+            else:
+                but = []
+                if not dft:
+                    dft = "Delete"
+            but.extend([
+                ("Delete", "D", "Permanently Delete the files"),
+                ("Keep", "K", "Keep the files in the Work Directory")])
+            ask = askChoice(self.mf.body, "Temporary Files",
+                "What do you wish to do with the Temporary Report Files "\
+                "in the wrk Directory?", butt=but, default=dft)
+            if ask == "T":
+                for fle in fles:
+                    try:
+                        send2trash(fle)
+                    except:
+                        pass
+            elif ask == "D":
+                for fle in fles:
+                    try:
+                        os.remove(fle)
+                    except:
+                        pass
+
+    def doExit(self, dbm=True, sysexit=True):
+        if dbm and self.db.dbopen:
+            self.db.closeDbase()
+        if self.debug:
+            sys.settrace(None)
+        if self.output:
+            # Close and display stdout -- Windows Problem
+            try:
+                sys.stdout.close()
+                sys.stdout = sys.__stdout__
+                if os.path.getsize(self.stdout):
+                    text = open(self.stdout, "r")
+                    lines = text.readlines()
+                    text.close()
+                    if self.debug and len(lines) > 1000:
+                        maxi = 1000
+                    else:
+                        maxi = len(lines)
+                    mess = ""
+                    for x in xrange(maxi):
+                        mess = "%s%s" % (mess, lines[x - maxi])
+                    if self.help or self.version:
+                        scrn = None
+                    else:
+                        scrn = self.mf.body
+                    if self.debug:
+                        titl = "Trace Output"
+                    else:
+                        titl = "Standard Output"
+                    if self.xdisplay:
+                        ScrollText(title=titl, scrn=scrn, mess=mess)
+                    else:
+                        print(titl, mess)
+                # Housekeeping
+                for pid in xrange(1000):
+                    try:
+                        if self.debug:
+                            name = "tracer_%s.txt" % pid
+                        else:
+                            name = "stdout_%s.txt" % pid
+                        os.remove(os.path.join(getPrgPath(), name))
+                    except:
+                        pass
+            except:
+                pass
+        if sysexit:
+            sys.exit()
+
+    def doCheckSys(self):
+        sql = Sql(self.db, "ctlsys", prog=self.__class__.__name__)
+        if sql.error:
+            return "error"
+        rec = sql.getRec(tables="ctlsys", limit=1)
+        if not rec:
+            try:
+                self.user = {"name": "admin", "pwd": "", "lvl": 9}
+                self.execCommand("PNNY", "msc110", tit="System Record",
+                    menu=False, password=False)
+                rec = sql.getRec(tables="ctlsys", limit=1)
+            except:
+                rec = [0, "N", 0, 0, 0, "", 0, 0, 0, "", "", "N",
+                    "", "", "N", 0]
+                sql.insRec("ctlsys", rec)
+                self.db.commitDbase()
+        if not rec:
+            return "error"
+
+    def doCheckMst(self):
+        chk = self.conoCheck(1, ctl=True)
+        if not chk:
+            return
+        self.user = {"name": "admin", "pwd": "", "lvl": 9}
+        self.execCommand("PNNY", "ms1010", tit="Company Record",
+            menu=False, password=False)
+        chk = self.conoCheck(1, ctl=True)
+        if chk:
+            return "error"
+
+    def conoCheck(self, coy, prg=None, ctl=False):
+        if self.acoy and not self.acoy.count(coy):
+            self.conum = None
+            return "Unavailable Company Number"
+        if self.dcoy and self.dcoy.count(coy):
+            self.conum = None
+            return "Unavailable Company Number"
+        if prg in self.fsys and not self.fcoy[coy]:
+            return "xt"
+        gcl = GetCtl(self.mf)
+        chk = gcl.getCtl("ctlmst", coy, error=False)
+        if not chk:
+            self.conum = None
+            return "Invalid Company"
+        if ctl:
+            return
+        self.conum = coy
+        self.conum = chk["ctm_cono"]
+        self.conam = chk["ctm_name"]
+        self.email = chk["ctm_email"]
+        self.modul = chk["ctm_modules"]
+        if not prg:
+            return
+        # Check Module
+        mod = prg[:2].upper()
+        if mod in ("BM", "CA", "MS", "RP", "TD"):
+            return
+        for x in xrange(0, len(self.modul), 2):
+            if self.modul[x:x + 2] == mod:
+                return
+        return "System (%s) Not Enabled for Company %s" % (mod, self.conum)
+
+    def getCtlSys(self, cols):
+        try:
+            sql = Sql(self.db, "ctlsys", prog="ms0000")
+            if sql.error:
+                raise Exception
+            sss = sql.getRec(tables="ctlsys", cols=cols, limit=1)
+            if not sss:
+                raise Exception
+            if len(cols) == 1:
+                return sss[0]
+            else:
+                return sss
+        except:
+            sss = []
+            for col in cols:
+                sss.append(None)
+            return sss
+
+    def doSqlCmd(self):
+        if type(self.query) is list:
+            flenam = self.query
+        else:
+            name = os.path.abspath(self.query)
+            if os.path.isfile(name):
+                flenam = open(name, "r")
+            else:
+                return "Invalid Query File (%s)" % name
+        self.db.openDbase()
+        for line in flenam:
+            line = line.rstrip()
+            if not line or line[0] == "#":
+                continue
+            comm = line.split()
+            sel = False
+            qty = None
+            if comm and comm[0].lower() == "select":
+                sel = True
+                if comm[1][:3].lower() in ("avg", "max", "min", "sum"):
+                    qty = 1
+                elif comm[1].lower() == "count(*)":
+                    qty = 1
+                for num, cmd in enumerate(comm):
+                    if num < 2:
+                        continue
+                    if cmd == "limit":
+                        qty = int(comm[num + 1])
+                        break
+            try:
+                if comm[0] == "commit":
+                    self.db.commitDbase()
+                else:
+                    sq = Sql(self.db)
+                    if sel:
+                        ret = sq.sqlRec(line, limit=qty)
+                        self.mess = ""
+                        for r in ret:
+                            if type(r) is list:
+                                r = str(r)[1:-1]
+                            else:
+                                r = str(r)
+                            if not self.mess:
+                                self.mess = r
+                            else:
+                                self.mess = self.mess + "\n" + r
+                        if self.xdisplay and self.output:
+                            self.mf.window.deiconify()
+                            self.mf.head.configure(text="SQL Query")
+                            but = ([("Save", self.doSave)])
+                            ScrollText(scrn=self.mf.body, mess=self.mess,
+                                butt=but)
+                        else:
+                            print(self.mess)
+                    else:
+                        sq.sqlRec(line)
+            except:
+                self.db.closeDbase()
+                return "Error in SQL Statement\n\n%s" % line
+        self.db.closeDbase()
+
+    def doSave(self):
+        fle = open(os.path.join(self.rcdic["wrkdir"], "query.txt"), "w")
+        fle.write(self.mess + "\n")
+        fle.close()
+
 if __name__ == "__main__":
-    # Run Tartan
+    import getopt
+
+    # Add the program path to the PATH variable if possible
+    ppath = os.path.realpath(sys.path[0])
+    if os.path.isfile(ppath):
+        ppath = os.path.normpath(os.path.dirname(ppath))
+    if ppath not in os.environ["PATH"].split(os.pathsep):
+        epath = "%s%s%s" % (os.environ["PATH"], os.pathsep, ppath)
+        os.environ["PATH"] = epath
+    # Ubuntu Unity uses the Global Menu which breaks Tartan's Menu
+    if sys.platform == "linux2":
+        os.environ["UBUNTU_MENUPROXY"] = "0"
+    # Load options
     try:
         opts, args = getopt.getopt(
-            sys.argv[1:],
-            "ab:c:de:f:hiklnop:q:R:r:t:u:vxz", [
+            sys.argv[1:], "ab:c:de:f:hiklnop:q:R:r:t:u:vxz", [
                 "altered", "bpwd=", "conum=", "debug", "exclude=", "finper=",
                 "help", "image", "loader", "nocheck", "output", "program=",
                 "query=", "rcfdir=", "rcfile=", "tcode=", "user=", "version",
                 "xdisplay", "zerobar"])
     except:
         opts, args = [("-h", "")], []
-    try:
-        from msc000 import msc000
-    except:
-        from mst.msc000 import msc000
-    msc000(VERSION, opts, args)
+    ms0000(opts, args)
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== removed file 'mst/msc000.py'
--- mst/msc000.py	2020-03-06 12:26:48 +0000
+++ mst/msc000.py	1970-01-01 00:00:00 +0000
@@ -1,1842 +0,0 @@
-"""
-SYNOPSIS
-    This file is part of Tartan Systems (TARTAN).
-
-AUTHOR
-    Written by Paul Malherbe, <paul@tartan.co.za>
-
-COPYING
-    Copyright (C) 2004-2020 Paul Malherbe.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program. If not, see <https://www.gnu.org/licenses/>.
-"""
-
-import getpass, gc, glob, io, os, platform, sys, time
-from TartanClasses import AboutTartan, Dbase, DBCreate, FileDialog
-from TartanClasses import GetCtl, GUI, MainFrame, MkWindow, PwdConfirm
-from TartanClasses import ScrollText, SelectChoice, Sql, TarBckRes
-from TartanClasses import TartanConfig, TartanDialog, TartanMenu, TartanUser
-from tartanFunctions import askQuestion, askChoice, b64Convert, chkMod, copyList
-from tartanFunctions import dateDiff, ftpDownload, getPeriods, getPrgPath
-from tartanFunctions import internetConnect, loadRcFile, parsePrg, projectDate
-from tartanFunctions import runModule, showError, showException
-from tartanWork import allsys, tabdic, tarmen
-try:
-    from send2trash import send2trash
-    TRASH = True
-except:
-    TRASH = False
-
-class msc000(object):
-    def __init__(self, version, opts, args):
-        self.cv = [version, "%s.%s" % version]
-        default = [
-            ("altered", False),
-            ("bpwd", ""),
-            ("conum", None),
-            ("debug", False),
-            ("exclude", []),
-            ("finper", None),
-            ("help", False),
-            ("itoggle", False),
-            ("loader", False),
-            ("nocheck", False),
-            ("program", None),
-            ("query", None),
-            ("rcfdir", None),
-            ("rcfile", None),
-            ("tcode", 0),
-            ("user", {}),
-            ("version", False),
-            ("xdisplay", True),
-            ("zerobar", False)]
-        if sys.platform == "win32":
-            default.append(("output", True))
-        else:
-            default.append(("output", False))
-        for arg, val in default:
-            setattr(self, arg, val)
-        for o, v in opts:
-            if o in ("-a", "--altered"):
-                self.altered = True
-            if o in ("-b", "--bpwd"):
-                self.bpwd = v
-            elif o in ("-c", "--conum"):
-                self.conum = int(v)
-            elif o in ("-d", "--debug"):
-                self.debug = True
-            elif o in ("-e", "--exclude"):
-                self.exclude = v.split(",")
-            elif o in ("-f", "--finper"):
-                self.finper = int(v)
-            elif o in ("-h", "--help"):
-                self.help = True
-            elif o in ("-i", "--image"):
-                self.itoggle = True
-            elif o in ("-l", "--loader"):
-                self.loader = True
-            elif o in ("-n", "--nocheck"):
-                self.nocheck = True
-            elif o in ("-o", "--output"):
-                if sys.platform == "win32":
-                    self.output = False
-                else:
-                    self.output = True
-            elif o in ("-p", "--program"):
-                self.program = v
-            elif o in ("-q", "--query"):
-                if not args:
-                    if len(v.split()) == 1:
-                        # Execute sql commands in a file
-                        self.query = v
-                    else:
-                        self.query = [v.replace("\\", "")]
-                else:
-                    self.query = []
-                    for a in args:
-                        if a.count(";"):
-                            b = a.split(";")
-                            v = "%s %s" % (v, b[0].replace("\\", ""))
-                            self.query.append(v)
-                            v = b[1]
-                            continue
-                        if not v:
-                            v = a
-                        else:
-                            v = "%s %s" % (v, a.replace("\\", ""))
-                    self.query.append(v)
-            elif o in ("-R", "--rcfdir"):
-                self.rcfdir = v
-            elif o in ("-r", "--rcfile"):
-                self.rcfile = v
-            elif o in ("-t", "--tcode"):
-                self.tcode = int(v)
-            elif o in ("-u", "--user"):
-                user = v.split(":")
-                self.user["name"] = user[0]
-                if len(user) == 2:
-                    self.user["pwd"] = user[1]
-                else:
-                    self.user["pwd"] = ""
-            elif o in ("-v", "--version"):
-                self.version = True
-            elif o in ("-x", "--xdisplay"):
-                self.xdisplay = False
-            elif o in ("-z", "--zerobar"):
-                self.zerobar = True
-        if self.output:
-            # Redirect stdout
-            for pid in xrange(1000):
-                if self.debug:
-                    name = "tracer_%s.txt" % pid
-                else:
-                    name = "stdout_%s.txt" % pid
-                self.stdout = os.path.join(getPrgPath(), name)
-                try:
-                    if not os.path.exists(self.stdout):
-                        sys.stdout = open(self.stdout, "w")
-                        os.chmod(self.stdout, 0o777)
-                        break
-                except:
-                    pass
-        if self.help:
-            print("""
-Tartan Systems Help
-
-Usage:      python ms0000.py [options]
-
-Options:
-            -a, --altered           Check for Altered Tables
-            -b, --bpwd=             The backup password
-            -c, --conum=            The company number
-            -d, --debug             Enter debug/trace mode
-            -e, --exclude=          Modules to ignore in debug/trace mode
-            -f, --finper=           The financial period
-            -h, --help              This Help Message
-            -i, --image             Toggle the Tartan image option.
-            -l, --loader            Try and remove module before importing
-            -n, --nocheck           Do not check for system records
-            -o, --output            Toggle stdout redirection to stdout.txt
-                                        Linux   defaults to False
-                                        Windows defaults to True
-            -p, --program=          Execute program directly bypassing the menu
-            -q, --query=            Execute a sql query
-            -R, --rcfdir=           Directory of Available Tartan RC Files
-            -r, --rcfile=           Path of Tartan RC File to use
-            -t, --tcode=            Transaction code
-            -u, --user=             User name and password e.g. name:password
-            -v, --version           Display Version Details
-            -x, --xdisplay          Do not have a mainframe with -ptarBck
-            -z, --zerobar           Do not have a progressbar with -ptarBck
-""")
-            self.doExit(dbm=False)
-        if not self.version and not self.xdisplay:
-            nodisp = ("tarBck", "tarUpd", "ml6030")
-            if not self.query and self.program not in nodisp:
-                print("xdisplay False but module not in %s" % str(nodisp))
-                self.doExit(dbm=False)
-            elif not self.user:
-                print("xdisplay False but No User Name")
-                self.doExit(dbm=False)
-        if not self.version and self.xdisplay and not GUI:
-            print("Tkinter/ttk not Available or Installed")
-            self.doExit(dbm=False)
-        if self.version:
-            nm = platform.uname()
-            print("%-16s: %s" % ("Tartan", self.cv[1]))
-            print("%-16s: %s, %s, %s" % ("O/System", nm[0], nm[2], nm[4]))
-            print("%-16s: %s" % ("python", sys.version.split()[0]))
-            try:
-                from TartanClasses import tk
-                print("%-16s: %s" % ("tcl/tk",
-                    tk.Tcl().eval("info patchlevel")))
-            except:
-                print("%-16s: %s" % ("Tcl/Tk", "Not Installed"))
-            mods = (
-                ("fpdf", "fpdf", "__version__"),
-                ("PIL", "pillow", "__version__"),
-                ("fdb", "fdb", "__version__"),
-                ("ghostscript", "ghostscript", "__version__"),
-                ("markdown", "markdown", "__version__"),
-                ("ofxtools", "ofxtools", "__version__"),
-                ("psycopg2", "psycopg2", "__version__"),
-                ("pyaes", "pyaes", "VERSION"),
-                ("pychart", "python-chart", ("version", "version")),
-                ("Crypto", "pycryptodome", "__version__"),
-                ("pyexcel_ods", "pyexcel-ods", None),
-                ("pygal", "pygal", "__version__"),
-                ("pymysql", "pymysql", "__version__"),
-                ("smb", "pysmb", None),
-                ("sqlite3", "pysqlite", "version"),
-                ("sqlite3", "sqlite3", "sqlite_version"),
-                ("escpos", "python-escpos", ("version", "version")),
-                ("requests", "requests", "__version__"),
-                ("send2trash", "send2trash", None),
-                ("tkcolorpicker", "tkcolorpicker", None),
-                ("tkinterhtml", "tkinterhtml", None),
-                ("tqdm", "tqdm", None),
-                ("xlrd", "xlrd", "__VERSION__"),
-                ("xlwt", "xlwt", "__VERSION__"))
-            for mod in mods:
-                ver = chkMod(mod[0])
-                if not ver:
-                    print("%-16s: Not Installed" % mod[1])
-                else:
-                    if not mod[2]:
-                        print("%-16s: Installed" % mod[1])
-                    else:
-                        if type(mod[2]) == tuple:
-                            ver = getattr(ver, mod[2][0])
-                            ver = getattr(ver, mod[2][1])
-                        else:
-                            ver = getattr(ver, mod[2])
-                        if type(ver) == list:
-                            ver = "%s.%s.%s" % tuple(ver)
-                        ver = ver.split()[0]
-                        print("%-16s: %s" % (mod[1], ver))
-            self.doExit(dbm=False)
-        if self.debug:
-            # Set trace mode
-            import trace
-            igm = ["__init__"]
-            if self.exclude:
-                igm.extend(self.exclude)
-            if sys.platform == "win32" and \
-                    os.path.basename(sys.path[0]) == "library.zip":
-                igd = []
-                for mod in sys.modules:
-                    igm.append(mod)
-            else:
-                igd = [sys.prefix, sys.exec_prefix]
-            os.environ["TARTANDB"] = "1"
-            self.tracer = trace.Trace(ignoredirs=igd, ignoremods=igm,
-                trace=1, count=0)
-        self.setVariables()
-        if self.rcfdir:
-            if not os.path.isdir(self.rcfdir):
-                showError(None, "Directory Error",
-                    "Invalid -R Directory: %s" % self.rcfdir)
-                self.doExit(dbm=False)
-            icon = os.path.join(getPrgPath(), "img", "tartan.png")
-            scrn = MkWindow(tk=True, icon=icon).newwin
-            dialog = FileDialog(**{"parent": scrn, "initd": self.rcfdir})
-            self.rcfile = dialog.askopenfilename()
-            scrn.destroy()
-            if not self.rcfile:
-                self.doExit(dbm=False)
-        self.mf = None
-        self.loop = False
-        self.rcdic = None
-        main = "Tartan Systems - Copyright %s 2004-2020 Paul Malherbe" % \
-            unichr(0xa9)
-        while not self.rcdic:
-            self.rcdic = loadRcFile(self.rcfile, default=True)
-            if self.rcdic == "error":
-                self.doExit(dbm=False)
-            elif not os.path.isfile(self.rcdic["name"]):
-                self.mf = MainFrame(title=main, rcdic=self.rcdic)
-                if self.mf.rcdic == "error":
-                    self.doExit(dbm=False)
-                self.mf.dbm = None
-                self.mf.window.deiconify()
-                cfg = TartanConfig(self.mf, rcfile=self.rcfile,
-                    rcdic=self.rcdic, level=9)
-                if not cfg.rcfile:
-                    self.doExit(dbm=False)
-                self.rcfile = self.mf.rcfile = cfg.rcfile
-                self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
-        titl = "%s - (%s - %s@%s)" % (main, self.rcdic["dbase"],
-            self.rcdic["dbname"], self.rcdic["dbhost"])
-        if not self.mf:
-            # Create MainFrame if not already existing
-            self.mf = MainFrame(title=titl, rcdic=self.rcdic,
-                xdisplay=self.xdisplay)
-            if self.mf.rcdic == "error":
-                self.doExit(dbm=False)
-        else:
-            self.mf.window.title(titl)
-        if self.xdisplay:
-            self.mf.head.configure(text="Tartan Systems")
-        # Try connecting to the database and create if missing
-        self.db = Dbase(rcdic=self.rcdic, screen=self.mf.body)
-        if self.db.err:
-            self.doExit(dbm=False)
-        self.mf.dbm = self.db
-        err = self.db.checkDbase()
-        if err not in (True, False):
-            self.doExit()
-        elif err is False:
-            ok = askQuestion(self.mf.window, "Database",
-                "Create the Database Now?")
-            if ok == "no":
-                self.doExit()
-            else:
-                opts = [
-                    ("-c", "i"),
-                    ("-l", self.mf.body),
-                    ("-u", self.rcdic["dbuser"]),
-                    ("-p", self.rcdic["dbpwd"]),
-                    ("-v", self.cv[1]),
-                    ("-x", True)]
-                DBCreate(dbm=self.db, opts=opts)
-                self.tarUpd(True)
-        if not self.nocheck:
-            # Open the database
-            self.db.openDbase()
-            # Check for ctlsys and if missing call msc110
-            err = self.doCheckSys()
-            if not err:
-                # Check for ctlmst and if missing call ms1010
-                err = self.doCheckMst()
-            if err:
-                # If error, exit
-                self.doExit()
-            # List of financial modules
-            self.fmod = ["ms1020", "ms1040", "ms3010", "msy010", "msy020"]
-            # Close dbase
-            self.db.closeDbase()
-        if self.user:
-            # Check if user details supplied are valid
-            self.userReadCheck(user=self.user["name"], pwd=self.user["pwd"],
-                pwdchk=True)
-            if not self.user:
-                if self.xdisplay:
-                    scrn = self.mf.window
-                else:
-                    scrn = "text"
-                showError(scrn, "Error", "Invalid User or User Password")
-        else:
-            # Login user
-            self.userLogin()
-        if not self.user:
-            # Exit if not valid user
-            self.doExit()
-        if not self.program or self.program != "tarUpd":
-            # Check tartan version
-            self.doVersionCheck()
-        if self.query:
-            # Excecute sql query
-            if self.user["lvl"] == 9:
-                err = self.doSqlCmd()
-            else:
-                err = "Invalid Security Level"
-            if err:
-                if self.xdisplay:
-                    showError(self.mf.body, "Data Base Error",
-                        "\nDbCommand Error: %s\n" % err)
-                else:
-                    print("Data Base Error", "DbCommand Error: %s\n" % err)
-            self.doExit()
-        if self.program:
-            # Excecute module without the menu
-            mods = copyList(self.usrmod)
-            mods.append(["PNNN", "mm_sy", "tb1010", 9, "Amend Tables"])
-            mods.append(["PNNN", "mm_sy", "tb1030", 9, "Edit Tables"])
-            mods.append(["PNNN", "mm_sy", "tb3010", 9, "Print Tables"])
-            found = False
-            for mod in mods:
-                if mod[2] == self.program:
-                    if len(mod) == 5:
-                        found = True
-                        break
-                    elif len(mod) == 6 and mod[5] == self.tcode:
-                        found = True
-                        break
-            if found:
-                if self.xdisplay and self.program != "ps2010":
-                    self.mf.window.deiconify()
-                self.execCommand(mod[0], self.program, mod[4], rtn=self.tcode,
-                    menu=False)
-            else:
-                print("Invalid Module (%s) or Missing Options e,g, "\
-                    "(-c, -f or -t)" % self.program)
-            self.doExit()
-        if self.itoggle:
-            # Toggle the display of the tartan image
-            if self.mf.rcdic["img"].lower() == "y":
-                self.image = False
-            else:
-                self.image = True
-        elif self.mf.rcdic["img"].lower() == "y":
-            # Display the tartan image
-            self.image = True
-        else:
-            # Do not display the tartan image
-            self.image = False
-        if self.image:
-            image = os.path.join(self.rcdic["prgdir"], "img", "tartan.png")
-        else:
-            image = None
-        # Create the tartan menu
-        self.tarmen = TartanMenu(mf=self.mf, usr=self.user["name"],
-            men=self.usrmen, mod=self.usrmod, lvl=self.user["lvl"],
-            cmd=self.execCommand, img=image)
-        if not self.doVersionCheck():
-            # Check for notes
-            self.checkNotes()
-        # Display the tartan menu
-        self.tarmen.drawMenu()
-
-    def setVariables(self):
-        self.vop = []
-        self.sss = {}
-        self.men = []
-        self.mod = []
-        self.acoy = []
-        self.dcoy = []
-        self.fsys = ("ms1020", "ms1040", "ms3010", "msy010", "msy020")
-        for s in sorted(list(allsys.items()), key=lambda kv: kv[1][3]):
-            try:
-                self.men.extend(tarmen["%2smen" % s[1][1].lower()])
-                self.mod.extend(tarmen["%2smod" % s[1][1].lower()])
-                self.sss[s[1][1].lower()] = s[1][0]
-            except:
-                pass
-        t = time.localtime()
-        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
-        self.direct = False
-        self.tarmen = None
-        self.email = None
-
-    def userLogin(self):
-        if not self.db.dbopen:
-            self.db.openDbase()
-            dbopend = True
-        else:
-            dbopend = False
-        if not self.user:
-            self.userReadCheck()
-            if self.user and not self.user["pwd"]:
-                return
-        if self.user:
-            login = self.user["name"]
-        else:
-            try:
-                login = getpass.getuser()
-                if not self.userReadCheck(login, userchk=True):
-                    raise Exception
-            except:
-                login = ""
-        tit = ("User Login and Validation",)
-        fld = (
-            (("T",0,0,0),"INA",30,"Name","Your User Name",
-                login,"N",self.usrNam,None,None,None,None,
-                "Your log-in Name"),
-            (("T",0,1,0),"IHA",30,"Password","Your Password",
-                "","N",self.usrPwd,None,None,None,None,
-                "Your password. You are allowed a Maximum of 3 attempts."))
-        but = (("Quit", None, self.noUser, 1, None, None),)
-        self.li = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=((self.endUser, "n"),), txit=(self.noUser,))
-        self.loop = True
-        self.mf.startLoop()
-        if dbopend:
-            self.db.closeDbase()
-
-    def usrNam(self, frt, pag, r, c, p, i, w):
-        self.userReadCheck(w)
-        if not self.user:
-            return "Invalid User"
-        if not self.user["pwd"]:
-            return "sk1"
-        self.times = 0
-
-    def usrPwd(self, frt, pag, r, c, p, i, w):
-        err = self.userCheckPwd(w)
-        if not err:
-            return "nc"
-        elif err == "Expired Password" or self.times == 2:
-            return "xt"
-        else:
-            self.times += 1
-            return "Invalid Password"
-
-    def noUser(self):
-        self.user = {}
-        self.endUser()
-
-    def endUser(self):
-        self.loop = False
-        self.li.closeProcess()
-        self.mf.closeLoop()
-
-    def userReadCheck(self, user=None, userchk=False, pwd=None, pwdchk=False):
-        if not self.db.dbopen:
-            self.db.openDbase()
-            dbopend = True
-        else:
-            dbopend = False
-        sql = Sql(self.db, ["ctlmst", "ctlpwu", "ctlpwm"], prog="msc000")
-        if not user:
-            chk = sql.getRec(tables="ctlpwu")
-            if len(chk) == 1:
-                user = chk[0][sql.ctlpwu_col.index("usr_name")]
-        usr = sql.getRec(tables="ctlpwu", where=[("usr_name", "=", user)],
-            limit=1)
-        if userchk:
-            if dbopend:
-                self.db.closeDbase()
-            return usr
-        if not usr:
-            self.user = {}
-        else:
-            self.user = {
-                "name": user,
-                "pwd":  usr[sql.ctlpwu_col.index("usr_pwd")]}
-            if "usr_last" in sql.ctlpwu_col:
-                self.user["last"] = usr[sql.ctlpwu_col.index("usr_last")]
-            else:
-                self.user["last"] = 0
-            if "usr_coy" in sql.ctlpwu_dic:
-                self.user["acoy"] = usr[sql.ctlpwu_col.index("usr_coy")]
-                self.user["dcoy"] = ""
-            else:
-                self.user["acoy"] = usr[sql.ctlpwu_col.index("usr_acoy")]
-                self.user["dcoy"] = usr[sql.ctlpwu_col.index("usr_dcoy")]
-            self.user["lvl"] = usr[sql.ctlpwu_col.index("usr_lvl")]
-            if pwdchk and self.user["pwd"] and self.userCheckPwd(pwd):
-                self.user = {}
-            if self.user:
-                self.acoy = []
-                self.dcoy = []
-                self.usrnam = self.user["name"]
-                self.pwd = self.user["pwd"]
-                acoy = self.user["acoy"]
-                dcoy = self.user["dcoy"]
-                self.lvl = self.user["lvl"]
-                if acoy:
-                    acoy = acoy.split(",")
-                else:
-                    acoy = []
-                for co in acoy:
-                    if int(co):
-                        self.acoy.append(int(co))
-                if dcoy:
-                    dcoy = dcoy.split(",")
-                else:
-                    dcoy = []
-                for co in dcoy:
-                    if int(co):
-                        self.dcoy.append(int(co))
-                nos = []
-                # All systems not in the company and phone modules - nos
-                for sss in self.sss:
-                    if sss not in ("ms", "td"):
-                        nos.append(sss)
-                # Remove enabled systems
-                self.mods = sql.getRec(tables="ctlmst", cols=["ctm_modules"],
-                    group="ctm_modules")
-                for mod in self.mods:
-                    for x in xrange(0, len(mod[0]), 2):
-                        m = mod[0][x:x+2]
-                        if m.lower() in nos:
-                            nos.remove(m.lower())
-                # All systems excluded for the user - ctlpwm - nos
-                tmp = sql.getRec(tables="ctlpwm", cols=["mpw_sys"],
-                    where=[("mpw_usr", "=", self.user["name"]),
-                    ("mpw_prg", "=", "")])
-                if tmp:
-                    for s in tmp:
-                        if s not in nos:
-                            nos.append(s[0])
-                # All modules excluded for the user - ctlpwm - nop
-                nop = sql.getRec(tables="ctlpwm", cols=["mpw_sys",
-                    "mpw_prg"], where=[("mpw_usr", "=", self.user["name"]),
-                    ("mpw_prg", "<>", ""), ("mpw_pwd", "=", "")])
-                # All modules enabled for the user - self.vop
-                self.vop = sql.getRec(tables="ctlpwm", cols=["mpw_sys",
-                    "mpw_prg", "mpw_coy", "mpw_pwd"], where=[("mpw_usr",
-                    "=", self.user["name"]), ("mpw_prg", "<>", ""),
-                    ("mpw_pwd", "<>", "")])
-                if self.vop:
-                    for sss, mod, coy, pwd in self.vop:
-                        if sss in nos:
-                            # System in nos, remove system from nos
-                            nos.remove(sss)
-                            for prg in self.mod:
-                                # Add all modules in sss to nop
-                                if prg[2][:2] == sss:
-                                    nop.append([prg[2][:2], prg[2][2:]])
-                    for sss, mod, coy, pwd in self.vop:
-                        # Remove all enabled modules from nop
-                        if [sss, mod] in nop:
-                            nop.remove([sss, mod])
-            # Generate dictionary of financial companies
-            self.fcoy = {}
-            sql = Sql(self.db, ["ctlmst", "ctlynd"], prog="msc000")
-            jon = "Left outer join ctlynd on cye_cono=ctm_cono"
-            col = ["ctm_cono", "max(cye_period)"]
-            grp = "ctm_cono"
-            chk = sql.getRec(tables="ctlmst", join=jon, cols=col, group=grp)
-            for coy in chk:
-                self.fcoy[coy[0]] = coy[1]
-            # Create usrmen and usrmod
-            self.usrmen = []
-            self.usrmod = []
-            for men in self.men:
-                if not men:
-                    continue
-                add = True
-                for sss in nos:
-                    if men[1] == "mm_%s" % sss:
-                        add = False
-                if add:
-                    self.usrmen.append(men)
-            mods = copyList(self.mod)
-            for mod in mods:
-                add = True
-                if len(self.fcoy) == 1 and not self.fcoy[1]:
-                    if mod[0][0] == "P" and mod[2] in self.fmod:
-                        continue
-                    if mod[2] == "ms1010":
-                        mod[4] = "Club Record Maintenance"
-                for sss in nos:
-                    if mod[2][:2] == sss:
-                        add = False
-                for sss, prg in nop:
-                    if mod[2] == "%s%s" % (sss, prg):
-                        add = False
-                if add:
-                    self.usrmod.append(mod)
-        if dbopend:
-            self.db.closeDbase()
-
-    def userCheckPwd(self, pwd):
-        try:
-            crypt = b64Convert("decode", self.user["pwd"])
-        except:
-            crypt = self.user["pwd"]
-        if pwd == self.mf.override:
-            return
-        elif pwd in (self.user["pwd"], crypt):
-            pwlife = self.getCtlSys(["sys_pwlife"])
-            if not pwlife or not self.user["last"]:
-                return
-            t = time.localtime()
-            dte = (t[0] * 10000) + (t[1] * 100) + t[2]
-            chk = projectDate(self.user["last"], pwlife)
-            dif = dateDiff(dte, chk, ptype="days")
-            if not dif:
-                chg = askQuestion(self.mf.window, "Password Expired",
-                    "Your Password Has Expired.\n\nDo You Want to Renew It?")
-                tx = "Expired Password"
-            elif dif < 8:
-                chg = askQuestion(self.mf.window, "Password Expiring",
-                    "Your Password Expires in %s Day(s)!!!\n\nDo You Want "\
-                    "to Renew It Now?" % dif)
-                tx = None
-            else:
-                chg = "no"
-                tx = None
-            if chg == "yes":
-                self.chgPwd()
-                if self.new:
-                    return self.userCheckPwd(self.new)
-                else:
-                    return self.userCheckPwd(self.user["pwd"])
-            else:
-                return tx
-        else:
-            return "Invalid Password"
-
-    def userLogout(self):
-        self.user = {}
-
-    def execCommand(self, typ, prg, tit="", rtn=None, menu=True, password=True):
-        if menu:
-            if self.program and prg == "ps2010":
-                self.mf.window.iconify()
-            self.tarmen.closeMenu()
-        if prg not in ("sysUpd", "sysEnd"):
-            if prg == "tarUpd":
-                vtype = "upd"
-            else:
-                vtype = "chk"
-            if self.doVersionCheck(vtype):
-                if menu:
-                    self.tarmen.drawMenu()
-                return
-        if rtn is not None:
-            try:
-                rtn = int(rtn)
-            except:
-                rtn = None
-        if not self.db.dbopen:
-            self.db.openDbase()
-            dbopend = True
-        else:
-            dbopend = False
-        if password and self.getCtlSys(["sys_pwmust"]) == "Y" and not \
-                self.user["pwd"] and prg not in ("chgPwd", "chgUsr", "sysEnd"):
-            showError(self.mf.window, "Missing Password",
-                """Passwords are Enforced.
-
-Please Create a Password by going to:
-
-System --> Change Password""")
-        elif typ[0] == "F":
-            if self.xdisplay:
-                self.mf.head.configure(text="%s (%s)" % (tit, prg))
-                self.mf.updateStatus("")
-            try:
-                getattr(self, prg)()
-            except SystemExit:
-                os._exit(0)
-            except:
-                if self.xdisplay:
-                    for wgt in self.mf.window.winfo_children():
-                        if wgt not in (
-                                self.mf.head, self.mf.body, self.mf.status):
-                            wgt.destroy()
-                    showException(self.mf.body, self.rcdic["wrkdir"],
-                        "Function %s Error" % prg, dbm=self.db)
-                else:
-                    showException(None, self.rcdic["wrkdir"],
-                        "Function %s Error" % prg, dbm=self.db)
-                if dbopend:
-                    self.db.closeDbase()
-                self.doExit()
-        elif typ[0] == "P":
-            self.mf.updateStatus("")
-            mcoy = None
-            error = False
-            if self.vop:
-                sss = prg[:2]
-                mmm = prg[2:]
-                if rtn:
-                    mmm = mmm[:3] + str(rtn)
-                for vvv in self.vop:
-                    if vvv[0] == sss and vvv[1] == mmm:
-                        mcoy, self.mpwd = vvv[2:]
-                        error = self.pwdCheck()
-            if not error:
-                popt = {"mf": self.mf}
-                if typ[1] == "Y":
-                    if typ[2] in ("L", "Y"):
-                        if self.program and self.conum:
-                            error = self.conoCheck(self.conum, prg=prg)
-                            if not error and typ[2] == "L":
-                                self.getLastPeriod()
-                        else:
-                            self.getCompany(prg=prg, period=typ[2])
-                        if not self.conum:
-                            error = True
-                        if not error:
-                            if prg in (
-                                    "gl3030", "gl3040", "gl3050", "gl3080",
-                                    "gl4010", "gl4020", "gl6030", "gl6040",
-                                    "gl6070"):
-                                # Check if period is up to date
-                                check = True
-                            else:
-                                check = False
-                            per = getPeriods(self.mf, self.conum, self.finper,
-                                check=check)
-                            if per == (None, None, None):
-                                error = True
-                            elif rtn and per[2] == "Y":
-                                showError(self.mf.body, "Period Error",
-                                    "This Period Has Already Been Finalised")
-                                error = True
-                            else:
-                                popt["period"] = (self.finper, (per[0].work,
-                                    per[0].disp), (per[1].work, per[1].disp))
-                    else:
-                        if self.program and self.conum:
-                            error = self.conoCheck(self.conum, prg=prg)
-                        else:
-                            self.getCompany(prg=prg, period=False)
-                        if not self.conum:
-                            error = True
-                    if mcoy and self.conum != mcoy:
-                        showError(self.mf.body, "Company Error",
-                            "This Company, Module Combination "\
-                            "is Not Allowed for This User")
-                        error = True
-                    if not error:
-                        popt["conum"] = self.conum
-                        popt["conam"] = self.conam
-                        text = "%-s for %s (%s)" % (tit, self.conam, prg)
-                else:
-                    text = "%-s for All Companies (%s)" % (tit, prg)
-            if not error:
-                if typ[3] == "Y":
-                    popt["capnm"] = self.user["name"]
-                if prg == "ml1010":
-                    popt["level"] = self.user["lvl"]
-                if rtn:
-                    popt["rtn"] = int(rtn)
-                if self.xdisplay:
-                    self.mf.head.configure(text=text)
-                    self.mf.updateStatus("")
-                if self.debug:
-                    self.tracer.runfunc(self.doRunModule, prg, **popt)
-                else:
-                    self.doRunModule(prg, **popt)
-        if self.xdisplay:
-            self.mf.head.configure(text="Tartan Systems")
-        if dbopend:
-            try:
-                # Rollback any uncommitted transactions
-                self.db.rollbackDbase()
-            except:
-                pass
-            try:
-                # Close the database
-                self.db.closeDbase()
-            except:
-                pass
-        if menu:
-            # Display the menu
-            if prg == "ms1010":
-                self.userReadCheck(user=self.user["name"])
-                self.tarmen.lvl = self.user["lvl"]
-                self.tarmen.men = self.usrmen
-                self.tarmen.mod = self.usrmod
-                self.tarmen.setVariables()
-            if not self.doVersionCheck():
-                self.checkNotes()
-            self.tarmen.drawMenu()
-
-    def pwdCheck(self):
-        tit = ("Password Validation",)
-        fld = ((("T",0,0,0),"IHA",30,"Password","Password",
-            "","N", self.doPGet,None,None,None,None),)
-        but = (("Cancel", None, self.doPCancel, 1, None, None),)
-        self.df = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=((self.doPEnd, "n"),), txit=(self.doPCancel,))
-        self.mf.startLoop()
-        return self.pwderr
-
-    def doPGet(self, frt, pag, r, c, p, i, w):
-        if w != b64Convert("decode", self.mpwd):
-            return "Invalid Password"
-        self.pwderr = False
-
-    def doPCancel(self):
-        self.pwderr = True
-        self.doPEnd()
-
-    def doPEnd(self):
-        self.df.closeProcess()
-        self.mf.closeLoop()
-
-    def getCompany(self, prg=None, period=None):
-        self.prg = prg
-        self.pertyp = period
-        sql = Sql(self.db, "ctlmst", prog="msc000")
-        if self.acoy:
-            whr = [("ctm_cono", "in", tuple(self.acoy))]
-        else:
-            whr = None
-        coy = sql.getRec(tables="ctlmst", where=whr, order="ctm_cono")
-        if not coy:
-            showError(self.mf.window, "Error", "No Valid Company Records.")
-            return
-        self.coys = len(coy)
-        if self.coys == 1:
-            # Single Company
-            if prg in self.fsys and not self.fcoy[1]:
-                return
-            self.conum = coy[0][sql.ctlmst_col.index("ctm_cono")]
-            self.conam = coy[0][sql.ctlmst_col.index("ctm_name")].rstrip()
-            self.email = coy[0][sql.ctlmst_col.index("ctm_email")].rstrip()
-            self.modul = coy[0][sql.ctlmst_col.index("ctm_modules")].rstrip()
-            if not self.pertyp:
-                self.finper = None
-                return
-        if not self.conum:
-            if self.acoy:
-                self.conum = self.acoy[0]
-            else:
-                self.conum = 1
-        csel = {
-            "stype": "R",
-            "tables": ("ctlmst",),
-            "cols": (
-                ("ctm_cono", "", 0, "Com"),
-                ("ctm_name", "", 0, "Name", "Y")),
-            "order": "ctm_cono"}
-        if self.acoy:
-            csel["where"] = [("ctm_cono", "in", tuple(self.acoy))]
-        if self.coys == 1:
-            # Single Company
-            tit = ("Period Details",)
-            fld = []
-        else:
-            tit = ("Company Details",)
-            fld = [
-                [("T",0,0,0),"IUI",3,"Company Number","",
-                    self.conum,"N",self.coNum,csel,None,("notzero",)],
-                [("T",0,1,0),"ONA",30,"Company Name","",
-                    "","N",None,None,None,None]]
-        if self.pertyp == "Y":
-            self.psel = {
-                "stype": "R",
-                "tables": ("ctlynd",),
-                "cols": (
-                    ("cye_period", "", 0, "Prd"),
-                    ("cye_start", "", 0, "Start"),
-                    ("cye_end", "", 0, "End"),
-                    ("cye_final", "", 0, "F")),
-                "where": []}
-            fld.append(
-                [["T",0,2,0],"IUI",3,"Financial Period","",
-                    0,"N",self.finPeriod,self.psel,None,None])
-            if self.coys == 1:
-                self.psel["where"] = [("cye_cono", "=", self.conum)]
-                fld[0][0][2] = 0
-                self.getLastPeriod()
-                fld[0][5] = self.finper
-        elif self.pertyp == "L":
-            self.getLastPeriod()
-            if self.coys == 1:
-                return
-        else:
-            self.finper = None
-            if self.coys == 1:
-                return
-        but = (("Cancel", None, self.coExit, 1, ("T",0,1), ("T",0,0)),)
-        self.cp = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=((self.coEnd, "y"),), txit=(self.coExit,))
-        if self.conum:
-            try:
-                self.cp.loadEntry("T", 0, 0, data=self.conum)
-                self.cp.loadEntry("T", 0, 1, data=self.conam)
-                if self.pertyp == "Y" and self.finper is not None:
-                    self.cp.topf[0][2][5] = self.finper
-                    self.cp.loadEntry("T", 0, 2, data=self.finper)
-            except:
-                pass
-        self.cp.focusField("T", 0, 1)
-        self.mf.startLoop()
-
-    def coNum(self, frt, pag, r, c, p, i, w):
-        err = self.conoCheck(w, prg=self.prg)
-        if err:
-            return err
-        self.cp.loadEntry("T", pag, p+1, data=self.conam)
-        if not self.pertyp or self.pertyp == "L":
-            return "ok"
-        self.psel["where"] = [("cye_cono", "=", self.conum)]
-        if self.finper is None:
-            self.getLastPeriod()
-        self.cp.topf[0][2][5] = self.finper
-
-    def getLastPeriod(self):
-        sql = Sql(self.db, "ctlynd", prog="msc000")
-        p = sql.getRec(tables="ctlynd", cols=["max(cye_period)"],
-            where=[("cye_cono", "=", self.conum)])
-        self.finper = int(p[0][0])
-
-    def finPeriod(self, frt, pag, r, c, p, i, w):
-        sql = Sql(self.db, "ctlynd", prog="msc000")
-        r = sql.getRec(tables="ctlynd", cols=["cye_period"],
-            where=[("cye_cono", "=", self.conum), ("cye_period", "=", w)],
-            limit=1)
-        if not r:
-            return "Invalid Financial Period"
-        self.finper = w
-
-    def coExit(self):
-        self.conum = None
-        self.coEnd()
-
-    def coEnd(self):
-        self.cp.closeProcess()
-        self.mf.closeLoop()
-
-    def doRunModule(self, *prg, **popt):
-        if self.loader:
-            try:
-                for mod in sys.modules:
-                    if mod.count(prg[0]):
-                        del(sys.modules[mod])
-                        gc.collect()
-            except:
-                pass
-        try:
-            if "rtn" in popt:
-                rtn = popt["rtn"]
-            else:
-                rtn = 0
-            sql = Sql(self.db, ["ffield", "ctllog"], prog="msc000")
-            if not sql.error:
-                chk = sql.getRec(tables="ffield",
-                    where=[("ff_tabl", "=", "ctllog")])
-            if not sql.error and len(chk) == 7:
-                if not self.user:
-                    name = "admin"
-                else:
-                    name = self.user["name"]
-                logd = [getpass.getuser(), name, prg[0], rtn]
-                if "conum" in popt:
-                    logd.append(popt["conum"])
-                else:
-                    logd.append(0)
-                if "period" in popt:
-                    logd.append(popt["period"][0])
-                else:
-                    logd.append(0)
-                logd.append(long(
-                    "%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3]))
-                sql.insRec("ctllog", data=logd)
-                self.db.commitDbase()
-            if not runModule(prg[0], **popt):
-                raise Exception
-        except:
-            if self.xdisplay:
-                for wgt in self.mf.window.winfo_children():
-                    if wgt not in (self.mf.head, self.mf.body, self.mf.status):
-                        wgt.destroy()
-                showException(self.mf.body, self.rcdic["wrkdir"],
-                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
-            else:
-                showException(None, self.rcdic["wrkdir"],
-                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
-
-    def checkNotes(self):
-        self.db.openDbase()
-        t = time.localtime()
-        self.cdate = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.sql = Sql(self.db, ["ctlnot", "ctlpwu"], prog="msc000")
-        chk = self.sql.getRec(tables="ctlnot", where=[("(", "not_user", "=",
-            self.user["name"], "or", "not_auser", "=", self.user["name"],
-            ")"), ("not_adate", ">", 0), ("not_adate", "<=", self.cdate),
-            ("not_aflag", "<>", "C")])
-        if chk:
-            ok = askQuestion(self.mf.window, "Notes", "There are Notes "\
-                "Flagged for Action Still Outstanding, do You want to "\
-                "View them?")
-            if ok == "yes":
-                self.showNotes(chk)
-        self.db.closeDbase()
-
-    def showNotes(self, notes):
-        data = []
-        for note in notes:
-            nte = note[:4]
-            nte.append(note[6])
-            nte.append(note[7])
-            nte.append(note[8])
-            nte.append(note[5])
-            nte.append(note[9])
-            data.append(nte)
-        tits = "Today's Notes"
-        cols = [
-            ("not_cono", "Coy", 3, "UI", "N"),
-            ("not_sys", "Sys", 3, "UA", "N"),
-            ("not_key", "Key", 30, "NA", "N"),
-            ("not_date", "Entry-Date", 10, "D1", "N"),
-            ("not_aflag", "F", 1, "UA", "N"),
-            ("not_adate", "Action-Dte", 10, "d1", "N"),
-            ("not_auser", "Action-User", 20, "NA", "N"),
-            ("not_desc", "Description", 50, "TX", "N"),
-            ("not_seq", "Sequence", 10, "US", "N")]
-        sr = SelectChoice(self.mf.body, tits, cols, data)
-        if sr.selection:
-            self.selectNote(sr.selection)
-            self.checkNotes()
-
-    def selectNote(self, note):
-        self.chgflag = note[5]
-        self.chgdate = note[6]
-        self.chguser = note[7]
-        self.nseq = note[-1:][0]
-        tit = ("Notes Editing",)
-        r1s = (("Normal","N"),("Urgent","U"),("Completed","C"))
-        fld = (
-            (("T",0,0,0),"O@not_date",0,""),
-            (("T",0,1,0),"O@not_user",0,""),
-            (("T",0,2,0),"OTV",(50,10),"Details"),
-            (("T",0,3,0),("IRB",r1s),0,"Action Flag (C/N/U)","Action Flag",
-                "N","N",self.doChgFlag,None,None,None),
-            (("T",0,4,0),"I@not_adate",0,"","",
-                "","N",self.doChgDate,None,None,("efld",)),
-            (("T",0,5,0),"I@not_auser",0,"","",
-                "","N",self.doChgUser,None,None,("efld",)))
-        but = (
-            ("Accept",None,self.doNEnd,1,None,None),
-            ("Cancel",None,self.doNExit,1,None, None))
-        tnd = ((self.doNEnd, "n"), )
-        txt = (self.doNExit, )
-        self.nf = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=tnd, txit=txt, focus=False)
-        self.nf.loadEntry("T", 0, 0, data=note[4])
-        self.nf.loadEntry("T", 0, 1, data=self.user["name"])
-        self.nf.loadEntry("T", 0, 2, data=note[8])
-        self.nf.loadEntry("T", 0, 3, data=note[5])
-        self.nf.loadEntry("T", 0, 4, data=note[6])
-        self.nf.loadEntry("T", 0, 5, data=note[7])
-        if self.chgflag == "C":
-            self.nf.setWidget(self.nf.B0, "normal")
-            self.nf.setWidget(self.nf.B1, "normal")
-        else:
-            self.nf.focusField("T", 0, 4)
-        self.mf.startLoop()
-
-    def doChgFlag(self, frt, pag, r, c, p, i, w):
-        self.chgflag = w
-        if self.chgflag == "C":
-            return "nd"
-
-    def doChgDate(self, frt, pag, r, c, p, i, w):
-        self.chgdate = w
-
-    def doChgUser(self, frt, pag, r, c, p, i, w):
-        usr = self.sql.getRec(tables="ctlpwu", where=[("usr_name", "=", w)],
-            limit=1)
-        if not usr:
-            return "Invalid User Name"
-        self.chguser = w
-        return "nd"
-
-    def doNEnd(self):
-        self.sql.updRec("ctlnot", cols=["not_aflag", "not_adate", "not_auser"],
-            data=[self.chgflag, self.chgdate, self.chguser], where=[("not_seq",
-            "=", self.nseq)])
-        self.db.commitDbase()
-        self.doNExit()
-
-    def doNExit(self):
-        self.nf.closeProcess()
-        self.mf.closeLoop()
-
-    def chgUsr(self):
-        if not self.db.dbopen:
-            self.db.openDbase()
-            dbopend = True
-        else:
-            dbopend = False
-        sql = Sql(self.db, "ctlpwu", prog=self.__class__.__name__)
-        cnt = sql.getRec(tables="ctlpwu", cols=["count(*)"],
-            where=[("usr_name", "<>", self.user["name"])], limit=1)
-        if not cnt[0]:
-            showError(self.mf.window, "Change", "There are No Other Users")
-            self.db.closeDbase()
-            return
-        self.userLogout()
-        self.userLogin()
-        if dbopend:
-            self.db.closeDbase()
-        if not self.user:
-            self.doExit()
-        self.tarmen.usr = self.user["name"]
-        self.tarmen.lvl = self.user["lvl"]
-        self.tarmen.men = self.usrmen
-        self.tarmen.mod = self.usrmod
-        self.tarmen.setVariables()
-
-    def chgPwd(self):
-        tit = ("Change Password",)
-        fld = (
-            (("T",0,0,0),"IHA",30,"Old Password","",
-                "","N",self.doOldPwd,None,None,None,None),
-            (("T",0,1,0),"IHA",30,"New Password","",
-                "","N",self.doNewP1,None,None,None,None),
-            (("T",0,2,0),"IHA",30,"New Password","New Password Again",
-                "","N",self.doNewP2,None,None,None,None))
-        but = (("Cancel", None, self.doPwdExit, 1, None, None),)
-        self.np = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=((self.doPwdEnd, "n"),), txit=(self.doPwdExit,))
-        if not self.pwd:
-            self.np.skip[self.np.pag].append(1)
-            self.np.focusField(self.np.frt, self.np.pag, col=2)
-        if self.loop:
-            self.np.mstFrame.wait_window()
-        else:
-            self.mf.startLoop()
-
-    def doOldPwd(self, frt, pag, r, c, p, i, w):
-        if w == self.pwd or w == b64Convert("decode", self.pwd):
-            pass
-        else:
-            return "Invalid Old Password"
-
-    def doNewP1(self, frt, pag, r, c, p, i, w):
-        if w == self.pwd or w == b64Convert("decode", self.pwd):
-            return "Same Password"
-        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
-        if not w and pwmust == "Y":
-            return "You Must Have a Password"
-        if pwsize and len(w) < pwsize:
-            return "Minimum of %s Characters Required" % pwsize
-        self.new = w
-
-    def doNewP2(self, frt, pag, r, c, p, i, w):
-        if w != self.new:
-            return "Invalid New Password"
-        self.pwd = b64Convert("encode", w)
-
-    def doPwdEnd(self):
-        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
-        if not self.pwd and pwmust == "Y":
-            if not self.pwd:
-                self.np.skip[self.np.pag].append(1)
-                self.np.focusField(self.np.frt, self.np.pag, col=2)
-            else:
-                self.np.focusField(self.np.frt, self.np.pag, col=1)
-            self.mf.updateStatus("You Must Have a Password",
-                bg="white", fg="red")
-            return
-        t = time.localtime()
-        dte = (t[0] * 10000) + (t[1] * 100) + t[2]
-        sql = Sql(self.db, "ctlpwu", prog="msc000")
-        sql.updRec("ctlpwu", cols=["usr_pwd", "usr_last"], data=[self.pwd,
-            dte], where=[("usr_name", "=", self.user["name"])])
-        self.db.commitDbase()
-        self.user["pwd"] = self.pwd
-        self.user["last"] = dte
-        self.np.closeProcess()
-        if not self.loop:
-            self.mf.closeLoop()
-
-    def doPwdExit(self):
-        self.new = None
-        self.np.closeProcess()
-        if not self.loop:
-            self.mf.closeLoop()
-
-    def tarUsr(self):
-        sss = []
-        prg = {}
-        keys = list(self.sss.keys())
-        keys.sort()
-        for s in keys:
-            sm = []
-            sss.append((self.sss[s], s))
-            for mod in self.mod:
-                if mod[0][0] == "P" and mod[2][:2] == s:
-                    if len(mod) == 6:
-                        mod[2] = "%s%s" % (mod[2][:5], mod[5])
-                    sm.append((mod[3], mod[2][2:], mod[4]))
-            prg[s] = sm
-        TartanUser(self.mf, sss, prg)
-
-    def sysUpd(self):
-        tit = ("System Upgrade",)
-        typ = (("Internet", "I"), ("Local", "L"))
-        fld = (
-            (("T",0,0,0),("IRB",typ),0,"Upgrade Type","",
-                "I","N",self.doSysLoc,None,None,None,None),
-            (("T",0,1,0),"ONA",9,"Current Version","",
-                "","N",None,None,None,None,None),
-            (("T",0,2,0),"ONA",9,"Upgrade Version","",
-                "","N",None,None,None,None,None))
-        but = (
-            ("Upgrade", None, self.doSysUpgrade, 0, ("T",0,0), ("T",0,1)),
-            ("Cancel", None, self.doSysUpdXit, 1, None, None))
-        self.su = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
-            butt=but, tend=None, txit=(self.doSysUpdXit,))
-        self.mf.startLoop()
-
-    def doSysLoc(self, frt, pag, r, c, p, i, w):
-        self.updtyp = w
-        self.upgsys = ""
-        for mod in self.mods:
-            if mod == ["BC"] and self.upgsys != "Tartan":
-                self.upgsys = "Bwlclb"
-            elif mod == ["BS"] and self.upgsys != "Tartan":
-                self.upgsys = "Bksclb"
-            elif mod == ["CS"] and self.upgsys != "Tartan":
-                self.upgsys = "Cshana"
-            elif mod == ["SC"] and self.upgsys != "Tartan":
-                self.upgsys = "Seccmp"
-            else:
-                self.upgsys = "Tartan"
-        if self.updtyp == "I":
-            err = self.doSysChkUpgrade()
-            if err:
-                showError(self.mf.window, err[0], err[1])
-                return "Upgrade Error"
-            else:
-                self.su.loadEntry("T", 0, 1, data=self.cv[1])
-                self.su.loadEntry("T", 0, 2, data=self.nt)
-                return
-        self.su.setWidget(self.su.mstFrame, "hide")
-        if sys.platform == "win32":
-            ftype = [("Upgrade Files", "%s_5.*.exe" % self.upgsys)]
-        else:
-            ftype = [("Upgrade Files", "%s_5.*.tgz" % self.upgsys)]
-        dialog = FileDialog(**{
-            "parent": self.mf.body,
-            "title": "Select Upgrade File",
-            "initd": self.rcdic["upgdir"],
-            "ftype": ftype})
-        self.updfle = dialog.askopenfilename()
-        self.su.setWidget(self.su.mstFrame, "show")
-        if not self.updfle:
-            return "Invalid File"
-        self.su.loadEntry("T", 0, 1, data=self.cv[1])
-        nv = os.path.basename(self.updfle).split("_")[1].split(".")
-        self.nv = (int(nv[0]), int(nv[1]))
-        self.nt = "%s.%s" % self.nv
-        self.su.loadEntry("T", 0, 2, data=self.nt)
-        self.su.setWidget(self.su.B0, "focus")
-        if int(nv[0]) > self.cv[0][0]:
-            return
-        if int(nv[0]) == self.cv[0][0] and int(nv[1]) > self.cv[0][1]:
-            return
-        self.updfle = None
-        showError(self.mf.window, "Invalid Version",
-            "Not Later Than Current Version.")
-        return "Version Error"
-
-    def doSysChkUpgrade(self):
-        try:
-            flenam = io.BytesIO()
-            error = ftpDownload("ftp.tartan.co.za", "current", dest=flenam)
-            if error:
-                raise Exception
-            v = flenam.getvalue().strip().split(".")
-            flenam.close()
-            self.nv = (int(v[0]), int(v[1]))
-            self.nt = "%s.%s" % self.nv
-            if self.nv[0] > self.cv[0][0]:
-                return
-            elif self.nv[0] == self.cv[0][0] and self.nv[1] > self.cv[0][1]:
-                return
-            return ("Upgrade Error", "No Upgrade Available")
-        except:
-            return ("Connection Error", """Please Ensure that You Are Connected to the Internet.
-
-
-If Not, Please Connect and then Try Again!""")
-
-    def doSysUpgrade(self):
-        self.su.closeProcess()
-        self.mf.updateStatus("")
-        self.mf.closeLoop()
-        ScrollText(scrn=self.mf.body, mess="""
-                        Performing the Upgrade
-
-  After the update has completed you must perform the following:
-
-  1) If you are running Linux the downloaded file will be in your
-     '~/upg' directory. The file's name will be something like
-     '%s_5.x.tgz'.
-
-                                 or
-
-  1) If you are running Windows the downloaded file will be in your
-     'C:\\Tartan\\upg' directory. The file's name will be something like
-     '%s_5.x.exe'.
-  2) Restart Tartan.
-  3) Execute the 'Update File Formats' routine on the 'System' menu.
-  4) If Tartan is installed on other workstations, copy the downloaded
-     file to those other workstations and either, in the case of linux,
-     extract the file into the ~/prg directory or, in the case of
-     Windows, execute the file.""" % (self.upgsys, self.upgsys))
-        try:
-            if self.updtyp == "I":
-                if sys.platform == "win32":
-                    nam = self.upgsys + "_%s.%s_upd.exe" % self.nv
-                    fle = os.path.join(self.mf.rcdic["upgdir"], nam)
-                    error = ftpDownload("ftp.tartan.co.za", nam,
-                        word=self.email, dest=fle, close=True)
-                    if error:
-                        nam = nam.replace("_upd", "")
-                        fle = os.path.join(self.mf.rcdic["upgdir"], nam)
-                        error = ftpDownload("ftp.tartan.co.za", nam,
-                            word=self.email, dest=fle, close=True)
-                else:
-                    nam = self.upgsys + "_%s.%s.%s.tgz" % self.nv
-                    fle = os.path.join(self.mf.rcdic["upgdir"], nam)
-                    error = ftpDownload("ftp.tartan.co.za", nam,
-                        word=self.email, dest=fle, close=True)
-                if error:
-                    raise Exception
-            else:
-                fle = self.updfle
-            if sys.platform == "win32":
-                os.spawnv(os.P_NOWAIT, fle, (fle,))
-            else:
-                os.spawnv(os.P_NOWAIT, "/bin/tar",
-                    ("tar", "-xzf", fle, "-C", self.mf.rcdic["prgdir"]))
-            os._exit(0)
-        except:
-            showError(self.mf.window, "Get Error",
-                "Upgrade File Could Not be Retrieved.\n\n"\
-                "Your System Has Not Been Upgraded.\n\n"\
-                "Please Contact Your IT Manager.")
-            self.doSysUpdXit()
-
-    def doSysUpdXit(self):
-        self.su.closeProcess()
-        self.mf.closeLoop()
-
-    def tarUpd(self, dbcreate=False):
-        if not dbcreate:
-            # Check on status of Database
-            if self.mf.window:
-                ok = askQuestion(self.mf.window, "Backup",
-                    "Have You Backed Up the Database?", default="no")
-            else:
-                ok = raw_input("Have You Backed Up the Database? (yes/no) ")
-            if ok != "yes":
-                return
-        else:
-            if self.xdisplay:
-                self.mf.head.configure(text="Update File Formats (tarUpd)")
-                self.mf.updateStatus("")
-        dbopen = self.db.dbopen
-        if not dbopen:
-            self.db.openDbase()
-        popt = {
-            "mf": self.mf,
-            "bar": True,
-            "cln": True,
-            "pwd": self.mf.rcdic["dbpwd"],
-            "rcf": self.rcfile,
-            "upd": False,
-            "usr": self.mf.rcdic["dbuser"],
-            "ver": self.cv[1]}
-        self.doRunModule("tb1020", **popt)
-        if not dbopen:
-            self.db.closeDbase()
-
-    def doVersionCheck(self, vtype="chk"):
-        if not self.db.dbopen:
-            self.db.openDbase()
-            dbopend = True
-        else:
-            dbopend = False
-        if self.xdisplay:
-            scrn = self.mf.window
-        else:
-            scrn = "text"
-        sql = Sql(self.db, ["ftable", "ffield", "verupd"])
-        chk = sql.getRec(tables="verupd", limit=1)
-        if not chk:
-            showError(scrn, "Version Error", "Missing verupd Table")
-            self.doExit()
-        v = chk[0].split(".")
-        ov = (int(v[0]), int(v[1].rstrip()))
-        if ov < (5, 5):
-            showError(scrn, "Version Error",
-                """The Version of the Data, %s.%s, is too Old.
-
-Please follow the upgrade instructions at http://www.tartan.co.za/Downloads
-
-or
-
-Email paul@tartan.co.za, with your version number, for assistance.""" % ov)
-            self.doExit()
-        if ov > self.cv[0]:
-            if dbopend:
-                self.db.closeDbase()
-            ok = askQuestion(scrn, "Version Error",
-                """Your Version of TARTAN (%s) Is Older than the File Formats!
-
-Do You Want to Upgrade TARTAN Now?""" % self.cv[1], default="yes")
-            if ok == "yes":
-                self.sysUpd()
-            self.doExit()
-        if vtype == "upd":
-            if dbopend:
-                self.db.closeDbase()
-            return
-        if ov != self.cv[0]:
-            err = True
-        else:
-            err = False
-        chg = False
-        if self.altered:
-            for tb in tabdic:
-                for ext in ("fld", "idx"):
-                    lines = tabdic[tb][ext]
-                    f1 = []
-                    for line in lines:
-                        f1.append(line)
-                    if ext == "fld":
-                        fle = sql.getRec(tables="ffield", where=[("ff_tabl",
-                            "=", tb)], order="ff_seq")
-                        f2 = []
-                        for f in fle:
-                            tp = [int(f[1]), f[2], f[3], float(f[4])]
-                            tp.extend(f[5:])
-                            f2.append(tp)
-                    else:
-                        fle = sql.getRec(tables="ftable", where=[("ft_tabl",
-                            "=", tb)], order="ft_seq")
-                        f2 = []
-                        for f in fle:
-                            tp = [f[1], int(f[2]), f[3]]
-                            for t in f[4:]:
-                                if t:
-                                    tp.append(t)
-                            f2.append(tp)
-                    if not f1 == f2:
-                        chg = True
-                        break
-        if dbopend:
-            self.db.closeDbase()
-        if chg or err:
-            ok = askQuestion(scrn, "Version Error",
-                """Your File Formats Need Updating,
-
-Do You Want to Update Your Files?""", default="yes")
-            if ok == "yes":
-                self.tarUpd(True)
-            else:
-                self.doExit()
-
-    def tarBck(self):
-        self.db.openDbase()
-        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarBck",
-            passwd=self.bpwd)
-        if cf.flag == "ok":
-            try:
-                sql = Sql(self.db, ["ctlmst", "ctlsys"], prog="msc000")
-                if sql.error:
-                    raise Exception
-                csys = sql.getRec(tables="ctlsys", cols=["sys_budays",
-                    "sys_msvr", "sys_mprt", "sys_msec", "sys_maut",
-                    "sys_mnam", "sys_mpwd"], limit=1)
-                if not csys:
-                    raise Exception
-            except:
-                csys = None
-            if self.zerobar:
-                TarBckRes(self.mf, mode="B", csys=csys, bar=False)
-            else:
-                TarBckRes(self.mf, mode="B", csys=csys)
-        else:
-            if self.xdisplay:
-                scrn = self.mf.window
-            else:
-                scrn = "text"
-            showError(scrn, "Error", "Invalid Backup Password")
-
-    def tarRes(self):
-        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarRes",
-            passwd=self.bpwd)
-        if cf.flag == "ok":
-            TarBckRes(self.mf, mode="R", ver=self.cv[1])
-
-    def tarCfg(self):
-        cfg = TartanConfig(self.mf, rcdic=self.rcdic, level=self.lvl)
-        if cfg.rcfile:
-            self.rcfile = cfg.rcfile
-        self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
-        geo = self.rcdic["geo"].split("x")
-        self.mf.geo = [int(geo[0]), int(geo[1])]
-        self.mf.resizeChildren()
-
-    def sysEnd(self):
-        self.userLogout()
-        self.doHousekeeping()
-        self.doExit()
-
-    def doAbout(self, event=None):
-        AboutTartan(self.mf, self.cv[1])
-
-    def doManual(self):
-        self.doBrowser("Manual")
-
-    def doQuick(self):
-        self.doBrowser("QuickStart")
-
-    def doBrowser(self, doc):
-        pdf = os.path.join(self.rcdic["prgdir"], "doc", "%s.pdf" % doc)
-        if os.path.exists(pdf):
-            exe, cmd = parsePrg(self.rcdic["vwr"])
-            cmd.append(pdf)
-            os.spawnv(os.P_NOWAIT, exe, tuple(cmd))
-        elif internetConnect():
-            try:
-                import webbrowser
-                web = "http://tartan.co.za/cgi-bin/simple_web.py/%s" % doc
-                webbrowser.open(web)
-            except:
-                showError(self.mf.window, "Error", "Browser Not Found.")
-        else:
-            showError(self.mf.window, "Error", "No Internet Connection.")
-
-    def doHousekeeping(self):
-        fles = []
-        for tp in ("csv","gif","jpg","odt","pdf","png","ps","svg","xls"):
-            fles.extend(glob.glob(os.path.join(self.rcdic["wrkdir"],
-                "*.%s" % tp)))
-        if fles:
-            dft = None
-            if "wrkf" in self.mf.rcdic:
-                if self.mf.rcdic["wrkf"] == "T":
-                    dft = "Trash"
-                elif self.mf.rcdic["wrkf"] == "D":
-                    dft = "Delete"
-                else:
-                    dft = "Keep"
-            if TRASH:
-                but = [("Trash", "T", "Send files to Recycle Bin")]
-                if not dft:
-                    dft = "Trash"
-            else:
-                but = []
-                if not dft:
-                    dft = "Delete"
-            but.extend([
-                ("Delete", "D", "Permanently Delete the files"),
-                ("Keep", "K", "Keep the files in the Work Directory")])
-            ask = askChoice(self.mf.body, "Temporary Files",
-                "What do you wish to do with the Temporary Report Files "\
-                "in the wrk Directory?", butt=but, default=dft)
-            if ask == "T":
-                for fle in fles:
-                    try:
-                        send2trash(fle)
-                    except:
-                        pass
-            elif ask == "D":
-                for fle in fles:
-                    try:
-                        os.remove(fle)
-                    except:
-                        pass
-
-    def doExit(self, dbm=True, sysexit=True):
-        if dbm and self.db.dbopen:
-            self.db.closeDbase()
-        if self.debug:
-            sys.settrace(None)
-        if self.output:
-            # Close and display stdout -- Windows Problem
-            try:
-                sys.stdout.close()
-                sys.stdout = sys.__stdout__
-                if os.path.getsize(self.stdout):
-                    text = open(self.stdout, "r")
-                    lines = text.readlines()
-                    text.close()
-                    if self.debug and len(lines) > 1000:
-                        maxi = 1000
-                    else:
-                        maxi = len(lines)
-                    mess = ""
-                    for x in xrange(maxi):
-                        mess = "%s%s" % (mess, lines[x - maxi])
-                    if self.help or self.version:
-                        scrn = None
-                    else:
-                        scrn = self.mf.body
-                    if self.debug:
-                        titl = "Trace Output"
-                    else:
-                        titl = "Standard Output"
-                    if self.xdisplay:
-                        ScrollText(title=titl, scrn=scrn, mess=mess)
-                    else:
-                        print(titl, mess)
-                # Housekeeping
-                for pid in xrange(1000):
-                    try:
-                        if self.debug:
-                            name = "tracer_%s.txt" % pid
-                        else:
-                            name = "stdout_%s.txt" % pid
-                        os.remove(os.path.join(getPrgPath(), name))
-                    except:
-                        pass
-            except:
-                pass
-        if sysexit:
-            sys.exit()
-
-    def doCheckSys(self):
-        sql = Sql(self.db, "ctlsys", prog=self.__class__.__name__)
-        if sql.error:
-            return "error"
-        rec = sql.getRec(tables="ctlsys", limit=1)
-        if not rec:
-            try:
-                self.user = {"name": "admin", "pwd": "", "lvl": 9}
-                self.execCommand("PNNY", "msc110", tit="System Record",
-                    menu=False, password=False)
-                rec = sql.getRec(tables="ctlsys", limit=1)
-            except:
-                rec = [0, "N", 0, 0, 0, "", 0, 0, 0, "", "", "N",
-                    "", "", "N", 0]
-                sql.insRec("ctlsys", rec)
-                self.db.commitDbase()
-        if not rec:
-            return "error"
-
-    def doCheckMst(self):
-        chk = self.conoCheck(1, ctl=True)
-        if not chk:
-            return
-        self.user = {"name": "admin", "pwd": "", "lvl": 9}
-        self.execCommand("PNNY", "ms1010", tit="Company Record",
-            menu=False, password=False)
-        chk = self.conoCheck(1, ctl=True)
-        if chk:
-            return "error"
-
-    def conoCheck(self, coy, prg=None, ctl=False):
-        if self.acoy and not self.acoy.count(coy):
-            self.conum = None
-            return "Unavailable Company Number"
-        if self.dcoy and self.dcoy.count(coy):
-            self.conum = None
-            return "Unavailable Company Number"
-        if prg in self.fsys and not self.fcoy[coy]:
-            return "xt"
-        gcl = GetCtl(self.mf)
-        chk = gcl.getCtl("ctlmst", coy, error=False)
-        if not chk:
-            self.conum = None
-            return "Invalid Company"
-        if ctl:
-            return
-        self.conum = coy
-        self.conum = chk["ctm_cono"]
-        self.conam = chk["ctm_name"]
-        self.email = chk["ctm_email"]
-        self.modul = chk["ctm_modules"]
-        if not prg:
-            return
-        # Check Module
-        mod = prg[:2].upper()
-        if mod in ("BM", "CA", "MS", "RP", "TD"):
-            return
-        for x in xrange(0, len(self.modul), 2):
-            if self.modul[x:x + 2] == mod:
-                return
-        return "System (%s) Not Enabled for Company %s" % (mod, self.conum)
-
-    def getCtlSys(self, cols):
-        try:
-            sql = Sql(self.db, "ctlsys", prog="msc000")
-            if sql.error:
-                raise Exception
-            sss = sql.getRec(tables="ctlsys", cols=cols, limit=1)
-            if not sss:
-                raise Exception
-            if len(cols) == 1:
-                return sss[0]
-            else:
-                return sss
-        except:
-            sss = []
-            for col in cols:
-                sss.append(None)
-            return sss
-
-    def doSqlCmd(self):
-        if type(self.query) is list:
-            flenam = self.query
-        else:
-            name = os.path.abspath(self.query)
-            if os.path.isfile(name):
-                flenam = open(name, "r")
-            else:
-                return "Invalid Query File (%s)" % name
-        self.db.openDbase()
-        for line in flenam:
-            line = line.rstrip()
-            if not line or line[0] == "#":
-                continue
-            comm = line.split()
-            sel = False
-            qty = None
-            if comm and comm[0].lower() == "select":
-                sel = True
-                if comm[1][:3].lower() in ("avg", "max", "min", "sum"):
-                    qty = 1
-                elif comm[1].lower() == "count(*)":
-                    qty = 1
-                for num, cmd in enumerate(comm):
-                    if num < 2:
-                        continue
-                    if cmd == "limit":
-                        qty = int(comm[num + 1])
-                        break
-            try:
-                if comm[0] == "commit":
-                    self.db.commitDbase()
-                else:
-                    sq = Sql(self.db)
-                    if sel:
-                        ret = sq.sqlRec(line, limit=qty)
-                        self.mess = ""
-                        for r in ret:
-                            if type(r) is list:
-                                r = str(r)[1:-1]
-                            else:
-                                r = str(r)
-                            if not self.mess:
-                                self.mess = r
-                            else:
-                                self.mess = self.mess + "\n" + r
-                        if self.xdisplay and self.output:
-                            self.mf.window.deiconify()
-                            self.mf.head.configure(text="SQL Query")
-                            but = ([("Save", self.doSave)])
-                            ScrollText(scrn=self.mf.body, mess=self.mess,
-                                butt=but)
-                        else:
-                            print(self.mess)
-                    else:
-                        sq.sqlRec(line)
-            except:
-                self.db.closeDbase()
-                return "Error in SQL Statement\n\n%s" % line
-        self.db.closeDbase()
-
-    def doSave(self):
-        fle = open(os.path.join(self.rcdic["wrkdir"], "query.txt"), "w")
-        fle.write(self.mess + "\n")
-        fle.close()
-
-# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'mst/msy010.py'
--- mst/msy010.py	2020-03-01 12:48:20 +0000
+++ mst/msy010.py	2020-03-24 14:27:56 +0000
@@ -139,38 +139,48 @@
         if w == "Y":
             if "AR" in self.mod:
                 c = self.gc.getCtl("assctl", self.opts["conum"])
-                if c and c["cta_glint"] == "Y" and c["cta_lastp"] < self.cur:
+                if not c:
+                    return "Missing Asset Control"
+                if c["cta_glint"] == "Y" and c["cta_lastp"] < self.cur:
                     return "Depreciation Has Not Been Raised for Assets"
             if "LN" in self.mod:
                 c = self.gc.getCtl("lonctl", self.opts["conum"])
-                lst = c["cln_last"]
-                if c:
-                    glt = c["cln_glint"]
-                    drt = c["cln_drte"]
-                    crt = c["cln_crte"]
-                    lst = c["cln_last"]
-                    if glt == "Y" and (drt or crt) and lst < self.end:
-                        return "Interest Has Not Been Raised for Loans"
+                if not c:
+                    return "Missing Loans Control"
+                lst = c["cln_last"]
+                glt = c["cln_glint"]
+                drt = c["cln_drte"]
+                crt = c["cln_crte"]
+                lst = c["cln_last"]
+                if glt == "Y" and (drt or crt) and lst < self.end:
+                    return "Interest Has Not Been Raised for Loans"
             if "ML" in self.mod:
                 c = self.gc.getCtl("memctl", self.opts["conum"])
-                if c and c["mcm_glint"] == "Y" and c["mcm_lme"] < self.end:
+                if not c:
+                    return "Missing Members Control"
+                if c["mcm_glint"] == "Y" and c["mcm_lme"] < self.end:
                     return "A Month-End Has Not Been Completed for Members"
             if "RC" in self.mod:
                 c = self.gc.getCtl("rcactl", self.opts["conum"])
-                if c and c["cte_glint"] == "Y" and c["cte_lme"] < self.end:
+                if not c:
+                    return "Missing Rentals Control"
+                if c["cte_glint"] == "Y" and c["cte_lme"] < self.end:
                     return "A Month-End Has Not Been Completed for Rentals"
             if "RT" in self.mod:
                 c = self.gc.getCtl("rtlctl", self.opts["conum"])
-                if c and c["ctr_glint"] == "Y" and c["ctr_lme"] < self.end:
+                if not c:
+                    return "Missing Rentals Control"
+                if c["ctr_glint"] == "Y" and c["ctr_lme"] < self.end:
                     return "A Month-End Has Not Been Completed for Rentals"
             if "WG" in self.mod:
                 c = self.gc.getCtl("wagctl", self.opts["conum"])
-                if c:
-                    glt = c["ctw_glint"]
-                    rte = c["ctw_i_rate"]
-                    lst = c["ctw_i_date"]
-                    if glt == "Y" and rte and lst < self.end:
-                        return "Interest Has Not Been Raised for Staff Loans"
+                if not c:
+                    return "Missing Salaries Control"
+                glt = c["ctw_glint"]
+                rte = c["ctw_i_rate"]
+                lst = c["ctw_i_date"]
+                if glt == "Y" and rte and lst < self.end:
+                    return "Interest Has Not Been Raised for Staff Loans"
         self.final = w
 
     def doEnd(self):
@@ -218,7 +228,8 @@
                 if "stkmst" in tabdic:
                     # Clear RNE Stock Take System
                     tabs = ["stkmst", "stkpag", "stklin"]
-                    sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
+                    sql = Sql(self.opts["mf"].dbm, tabs,
+                            prog=self.__class__.__name__)
                     for tab in tabs:
                         sql.delRec(tab)
         else:

=== modified file 'rca/rc1010.py'
--- rca/rc1010.py	2020-03-01 12:48:20 +0000
+++ rca/rc1010.py	2020-03-24 14:29:15 +0000
@@ -40,7 +40,10 @@
         if self.sql.error:
             return
         self.gc = GetCtl(self.opts["mf"])
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         return True
 
     def mainProcess(self):

=== modified file 'rca/rcc110.py'
--- rca/rcc110.py	2020-03-01 12:48:20 +0000
+++ rca/rcc110.py	2020-03-24 14:30:04 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -67,6 +69,8 @@
                 ["rca_tnt", "Tenants Control", 0],
                 ["rca_trx", "Tenants Charges", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'rtl/rt1010.py'
--- rtl/rt1010.py	2020-03-01 12:48:20 +0000
+++ rtl/rt1010.py	2020-03-24 14:31:05 +0000
@@ -44,7 +44,10 @@
         if self.sql.error:
             return
         self.gc = GetCtl(self.opts["mf"])
-        self.taxdf = self.gc.getCtl("ctlmst", self.opts["conum"])["ctm_taxdf"]
+        ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
+        self.taxdf = ctlmst["ctm_taxdf"]
         return True
 
     def mainProcess(self):

=== modified file 'std/TartanClasses.py'
--- std/TartanClasses.py	2020-03-05 13:45:54 +0000
+++ std/TartanClasses.py	2020-03-25 07:16:11 +0000
@@ -240,6 +240,8 @@
         "sysupd": os.path.join(imgdir, "network.png"),
         "tarbck": os.path.join(imgdir, "backup.png"),
         "tarcfg": os.path.join(imgdir, "preferences.png"),
+        "tarexp": os.path.join(imgdir, "export.png"),
+        "tarimp": os.path.join(imgdir, "import.png"),
         "tarres": os.path.join(imgdir, "restore.png"),
         "tarusr": os.path.join(imgdir, "users.png"),
         "tb1040": os.path.join(imgdir, "copy.png"),
@@ -1946,7 +1948,7 @@
 
     Draw the menus as follows:
 
-        menu = TartanMenu(usr, men, mod, ign, lvl, cmd, img)
+        menu = TartanMenu({args})
 
         mf  = Tartan MainFrame
         usr = Name of user
@@ -2067,8 +2069,11 @@
             else:
                 image = None
             if image:
-                image = image.resize((20, 20), 0)
-                setattr(self, "image%s" % stk, ImageTk.PhotoImage(image))
+                try:
+                    getattr(self, "image%s" % stk)
+                except:
+                    image = image.resize((20, 20), 0)
+                    setattr(self, "image%s" % stk, ImageTk.PhotoImage(image))
                 if idx is None:
                     mens[m[1]].add("command", label=m[4], command=cmd,
                         font=font, underline=pos, image=getattr(self,
@@ -18215,4 +18220,248 @@
             self.window.destroy()
         self.window.update()
 
+class ExportDbase(object):
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.doVariables():
+            self.doMain()
+            self.opts["mf"].startLoop()
+
+    def doVariables(self):
+        self.noco = []
+        self.coys = []
+        for tab in tartanWork.tabdic:
+            if tartanWork.tabdic[tab]["fld"][0][1].count("_cono"):
+                self.coys.append(tab)
+            else:
+                self.noco.append(tab)
+        self.noco.extend(["ctlpwr", "genrpt"])
+        self.coys.remove("ctlpwr")
+        self.coys.remove("genrpt")
+        self.sqf = Sql(self.opts["mf"].dbm, self.noco + self.coys,
+            prog=__name__)
+        if self.sqf.error:
+            return
+        self.cv = self.sqf.getRec(tables="verupd", cols=["ver_version"],
+            limit=1)[0]
+        self.wrkdir = self.opts["mf"].rcdic["wrkdir"]
+        return True
+
+    def doMain(self):
+        tit = "Company Export Routine"
+        coy = {
+            "stype": "R",
+            "tables": ("ctlmst",),
+            "cols": (
+                ("ctm_cono", "", 0, "Coy"),
+                ("ctm_name", "", 0, "Name"))}
+        pth = {
+            "stype":  "F",
+            "types":  "dir",
+            "initd":  ""}
+        fld = (
+            (("T",0,0,0),"I@ctm_cono",0,"","",
+                "","N",self.doCoy,coy,None,("notzero",)),
+            (("T",0,0,0),"ONA",46,""),
+            (("T",0,1,0),"ITX",50,"Directory","",
+                self.wrkdir,"N",self.doDir,pth,None,("dir",)))
+        but = (("Exit", None, self.doExit, 0, ("T",0,1), ("T",0,0)),)
+        tnd = ((self.doEnd,"y"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], tops=True, title=tit,
+            eflds=fld, butt=but, tend=tnd, txit=txt)
+
+    def doCoy(self, frt, pag, r, c, p, i, w):
+        acc = self.sqf.getRec(tables="ctlmst", where=[("ctm_cono", "=", w),
+            ("ctm_cono", "=", w)], limit=1)
+        if not acc:
+            return "Invalid Company"
+        self.cono = [w]
+        cti = self.sqf.getRec(tables="genint", cols=["cti_inco"],
+            where=[("cti_cono", "=", w)], order="cti_inco")
+        if cti:
+            if len(cti) == 1:
+                txt = "1 Company"
+            else:
+                txt = "%s Companies" % len(cti)
+            ok = askQuestion(self.opts["mf"].body, "Intercompany",
+                """This Company is Linked to %s.
+
+Do you want to Export All Linked Companies?""" % txt, default="no")
+            if ok == "no":
+                return "Intercompany"
+            for c in cti:
+                self.cono.append(c[0])
+        self.df.loadEntry(frt, pag, p+1,
+            data=acc[self.sqf.ctlmst_col.index("ctm_name")])
+
+    def doDir(self, frt, pag, r, c, p, i, w):
+        self.dir = w
+
+    def doEnd(self):
+        self.df.closeProcess()
+        dbnam = "%s%03i.db" % (self.opts["mf"].dbm.dbname, self.cono[0])
+        rcdic = loadRcFile(dbnam, default=True)
+        rcdic["dbname"] = dbnam
+        rcdic["dbdir"] = self.dir
+        self.dbm = Dbase(rcdic=rcdic, screen=self.opts["mf"].body)
+        opts = [
+            ("-c", "i"),
+            ("-l", self.opts["mf"].body),
+            ("-u", rcdic["dbuser"]),
+            ("-p", rcdic["dbpwd"]),
+            ("-v", self.cv),
+            ("-x", True)]
+        DBCreate(dbm=self.dbm, opts=opts)
+        self.dbm.openDbase()
+        self.dbm.cu.execute("PRAGMA JOURNAL_MODE=OFF")
+        self.dbm.cu.execute("PRAGMA SYNCHRONOUS=OFF")
+        self.sqt = Sql(self.dbm, self.noco + self.coys, prog=__name__)
+        mxs = len(self.noco) + len(self.coys)
+        num = 0
+        pb = ProgressBar(self.opts["mf"].body, mxs=mxs, typ="Exporting")
+        for tab in self.noco:
+            pb.displayProgress(num)
+            self.doTable(tab)
+            num += 1
+        for tab in self.coys:
+            pb.displayProgress(num)
+            for cnt, coy in enumerate(self.cono):
+                self.doTable(tab, coy, cnt)
+            num += 1
+        pb.closeProgress()
+        coy = ""
+        for c in self.cono:
+            if not coy:
+                coy = str(c)
+            else:
+                coy = "%s,%s" % (coy, str(c))
+        self.sqt.updRec("ctlpwu", cols=["usr_acoy", "usr_lvl"],
+            data=[coy, 6])
+        self.dbm.commitDbase()
+        self.dbm.closeDbase()
+        self.opts["mf"].closeLoop()
+
+    def doTable(self, tab, cono=None, num=0):
+        self.opts["mf"].updateStatus(tab)
+        if not num:
+            self.sqt.delRec(tab)
+        if cono and tab != "genrpt":
+            cols = getattr(self.sqf, "%s_col" % tab)
+            data = self.sqf.getRec(tables=tab, where=[(cols[0], "=", cono)])
+        else:
+            data = self.sqf.getRec(tables=tab)
+        if data:
+            self.sqt.insRec(tab, data=data, kseq=True)
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+class ImportDbase(object):
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.doVariables():
+            self.doMain()
+            self.opts["mf"].startLoop()
+
+    def doVariables(self):
+        self.tabs = list(tartanWork.tabdic.keys())
+        self.sqt = Sql(self.opts["mf"].dbm, self.tabs, prog=__name__)
+        if self.sqt.error:
+            return
+        self.dbnam = self.opts["mf"].dbm.dbname
+        self.cv = self.sqt.getRec(tables="verupd", cols=["ver_version"],
+            limit=1)[0]
+        self.wrkdir = self.opts["mf"].rcdic["wrkdir"]
+        return True
+
+    def doMain(self):
+        tit = "Company Merge Routine"
+        fle = {
+            "stype": "F",
+            "types": "fle",
+            "initd": self.wrkdir,
+            "ftype": [["Database File", "*.db"]]}
+        fld = (
+            (("T",0,0,0),"ITX",50,"Merge File","",
+                "","N",self.doFle,fle,None,("fle",)),)
+        but = (("Exit", None, self.doExit, 0, ("T",0,1), ("T",0,0)),)
+        tnd = ((self.doEnd,"y"),)
+        txt = (self.doExit,)
+        self.df = TartanDialog(self.opts["mf"], tops=True, title=tit,
+            eflds=fld, butt=but, tend=tnd, txit=txt)
+
+    def doFle(self, frt, pag, r, c, p, i, w):
+        self.fle = w
+
+    def doEnd(self):
+        self.df.closeProcess()
+        dbnam = os.path.basename(self.fle)
+        dbdir = os.path.dirname(self.fle)
+        rcdic = loadRcFile(dbnam, default=True)
+        rcdic["dbname"] = dbnam
+        rcdic["dbdir"] = dbdir
+        try:
+            self.dbm = Dbase(rcdic=rcdic, screen=self.opts["mf"].body)
+            self.dbm.openDbase()
+            self.sqf = Sql(self.dbm, self.tabs, prog=__name__)
+            cv = self.sqf.getRec(tables="verupd", cols=["ver_version"],
+                limit=1)[0]
+            if cv != self.cv:
+                showError(self.opts["mf"].body, "Version Error",
+                    """The Versions of the Two Databases are Not the Same.
+
+Database: %s %s
+Database: %s %s
+
+Only Databases of the Same Version can be Merged.""" % (self.dbnam,
+                    self.cv, dbnam, cv))
+                raise Exception
+            err = []
+            c1 = self.sqt.getRec(tables="ctlmst", cols=["ctm_cono", "ctm_name"],
+                order="ctm_cono")
+            for c in c1:
+                c2 = self.sqf.getRec(tables="ctlmst", cols=["ctm_name"],
+                    where=[("ctm_cono", "=", c[0])], limit=1)
+                if not c2:
+                    err.append((c[0], c[1], "Not Found"))
+                elif c2[0] != c[1]:
+                    err.append((c[0], c[1], c2[0]))
+            if err:
+                txt = "Different Company Names:\n\n"
+                txt += "%3s %-30s %-30s" % ("Num", "Original", "Importing")
+                for e in err:
+                    txt += "%03i %-30s %-30s" % e
+                showError(self.opts["mf"].body, "Name Error", txt)
+                raise Exception
+            pb = ProgressBar(self.opts["mf"].body, mxs=len(self.tabs),
+                typ="Merging")
+            for num, tab in enumerate(self.tabs):
+                pb.displayProgress(num)
+                if tab == "ctlpwu":
+                    continue
+                self.doTable(tab)
+            pb.closeProgress()
+            self.opts["mf"].dbm.commitDbase(ask=True)
+            self.opts["mf"].closeLoop()
+        except:
+            self.opts["mf"].closeLoop()
+
+    def doTable(self, tab):
+        self.opts["mf"].updateStatus(tab)
+        cols = getattr(self.sqf, "%s_col" % tab)
+        recs = self.sqf.getRec(tables=tab)
+        for rec in recs:
+            whr = []
+            for n, c in enumerate(cols):
+                whr.append((c, "=", rec[n]))
+            chk = self.sqt.getRec(tables=tab, where=whr)
+            if not chk:
+                self.sqt.insRec(tab, rec)
+
+    def doExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'std/tartanWork.py'
--- std/tartanWork.py	2020-03-06 11:35:08 +0000
+++ std/tartanWork.py	2020-03-22 08:58:36 +0000
@@ -3899,6 +3899,8 @@
         ["PNNN","mm_sy","tb1040",9,"Copy Tables"],
         ["F","mm_sy","tarBck",0,"Backup Database"],
         ["F","mm_sy","tarRes",5,"Restore Database"],
+        ["F","mm_sy","tarExp",0,"Export Database"],
+        ["F","mm_sy","tarImp",5,"Merge Database"],
         ["F","mm_sy","tarCfg",0,"Preferences"],
         ["F","mm_sy","sysEnd",0,"Quit"],
         ["PNNY","ms_fm","msc110",7,"System Record Maintenance"],
@@ -3965,7 +3967,8 @@
         ["PYNN","gl_tb","gl6070",6,"Merge Accounts Into a Control"],
         ["PNNN","gl_tb","gl6080",1,"Missing Account Numbers"],
         ["PYYY","gl_qy","gl4010",0,"Interrogation (Normal)"],
-        ["PYYN","gl_qy","gl4020",1,"Interrogation (Financials)"]],
+        ["PYYN","gl_qy","gl4020",1,"Interrogation (Financials)"],
+        ["F","mm_gl","doManual",0,"Manual (GEN)"]],
 
     # Creditor's Ledger Routines
     "crmen": [
@@ -3995,7 +3998,8 @@
         ["PYNN","cr_tb","cr6010",5,"Change Account Numbers"],
         ["PYNN","cr_tb","cr6020",3,"Transaction Reallocations"],
         ["PYNY","cr_tb","cr6030",5,"Account Redundancy"],
-        ["PYNY","mm_cr","cr4010",0,"Interrogation"]],
+        ["PYNY","mm_cr","cr4010",0,"Interrogation"],
+        ["F","mm_cr","doManual",0,"Manual (CRS)"]],
 
     # Debtor"s Ledger Routines
     "drmen": [
@@ -4038,7 +4042,8 @@
         ["PYNN","dr_tb","dr6020",3,"Transaction Reallocations"],
         ["PYNY","dr_tb","dr6030",5,"Account Redundancy"],
         ["PYNN","dr_tb","dr6040",3,"Populate Credit Ratings"],
-        ["PYNY","mm_dr","dr4010",0,"Interrogation"]],
+        ["PYNY","mm_dr","dr4010",0,"Interrogation"],
+        ["F","mm_dr","doManual",0,"Manual (DRS)"]],
 
     # Stores Ledger Routines
     "stmen": [
@@ -4081,7 +4086,8 @@
         ["PYYY","st_tb","st6020",5,"Revalue Stock Records"],
         ["PYNY","st_tb","st6030",5,"Stock Redundancy"],
         ["PYYY","st_tb","st6040",5,"Cancel Purchase Orders"],
-        ["PYYY","mm_st","st4010",0,"Interrogation"]],
+        ["PYYY","mm_st","st4010",0,"Interrogation"],
+        ["F","mm_st","doManual",0,"Manual (STR)"]],
 
     # Sales Invoicing Routines
     "simen": [
@@ -4100,7 +4106,8 @@
         ["PYNN","si_rp","si3080",1,"Reprint Sales Documents"],
         ["PYYN","si_rp","si3090",1,"Cancelled Sales Documents"],
         ["PYNN","si_tb","si6010",5,"Change Customer Order Number"],
-        ["PYNN","si_tb","si6020",5,"Cancel Outstanding Documents"]],
+        ["PYNN","si_tb","si6020",5,"Cancel Outstanding Documents"],
+        ["F","mm_si","doManual",0,"Manual (SLS)"]],
 
     # Point of Sale Routines
     "psmen": [],
@@ -4108,7 +4115,8 @@
         ["PYNY","mm_ps","psc110",5,"Terminal Records"],
         ["PYLY","mm_ps","ps2010",2,"Data Capture"],
         ["PYLY","mm_ps","ps2020",1,"Cash Declaration"],
-        ["PYYN","mm_ps","ps2030",5,"Cash Reconciliation"]],
+        ["PYYN","mm_ps","ps2030",5,"Cash Reconciliation"],
+        ["F","mm_ps","doManual",0,"Manual (POS)"]],
 
     # Assets Register
     "armen": [
@@ -4133,7 +4141,8 @@
         ["PYYN","ar_rp","ar3040",1,"Asset Register"],
         ["PYNN","ar_rp","ar3050",1,"Notes Listing"],
         ["PYNN","ar_tb","ar6010",5,"Change Asset Codes"],
-        ["PYYY","mm_ar","ar4010",0,"Interrogation"]],
+        ["PYYY","mm_ar","ar4010",0,"Interrogation"],
+        ["F","mm_ar","doManual",0,"Manual (ASS)"]],
 
     # Bookings Manager
     "bkmen": [
@@ -4157,7 +4166,8 @@
         ["PYNN","bk_rp","bk3060",1,"Notes Listing"],
         ["PYNN","bk_rp","bk3070",1,"Account Statements"],
         ["PYNN","bk_rp","bk3080",1,"Reprint Documents"],
-        ["PYNN","bk_rp","bk3090",1,"Summary Report"]],
+        ["PYNN","bk_rp","bk3090",1,"Summary Report"],
+        ["F","mm_bk","doManual",0,"Manual (BKM)"]],
 
     # Loan's Ledger
     "lnmen": [
@@ -4180,7 +4190,8 @@
         ["PYYN","ln_rp","ln3040",1,"Statements"],
         ["PYNN","ln_rp","ln3050",1,"Notes Listing"],
         ["PYNN","ln_tb","ln6010",5,"Change Account Numbers"],
-        ["PYLY","mm_ln","ln4010",0,"Interrogation"]],
+        ["PYLY","mm_ln","ln4010",0,"Interrogation"],
+        ["F","mm_ln","doManual",0,"Manual (LON)"]],
 
     # Member's Ledger
     "mlmen": [
@@ -4214,7 +4225,8 @@
         ["PYNN","ml_tb","ml6020",3,"Synchronise Access Control"],
         ["PYNN","ml_tb","ml6030",3,"Export Access Control"],
         ["PYLY","mm_ml","ml1010",1,"Member Records"],
-        ["PYYY","mm_ml","mlm010",4,"Month End Routine",0]],
+        ["PYYY","mm_ml","mlm010",4,"Month End Routine",0],
+        ["F","mm_ml","doManual",0,"Manual (MEM)"]],
 
     # Rental's Ledger (Basic)
     "rtmen": [
@@ -4236,7 +4248,8 @@
         ["PYNN","rt_rp","rt3050",1,"Notes Listing"],
         ["PYNN","rt_tb","rt6010",5,"Change Account Numbers"],
         ["PYNY","mm_rt","rt4010",1,"Interrogation"],
-        ["PYNY","mm_rt","rtm010",4,"Month End Routine",0]],
+        ["PYNY","mm_rt","rtm010",4,"Month End Routine",0],
+        ["F","mm_rt","doManual",0,"Manual (RTL)"]],
 
     # Rental's Ledger (Extended)
     "rcmen": [
@@ -4263,7 +4276,8 @@
         ["PYNY","rc_qy","rc4010",0,"Owners Interrogation"],
         ["PYNY","rc_qy","rc4020",0,"Tenants Interrogation"],
         ["PYNY","mm_rc","rc2010",2,"Data Capture"],
-        ["PYNY","mm_rc","rcm010",4,"Month End Routine"]],
+        ["PYNY","mm_rc","rcm010",4,"Month End Routine"],
+        ["F","mm_rc","doManual",0,"Manual (RCA)"]],
 
     # Salaries & Wages Routines
     "wgmen": [
@@ -4290,7 +4304,8 @@
         ["PYNN","wg_rp","wg3050",1,"IRP5 Statements"],
         ["PYNN","wg_rp","wg3060",1,"Notes Listing"],
         ["PYNN","wg_rp","wg3070",1,"Payslips Reprint"],
-        ["PYNY","mm_wg","wg4010",0,"Interrogation"]],
+        ["PYNY","mm_wg","wg4010",0,"Interrogation"],
+        ["F","mm_wg","doManual",0,"Manual (WAG)"]],
 
     # Staff Loan Routines
     "slmen": [
@@ -4306,7 +4321,8 @@
         ["PYNN","sl_rp","sl3020",1,"Transaction Audit Trail"],
         ["PYNN","sl_rp","sl3030",1,"Master Listing"],
         ["PYNN","sl_rp","sl3040",1,"Statements"],
-        ["PYLY","mm_sl","sl4010",0,"Interrogation"]],
+        ["PYLY","mm_sl","sl4010",0,"Interrogation"],
+        ["F","mm_sl","doManual",0,"Manual (SLN)"]],
 
     # Bowling Club Routines
     "bcmen": [
@@ -4341,7 +4357,8 @@
         ["PYNN","bc_cc","bc3110",1,"Contact Request Forms"],
         ["PYNN","bc_tb","bc6010",3,"Change Tab Numbers"],
         ["PYNN","bc_tb","bc6020",3,"Delete Visitors' Tabs"],
-        ["PYNN","bc_tb","bc6030",3,"Clear History"]],
+        ["PYNN","bc_tb","bc6030",3,"Clear History"],
+        ["F","mm_bc","doManual",0,"Manual (BWL)"]],
 
     # Book Clubs
     "bsmen": [
@@ -4350,7 +4367,8 @@
         ["PYNY","bs_fm","bsc110",0,"Member Records"],
         ["PNNY","bs_fm","bsc210",0,"Author Records"],
         ["PYNY","mm_bs","bs1010",0,"Book Records"],
-        ["PYNY","mm_bs","bs3010",0,"Books Listing"]],
+        ["PYNY","mm_bs","bs3010",0,"Books Listing"],
+        ["F","mm_bs","doManual",0,"Manual (BKS)"]],
 
     # Sectional Competitions
     "scmen": [
@@ -4361,13 +4379,15 @@
         ["PYNN","mm_sc","sc2010",0,"Capture Entries"],
         ["PYNN","mm_sc","sc3010",0,"List Entries"],
         ["PYNN","mm_sc","sc2020",0,"Competiton Draw"],
-        ["PYNN","mm_sc","sc2030",0,"Capture Results"]],
+        ["PYNN","mm_sc","sc2030",0,"Capture Results"],
+        ["F","mm_sc","doManual",0,"Manual (SCP)"]],
 
     # Cash Analysis Routines
     "csmen": [],
     "csmod": [
         ["PYNY","mm_cs","cs2010",0,"Capture Analysis"],
-        ["PYNY","mm_cs","cs3010",0,"List Analysis"]],
+        ["PYNY","mm_cs","cs3010",0,"List Analysis"],
+        ["F","mm_cs","doManual",0,"Manual (CSH)"]],
 
     # Telephone Directory
     "tdmen": [
@@ -4513,6 +4533,9 @@
         ["memctc", "mcc_code", "memctc", "mcc_code"],
         ["memctc", "mcc_type", "memcat", "mlc_type"],
         ["memctc", "mcc_code", "memcat", "mlc_code"],
+        ["posmst", "psm_cono", "postrn", "pst_cono"],
+        ["posmst", "psm_host", "postrn", "pst_host"],
+        ["posmst", "psm_docno", "postrn", "pst_docno"],
         ["rcaowm", "rom_cono", "rcaprm", "rcp_cono"],
         ["rcaowm", "rom_acno", "rcaprm", "rcp_owner"],
         ["rcaowm", "rom_cono", "rcatnm", "rtn_cono"],
@@ -4540,6 +4563,9 @@
         ["rcatnm", "rtn_owner", "rcatnt", "rtu_owner"],
         ["rcatnm", "rtn_code", "rcatnt", "rtu_code"],
         ["rcatnm", "rtn_acno", "rcatnt", "rtu_acno"],
+        ["rtlmst", "rtm_cono", "rtltrn", "rtt_cono"],
+        ["rtlmst", "rtm_code", "rtltrn", "rtt_code"],
+        ["rtlmst", "rtm_acno", "rtltrn", "rtt_acno"],
         ["rtlprm", "rtp_cono", "rtlcon", "rtc_cono"],
         ["rtlprm", "rtp_code", "rtlcon", "rtc_code"],
         ["rtlprm", "rtp_cono", "rtlmst", "rtm_cono"],

=== modified file 'str/stc110.py'
--- str/stc110.py	2020-03-01 12:48:20 +0000
+++ str/stc110.py	2020-03-24 14:32:54 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -62,6 +64,8 @@
                 ["stk_soh", "Stock on Hand", 0],
                 ["stk_susp", "Stock Reconciliation", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

=== modified file 'tab/tb1020.py'
--- tab/tb1020.py	2020-03-01 12:48:20 +0000
+++ tab/tb1020.py	2020-03-23 08:32:15 +0000
@@ -531,52 +531,6 @@
             for dat in datdic[table]:
                 sql.insRec(table, data=dat)
 
-    def doCheckIndex(self, table, index):
-        if self.rcdic["dbase"] == "PgSQL":
-            sel = "Select * from pg_indexes where schemaname='public' "\
-                "and tablename='%s' and indexname='%s'" % (table, index)
-        elif self.rcdic["dbase"] == "SQLite":
-            sel = "Select * from sqlite_master where type='index' "\
-                "and tbl_name='%s' and name='%s'" % (table, index)
-        elif self.rcdic["dbase"] == "FBird":
-            sel = "Select * from rdb$indices where rdb$relation_name in "\
-                "('%s', '%s') and rdb$index_name in ('%s', '%s')" % \
-                (table.lower(), table.upper(), index.lower(), index.upper())
-        elif self.opts["mf"].rcdic["dbase"] == "MySQL":
-            sel = "Show indexes from %s where key_name = '%s'" % (table, index)
-        return self.sql.sqlRec(sel, limit=1)
-
-    def doCreateIndexes(self, table):
-        if sys.platform == "win32" or self.rcdic["dbase"] in ("FBird", "MySQL"):
-            if table in ("memkon", "emllog"):
-                return
-        keys = self.sql.getRec(tables="ftable", where=[("ft_tabl","=", table)])
-        if not keys:
-            return
-        if self.opts["mf"] and self.opts["mf"].window:
-            self.opts["mf"].updateStatus("Creating New Indexes for %s" % table)
-        blbkey = ("ctllog", "emllog", "genrct", "memkon", "telmst")
-        for key in keys:
-            if self.dbm.dbase in ("FBird", "MySQL") and table in blbkey:
-                continue
-            nam = "%s_key%s" % (table, str(key[2]))
-            if not self.doCheckIndex(table, nam):
-                idx = ""
-                for k in key[4:]:
-                    if k:
-                        if idx:
-                            idx = "%s,%s" % (idx, k)
-                        else:
-                            idx = k
-                if key[3] == "N":
-                    sql = "Create index"
-                else:
-                    sql = "Create unique index"
-                try:
-                    self.sql.sqlRec("%s %s on %s (%s)" % (sql, nam, table, idx))
-                except:
-                    pass
-
     def doFinal(self):
         chg = False
         for tab in ("ffield", "ftable"):
@@ -628,6 +582,59 @@
         if self.opts["mf"] and self.opts["mf"].window:
             spl.closeSplash()
 
+    def doCreateIndexes(self, table):
+        keys = self.sql.getRec(tables="ftable", where=[("ft_tabl","=", table)])
+        if not keys:
+            return
+        if self.opts["mf"] and self.opts["mf"].window:
+            self.opts["mf"].updateStatus("Creating New Indexes for %s" % table)
+        for key in keys:
+            nam = "%s_key%s" % (table, str(key[2]))
+            if not self.doCheckIndex(table, nam):
+                idx = ""
+                skip = False
+                for k in key[4:]:
+                    if k:
+                        if self.rcdic["dbase"] in ("SQLite", "FBird", "MySQL"):
+                            if self.checkBlob(table, k):
+                                skip = True
+                                break
+                        if idx:
+                            idx = "%s,%s" % (idx, k)
+                        else:
+                            idx = k
+                if skip:
+                    continue
+                if key[3] == "N":
+                    sql = "Create index"
+                else:
+                    sql = "Create unique index"
+                try:
+                    self.sql.sqlRec("%s %s on %s (%s)" % (sql, nam, table, idx))
+                except:
+                    pass
+
+    def doCheckIndex(self, table, index):
+        if self.rcdic["dbase"] == "PgSQL":
+            sel = "Select * from pg_indexes where schemaname='public' "\
+                "and tablename='%s' and indexname='%s'" % (table, index)
+        elif self.rcdic["dbase"] == "SQLite":
+            sel = "Select * from sqlite_master where type='index' "\
+                "and tbl_name='%s' and name='%s'" % (table, index)
+        elif self.rcdic["dbase"] == "FBird":
+            sel = "Select * from rdb$indices where rdb$relation_name in "\
+                "('%s', '%s') and rdb$index_name in ('%s', '%s')" % \
+                (table.lower(), table.upper(), index.lower(), index.upper())
+        elif self.opts["mf"].rcdic["dbase"] == "MySQL":
+            sel = "Show indexes from %s where key_name = '%s'" % (table, index)
+        return self.sql.sqlRec(sel, limit=1)
+
+    def checkBlob(self, table, key):
+        cols = tabdic[table]["fld"]
+        for col in cols:
+            if col[1] == key and col[2] == "TX":
+                return True
+
 if __name__ == "__main__":
     import getopt
 
@@ -658,7 +665,7 @@
     -r [file]       = tartanrc file to use, defaults to ~/.tartanrc
     -t [table]      = Table to update
     -u [user]       = Database Admin User Name
-    -v [x.x.x]      = The New version number
+    -v [x.x]        = The New version number
 """)
             sys.exit()
         elif o == "-b":

=== modified file 'uty/pkgprg.py'
--- uty/pkgprg.py	2020-03-05 13:45:54 +0000
+++ uty/pkgprg.py	2020-03-20 12:52:04 +0000
@@ -424,7 +424,7 @@
 os.chdir(pypath)
 if os.path.exists("%s/tmp" % pypath):
     shutil.rmtree("%s/tmp" % pypath)
-man = csys
+man = "Manual"
 if system == "bksclb":
     fles = ["doc/BKSMST.rst", "doc/BKS.rst"]
 elif system == "bwlclb":
@@ -543,7 +543,7 @@
         exeCmd("ssh %s chmod a+r /srv/ftp/*" % sv)
         exeCmd("ssh %s chown paul:paul /srv/ftp/*" % sv)
         if system == "tartan":
-            exeCmd("rsync -az %s/%s/doc/Tartan.rst %s:/var/www/tartan.co.za/htdocs/Manual/Manual.rst --progress" % (bd, bv, sv))
+            exeCmd("rsync -az %s/%s/doc/Manual.rst %s:/var/www/tartan.co.za/htdocs/Manual/Manual.rst --progress" % (bd, bv, sv))
             exeCmd("rsync -az %s/%s/doc/QST.rst %s:/var/www/tartan.co.za/htdocs/QuickStart/QuickStart.rst --progress" % (bd, bv, sv))
             exeCmd("rsync -az %s/%s/doc/Downloads.rst %s:/var/www/tartan.co.za/htdocs/Downloads/ --progress" % (bd, bv, sv))
             exeCmd("rsync -az %s/%s/doc/Changes.rst %s:/var/www/tartan.co.za/htdocs/Changes/ --progress" % (bd, bv, sv))
@@ -589,6 +589,7 @@
             "mcbagro@gmail.com",
             "mel@acsaccounting.co.za",
             "mike@annettelaing.co.za",
+            "nathan@barrowdale.co.za",
             "no2pigstash@hotmail.com",
             "paul@tartan.co.za",
             "paulabergh@mweb.co.za",
@@ -627,7 +628,7 @@
     exeCmd("todos -o %s/tempcd/AUTORUN.INF" % bd)
     exeCmd("chmod a+x %s/tempcd/AUTORUN.INF" % bd)
     # Add Documentation
-    exeCmd("rst2pdf %s/%s/doc/Tartan.rst -o %s/tempcd/Manual.pdf "\
+    exeCmd("rst2pdf %s/%s/doc/Manual.rst -o %s/tempcd/Manual.pdf "\
         "-s %s/%s/doc/mystylesheet" % (bd, bv, bd, bd, bv))
     # Make CD iso
     exeCmd("mkisofs -r -J -l -D -V 'Tartan Systems %s.%s' -p 'Paul Malherbe paul@tartan.co.za' -copyright 'Paul Malherbe' -o %s/TartanCD/Tartan.iso -graft-points /\=%s/tempcd" % (ver[0], ver[1], bd, bd))
@@ -635,8 +636,6 @@
 if system == "tartan" and verinc and windows and publish:
     # Sourceforge
     os.chdir("%s/TartanExe" % bd)
-    shutil.copy("%s/doc/Tartan.rst" % pypath, "readme.rst")
     exeCmd("%s/uty/upload.sh %s" % (pypath, newver))
-    os.remove("readme.rst")
 print("DONE")
 # END

=== modified file 'uty/upload.sh'
--- uty/upload.sh	2019-07-03 13:49:08 +0000
+++ uty/upload.sh	2020-03-11 15:41:19 +0000
@@ -1,7 +1,6 @@
 #!/bin/bash
 lftp -u pmalherbe,jaguar2292 sftp://tartansystems@web.sourceforge.net <<EOF
 cd /home/pfs/project/tartansystems
-put readme.rst
 mkdir Release_$1
 cd Release_$1
 put Tartan_$1.tgz

=== modified file 'wag/wg1010.py'
--- wag/wg1010.py	2020-03-01 12:48:20 +0000
+++ wag/wg1010.py	2020-03-18 11:10:53 +0000
@@ -96,8 +96,8 @@
             (("T",1,1,0),"INA",30,"Names","",
                 "","N",None,None,None,("notblank",)),
             (("T",1,2,0),"ID1",10,"Date of Birth","",
-                "","N",None,None,None,("efld",)),
-            (("T",1,3,0),"INA",13,"ID Number","",
+                "","N",self.doDOB,None,None,("efld",)),
+            (("T",1,3,0),"IUL",13,"ID Number","",
                 "","N",self.doIdNo,None,None,("notblank",)),
             (("T",1,4,0),"INA",16,"Spouse Name","",
                 "","N",None,None,None,None),
@@ -257,9 +257,12 @@
             return "Invalid Department"
         self.dept = w
 
+    def doDOB(self, frt, pag, r, c, p, i, w):
+        self.dob = w
+
     def doIdNo(self, frt, pag, r, c, p, i, w):
-        a = str(w)[:6]
-        b = str(self.df.t_work[pag][r][i-1])[2:]
+        a = int(w / 10000000)
+        b = int(self.dob % 1000000)
         if a != b:
             return "ID Number Does Not Agree with Birth Date"
         if not luhnFunc(int(w)):

=== modified file 'wag/wgc110.py'
--- wag/wgc110.py	2020-03-01 12:48:20 +0000
+++ wag/wgc110.py	2020-03-24 14:33:48 +0000
@@ -37,6 +37,8 @@
     def setVariables(self):
         gc = GetCtl(self.opts["mf"])
         ctlmst = gc.getCtl("ctlmst", self.opts["conum"])
+        if not ctlmst:
+            return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
         for x in xrange(0, len(mods), 2):
@@ -63,6 +65,8 @@
                 ["wag_slc", "Staff Loans Control", 0],
                 ["wag_sli", "Staff Loans Interest", 0]]
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
+            if not ctlctl:
+                return
             for num, ctl in enumerate(self.ctl):
                 if ctl[0] in ctlctl:
                     self.ctl[num][2] = ctlctl[ctl[0]]

