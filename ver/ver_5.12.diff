=== modified file '.bzrignore' (properties changed: -x to +x)
--- old/.bzrignore	2020-04-21 08:42:36 +0000
+++ new/.bzrignore	2020-07-10 21:45:44 +0000
@@ -60,6 +60,7 @@
 sve/
 thm/
 uty/img
+uty/RawPrint.exe
 uty/SumatraPDF.exe
 ver/
 web/
@@ -67,3 +68,4 @@
 doc/vimrecord.txt
 uty/newpkg.py
 doc/dstvreset.txt
+other

=== renamed file 'std/TartanClasses.py' => 'TartanClasses.py' (properties changed: -x to +x)
--- old/std/TartanClasses.py	2020-04-21 08:42:36 +0000
+++ new/TartanClasses.py	2020-12-11 12:51:31 +0000
@@ -27,20 +27,20 @@
 # Standard Python modules
 # ========================================================
 import calendar, copy, csv, functools, glob, gzip, os, re, shutil, sys
-import tarfile, textwrap, threading, time, webbrowser
+import subprocess, tarfile, tempfile, textwrap, threading, time, webbrowser
 # ========================================================
 # TARTAN Standard Functions and Variables e.g. showError
 # ========================================================
-from tartanFunctions import askQuestion, b64Convert, chkAggregate, copyList
-from tartanFunctions import dateDiff, doPrinter, doWriteExport, getColors
-from tartanFunctions import getFileName, getFontSize, getModName, getPeriods
-from tartanFunctions import getPrgPath, getSingleRecords, getTrn, getUnderline
-from tartanFunctions import importTkinter, loadRcFile, makeArray, mthendDate
-from tartanFunctions import projectDate, removeFunctions, sendMail, showError
-from tartanFunctions import showException, showPrinters, showWarning, chkMod
-from tartanFunctions import doPublish
+from tartanFunctions import askQuestion, b64Convert, chkAggregate, chkMod
+from tartanFunctions import copyList, dateDiff, doPrinter, doWriteExport
+from tartanFunctions import getColors, getCost, getFileName, getFontSize
+from tartanFunctions import getImage, getModName, getPeriods, getPrgPath
+from tartanFunctions import getPrinters, getSell, getSingleRecords, getTrn
+from tartanFunctions import getUnderline, importTkinter, loadRcFile
+from tartanFunctions import luhnFunc, makeArray, mthendDate, parsePrg
+from tartanFunctions import printPDF, projectDate, removeFunctions, sendMail
+from tartanFunctions import showError, showException, showWarning, doPublish
 import tartanWork
-#from profilehooks import profile
 
 try:
     from tarchg import changes
@@ -66,13 +66,13 @@
     print("Missing fpdf or python-imaging module")
     os._exit(1)
 # ========================================================
-# PyPDF
+# MuPDF
 # ========================================================
 try:
-    from pyPdf import PdfFileWriter, PdfFileReader
-    PyPDF = True
+    import fitz
+    FITZ = True
 except:
-    PyPDF = False
+    FITZ = False
 # ========================================================
 # Excel import and export modules
 # ========================================================
@@ -82,10 +82,7 @@
     XLRD = True
 except:
     XLRD = False
-if chkMod("xlwt"):
-    XLWT = True
-else:
-    XLWT = False
+XLWT = bool(chkMod("xlwt"))
 # ========================================================
 # Openoffice import module
 # ========================================================
@@ -98,22 +95,11 @@
 # Curses Progress Bar
 # ========================================================
 try:
-    from tqdm import tqdm
+    from progress.bar import Bar
     TBAR = True
 except:
     TBAR = False
 # ========================================================
-# PyChart imports
-# ========================================================
-try:
-    from pychart import area, arrow, axis, bar_plot, category_coord
-    from pychart import chart_object, line_plot, pie_plot
-    from pychart import theme as pychart_theme
-    from pychart import canvas as pychart_canvas
-    PYCHART = True
-except:
-    PYCHART = False
-# ========================================================
 # PyGal imports
 # ========================================================
 try:
@@ -122,7 +108,9 @@
 except:
     PYGAL = False
 try:
-    CVTSVG = False
+    from svglib.svglib import svg2rlg
+    from reportlab.graphics import renderPDF
+    CVTSVG = True
 except:
     CVTSVG = False
 # ========================================================
@@ -141,19 +129,19 @@
     if not tk:
         raise Exception
 
-    if sys.version_info.major == 3:
+    try:
         import tkinter.filedialog as tkfile
         import tkinter.font as tkfont
-    else:
+    except:
         import tkFileDialog as tkfile
         import tkFont as tkfont
     try:
         from tkcolorpicker import askcolor
         CPICK = True
     except:
-        if sys.version_info.major == 3:
+        try:
             import tkinter.colorchooser as tkcolor
-        else:
+        except:
             import tkColorChooser as tkcolor
         CPICK = False
     from PIL import Image, ImageTk
@@ -164,93 +152,6 @@
         "odiaeresis", "Odiaeresis",
         "udiaeresis", "Udiaeresis",
         "ssharp"]
-    imgdir = os.path.join(getPrgPath(), "img")
-    images = {}
-    for img in glob.glob(os.path.join(imgdir, "*.png")):
-        images[os.path.basename(img).lower().replace(".png", "")] = img
-    aliases = {
-        "abort": os.path.join(imgdir, "no.png"),
-        "accept": os.path.join(imgdir, "yes.png"),
-        "accounts": os.path.join(imgdir, "ledger.png"),
-        "add": os.path.join(imgdir, "insert.png"),
-        "all": os.path.join(imgdir, "show.png"),
-        "alter": os.path.join(imgdir, "convert.png"),
-        "amend": os.path.join(imgdir, "edit.png"),
-        "amendment": os.path.join(imgdir, "edit.png"),
-        "apply": os.path.join(imgdir, "yes.png"),
-        "arrivals": os.path.join(imgdir, "print.png"),
-        "automatic": os.path.join(imgdir, "auto.png"),
-        "back": os.path.join(imgdir, "left.png"),
-        "c/card": os.path.join(imgdir, "ccard.png"),
-        "cancel": os.path.join(imgdir, "no.png"),
-        "change": os.path.join(imgdir, "convert.png"),
-        "chgpwd": os.path.join(imgdir, "users.png"),
-        "chgusr": os.path.join(imgdir, "users.png"),
-        "choice": os.path.join(imgdir, "question.png"),
-        "contacts": os.path.join(imgdir, "users.png"),
-        "continue": os.path.join(imgdir, "yes.png"),
-        "create": os.path.join(imgdir, "convert.png"),
-        "credit": os.path.join(imgdir, "refund.png"),
-        "crop/print": os.path.join(imgdir, "print.png"),
-        "crsmaint": os.path.join(imgdir, "edit.png"),
-        "crsquery": os.path.join(imgdir, "question.png"),
-        "declaration": os.path.join(imgdir, "print.png"),
-        "deladd": os.path.join(imgdir, "truck.png"),
-        "delete": os.path.join(imgdir, "close.png"),
-        "deposits": os.path.join(imgdir, "print.png"),
-        "detail": os.path.join(imgdir, "show.png"),
-        "display": os.path.join(imgdir, "show.png"),
-        "doabout": os.path.join(imgdir, "about.png"),
-        "domanual": os.path.join(imgdir, "help.png"),
-        "doquick": os.path.join(imgdir, "help.png"),
-        "draw": os.path.join(imgdir, "edit.png"),
-        "drsmaint": os.path.join(imgdir, "edit.png"),
-        "drsquery": os.path.join(imgdir, "question.png"),
-        "edi": os.path.join(imgdir, "import.png"),
-        "enquire": os.path.join(imgdir, "question.png"),
-        "entered": os.path.join(imgdir, "users.png"),
-        "exit": os.path.join(imgdir, "quit.png"),
-        "fixed": os.path.join(imgdir, "entries.png"),
-        "forward": os.path.join(imgdir, "right.png"),
-        "generate": os.path.join(imgdir, "process.png"),
-        "history": os.path.join(imgdir, "age.png"),
-        "interrogate": os.path.join(imgdir, "question.png"),
-        "logout": os.path.join(imgdir, "quit.png"),
-        "maintain": os.path.join(imgdir, "edit.png"),
-        "manual": os.path.join(imgdir, "edit.png"),
-        "members": os.path.join(imgdir, "teams.png"),
-        "modify": os.path.join(imgdir, "convert.png"),
-        "movements": os.path.join(imgdir, "question.png"),
-        "non": os.path.join(imgdir, "users.png"),
-        "none": os.path.join(imgdir, "no.png"),
-        "notes": os.path.join(imgdir, "edit.png"),
-        "normal": os.path.join(imgdir, "age.png"),
-        "payment": os.path.join(imgdir, "cash.png"),
-        "rates": os.path.join(imgdir, "discount.png"),
-        "recipe": os.path.join(imgdir, "entries.png"),
-        "replace": os.path.join(imgdir, "convert.png"),
-        "reprint": os.path.join(imgdir, "print.png"),
-        "re-sequence": os.path.join(imgdir, "reorder.png"),
-        "reset": os.path.join(imgdir, "clear.png"),
-        "search": os.path.join(imgdir, "find.png"),
-        "showcal": os.path.join(imgdir, "calendar.png"),
-        "statement": os.path.join(imgdir, "show.png"),
-        "strmaint": os.path.join(imgdir, "edit.png"),
-        "strquery": os.path.join(imgdir, "question.png"),
-        "sysend": os.path.join(imgdir, "quit.png"),
-        "sysupd": os.path.join(imgdir, "network.png"),
-        "tarbck": os.path.join(imgdir, "backup.png"),
-        "tarcfg": os.path.join(imgdir, "preferences.png"),
-        "tarexp": os.path.join(imgdir, "export.png"),
-        "tarmrg": os.path.join(imgdir, "import.png"),
-        "tarres": os.path.join(imgdir, "restore.png"),
-        "tarusr": os.path.join(imgdir, "users.png"),
-        "tb1040": os.path.join(imgdir, "copy.png"),
-        "toggle": os.path.join(imgdir, "convert.png"),
-        "transact": os.path.join(imgdir, "edit.png"),
-        "upgrade": os.path.join(imgdir, "update.png"),
-        "view": os.path.join(imgdir, "preview.png"),
-        "void": os.path.join(imgdir, "no.png")}
 
     def unbindAllWidgets(widget):
         binds = []
@@ -260,8 +161,8 @@
                 widget.winfo_toplevel().unbind(bind)
         return binds
 
-    # Window Placement
     def getManager(widget):
+        # Window Placement
         try:
             children = widget.winfo_children()
             if not children:
@@ -276,81 +177,21 @@
             mgr = "pack"
         return mgr
 
-    def getWindowXY(window, parent, size=None, relx=None, rely=None):
-        parent.update_idletasks()
-        if not size:
-            w_width = window.winfo_reqwidth()
-            w_height = window.winfo_reqheight()
-        else:
-            w_width, w_height = size
-        s_width = window.winfo_screenwidth()
-        s_height = window.winfo_screenheight()
-        m_x = m_y = 0
-        m_width, m_height = s_width, s_height
-        if parent and parent.winfo_ismapped():
-            m_x = m_y = None
-            try:
-                m_width, m_height, m_x, m_y = getGeometry(parent)
-            except:
-                pass
-            if m_x is None:
-                m_x = parent.winfo_x()
-                m_y = parent.winfo_y()
-                m_width = parent.winfo_width()
-                m_height = parent.winfo_height()
-                if relx is None:
-                    relx = 0.5
-                if rely is None:
-                    rely = 0.3
-            else:
-                if relx is None:
-                    relx = 0.5
-                if rely is None:
-                    rely = 0.5
-            m_x = max(m_x, 0)
-            m_y = max(m_y, 0)
-        else:
-            if relx is None:
-                relx = 0.5
-            if rely is None:
-                rely = 0.3
-        x = m_x + int((m_width - w_width) * relx)
-        y = m_y + int((m_height - w_height) * rely)
-        if x < 0:
-            x = 0
-        elif x + w_width + 32 > s_width:
-            x = max(0, int((s_width - w_width) / 2))
-        if y < 0:
-            y = 0
-        elif y + w_height + 32 > s_height:
-            y = max(0, int((s_height - w_height) / 2))
-        return w_width, x, y
-
-    def getGeometry(window):
-        wm_re = re.compile(r"^(\d+)x(\d+)\+([\-]?\d+)\+([\-]?\d+)$")
-        g = window.wm_geometry()
-        m = wm_re.search(g)
-        if not m:
-            raise tk.TclError("invalid geometry " + str(g))
-        l = list(map(int, m.groups()))
-        if window.wm_state() == "zoomed":
-            # workaround as Tk returns the "unzoomed" origin
-            l[2] = l[3] = 0
-        return l
-
     def placeWindow(window, parent=None, place="C", size=None, expose=False):
         window.update_idletasks()
+        if size:
+            ww, wh = size
+        else:
+            ww = window.winfo_reqwidth()
+            wh = window.winfo_reqheight()
         if window.winfo_class().lower() == "tk":
             parent = None
         if parent:
             if parent.winfo_class().lower() not in ("tk", "toplevel"):
                 parent = parent.winfo_toplevel()
-            ww, wx, wy = getWindowXY(window, parent=parent, size=size)
+            wx = int(parent.winfo_x() + (parent.winfo_width() / 2 - ww / 2))
+            wy = int(parent.winfo_y() + (parent.winfo_height() / 2 - wh / 2))
         else:
-            if size:
-                ww = size[0]
-            else:
-                ww = window.winfo_reqwidth()
             if place == "L":
                 wx = 0
                 wy = 0
@@ -360,39 +201,25 @@
             else:
                 wx = int((window.winfo_screenwidth() - ww) / 2)
                 wy = 0
-        if size:
-            window.geometry("%sx%s+%s+%s" % (size[0], size[1], wx, wy))
-        else:
-            window.geometry("+%s+%s" % (wx, wy))
+        window.geometry("%sx%s+%s+%s" % (ww, wh, wx, wy))
         if expose:
             window.deiconify()
         window.update_idletasks()
 
     def cut_pasteMenu(event):
         # Cut, copy and paste menu
-        def getimage(lab):
-            stk = lab.lower().split()[0]
-            if stk in images:
-                image = Image.open(images[stk])
-            elif stk in aliases and os.path.isfile(aliases[stk]):
-                image = Image.open(aliases[stk])
-            else:
-                return
-            image = image.resize((20, 20), 0)
-            return ImageTk.PhotoImage(image)
-
         wid = event.widget
         font = tkfont.Font(font=("Arial", 10))
         wid.menu = tk.Menu(wid, tearoff=False, takefocus=0, font=font)
-        image = getimage("Cut")
+        image = getImage("Cut", (20, 20))
         wid.menu.add_command(label="Cut", image=image, compound="left",
             accelerator="Ctl-X", font=font)
         wid.menu.i1 = image
-        image = getimage("Copy")
+        image = getImage("Copy", (20, 20))
         wid.menu.add_command(label="Copy", image=image, compound="left",
             accelerator="Ctl-C", font=font)
         wid.menu.i2 = image
-        image = getimage("Paste")
+        image = getImage("Paste", (20, 20))
         wid.menu.add_command(label="Paste", image=image, compound="left",
             accelerator="Ctl-V", font=font)
         wid.menu.i3 = image
@@ -461,7 +288,7 @@
             widgets[idx].focus_set()
 
     class MyButton(ttk.Button):
-        def __init__(self, parent, cmd=None, img=True, fnt=None, **kwargs):
+        def __init__(self, parent, cmd=None, txt=True, img=True, fnt=None, **kwargs):
             if "style" not in kwargs:
                 kwargs["style"] = "MyButton.TButton"
             kwargs["width"] = -1
@@ -482,27 +309,23 @@
                     name = "%s%s%s" % tuple(fnt)
                 style.configure("%s.MyButton.TButton" % name, font=fnt)
                 self.configure(style="%s.MyButton.TButton" % name)
-            self.setLabel(kwargs["text"], kwargs["underline"], img=img, cmd=cmd)
+            self.setLabel(kwargs["text"], kwargs["underline"], txt=txt,
+                img=img, cmd=cmd)
 
-        def setLabel(self, text, udl=-1, img=True, cmd=None):
+        def setLabel(self, text, udl=-1, txt=True, img=True, cmd=None):
             self.configure(text=text, underline=udl)
             if img:
                 try:
                     hgt = int(self.winfo_reqheight() * .6)
                     if hgt < 1:
                         hgt = 20
-                    stk = text.lower().split()[0]
-                    if stk in images:
-                        imgfl = images[stk]
-                    elif stk in aliases:
-                        imgfl = aliases[stk]
-                    else:
-                        imgfl = images["yes"]
-                    if imgfl:
-                        image = Image.open(imgfl)
-                        image = image.resize((hgt, hgt), 0)
-                        self.image = ImageTk.PhotoImage(image)
+                    self.image = getImage(text, (hgt, hgt))
+                    if self.image is None:
+                        self.image = getImage("yes", (hgt, hgt))
+                    if txt:
                         self.configure(compound="left", image=self.image)
+                    else:
+                        self.configure(image=self.image)
                 except:
                     pass
             if not cmd:
@@ -520,8 +343,8 @@
 
         def execButCmd(self, event):
             try:
+                self.update_idletasks()
                 self.event_generate("<Leave>")
-                self.update_idletasks()
                 if str(self.cget("state")) == "normal":
                     if sys.platform == "win32":
                         self.state(("!active", "!focus", "!pressed"))
@@ -563,10 +386,7 @@
             else:
                 placeWindow(self, widget, expose=True)
             self.grab_set()
-            if self._locale is None:
-                self._cal = calendar.TextCalendar(self._fwday)
-            else:
-                self._cal = calendar.TextCalendar(self._fwday, self._locale)
+            self._cal = calendar.TextCalendar(self._fwday)
             self._setup_styles()       # creates custom styles
             self._create_topbar()      # create top bar
             self._selection = None
@@ -591,21 +411,21 @@
         def _setup_styles(self):
             # custom ttk styles
             style = ttk.Style(self.master)
-            arrow_layout = lambda dir: ([("Button.focus",
-                {"children": [("Button.%sarrow" % dir, None)]})])
+            arrow_layout = lambda ddd: ([("Button.focus",
+                {"children": [("Button.%sarrow" % ddd, None)]})])
             style.layout("L.TButton", arrow_layout("left"))
             style.layout("R.TButton", arrow_layout("right"))
 
         def _create_topbar(self):
-            bar = ttk.Frame(self, relief="flat")
-            bar.pack(side="top", fill="x", padx=2, pady=2)
-            lbtn = ArrowButton(bar, direction="left", command=self._prev_month)
-            rbtn = ArrowButton(bar, direction="right", command=self._next_month)
-            self._header = MyLabel(bar, anchor="c", text="", font=self._font)
+            tbr = ttk.Frame(self, relief="flat")
+            tbr.pack(side="top", fill="x", padx=2, pady=2)
+            lbtn = ArrowButton(tbr, direction="left", command=self._prev_month)
+            rbtn = ArrowButton(tbr, direction="right", command=self._next_month)
+            self._header = MyLabel(tbr, anchor="c", text="", font=self._font)
             lbtn.grid(row=0, column=0, sticky="w")
             self._header.grid(row=0, column=1, padx=6)
             rbtn.grid(row=0, column=2, sticky="w")
-            bar.grid_columnconfigure(1, weight=1)
+            tbr.grid_columnconfigure(1, weight=1)
             self._calendar = None
 
         def _build_calendar(self):
@@ -626,20 +446,17 @@
                 day.grid(row=0, column=num)
             cal = self._cal.monthdayscalendar(self._idate.year,
                 self._idate.month)
-            for row in xrange(len(cal)):
-                for num, col in enumerate(cal[row]):
+            for seq, row in enumerate(cal):
+                for num, col in enumerate(row):
                     if col:
-                        if int(col) == self._idate.day:
-                            color = True
-                        else:
-                            color = False
+                        color = bool(int(col) == self._idate.day)
                         day = MyLabel(self._calendar, text="%3s" % col,
                             color=color, relief="ridge", font=self._font)
                         day.bind("<ButtonRelease-1>", self._pressed)
                     else:
                         day = MyLabel(self._calendar, text="%3s" % "",
                             color=False, relief="ridge", font=self._font)
-                    day.grid(row=row + 1, column=num)
+                    day.grid(row=seq + 1, column=num)
             # set the minimal size for the widget and other bindings
             self._calendar.bind("<Map>", self._minsize)
             self._calendar.bind("<Up>", self._next_period)
@@ -745,10 +562,7 @@
             cut_pasteMenu(event)
 
         def maxsize(self, maxsize, before, after):
-            if len(after) <= int(maxsize):
-                return True
-            else:
-                return False
+            return bool(len(after) <= int(maxsize))
 
         def in_line_way(self, event):
             if not self.get():
@@ -912,20 +726,23 @@
     class MyMessageBox(object):
         def __init__(self, parent, dtype, title, mess, butt=None, dflt=None,
                 plc=True):
-            self.parent = parent
-            if not self.parent:
+            if not parent:
                 self.geom = True
-                mkw = MkWindow(remov=False, resiz=False)
-                self.parent = mkw.newwin
+                self.parent = MkWindow(tk=True, remov=False, resiz=False).newwin
+                placeWindow(self.parent)
             else:
                 self.geom = False
+                self.parent = parent
             style = ttk.Style()
             style.configure("MFrame.TFrame", background="black")
             self.frame = MyFrame(self.parent, bg="black", borderwidth=5,
                 relief="ridge", style="MFrame.TFrame")
             if plc:
                 self.frame.place(anchor="center", relx=0.5, rely=0.5)
-            self.frame.grab_set()
+            try:
+                self.frame.grab_set()
+            except:
+                pass
             # Save and clear toplevel bindings
             self.topbinds = unbindAllWidgets(self.frame)
             # Save and disable all buttons
@@ -957,15 +774,9 @@
             label = MyLabel(self.frame, text=mess, padding=5, anchor="w",
                 justify="left", color=False, foreground="black",
                 background="white", wraplength=wrap)
-            try:
-                image = os.path.join(getPrgPath(), "img", "%s.png" % dtype)
-                if os.path.isfile(image):
-                    image = Image.open(image)
-                    image = image.resize((48, 48))
-                    self.tkimg = ImageTk.PhotoImage(image)
-                    label.configure(image=self.tkimg, compound="left")
-            except:
-                pass
+            self.tkimg = getImage(dtype)
+            if self.tkimg:
+                label.configure(image=self.tkimg, compound="left")
             label.pack(fill="both", expand="yes")
             bbox = MyButtonBox(self.frame, row=1)
             self.butts = []
@@ -1059,8 +870,8 @@
 
         def goLeft(self, event):
             childs = self.parent.winfo_children()
-            for x in xrange(0, len(childs)):
-                if childs[x].winfo_class() == "TRadiobutton":
+            for x, c in enumerate(childs):
+                if c.winfo_class() == "TRadiobutton":
                     break
             if self.focus_get() == childs[x]:
                 return
@@ -1415,15 +1226,15 @@
             for key in ("Left", "Right", "Up", "Down", "Prior", "Next"):
                 self.window.bind("<%s>" % key, self._scroll)
             # Close and Other buttons
-            quit = True
+            _quit = True
             bbox = MyButtonBox(self.window)
             if "butt" in self.opts:
                 for but in self.opts["butt"]:
                     bbox.addButton(but[0], but[1])
                     if but[0] in ("Exit", "Quit"):
-                        quit = False
+                        _quit = False
                         self.window.bind("<Escape>", but[1])
-            if quit:
+            if _quit:
                 bbox.addButton("Quit", self._quit)
                 self.window.bind("<Escape>", self._quit)
             # Pack frame
@@ -1508,6 +1319,11 @@
                 window=self.interior, anchor="nw")
             self.interior.bind("<Configure>", self._configure_interior)
             self.cnv.bind("<Configure>", self._configure_canvas)
+            if sys.platform == "win32":
+                self.bind("<MouseWheel>", self._on_mousewheel)
+            else:
+                self.bind("<Button-4>", self._on_mousewheel)
+                self.bind("<Button-5>", self._on_mousewheel)
 
         def _configure_interior(self, event):
             # update the scrollbars to match the size of the inner frame
@@ -1525,8 +1341,16 @@
                 self.cnv.itemconfigure(self.interior_id,
                     width=self.cnv.winfo_width())
 
+        def _on_mousewheel(self, event):
+            if sys.platform == "win32":
+                scroll = -1 if event.delta > 0 else 1
+            else:
+                scroll = -1 if event.num == 4 else 1
+            self.cnv.yview_scroll(scroll, "units")
+
     GUI = True
-except:
+except Exception as err:
+    print(err)
     GUI = False
 
 # =========================================================
@@ -1562,11 +1386,11 @@
                 if not title:
                     title = "Tartan Systems - Copyright %s 2004-2020 "\
                         "Paul Malherbe" % unichr(0xa9)
-                icon = os.path.join(getPrgPath(), "img", "tartan.png")
-                self.window = MkWindow(tk=True, title=title, icon=icon,
+                self.window = MkWindow(tk=True, title=title, icon="tartan",
                     resiz=resiz).newwin
                 self.setThemeFont()
                 self.createChildren()
+                self.window.config(cursor="arrow")
             else:
                 self.children = False
                 self.window = None
@@ -1598,7 +1422,8 @@
         if self.rcdic["theme"] in ("alt", "clam", "classic", "default"):
             self.style.configure("MyButton.TButton",
                 foreground=self.rcdic["bfg"],
-                background=self.rcdic["bbg"])
+                background=self.rcdic["bbg"],
+                padding=2)
             self.style.map("MyButton.TButton",
                 foreground=[
                     ("active", self.rcdic["ffg"]),
@@ -1778,7 +1603,7 @@
             elif arg == "remov":
                 self.remov = True
             elif arg == "size":
-                self.size = None
+                self.size = ""
             elif arg == "tk":
                 self.tk = False
             elif arg == "resiz":
@@ -1787,7 +1612,6 @@
                 setattr(self, arg, None)
         self.drawWindow()
         self.setAttributes()
-        self.newwin.withdraw()
 
     def drawWindow(self):
         if self.tk:
@@ -1823,19 +1647,15 @@
                     "::tk::dialog::file::showHiddenVar", "0")
             except:
                 pass
-        elif self.trans:
-            # Transient toplevel
-            if self.trans.winfo_class() in ("Tk", "Toplevel"):
-                self.newwin = tk.Toplevel(self.trans)
-            else:
-                self.newwin = tk.Toplevel(self.trans.winfo_toplevel())
         else:
-            # Normal toplevel
             self.newwin = tk.Toplevel()
+            if self.trans:
+                self.newwin.transient(self.trans)
+        self.newwin.withdraw()
         if self.icon:
             try:
                 self.newwin.tk.call("wm", "iconphoto", self.newwin._w,
-                    "-default", ImageTk.PhotoImage(Image.open(self.icon)))
+                    "-default", getImage(self.icon))
             except:
                 pass
         self.newwin.protocol("WM_DELETE_WINDOW", self.doDestroy)
@@ -1853,7 +1673,7 @@
         else:
             self.newwin.update_idletasks()
             try:
-                self.newwin.wm_attributes('-type', 'splash')
+                self.newwin.wm_attributes("-type", "splash")
             except:
                 self.newwin.overrideredirect(True)
         if not self.resiz:
@@ -2053,8 +1873,7 @@
                     if m[1] == mm[1]:
                         if m[6] == mm[2]:
                             break
-                        else:
-                            idx += 1
+                        idx += 1
             else:
                 idx = None
             if m[4] == "Quit":
@@ -2063,27 +1882,20 @@
             if m[4][pos] not in labs[m[1]]:
                 labs[m[1]].append(m[4][pos])
             cmd = (self.menubar.register(self.cmd), m[0], m[2], m[4], rtn)
-            stk = m[2].lower().split()[0]
-            if stk in images:
-                image = Image.open(images[stk])
-            elif stk in aliases and os.path.isfile(aliases[stk]):
-                image = Image.open(aliases[stk])
-            else:
-                image = None
+            image = getImage(m[2], (20, 20))
             if image:
                 try:
-                    getattr(self, "image%s" % stk)
+                    getattr(self, "image%s" % m[2])
                 except:
-                    image = image.resize((20, 20), 0)
-                    setattr(self, "image%s" % stk, ImageTk.PhotoImage(image))
+                    setattr(self, "image%s" % m[2], image)
                 if idx is None:
                     mens[m[1]].add("command", label=m[4], command=cmd,
                         font=font, underline=pos, image=getattr(self,
-                        "image%s" % stk), compound="left")
+                        "image%s" % m[2]), compound="left")
                 else:
                     mens[m[1]].insert(idx, "command", label=m[4], command=cmd,
                         font=font, underline=pos, image=getattr(self,
-                            "image%s" % stk), compound="left")
+                            "image%s" % m[2]), compound="left")
             elif idx is None:
                 mens[m[1]].add("command", label=m[4], command=cmd, font=font,
                     underline=pos)
@@ -2091,7 +1903,7 @@
                 mens[m[1]].insert(idx, "command", label=m[4], command=cmd,
                     font=font, underline=pos)
         # Calculate optimal font to show all items
-        self.menubar.update_idletasks()
+        self.mf.window.update_idletasks()
         while self.menubar.winfo_reqwidth() > self.mf.geo[0]:
             self.mf.rcdic["mfs"] = int(self.mf.rcdic["mfs"]) - 1
             self.mf.setThemeFont(butt=False)
@@ -2103,10 +1915,8 @@
         iwth = self.mf.body.winfo_reqwidth()
         ihgt = self.mf.body.winfo_reqheight()
         self.image = tk.Canvas(self.mf.body, width=iwth, height=ihgt)
-        if self.img and os.path.isfile(self.img):
-            pilimg = Image.open(self.img)
-            pilimg = pilimg.resize((iwth, ihgt), 0)
-            self.tkimg = ImageTk.PhotoImage(image=pilimg)
+        if self.img:
+            self.tkimg = getImage("tartan", (iwth, ihgt))
             self.image = tk.Canvas(self.mf.body, width=iwth, height=ihgt)
             self.image.create_image(0, 0, image=self.tkimg, anchor="nw")
             self.image.ilist = [self.tkimg]
@@ -2227,7 +2037,7 @@
             sw = int(self.window.winfo_screenwidth())
             sh = int(self.window.winfo_screenheight())
             rootsize = tuple(int(_) for _ in self.window.geometry().
-                split('+')[0].split('x'))
+                split("+")[0].split("x"))
             x = int(sw / 2) - int(rootsize[0] / 2)
             y = int(sh / 2) - int(rootsize[1] / 2)
             self.window.geometry("%dx%d+%d+%d" % (rootsize + (x, y)))
@@ -2258,7 +2068,6 @@
                 dbport:   The port to be used for PgSQL
                 dbuser:   The database user for PgSQL
                 dbpwd:    The database user's password for PgSQL
-                prgdir:   A directory where the program resides
                 wrkdir:   A work directory
     screen - A screen on which to display error messages else None
     """
@@ -2268,7 +2077,7 @@
         else:
             self.rcdic = rcdic
         check = ["dbase", "dbname", "dbhost", "dbdir", "dbport",
-            "dbuser", "dbpwd", "prgdir", "wrkdir"]
+            "dbuser", "dbpwd", "wrkdir"]
         for key in self.rcdic:
             setattr(self, key, self.rcdic[key])
             if key in check:
@@ -2330,13 +2139,11 @@
             self.blb = "blob"
         else:
             return
-        if "prgdir" not in self.rcdic:
-            self.prgdir = os.path.dirname(sys.argv[0])
         return True
 
     def checkDbase(self):
         "Check to see if a database exists"
-        exists = False
+        err = exists = False
         if self.dbase == "PgSQL":
             err = self.openDbase(dbname="postgres", err=False)
             if not err and self.db:
@@ -2344,11 +2151,10 @@
                     "pg_database where datname='%s'" % self.dbname)
                 if self.cu.fetchone()[0]:
                     exists = True
-        else:
-            if os.path.exists(self.dbdsn) and os.stat(self.dbdsn).st_size:
-                err = self.openDbase(err=False)
-                if not err and self.db and self.checkTable("ffield"):
-                    exists = True
+        elif os.path.exists(self.dbdsn) and os.stat(self.dbdsn).st_size:
+            err = self.openDbase(err=False)
+            if not err and self.db and self.checkTable("ffield"):
+                exists = True
             else:
                 err = False
         try:
@@ -2362,10 +2168,10 @@
     def createDbase(self):
         "Create a database if it does not exist"
         try:
-            err = self.checkDbase()
-            if err not in (True, False):
-                raise Exception(err)
-            elif err is True:
+            chk = self.checkDbase()
+            if chk not in (True, False):
+                raise Exception(chk)
+            if chk is True:
                 raise Exception("Database Already Exists")
             if self.dbase == "PgSQL":
                 self.openDbase(dbname="postgres", auto=True)
@@ -2507,8 +2313,10 @@
                 self.cu.execute("Select name from SQLITE_MASTER where "
                     "name = '%s' and type = 'table'" % table)
             return self.cu.fetchone()
-        except:
-            return
+        except Exception as err:
+            showException(self.screen, self.wrkdir,
+                "Error Checking Table (%s)\n\n%s" % (table, err))
+            os._exit(1)
 
     def createTable(self, table, drop=False, index=True):
         if self.checkTable(table):
@@ -2538,6 +2346,8 @@
                     qry += " %s(%s)," % (self.var, int(siz))
                 else:
                     qry += " %s," % self.var
+            elif typ == "ID":
+                qry += " %s," % self.lng
             elif typ[0] in ("S", "T", "U"):
                 if typ[1].upper() == "D":
                     if typ[0] == "S":
@@ -2548,8 +2358,11 @@
                 elif typ[1] in ("I", "M"):
                     qry += " %s," % self.itg
                 elif typ[1] == "S":
-                    sequence = nam
-                    qry += " %s," % self.ser
+                    if typ[0] == "T":
+                        qry += " %s," % self.var
+                    else:
+                        sequence = nam
+                        qry += " %s," % self.ser
                 elif typ[1] == "X":
                     qry += " %s," % self.txt
             else:
@@ -2622,6 +2435,8 @@
                     "Delete from ffield where ff_tabl = '%s'" % table)
                 self.cu.execute(
                     "Delete from ftable where ft_tabl = '%s'" % table)
+            if self.dbase == "SQLite":
+                self.db.execute("VACUUM")
 
 class Sql(object):
     """
@@ -2629,13 +2444,13 @@
         table_col  = A list of all column names
         table_fld  = A string of all column names comma delimited
         table_dic  = A dictionary of columns having:
-                     {"colname": table, seq, type, size, desc, head}
+                     {"colname": [table, seq, type, size, desc, head]}
     """
-    def __init__(self, dbm, tables=None, err=True, prog=None):
+    def __init__(self, dbm, tables=None, error=True, prog=None):
         """
         dbm    - The database class
         tables - The tables required for the insRec function
-        err    - Whether to show an error if a table is missing
+        error  - Whether to show an error if a table is missing
         prog   - The calling module name
         """
         self.dbm = dbm
@@ -2656,20 +2471,21 @@
                 "order by ff_seq" % self.dbm.dbf, (table,)))
             if cols and type(cols) in (list, tuple):
                 col = []
-                for c in cols:
-                    col.append(c[2])
-                setattr(self, "%s_col" % table, col)
                 fld = ""
                 dic = {}
                 for n, c in enumerate(cols):
-                    fld = "%s%s, " % (fld, c[2])
+                    col.append(c[2])
+                    if not fld:
+                        fld = c[2]
+                    else:
+                        fld = "%s, %s" % (fld, c[2])
                     dic[c[2]] = [table, c[1], c[3], c[4], c[5], c[6]]
-                fld = fld[:-2]
+                setattr(self, "%s_col" % table, col)
                 setattr(self, "%s_fld" % table, fld)
                 setattr(self, "%s_dic" % table, dic)
             else:
                 self.error.append(table)
-        if err and self.error:
+        if error and self.error:
             mess = "The Following Tables are Missing\n\n"
             for tab in self.error:
                 mess = "%s%s, " % (mess, tab)
@@ -2741,12 +2557,13 @@
                 (str(state), self.prog), dbm=self.dbm)
             os._exit(1)
 
-    def insRec(self, table, data=None, unique=False, dofmt=True, pbar=None):
+    def insRec(self, table, data=None, unique=False, dofmt=True, xprt=True, pbar=None):
         """
         table   = The table to insert into
         data    = A list or a list of lists of all the column's data
         unique  = Any column which must be unique e.g. drt_ref1
         dofmt   = Whether or not to format the data before inserting
+        xprt    = Blank the export flag
         pbar    = ProgressBar object
         """
         if table not in self.tables:
@@ -2778,7 +2595,7 @@
         fld = []
         # Generate column formats
         for n, c in enumerate(col):
-            if c.count("_xflag"):
+            if xprt and c.count("_xflag"):
                 xfl = c
                 idx = n
             elif dic[c][2] == "US":
@@ -2896,7 +2713,7 @@
             self.sqlRec(("Insert into %s %s values %s" %
                 (table, nfld, nfmt), ndat))
 
-    def getRec(self, tables, join=None, cols=None, where=None, data=None, group=None, order=None, fetch=False, limit=None):
+    def getRec(self, tables, join=None, cols=None, where=None, group=None, order=None, fetch=False, limit=None):
         """
         tables = A string or list of tables
         join   = A join statement
@@ -2916,12 +2733,9 @@
                     be used to join tuples of statements, "or" must be
                     implicitly stated as in the example above.
 
-        data   = If no where statement then this is a list of ALL the table's
-                    columns's data in order to build a where statement
-                    e.g. genmst would be: [1, 1, "P", "Hello", "N", "I"]
         group  = A string of columns to group by e.g. "drt_cono, drt_acno"
         order  = A string of columns to order by e.g. "drt_cono, drt_acno"
-        fetch  = Only fetch record from a previous select. True or False
+        fetch  = Only fetch records from a previous select. True or False
         limit  = The number of records to return e.g. 1 else returns all
         """
         # check for tables
@@ -2934,12 +2748,7 @@
             tables = [tables]
         # Start the get statement
         get = "Select"
-        # check for only one table if there is data
-        if not where and data and len(tables) > 1:
-            showError(None, "getRec Error",
-                "List of data exists but more than 1 table")
-            sys.exit()
-        # no cols get all columns
+        # If no cols get all columns
         if not cols:
             if len(tables) > 1:
                 showError(None, "getRec Error",
@@ -2949,13 +2758,13 @@
         grpreq = False
         grpcol = ""
         for col in cols:
-            tabchk = []
-            aggchk = False
-            asschk = False
-            rndchk = False
+            tb_chk = []
+            ag_chk = False
+            as_chk = False
+            rd_chk = False
             # Check for sum without round for decimal
             if col.count(" as "):
-                asschk = True
+                as_chk = True
                 ts1 = col.split(" as ")
             else:
                 ts1 = [col]
@@ -2968,27 +2777,27 @@
                         try:
                             dic = getattr(self, "%s_dic" % tab)
                             if t in dic and dic[t][2][1].lower() == "d":
-                                rndchk = str(dic[t][3]).split(".")[1]
+                                rd_chk = str(dic[t][3]).split(".")[1]
                         except:
-                            tabchk.append(tab)
-                if rndchk:
-                    col = "round(" + ts1[0] + ", %s)" % rndchk
-                    if asschk:
+                            tb_chk.append(tab)
+                if rd_chk:
+                    col = "round(" + ts1[0] + ", %s)" % rd_chk
+                    if as_chk:
                         col = col + " as " + ts1[1]
-                if tabchk:
+                if tb_chk:
                     print("Tables %s missing in sql class in module %s" % \
-                        (tabchk, self.prog))
+                        (tb_chk, self.prog))
             # Continue building the get statement
             get = "%s %s," % (get, col)
-            if asschk:
+            if as_chk:
                 col = col.split(" as ")[1].strip()
             else:
                 for agg in ("count(", "sum(", "avg(", "max(", "min("):
                     if col.lower().count(agg):
                         grpreq = True
-                        aggchk = True
+                        ag_chk = True
                         break
-            if not aggchk:
+            if not ag_chk:
                 if not grpcol:
                     grpcol = col
                 else:
@@ -3000,21 +2809,10 @@
         if join:
             get = "%s %s" % (get, join)
         if where:
+            # Selection of records
             whr, dat = self.getSqlWhere(where)
-        elif data:
-            # data contains the data for all the columns
-            whr = ""
-            dat = copyList(data)
-            for table in tables:
-                cols = getattr(self, "%s_col" % table)
-                for col in cols:
-                    if not whr:
-                        whr = "where %s = %s" % (col, self.dbm.dbf)
-                    else:
-                        whr = "%s and %s = %s" % (whr, col, self.dbm.dbf)
-            limit = 1
         else:
-            # all records
+            # All records
             whr = None
             dat = None
         if whr:
@@ -3041,29 +2839,29 @@
         table   = The table to update
         where   = A where statement like the getRec one
         data    = A list of data matching the columns in cols or all if no cols
-        cols    = A list of columns matching 'data' else None for all
+        cols    = A list of columns matching 'data' else None for all data cols
         dofmt   = Whether or not to format the data before updating
         """
         if not where and not data:
             showError(None, "updRec Error", "Missing where and list of data")
             sys.exit()
+        if table not in self.tables:
+            showError(None, "updRec Error",
+                "Table %s Not In Sql Tables\n\nIn module %s" %
+                (table, self.prog))
+            self.dbm.rollbackDbase()
+            sys.exit()
         cmd = ""
         ccc = getattr(self, "%s_col" % table)
         pfx = ccc[0].split("_")[0]
         xfl = "%s_xflag" % pfx
-        if not cols:
-            cols = ccc[:]
-            if len(data) != len(cols) and xfl in cols:
-                # Work around for new xflag column
-                data.insert(ccc.index(xfl), "")
-        if len(data) != len(cols):
-            showError(None, "updRec Error",
-                "Length of Data not equal to length of Cols (%s)" % table)
-            sys.exit()
         if self.impdbd and xfl in ccc:
+            # Exported database, delete old record and insert new one
             if where:
+                # Selected records
                 recs = self.getRec(table, where=where)
             else:
+                # All records
                 recs = self.getRec(table)
             for rec in recs:
                 dat = rec[:]
@@ -3071,28 +2869,34 @@
                 for num, col in enumerate(ccc):
                     if col == xfl:
                         dat[num] = ""
-                    elif col in cols:
+                    elif cols and col in cols:
                         dat[num] = data[cols.index(col)]
                     else:
                         dat[num] = rec[num]
                 self.insRec(table, data=dat)
-        else:
-            dic = getattr(self, "%s_dic" % table)
-            for num, col in enumerate(cols):
-                if not cmd:
-                    cmd = "Update %s set %s = %s" % (table, col, self.dbm.dbf)
-                else:
-                    cmd = "%s, %s = %s" % (cmd, col, self.dbm.dbf)
-                if dofmt:
-                    dat = CCD(data[num], dic[col][2], dic[col][3])
-                    if not dat.err:
-                        data[num] = dat.work
-            dat = copyList(data)
-            if where:
-                whr, ext = self.getSqlWhere(where)
-                dat.extend(ext)
-                cmd = "%s %s" % (cmd, whr)
-            self.sqlRec((cmd, tuple(dat)))
+                return
+        if not cols:
+            cols = ccc[:]
+        if len(data) != len(cols):
+            showError(None, "updRec Error",
+                "Length of Data not equal to length of Cols (%s)" % table)
+            sys.exit()
+        dic = getattr(self, "%s_dic" % table)
+        for num, col in enumerate(cols):
+            if not cmd:
+                cmd = "Update %s set %s = %s" % (table, col, self.dbm.dbf)
+            else:
+                cmd = "%s, %s = %s" % (cmd, col, self.dbm.dbf)
+            if dofmt:
+                dat = CCD(data[num], dic[col][2], dic[col][3])
+                if not dat.err:
+                    data[num] = dat.work
+        dat = copyList(data)
+        if where:
+            whr, ext = self.getSqlWhere(where)
+            dat.extend(ext)
+            cmd = "%s %s" % (cmd, whr)
+        self.sqlRec((cmd, tuple(dat)))
 
     def delRec(self, table, cols=None, data=None, where=None):
         """
@@ -3101,6 +2905,12 @@
         data  = A list of data matching the columns in cols or all columns
         where = A where statement if no data and cols, as per getRec
         """
+        if table not in self.tables:
+            showError(None, "delRec Error",
+                "Table %s Not In Sql Tables\n\nIn module %s" %
+                (table, self.prog))
+            self.dbm.rollbackDbase()
+            sys.exit()
         ccc = getattr(self, "%s_col" % table)
         pfx = ccc[0].split("_")[0]
         xfl = "%s_xflag" % pfx
@@ -3134,6 +2944,7 @@
             cmd = "Delete from %s" % table
             ddd = "Select * from %s" % table
         if self.impdbd and xfl in ccc:
+            # Exported database, insert records into delrec table
             recs = self.sqlRec(ddd)
             for rec in recs:
                 if rec[ccc.index(xfl)] == "Y":
@@ -3222,41 +3033,42 @@
     Data Types
     ============================================================================
     CB = CheckButton Box
+    CD = Currency Decimal Signed i.e. thousands separated by comma
     CI = Currency Integer Signed i.e. thousands separated by comma
-    CD = Currency Decimal Signed i.e. thousands separated by comma
     D0 = Date (CCYYMMDD)
     D1 = Date (CCYYMMDD)
-    d1 = Date (CCYYMMDD) Alowing Zero
     D2 = Current Period Date (CCYYMM)
-    d2 = Current Period Date (CCYYMM) Allowing Zero
     D3 = Date (DD-MMM-YYYY)
     DT = Date and Time (DD-MMM-YYYY-HH:MM)
-    MD = Month and Day (MMDD)
     FF = File or Directory Format
+    HA = Normal Alphanumeric Hidden as for Passwords
+    ID = Identity Number
     LA = Lower Case Alphanumeric (Must also have 'size' set)
     La = Lower Case Alphanumeric Right Justified (Must also have 'size' set)
-    HA = Normal Alphanumeric Hidden as for Passwords
+    MD = Month and Day (MMDD)
     NA = Normal Alphanumeric (Must also have 'size' set)
     Na = Normal Alphanumeric Right Justified (Must also have 'size' set)
     RB = RadioButton Box
     RW = Raw Data, No formatting or checking
     SD = Signed Decimal (size includes sign and decimals)
-    Sd = Convert Integer to Signed Decimal (size includes sign and decimals)
     SI = Signed Integer (size includes sign)
     SL = Signed Long Integer (size includes sign)
+    Sd = Convert Integer to Signed Decimal (size includes sign and decimals)
     TM = Time (HH:MM)
-    tM = Time (HH:MM) Allowing Zero
     TS = Timestamp (CCYY-MM-DD HH:MM:SS)
     TV = Text View - This is only used with TartanDialog for input purposes
+    TX = Text or Blob Alphanumeric Variable Length - Storing Text Views etc.
     Tv = Text View - This is only used with TartanDialog for input purposes
-    TX = Text or Blob Alphanumeric Variable Length - Storing Text Views etc.
     UA = Upper Case Alphanumeric (Must also have 'size' set)
-    Ua = Upper Case Alphanumeric Right Justified (Must also have 'size' set)
     UD = Unsigned Decimal (size includes decimals)
-    Ud = Convert Integer to Unsigned Decimal (size includes decimals)
     UI = Unsigned Integer
     UL = Unsigned Long Integer
     US = Unsigned Serial
+    Ua = Upper Case Alphanumeric Right Justified (Must also have 'size' set)
+    Ud = Convert Integer to Unsigned Decimal (size includes decimals)
+    d1 = Date (CCYYMMDD) Alowing Zero
+    d2 = Current Period Date (CCYYMM) Allowing Zero
+    tM = Time (HH:MM) Allowing Zero
     """
     def __init__(self, data, types, size=0):
         self.mthnum = {
@@ -3268,9 +3080,20 @@
         if len(types) == 3:
             types = types[1:]
         # ======================================================================
-        # Check, Radio Button Boxes, Raw Data Types and Timestamp
+        # Check and Radio Button Boxes, Raw Data Types and Timestamp
         # ======================================================================
-        if types in ("CB", "RB", "RW", "TS"):
+        if types == "TS" and len(str(data)) == 14:
+            self.err = ""
+            data = self.work = str(data)
+            yr = int(data[:4])
+            mt = int(data[4:6])
+            dy = int(data[6:8])
+            hr = int(data[8:10])
+            mm = int(data[10:12])
+            ss = int(data[12:14])
+            self.disp = "%4i-%02i-%02i %02i:%02i:%02i" % (yr,mt,dy,hr,mm,ss)
+            return
+        elif types in ("CB", "RB", "RW", "TS"):
             self.err = ""
             self.work = self.disp = self.data = data
             return
@@ -3291,7 +3114,7 @@
         elif types[1].lower() in ("a", "v", "x"):
             self.data = self.remNonAscii(data)
         else:
-            self.data = str(data).strip()
+            self.data = str(data).rstrip()
         self.types = types
         self.size = size
         if types in ("D1","d1","D2","d2","DT","dT","DM","dM","TM","tM"):
@@ -3335,7 +3158,7 @@
         elif self.types[1] in ("A","a"):
             dat = self.data[:self.quo]
             if self.types[1] == "A":
-                if not self.data:
+                if not dat:
                     self.work = dat
                     self.disp = " " * self.quo
                 else:
@@ -3349,7 +3172,7 @@
                 try:
                     if dat[-1:] == "L":
                         raise Exception
-                    dat = str(long(self.data))
+                    dat = str(long(dat))
                     if dat[-1:] == "L":
                         dat = dat[:-1]
                     self.work = dat.rjust(self.quo)
@@ -3367,7 +3190,7 @@
             self.unsignedInteger()
         elif self.types in ("CI", "SI"):
             self.signedInteger()
-        elif self.types == "UL":
+        elif self.types in ("ID", "UL"):
             self.unsignedLong()
         elif self.types == "SL":
             self.signedLong()
@@ -3375,19 +3198,21 @@
             self.unsignedDecimal()
         elif self.types in ("CD", "SD", "Sd"):
             self.signedDecimal()
-        elif self.types in ("FF", "TV", "Tv", "TX"):
-            self.work = self.data.strip()
-            self.disp = self.data.strip()
+        elif self.types == "FF":
+            self.pathFormat()
+        elif self.types in ("TV", "Tv", "TX"):
+            self.work = self.data.rstrip()
+            self.disp = self.data.rstrip()
         else:
             self.err = "Invalid Input, Retry (%s)" % self.types
 
     def remNonAscii(self, data):
         if data and type(data) in (str, unicode):
-            return str(re.sub(r"[^\x20-\x7e]", r"", data)).strip()
+            return str(re.sub(r"[^\x20-\x7e]", r"", data)).rstrip()
         elif type(data) == float:
-            return str(int(data)).strip()
+            return str(int(data)).rstrip()
         else:
-            return str(data).strip()
+            return str(data).rstrip()
 
     def chkD0_Date(self):
         date = self.data.replace("-", "")
@@ -3696,6 +3521,42 @@
         except:
             self.err = "Invalid Signed Decimal (%s)" % self.types
 
+    def pathFormat(self):
+        if not self.data:
+            self.work = self.disp = self.data
+            return
+        try:
+            if self.data.count("/"):
+                data = self.data.split("/")
+            else:
+                data = [self.data]
+            work = []
+            for dat in data:
+                if dat.count("\\"):
+                    work.extend(dat.split("\\"))
+                else:
+                    work.append(dat)
+            if sys.platform == "win32":
+                if work[0].count(":"):
+                    drive = work.pop(0).upper()
+                else:
+                    drive = os.path.splitdrive(os.getcwd())[0].upper()
+            else:
+                if not work[0]:
+                    del work[0]
+                    drive = os.sep
+                else:
+                    drive = os.getcwd()
+            if sys.platform == "win32":
+                data = os.path.join(drive, os.sep, *work)
+            else:
+                data = os.path.join(drive, *work)
+            self.work = self.disp = os.path.normpath(data)
+            if not os.path.isabs(self.work):
+                raise Exception
+        except:
+            self.err = "Invalid Path (%s)" % self.types
+
 class ASD(object):
     """
     Used for Adding and Subtracting Floats as follows:
@@ -3781,7 +3642,7 @@
                 sysdt = ((t[0] * 10000) + (t[1] * 100) + t[2])
                 self.sql.sqlRec("Insert into verupd values('%s', %s)" %
                     (self.ver, sysdt))
-            if self.put == "i" and self.dbm.dbase == "SQLite":
+            if self.dbm.dbase == "SQLite":
                 self.dbm.cu.execute("PRAGMA JOURNAL_MODE=DELETE")
                 self.dbm.cu.execute("PRAGMA SYNCHRONOUS=FULL")
             if self.cmt:
@@ -3793,30 +3654,7 @@
         if self.put != "i" and not self.dbm.dbopen:
             self.dbm.openDbase()
         self.sql = Sql(self.dbm)
-        if self.dbm.dbase == "PgSQL":
-            self.dtm = "timestamp"
-            self.key = "varchar"
-            self.var = "varchar"
-            self.txt = "text"
-            self.int = "int4"
-            self.lng = "int8"
-            self.dec = "numeric"
-            self.flt = "numeric"
-            self.ser = "serial"
-            self.blb = "varchar"
-        else:
-            self.dtm = "varchar"
-            self.key = "varchar"
-            self.var = "varchar"
-            self.txt = "blob"
-            self.int = "integer"
-            self.lng = "long"
-            self.dec = "float"
-            self.flt = "float"
-            self.ser = "integer primary key"
-            self.blb = "blob"
 
-    #@profile
     def doCreate(self):
         if self.tab:
             chk = self.doCheckTables(self.tab)
@@ -3824,10 +3662,10 @@
                 print("Details for Table(s) %s Do(es) Not Exist" % chk)
                 return False
         if self.put == "i":
-            err = self.dbm.checkDbase()
-            if err not in (True, False):
+            chk = self.dbm.checkDbase()
+            if chk not in (True, False):
                 os._exit(1)
-            elif err is True:
+            elif chk is True:
                 if self.drp:
                     answer = "yes"
                 else:
@@ -3841,7 +3679,7 @@
                     return False
             self.dbm.createDbase()
             self.dbm.openDbase(dbuser=self.usr, dbpwd=self.pwd, auto=True)
-        if self.put == "i" and self.dbm.dbase == "SQLite":
+        if self.dbm.dbase == "SQLite":
             self.dbm.cu.execute("PRAGMA JOURNAL_MODE=OFF")
             self.dbm.cu.execute("PRAGMA SYNCHRONOUS=OFF")
         if self.spl:
@@ -4033,8 +3871,8 @@
                             'rf'          = Re-focus on same field
                             'rt'          = Return True
                             'sk[1-99]'    = Skip the next [1-99] fields
+                            'text'        = An error message
                             'xt'          = Exit the frame
-                            'text'        = An error message
                 f1      = The record selection function to perform as:
                             a_name = {
                                  'stype':  "R",
@@ -4127,6 +3965,7 @@
                             ('notblank',)
                             ('notzero',)
                             ('between', 5, 2)
+                            ('idno',)
                             ('in', ("Y",'N'))
                             ('dir',)
                             ('file',)
@@ -4161,10 +4000,10 @@
 
     txit   =  A list of functions to execute on exiting top frames by page
 
-    cend   =  A list of lists of functions to execute on finishing a data line
+    cend   =  A list of lists of functions to execute on finishing a col line
                 by page having: (function, cnf)
 
-    cxit   =  A list of functions to execute on exiting a data frame by page
+    cxit   =  A list of functions to execute on exiting a col frames by page
 
     view   =  An entry field asking whether you would like to view the report
               It is a tuple (csv, dft) where:
@@ -4350,12 +4189,18 @@
             self.eflds = list(self.eflds)
             if self.repprt[0] == "Y":
                 # View/Print/Export dialog
-                prts = showPrinters(wrkdir=self.mf.rcdic["wrkdir"])
+                prts = getPrinters(wrkdir=self.mf.rcdic["wrkdir"])
+                data = prts[:]
+                if "Default" in data:
+                    data.remove("Default")
+                    dflt = "Default"
+                else:
+                    dflt = data[0]
                 prt = {
                     "stype": "C",
                     "titl": "Available Printers",
                     "head": ("Name", "Description"),
-                    "data": prts}
+                    "data": data}
                 rvs = [("View","V"),("Print","P"),("None","N")]
                 mes = """Select what to do with the generated report.
 
@@ -4378,7 +4223,7 @@
                     None,None, None,None,mes))
                 row += 1
                 self.eflds.append((("T",0,row,col),"INA",(30,50),"Printer Name",
-                    "","Default","Y",self.setPrtr,prt,None,("in", prts)))
+                    "",dflt,"Y",self.setPrtr,prt,None,("in", prts)))
             if self.repeml[0] == "Y":
                 # Email dialog
                 yns = (("Yes","Y"),("No","N"))
@@ -4494,7 +4339,7 @@
                 self.first = col[0]
             if col[0][1] < self.pgs:
                 showError(self.master, "Page Number",
-                    "The Page Number is Out of Sequence")
+                    "The Page Number (%s) is Out of Sequence" % str(col[0]))
                 sys.exit()
             elif col[1][0] == "R":
                 showError(self.master, "Old Radio Button %s" % str(col[0]),
@@ -4801,14 +4646,8 @@
 
     def drawNoteBook(self, page):
         # Create images for enabled and disabled
-        nbeimg = Image.open(os.path.join(getPrgPath(), "img",
-            "yes.png"))
-        nbeimg = nbeimg.resize((20, 20), 0)
-        self.nbeimg = ImageTk.PhotoImage(nbeimg)
-        nbdimg = Image.open(os.path.join(getPrgPath(), "img",
-            "no.png"))
-        nbdimg = nbdimg.resize((20, 20), 0)
-        self.nbdimg = ImageTk.PhotoImage(nbdimg)
+        self.nbeimg = getImage("yes", (20, 20))
+        self.nbdimg = getImage("no", (20, 20))
         # Create notebook
         self.nb = ttk.Notebook(self.mstFrame, takefocus=False)
         self.nb.grid(column=0, sticky="nswe")
@@ -4851,7 +4690,7 @@
         # Select notebook page by label text or page number
         if label:
             found = False
-            for index, tag in enumerate(self.tags):
+            for idx, tag in enumerate(self.tags):
                 if tag[0] == label:
                     found = True
                     break
@@ -4859,14 +4698,16 @@
                 print("Invalid Notebook Tag %s" % label)
                 return
         elif index is None:
-            index = page - 1
-        if self.nb.select() == self.nb.tabs()[index]:
+            idx = page - 1
+        else:
+            idx = index
+        if self.nb.select() == self.nb.tabs()[idx]:
             # Page already selected
             return
-        self.nb.select(index)
-        self.pag = index + 1
-        self.lastnbpage = index
-        cmd = self.tags[index][1]
+        self.nb.select(idx)
+        self.pag = idx + 1
+        self.lastnbpage = idx
+        cmd = self.tags[idx][1]
         if cmd:
             self.window.focus_set()
             cmd()
@@ -4881,7 +4722,7 @@
             else:
                 dirs = "F"
             if focus:
-                self.focusField("C", self.pag, self.last[self.pag][1], dir=dirs)
+                self.focusField("C", self.pag, self.last[self.pag][1], ddd=dirs)
         elif self.last[self.pag][0]:
             l = self.last[self.pag][0]
             m = self.topq[self.pag]
@@ -4891,7 +4732,7 @@
             else:
                 dirs = "F"
             if focus:
-                self.focusField("T", self.pag, self.last[self.pag][0], dir=dirs)
+                self.focusField("T", self.pag, self.last[self.pag][0], ddd=dirs)
         elif self.topq[self.pag]:
             if focus:
                 self.focusField("T", self.pag, 1)
@@ -5499,16 +5340,16 @@
                 self.backUp(self.frt, self.pag)
         return True
 
-    def focusField(self, frt, pag, col, clr=True, err="", dir="F", tag=True):
+    def focusField(self, frt, pag, col, clr=True, err="", ddd="F", tag=True):
         """
         This routine is used to focus on a widget:
             frt = The frame type, T = Top, C = Columnar
             pag = The frame number
             col = The column number
             clr = Clear the frame if first field of first page or
-                  Clear the rest of the row if Col Frame - True or False
+                  Clear the rest of the row if Column Frame - True or False
             err = An error message to display on the status line
-            dir = Direction, F = Forwards, B = Backwards when skipping fields
+            ddd = Direction, F = Forwards, B = Backwards when skipping fields
             tag = Select data in the text view widget
         """
         if frt == "T" and not self.topq[pag]:
@@ -5516,10 +5357,7 @@
         elif frt == "C" and not self.colq[pag]:
             return
         if type(clr) == str:
-            if clr == "True":
-                clr = True
-            else:
-                clr = False
+            clr = bool(clr == "True")
         # Force focus to application
         self.window.focus_force()
         if col == 1 and tuple(self.first[:2]) == (frt, pag) and clr:
@@ -5544,10 +5382,7 @@
             self.idx = self.pos
             flds = self.topf[self.pag][self.idx]
             fldd = self.topEntry[self.pag][self.pos]
-            if flds[1][0] == "I" and self.topListl[self.pag][self.pos]:
-                faut = True
-            else:
-                faut = False
+            faut = bool(flds[1][0] == "I" and self.topListl[self.pag][self.pos])
             # ==================================================================
             # If column field with Y in [6] clear rest of row
             # ==================================================================
@@ -5578,10 +5413,7 @@
             self.idx = self.pos % self.colq[self.pag]
             flds = self.colf[self.pag][self.idx]
             fldd = self.colEntry[self.pag][self.pos]
-            if flds[1][0] == "I" and self.colListl[self.pag][self.pos]:
-                faut = True
-            else:
-                faut = False
+            faut = bool(flds[1][0] == "I" and self.colListl[self.pag][self.pos])
             # ==================================================================
             # If column field with Y in [6] clear rest of row
             # ==================================================================
@@ -5640,15 +5472,15 @@
         # Check if Output Field Only and if so, skip it and return
         # ======================================================================
         if flds[1][0] in ("O", "OCB", "ORB"):
-            self.doSkipFld(dir.upper(), dflt)
+            self.doSkipFld(ddd.upper(), dflt)
             return
         # ======================================================================
         # Setting the status line help message
         # ======================================================================
         if flds[8] and flds[1][0] == "I":
-            sufx = ", <F1> to Select"
+            sufx = ", Enter to Continue, <F1> to Select"
         else:
-            sufx = ""
+            sufx = ", Enter to Continue"
         if flds[9]:
             sufx = sufx + ", <F5> to Delete"
         if flds[1][1:] == "TV":
@@ -5681,7 +5513,7 @@
                     self.mf.window.bell()
             self.mf.updateStatus("%s, Retry%s" % (err, sufx), "white", "red")
         else:
-            self.mf.updateStatus("%s%s" % (text, sufx))
+            self.mf.updateStatus("%s%s" % (text.lstrip(), sufx))
         # ======================================================================
         if type(flds[1]) in (list, tuple):
             if flds[1][0][1:] == "CB":
@@ -5694,8 +5526,8 @@
             self.doEntryField(self.frt, self.pag, self.idx, fldd, faut,
                 "focus", dflt)
 
-    def doSkipFld(self, dir, dflt=""):
-        if dir == "F":
+    def doSkipFld(self, ddd, dflt=""):
+        if ddd == "F":
             self.doInvoke(None, dflt)
         else:
             self.loadEntry(self.frt, self.pag, self.pos, data=dflt)
@@ -5707,7 +5539,7 @@
                         self.tend[self.pag][0]()
             else:
                 self.col = self.col - 1
-                self.focusField(self.frt, self.pag, self.col, dir=dir)
+                self.focusField(self.frt, self.pag, self.col, ddd=ddd)
 
     def deleteRecord(self, widget=None):
         # Disable the widget
@@ -5781,7 +5613,12 @@
             self.idx = self.idx - 1
             self.pos = self.pos - 1
             self.col = self.col - 1
-        self.focusField(frt, pag, self.col)
+        clr = False
+        if frt == "T" and self.topf[pag][self.pos][6] == "Y":
+            clr = True
+        elif frt == "C" and self.colf[pag][self.idx][6] == "Y":
+            clr = True
+        self.focusField(frt, pag, self.col, clr=clr)
 
     def clearFrame(self, frt, pag):
         self.skip[pag] = []
@@ -5892,7 +5729,7 @@
                                 "I","D","d","0","1","2","3"):
                             d.work = 0
                         else:
-                            d = ""
+                            d.work = ""
                     if d.work == 0 and not zero:
                         d.disp = ""
                 self.t_disp[pag][0][pos] = d.disp
@@ -6457,6 +6294,11 @@
                 return ("ok", )
             else:
                 return ("no", "Invalid %s, Not Found" % des)
+        elif val[0] == "idno":
+            if wrk and not luhnFunc(int(wrk)):
+                return ("no", "Invalid ID Number")
+            else:
+                return("ok")
         elif val[0] == "path":
             if os.path.exists(wrk):
                 return ("ok", )
@@ -6613,7 +6455,7 @@
                 if self.col == self.skip[self.pag][x]:
                     self.checkButtonsTags(frt, pag, self.col)
                     self.col = self.col - 1
-            self.focusField(frt, pag, self.col, dir="B")
+            self.focusField(frt, pag, self.col, ddd="B")
         elif cmd:
             self.window.focus_set()
             cmd()
@@ -6846,14 +6688,14 @@
         # Python 2.7.6 geom_info is broken
         root = wid.winfo_toplevel()
         words = root.splitlist(str(root.tk.call(geom, "info", wid)))
-        dict = {}
+        dics = {}
         for i in xrange(0, len(words), 2):
             key = words[i][1:]
             value = words[i+1]
             if str(value)[:1] == ".":
                 value = root._nametowidget(value)
-            dict[key] = value
-        return dict
+            dics[key] = value
+        return dics
 
     def closeProcess(self):
         try:
@@ -7122,11 +6964,11 @@
                 self.head = list(self.head)
                 self.head.insert(0, "")
             size = [0] * len(self.data[0])
-            for d in self.data:
-                for x in xrange(len(d)):
+            for dat in self.data:
+                for x, d in enumerate(dat):
                     try:
-                        if len(str(d[x])) > size[x]:
-                            size[x] = len(str(d[x]))
+                        if len(str(d)) > size[x]:
+                            size[x] = len(str(d))
                     except:
                         pass
             cols = []
@@ -7237,7 +7079,7 @@
              rowc = (2, "black", "white", "black", "grey") or
              rowc = 2
     """
-    def __init__(self, scrn, titl, cols, data, lines=0, sort=True, wait=True, cmnd=None, butt=None, neww=True, deco=True, live=True, posn=0, fltr=False, scrl=True, styl="Treeview", font="TkHeadingFont", addh=0, escape=True, colr=None, rowc=1):
+    def __init__(self, scrn, titl, cols, data, lines=0, sort=True, wait=True, cmnd=None, butt=None, neww=True, deco=True, modal=True, live=True, posn=0, fltr=False, scrl=True, styl="Treeview", font="TkHeadingFont", addh=0, escape=True, colr=None, rowc=1):
         self.scrn = scrn
         self.ocol = cols
         if titl:
@@ -7260,6 +7102,8 @@
             col = list(col)
             if len(col) == 4:
                 col.append("N")
+            elif col[4] == "F":
+                fltr = True
             if col[4] == "Y":
                 self.srch = num
             if self.headings:
@@ -7284,6 +7128,7 @@
             self.butt = butt
         self.neww = neww
         self.deco = deco
+        self.modal = modal
         self.live = live
         if self.live:
             self.mode = "browse"
@@ -7298,8 +7143,7 @@
             if self.font.cget("size") > 12:
                 self.font.configure(size=12)
         else:
-            self.font = tkfont.nametofont(font[0])
-            self.font.configure(size=font[1])
+            self.font = tkfont.Font(font=tuple(font))
         if colr is None:
             self.colr = []
         else:
@@ -7329,13 +7173,17 @@
         if self.neww:
             if self.scrn:
                 self.scrn.winfo_toplevel().config(cursor="watch")
-            mkw = MkWindow(trans=self.scrn, decor=self.deco, modal=self.deco,
+            mkw = MkWindow(trans=self.scrn, decor=self.deco, modal=self.modal,
                 title=self.titl, remov=False, resize=True)
             if not self.deco:
                 mkw.newwin.configure(bg="black", bd=3)
                 mkw.newwin.attributes("-topmost", False)
                 if self.titl:
                     titl = MyLabel(mkw.newwin, text=self.titl, anchor="c")
+                    tf = tkfont.nametofont("TkDefaultFont")
+                    nf = tkfont.Font(font=(tf.cget("family"), tf.cget("size"),
+                        "bold"))
+                    titl.configure(font=nf)
                     titl.pack(fill="x", expand="yes")
             self.window = mkw.newwin
             self.mstFrame = MyFrame(self.window)
@@ -7368,6 +7216,8 @@
         self.tree = ttk.Treeview(self.mstFrame, columns=nams,
             height=self.lines, show=show, selectmode=self.mode,
             style=self.styl)
+        if self.chek:
+            self.tree.configure(padding=[-15, 0, 0, 0])
         self.tree.grid(column=0, row=0, sticky="nswe")
         if self.scrl:
             vsb = ttk.Scrollbar(self.mstFrame, orient="vertical",
@@ -7392,7 +7242,7 @@
             butt.append(("Accept", self.doSelect))
         if not exits:
             butt.append(("Exit", self.doExit))
-        if self.fltr:
+        if len(self.cols) > 1 and self.fltr:
             butt.insert(0, ("Filter", self.doFilter))
         self.buttons = []
         if butt:
@@ -7420,10 +7270,9 @@
     def buildTree(self):
         if self.chek:
             try:
-                self.unchek = tk.PhotoImage(file=os.path.join(getPrgPath(),
-                    "img", "uncheck.gif"))
-                self.dochek = tk.PhotoImage(file=os.path.join(getPrgPath(),
-                    "img", "check.gif"))
+                # Create images for check and uncheck
+                self.unchek = getImage("uncheck")
+                self.dochek = getImage("check")
                 self.tree.heading("#0", image=self.unchek, anchor="e",
                     command=functools.partial(self.doToggle, "all"))
                 self.tree.column("#0", anchor="e", width=43, minwidth=43,
@@ -7482,9 +7331,9 @@
             for c in self.colr[1]:
                 self.tree.tag_configure("%s" % c, foreground=self.colr[1][c][0],
                     background=self.colr[1][c][1])
+        if self.escape:
+            self.tree.bind("<Escape>", self.doExit)
         if self.scrl:
-            if self.escape:
-                self.tree.bind("<Escape>", self.doExit)
             self.tree.bind("<Prior>", self.doScroll)
             self.tree.bind("<Home>", self.doScroll)
             self.tree.bind("<Next>", self.doScroll)
@@ -7517,6 +7366,7 @@
             # Scroll to last entry
             self.tree.update_idletasks()
             self.tree.see(last)
+            self.tree.focus_force()
         if self.neww:
             placeWindow(self.window, parent=self.scrn, expose=True)
 
@@ -7640,7 +7490,7 @@
                 continue
             start = None
             text = self.tree.item(child, "values")[self.srch]
-            if text.lower().startswith(pattern.lower()):
+            if text.lower().count(pattern.lower()):
                 self.tree.selection_set(child)
                 self.tree.update_idletasks()
                 self.tree.focus(child)
@@ -7674,7 +7524,7 @@
                     for i, t in enumerate(det[1][1]):
                         if det[1][0] == "XX" and typ == t[0]:
                             break
-                        elif det[1][0] == "xx" and typ == t[1]:
+                        if det[1][0] == "xx" and typ == t[1]:
                             break
                     tmp = CCD(i+1, "UI", 2).work
                 else:
@@ -7694,10 +7544,10 @@
         if event.keysym in ("Home", "End"):
             if event.keysym == "Home":
                 iid = iids[0]
-                self.tree.yview(tk.MOVETO, 0)
+                self.tree.yview("moveto", 0)
             else:
                 iid = iids[-1]
-                self.tree.yview(tk.MOVETO, 1)
+                self.tree.yview("moveto", 1)
         else:
             self.tree.update_idletasks()
             idx = iids.index(self.tree.focus())
@@ -7904,7 +7754,8 @@
             "title": "",
             "vertical": True,
             "width": 80,
-            "wrap": False}
+            "wrap": False,
+            "wait": True}
         for nam in defaults:
             if nam in args:
                 setattr(self, nam, args[nam])
@@ -7912,13 +7763,16 @@
                 setattr(self, nam, defaults[nam])
         self.setVariables()
         self.doProcess()
-        self.frame.wait_window()
+        if self.wait:
+            self.frame.wait_window()
 
     def setVariables(self):
         if self.butt:
             self.butt.insert(0, ("Continue", self.execStCmd))
-        else:
+        elif self.butt is None:
             self.butt = [("Continue", self.execStCmd)]
+        else:
+            self.butt = []
 
     def doProcess(self):
         if self.scrn:
@@ -8057,11 +7911,11 @@
             length=self.txtlab.winfo_width())
         self.pbar.pack(fill="x", expand="yes", pady=0)
         if self.esc:
-            self.pbt = threading.Thread()
             if self.typ == "G":
-                self.pbt.__init__(target=self.pbar.start, args=())
+                self.pbt = threading.Thread(target=self.pbar.start, args=())
             else:
                 self.pbar.configure(maximum=self.mxs)
+                self.pbt = threading.Thread(target=None, args=())
             self.pbt.start()
             but = MyButton(self.pbframe, cmd=self.quitProgress, text="Quit",
                 underline=0)
@@ -8231,6 +8085,7 @@
         defaults = {
             "rcfile": None,
             "rcdic": None,
+            "dbskp": False,
             "level": 3}
         for nam in args:
             defaults[nam] = args[nam]
@@ -8311,63 +8166,68 @@
                 "file can be altered with the -r option. Please refer "\
                 "to the manual for more detailed information."),
             (("T",1,0,0),("IRB",r1s),0,"Database Engine","",
-                "S","N",self.doEngine,None,None,None),
+                "S","N",self.doEngine,None,None,None,None,
+                "Use SQLite for single-user "\
+                "installations and PgSQL for multi-user installations.\n\n"\
+                "Single-user: Only one user will be accessing the database "\
+                "at any time.\n\nMulti-User: Many users could be accessing "\
+                "the database at any time."),
             (("T",1,1,0),"ILA",30,"Database Name","",
-                self.rcdic["dbname"],"N",None,None,None,("notblank",)),
-            (("T",1,2,0),"INA",30,"Host Name","",
-                "localhost","N",None,None,None,("notblank",)),
-            (("T",1,3,0),"IFF",50,"Files Directory","",
-                self.rcdic["dbdir"],"N",self.doDir,pth,None,None,None),
+                self.rcdic["dbname"],"N",self.doName,None,None,("notblank",)),
+            (("T",1,2,0),"IFF",50,"Files Directory","",
+                "","N",self.doDir,pth,None,("notblank",),None,
+                "The Directory where the Database will be located."),
+            (("T",1,3,0),"INA",30,"Host Name","",
+                "","N",None,None,None,("notblank",)),
             (("T",1,4,0),"IUI",4,"Port Number","",
                 "","N",None,None,None,("efld",)),
             (("T",1,5,0),"INA",30,"Administrator","",
-                self.rcdic["dbuser"],"N",None,None,None,("notblank",),None,
+                self.rcdic["dbuser"],"N",self.doAdmin,None,None,("efld",),None,
                 "The Database Administrator."),
             (("T",1,6,0),"IHA",30,"Password","",
-                self.rcdic["dbpwd"],"N",None,None,None,None,None,
+                self.rcdic["dbpwd"],"N",self.doPwd,None,None,None,None,
                 "The Database Administrator's Password."),
-            (("T",2,0,0),"IFF",50,"Program Path","",
-                self.rcdic["prgdir"],"N",self.doPrg,pth,None,("dir",),None,
-                "The Directory where the Tartan programs are situated."),
-            (("T",2,1,0),"IFF",50,"Backup Path","",
-                self.rcdic["bupdir"],"N",self.doDir,pth,None,None,None,
-                "The Directory where all backup's are stored."),
-            (("T",2,2,0),"IFF",50,"Work Path","",
-                self.rcdic["wrkdir"],"N",self.doDir,pth,None,None,None,
-                "The Directory where all work files are stored."),
-            (("T",2,3,0),"IFF",50,"Upgrade Path","",
-                self.rcdic["upgdir"],"N",self.doDir,pth,None,None,None,
+            (("T",2,0,0),"IFF",50,"Backup Path","",
+                "","N",self.doDir,pth,None,("notblank",),None,
+                "The Directory where all Backup Archives are stored."),
+            (("T",2,1,0),"IFF",50,"Work Path","",
+                "","N",self.doDir,pth,None,("notblank",),None,
+                "The Directory where all Work Files are stored."),
+            (("T",2,2,0),"IFF",50,"Upgrade Path","",
+                "","N",self.doDir,pth,None,("notblank",),None,
                 "The Directory where System Upgrades are stored."),
-            (("T",2,4,0),"IFF",50,"PDF Viewer","",
-                self.rcdic["vwr"],"N",None,fle,None,("cmd",),None,
-                "The Path of the program used to view PDF files."),
-            (("T",2,5,0),"IFF",50,"Print Command","",
-                self.rcdic["prn"],"N",None,fle,None,("cmd",),None,
-                "The Path of the program to use for printing reports."),
-            (("T",2,6,0),"IFF",50,"PS Converter","",
-                self.rcdic["cnv"],"N",None,fle,None,("cmd",),None,
-                "The Path of the program to use for converting PDF to PS."),
-            (("T",2,7,0),"IFF",50,"Spreadsheet Reader","",
-                self.rcdic["cnv"],"N",self.doExport,fle,None,None,None,
-                "The Path of the program to use for reading CSV and XLS "\
-                "files e.g. c:\Program Files\Microsoft Office\Office10"\
-                "\EXCEL.EXE"),
-            (("T",2,8,0),"INA",10,"Screen Geometry","",
+            (("T",2,3,0),"IFF",50,"PDF Viewer","",
+                self.rcdic["vwr"],"N",self.doVwr,fle,None,("cmd",),None,
+                "The Path to an External Program used to view PDF files. "\
+                "This is only required if pymupdf is not installed."),
+            (("T",2,4,0),"IFF",50,"Print Command","",
+                self.rcdic["prn"],"N",None,fle,None,("efld",),None,
+                "The Path and Options to an External Program used to "\
+                "print PDF files. Use %p% for the Printer and %f% for "\
+                "the File. These parameters will be replaced with the "\
+                "Actual items when activated. If this is left blank the "\
+                "Default application will be used, where possible."),
+            (("T",2,5,0),"IFF",50,"Spreadsheet Reader","",
+                self.rcdic["exp"],"N",self.doExport,fle,None,None,None,
+                "The Path to an External Program used to read Spreadsheets. "\
+                "If this is left blank the default application will be "\
+                "used, where possible."),
+            (("T",2,6,0),"INA",10,"Screen Geometry","",
                 self.rcdic["geo"],"N",self.doGeometry,None,None,("notblank",),
                 None,"The screen geometry, enter 0 to get the default"),
-            (("T",2,9,0),("IRB",r2s),0,"Screen Placement","",
+            (("T",2,7,0),("IRB",r2s),0,"Screen Placement","",
                 self.rcdic["plc"],"N",None,None,None,None),
-            (("T",2,10,0),("IRB",r3s),0,"Show Tartan Image","",
+            (("T",2,8,0),("IRB",r3s),0,"Show Tartan Image","",
                 self.rcdic["img"].upper(),"N",None,None,None,None),
-            (("T",2,11,0),("IRB",r3s),0,"Enforce Confirm","",
+            (("T",2,9,0),("IRB",r3s),0,"Enforce Confirm","",
                 self.rcdic["cnf"].upper(),"N",None,None,None,None),
-            (("T",2,12,0),("IRB",r4s),0,"Auto-completion","",
+            (("T",2,10,0),("IRB",r4s),0,"Auto-completion","",
                 self.rcdic["acnf"].upper(),"N",None,None,None,None),
-            (("T",2,13,0),("IRB",r3s),0,"Tool-tips","",
+            (("T",2,11,0),("IRB",r3s),0,"Tool-tips","",
                 self.rcdic["ttip"].upper(),"N",None,None,None,None),
-            (("T",2,14,0),("IRB",r3s),0,"Error Alarm","",
+            (("T",2,12,0),("IRB",r3s),0,"Error Alarm","",
                 self.rcdic["errs"].upper(),"N",None,None,None,None),
-            (("T",2,15,0),("IRB",r5s),0,"Work Files","",
+            (("T",2,13,0),("IRB",r5s),0,"Work Files","",
                 self.rcdic["wrkf"].upper(),"N",None,None,None,None),
             (("T",3,0,0),"INA",30,"Menu Font Name","",
                 self.rcdic["mft"],"N",self.doFtNam,aft,None,("in",self.aft),
@@ -8453,7 +8313,15 @@
             self.doExit,
             self.doExit)
         self.df = TartanDialog(self.mf, eflds=fld, tags=tag, butt=but,
-            tend=tnd, txit=txt, clicks=self.doClick)
+            tend=tnd, txit=txt, clicks=self.doClick, focus=False)
+        if self.dbskp:
+            self.df.loadEntry("T", 0, 0, data=self.rcfile)
+            self.df.doKeyPressed("T", 0, 0, self.rcfile)
+            self.dbase = self.rcdic["dbase"]
+            self.df.disableTag(0)
+            self.doEnd()
+        else:
+            self.df.focusField("T", 0, 1)
 
     def doRcFile(self, frt, pag, r, c, p, i, w):
         if self.level < 3 and w != self.rcfile:
@@ -8470,17 +8338,31 @@
         if w == "P":
             txt = "psycopg2"
             mod = "psycopg2"
-        elif w == "S":
+        else:
             txt = "pysqlite"
             mod = "sqlite3"
-        elif w == "M":
-            txt = "pymysql"
-            mod = "pymysql"
-        elif w == "F":
-            txt = "fdb"
-            mod = "fdb"
         if not chkMod(mod):
             return "Database Driver (%s) Missing" % txt
+        self.dbase = w
+        if self.dbase == "P":
+            self.df.topv[1][2] = ("efld",)
+            self.df.topv[1][3] = ("notblank",)
+            self.df.topv[1][5] = ("notblank",)
+            self.df.topv[1][6] = ("notblank",)
+            self.df.loadEntry(frt, pag, p+2, data="")
+        else:
+            self.df.topv[1][2] = ("notblank",)
+            self.df.topv[1][3] = ("efld",)
+            self.df.topv[1][5] = ("efld",)
+            self.df.topv[1][6] = ("efld",)
+            self.df.loadEntry(frt, pag, p+2, data=self.rcdic["dbdir"])
+            self.df.loadEntry(frt, pag, p+3, data="")
+
+    def doName(self, frt, pag, r, c, p, i, w):
+        if self.dbase == "P":
+            self.df.loadEntry(frt, pag, p+1, data="")
+            self.df.loadEntry(frt, pag, p+2, data="localhost")
+            return "sk1"
 
     def doDir(self, frt, pag, r, c, p, i, w):
         if not os.path.isdir(w):
@@ -8493,16 +8375,22 @@
                 os.makedirs(w)
             except:
                 return "Cannot Create %s Directory" % w
-
-    def doPrg(self, frt, pag, r, c, p, i, w):
-        if sys.platform == "win32":
-            found = False
-            for tst in ("py", "exe", "exe.manifest"):
-                nam = os.path.normpath(os.path.join(w, "ms0000.%s" % tst))
-                if os.path.isfile(nam):
-                    found = True
-            if not found:
-                return "Missing ms0000"
+        if self.dbase == "S" and pag == 1:
+            for x in range(1, 5):
+                self.df.loadEntry(frt, pag, p+x, data="")
+            return "nd"
+
+    def doVwr(self, frt, pag, r, c, p, i, w):
+        if not w and not FITZ:
+            return "pymupdf Not Installed"
+
+    def doAdmin(self, frt, pag, r, c, p, i, w):
+        if self.dbase == "P" and not w:
+            return "Invalid Administrator"
+
+    def doPwd(self, frt, pag, r, c, p, i, w):
+        if not w:
+            return "Invalid Password"
 
     def doConvrt(self, frt, pag, r, c, p, i, w):
         if w and not os.path.isfile(w):
@@ -8633,10 +8521,10 @@
             self.df.selPage(self.df.tags[self.df.pag][0])
 
     def doExit(self):
-        if self.df.pag == 0:
+        if self.df.pag in (0, 1):
             self.doQuit()
-        elif self.df.pag == 1:
-            pass
+        elif self.df.pag == 2 and self.dbskp:
+            self.df.focusField(self.df.frt, self.df.pag, self.df.col)
         else:
             self.df.selPage(self.df.tags[self.df.pag - 2][0])
 
@@ -8648,28 +8536,36 @@
             dbase = "S"
         self.df.loadEntry("T",1,0,dbase)
         self.df.loadEntry("T",1,1,self.rcdic["dbname"])
-        self.df.loadEntry("T",1,2,self.rcdic["dbhost"])
-        self.df.loadEntry("T",1,3,self.rcdic["dbdir"])
+        self.df.loadEntry("T",1,2,self.rcdic["dbdir"])
+        self.df.loadEntry("T",1,3,self.rcdic["dbhost"])
         self.df.loadEntry("T",1,4,self.rcdic["dbport"])
         self.df.loadEntry("T",1,5,self.rcdic["dbuser"])
         self.df.loadEntry("T",1,6,self.rcdic["dbpwd"])
+        if dbase == "P":
+            self.df.topv[1][2] = ("efld",)
+            self.df.topv[1][3] = ("notblank",)
+            self.df.topv[1][5] = ("notblank",)
+            self.df.topv[1][6] = ("notblank",)
+        else:
+            self.df.topv[1][2] = ("notblank",)
+            self.df.topv[1][3] = ("efld",)
+            self.df.topv[1][5] = ("efld",)
+            self.df.topv[1][6] = ("efld",)
         # General
-        self.df.loadEntry("T",2,0,self.rcdic["prgdir"])
-        self.df.loadEntry("T",2,1,self.rcdic["bupdir"])
-        self.df.loadEntry("T",2,2,self.rcdic["wrkdir"])
-        self.df.loadEntry("T",2,3,self.rcdic["upgdir"])
-        self.df.loadEntry("T",2,4,self.rcdic["vwr"])
-        self.df.loadEntry("T",2,5,self.rcdic["prn"])
-        self.df.loadEntry("T",2,6,self.rcdic["cnv"])
-        self.df.loadEntry("T",2,7,self.rcdic["exp"])
-        self.df.loadEntry("T",2,8,self.rcdic["geo"])
-        self.df.loadEntry("T",2,9,self.rcdic["plc"])
-        self.df.loadEntry("T",2,10,self.rcdic["img"].upper())
-        self.df.loadEntry("T",2,11,self.rcdic["cnf"].upper())
-        self.df.loadEntry("T",2,12,self.rcdic["acnf"].upper())
-        self.df.loadEntry("T",2,13,self.rcdic["ttip"].upper())
-        self.df.loadEntry("T",2,14,self.rcdic["errs"].upper())
-        self.df.loadEntry("T",2,15,self.rcdic["wrkf"].upper())
+        self.df.loadEntry("T",2,0,self.rcdic["bupdir"])
+        self.df.loadEntry("T",2,1,self.rcdic["wrkdir"])
+        self.df.loadEntry("T",2,2,self.rcdic["upgdir"])
+        self.df.loadEntry("T",2,3,self.rcdic["vwr"])
+        self.df.loadEntry("T",2,4,self.rcdic["prn"])
+        self.df.loadEntry("T",2,5,self.rcdic["exp"])
+        self.df.loadEntry("T",2,6,self.rcdic["geo"])
+        self.df.loadEntry("T",2,7,self.rcdic["plc"])
+        self.df.loadEntry("T",2,8,self.rcdic["img"].upper())
+        self.df.loadEntry("T",2,9,self.rcdic["cnf"].upper())
+        self.df.loadEntry("T",2,10,self.rcdic["acnf"].upper())
+        self.df.loadEntry("T",2,11,self.rcdic["ttip"].upper())
+        self.df.loadEntry("T",2,12,self.rcdic["errs"].upper())
+        self.df.loadEntry("T",2,13,self.rcdic["wrkf"].upper())
         # Font and Theme
         self.df.loadEntry("T",3,0,self.rcdic["mft"])
         self.df.loadEntry("T",3,1,self.rcdic["mfs"])
@@ -8724,12 +8620,11 @@
 
     def doWrite(self):
         rcf = os.path.dirname(self.rcfile)
-        dbd = self.df.t_work[1][0][3]
-        self.prgdir = self.df.t_work[2][0][0]
-        self.bupdir = self.df.t_work[2][0][1]
-        self.wrkdir = self.df.t_work[2][0][2]
-        self.upgdir = self.df.t_work[2][0][3]
-        for name in (rcf,dbd,self.prgdir,self.bupdir,self.wrkdir,self.upgdir):
+        dbd = self.df.t_work[1][0][2]
+        self.bupdir = self.df.t_work[2][0][0]
+        self.wrkdir = self.df.t_work[2][0][1]
+        self.upgdir = self.df.t_work[2][0][2]
+        for name in (rcf, dbd, self.bupdir, self.wrkdir, self.upgdir):
             name = self.checkCreateDir(name)
         cc = []
         if self.df.t_work[1][0][0] == "P":
@@ -8738,37 +8633,32 @@
             cc.append(["dbase", "SQLite"])
         cc.extend([
             ["dbname", self.df.t_work[1][0][1]],
-            ["dbhost", self.df.t_work[1][0][2]],
-            ["dbdir", os.path.normpath(self.df.t_work[1][0][3])],
+            ["dbdir", os.path.normpath(self.df.t_work[1][0][2])],
+            ["dbhost", self.df.t_work[1][0][3]],
             ["dbport", self.df.t_work[1][0][4]],
             ["dbuser", self.df.t_work[1][0][5]],
             ["dbpwd", self.df.t_work[1][0][6]],
-            ["prgdir", os.path.normpath(self.prgdir)],
             ["bupdir", os.path.normpath(self.bupdir)],
             ["wrkdir", os.path.normpath(self.wrkdir)],
             ["upgdir", os.path.normpath(self.upgdir)]])
+        if self.df.t_work[2][0][3]:
+            cc.append(["vwr", os.path.normpath(self.df.t_work[2][0][3])])
+        else:
+            cc.append(["vwr", ""])
         if self.df.t_work[2][0][4]:
-            cc.append(["vwr", os.path.normpath(self.df.t_work[2][0][4])])
-        else:
-            cc.append(["vwr", ""])
-        if self.df.t_work[2][0][5]:
-            cc.append(["prn", os.path.normpath(self.df.t_work[2][0][5])])
+            cc.append(["prn", os.path.normpath(self.df.t_work[2][0][4])])
         else:
             cc.append(["prn", ""])
-        if self.df.t_work[2][0][6]:
-            cc.append(["cnv", os.path.normpath(self.df.t_work[2][0][6])])
-        else:
-            cc.append(["cnv", ""])
         cc.extend([
-            ["exp", self.df.t_work[2][0][7]],
-            ["geo", self.df.t_work[2][0][8]],
-            ["plc", self.df.t_work[2][0][9]],
-            ["img", self.df.t_work[2][0][10]],
-            ["cnf", self.df.t_work[2][0][11]],
-            ["acnf", self.df.t_work[2][0][12]],
-            ["ttip", self.df.t_work[2][0][13]],
-            ["errs", self.df.t_work[2][0][14]],
-            ["wrkf", self.df.t_work[2][0][15]],
+            ["exp", self.df.t_work[2][0][5]],
+            ["geo", self.df.t_work[2][0][6]],
+            ["plc", self.df.t_work[2][0][7]],
+            ["img", self.df.t_work[2][0][8]],
+            ["cnf", self.df.t_work[2][0][9]],
+            ["acnf", self.df.t_work[2][0][10]],
+            ["ttip", self.df.t_work[2][0][11]],
+            ["errs", self.df.t_work[2][0][12]],
+            ["wrkf", self.df.t_work[2][0][13]],
             ["mft", self.df.t_work[3][0][0]],
             ["mfs", self.df.t_work[3][0][1]],
             ["dft", self.df.t_work[3][0][2]],
@@ -8793,9 +8683,7 @@
         f = open(self.rcfile, "w")
         for a, b in cc:
             f.write("['%s'] = '%s'\n" % (a, b))
-            if a == "prgdir":
-                self.prgdir = b
-            elif a == "bupdir":
+            if a == "bupdir":
                 self.bupdir = b
             elif a == "wrkdir":
                 self.wrkdir = b
@@ -8805,8 +8693,6 @@
                 self.vwr = b
             elif a == "prn":
                 self.prn = b
-            elif a == "cnv":
-                self.exp = b
             elif a == "exp":
                 self.exp = b
             else:
@@ -8879,36 +8765,39 @@
             defaults[nam] = args[nam]
         for nam in defaults:
             setattr(self, nam, defaults[nam])
-        if self.system.lower() == "drs":
-            idx = 3
-        else:
-            idx = 2
-        self.atyp, self.aref, self.agedt, self.amt, self.dis = self.agekey[idx:]
+        self.cancel = False
         if self.agetyp == "C":
-            self.data = None
+            return
+        self.cono = self.agekey[0]
+        if self.system.lower() == "drs":
+            self.achn = self.agekey[1]
+            self.acno = self.agekey[2]
+            idx = 3
         else:
-            self.doGetData()
-        self.cancel = False
-        if not self.data:
-            self.doAgeCurrent()
-        elif self.agetyp == "O":
+            self.acno = self.agekey[1]
+            idx = 2
+        flds = ("atyp", "aref", "aged", "aamt", "adis")
+        for x in range(idx, len(self.agekey)):
+            setattr(self, flds[x - idx], self.agekey[x])
+        self.doGetData()
+        if self.data and self.agetyp == "O":
             self.doAgeOldest()
-        else:
+        elif self.data:
             self.doAgeTrans()
 
     def doGetData(self):
-        if self.system.lower() == "drs":
+        if self.system.lower() == "crs":
+            col = ["crt_trdt", "crt_ref1", "crt_type", "crt_tramt"]
+            whr = [("crt_cono", "=", self.cono), ("crt_acno", "=",
+                self.acno)]
+        elif self.system.lower() == "drs":
             col = ["drt_trdt", "drt_ref1", "drt_type", "drt_tramt"]
-            whr = [("drt_cono", "=", self.agekey[0]), ("drt_chain", "=",
-                self.agekey[1]), ("drt_acno", "=", self.agekey[2])]
-        elif self.system.lower() == "crs":
-            col = ["crt_trdt", "crt_ref1", "crt_type", "crt_tramt"]
-            whr = [("crt_cono", "=", self.agekey[0]), ("crt_acno", "=",
-                self.agekey[1])]
+            whr = [("drt_cono", "=", self.cono), ("drt_chain", "=",
+                self.achn), ("drt_acno", "=", self.acno)]
         else:
             col = ["mlt_trdt", "mlt_refno", "mlt_type", "mlt_tramt"]
-            whr = [("mlt_cono", "=", self.agekey[0]), ("mlt_memno", "=",
-                self.agekey[1])]
+            whr = [("mlt_cono", "=", self.cono), ("mlt_memno", "=",
+                self.acno)]
         get, recs = getTrn(self.mf.dbm, self.system.lower(), whr=whr)
         self.data = []
         for rec in recs:
@@ -8922,11 +8811,8 @@
             dat.append(bal)
             self.data.append(dat)
 
-    def doAgeCurrent(self):
-        return
-
     def doAgeOldest(self):
-        unal = float(ASD(self.amt) + ASD(self.dis))
+        unal = float(ASD(self.aamt) + ASD(self.adis))
         for dat in self.data:
             trbal = float(ASD(dat[5]) + ASD(unal))
             if trbal < 0:
@@ -8939,56 +8825,56 @@
                 trbal = 0
             alloc = float(ASD(dat[5]) - ASD(trbal))
             if alloc:
-                self.doAllocate(dat[2], dat[1], alloc)
-        alloc = float(ASD(self.amt) + ASD(self.dis) - ASD(unal))
+                self.doAlloc(dat[2], dat[1], alloc)
+        alloc = float(ASD(self.aamt) + ASD(self.adis) - ASD(unal))
         if alloc:
-            self.doAllocated(alloc)
+            self.doAllocAge(alloc)
 
     def doAgeTrans(self):
-        unal = float(ASD(self.amt) + ASD(self.dis))
+        unal = float(ASD(self.aamt) + ASD(self.adis))
         self.ageT = AgeTrans(self.mf, self.system.lower(), self.data, unal)
         self.cancel = self.ageT.ccl
         if self.cancel:
             return
         for tr in self.ageT.data:
             if tr[6]:
-                self.doAllocate(tr[2], tr[1], tr[6])
-        totl = float(ASD(self.amt) + ASD(self.dis))
+                self.doAlloc(tr[2], tr[1], tr[6])
+        totl = float(ASD(self.aamt) + ASD(self.adis))
         alloc = float(ASD(totl) + ASD(self.ageT.total.work))
         if alloc:
-            self.doAllocated(alloc)
+            self.doAllocAge(alloc)
 
-    def doAllocate(self, typ, ref, amt):
+    def doAlloc(self, typ, ref, amt):
         if self.system.lower() == "drs":
-            data = self.agekey[:3] + [typ, ref, self.agedt, self.atyp,
+            data = self.agekey[:3] + [typ, ref, self.aged, self.atyp,
                 self.aref, amt, 0]
             sql = Sql(self.mf.dbm, "drsage", prog=__name__)
             sql.insRec("drsage", data=data)
         elif self.system.lower() == "crs":
-            data = self.agekey[:2] + [typ, ref, self.agedt, self.atyp,
+            data = self.agekey[:2] + [typ, ref, self.aged, self.atyp,
                 self.aref, amt, 0]
             sql = Sql(self.mf.dbm, "crsage", prog=__name__)
             sql.insRec("crsage", data=data)
         else:
-            data = self.agekey[:2] + [typ, ref, self.agedt, self.atyp,
+            data = self.agekey[:2] + [typ, ref, self.aged, self.atyp,
                 self.aref, amt, 0]
             sql = Sql(self.mf.dbm, "memage", prog=__name__)
             sql.insRec("memage", data=data)
 
-    def doAllocated(self, alloc):
-        if not self.dis:
+    def doAllocAge(self, alloc):
+        if not self.adis:
             da = 0.00
             aa = alloc
-        elif self.dis and self.dis < alloc:
-            da = float(ASD(self.dis) - ASD(alloc))
+        elif self.adis and self.adis < alloc:
+            da = float(ASD(self.adis) - ASD(alloc))
             aa = 0.00
         else:
-            da = self.dis
-            aa = float(ASD(alloc) - ASD(self.dis))
+            da = self.adis
+            aa = float(ASD(alloc) - ASD(self.adis))
         if da:
-            self.doAllocate(6, self.aref, da)
+            self.doAlloc(6, self.aref, da)
         if aa:
-            self.doAllocate(self.atyp, self.aref, aa)
+            self.doAlloc(self.atyp, self.aref, aa)
 
 class AgeTrans(object):
     """
@@ -9129,10 +9015,17 @@
     doAllBals       - Returns Total, Current, 30, 60, 90 and 120+ Balances with
                         or without transactions
     doCrsDrsHist    - Returns the Last 12 Months Sale and Payment Balances
-    doStrBals       - Returns Opening Balance Qty and Cost, Movements and
-                      Closing Balance Qty and Cost for the Current Month and
-                      for the Year to Date, Average and Last Cost & Selling
-                      prices.  If trans=True the transactions are returned.
+    doStrBals       - Returns
+                        Current Month
+                            [O/Bal Qty and Cost]
+                            [Movements]
+                            [C/Bal Qty and Cost]
+                        Year to Date
+                            [O/Bal Qty and Cost]
+                            [Movements]
+                            [C/Bal Qty and Cost]
+                        Average Cost, Last Cost & Selling Price
+                        If trans=True the transactions are also returned.
     doStrOrds       - Returns the Qty on Hand, Qty on Order and Qty Back Order
     doStrHist       - Returns the Last 12 Months Receipt and Issue Qty and Value
     doAssBals       - Returns the Opening Book Values for a Financial Period
@@ -9195,11 +9088,11 @@
                     else:
                         self.start = period[1]
                 else:
-                    self.start = curdt
+                    self.start = self.curdt
             elif self.system == "ASS" and len(keys) == 2:
                 self.sql = Sql(self.mf.dbm, "asstrn", prog=__name__)
                 self.group, self.code = keys
-                self.start = curdt
+                self.start = self.curdt
             else:
                 showError(self.mf.window, "Parameter Error",
                     "Invalid Parameters %s %s" % (self.system, str(keys)))
@@ -9341,9 +9234,8 @@
         # Current Period
         whr = copyList(where)
         whr.append(("stt_curdt", "<", self.curdt))
-        obal = self.sql.getRec("strtrn",
-            cols=["round(sum(stt_qty), 2)", "round(sum(stt_cost), 2)"],
-            where=whr, limit=1)
+        obal = self.sql.getRec("strtrn", cols=["round(sum(stt_qty), 2)",
+            "round(sum(stt_cost), 2)"], where=whr, limit=1)
         if not obal:
             obal = [0, 0]
         if not obal[0]:
@@ -9358,9 +9250,8 @@
             "round(sum(stt_sell), 2)"], where=whr, group=grp, order=grp)
         whr = copyList(where)
         whr.append(("stt_curdt", "<=", self.curdt))
-        cbal = self.sql.getRec("strtrn", cols=[
-            "round(sum(stt_qty), 2)", "round(sum(stt_cost), 2)"],
-            where=whr, limit=1)
+        cbal = self.sql.getRec("strtrn", cols=["round(sum(stt_qty), 2)",
+            "round(sum(stt_cost), 2)"], where=whr, limit=1)
         if not cbal:
             cbal = [0, 0]
         if not cbal[0]:
@@ -9371,9 +9262,8 @@
         # Year to Date
         whr = copyList(where)
         whr.append(("stt_curdt", "<", start))
-        obal = self.sql.getRec("strtrn",
-            cols=["round(sum(stt_qty), 2)", "round(sum(stt_cost), 2)"],
-            where=whr, limit=1)
+        obal = self.sql.getRec("strtrn", cols=["round(sum(stt_qty), 2)",
+            "round(sum(stt_cost), 2)"], where=whr, limit=1)
         if not obal:
             obal = [0, 0]
         if not obal[0]:
@@ -9389,7 +9279,7 @@
             move = []
         whr = copyList(where)
         whr.append(("stt_curdt", "<=", self.curdt))
-        cbal = self.sql.getRec("strtrn", cols=["round(sum(stt_qty), 2)",
+        cbal = self.sql.getRec(tables="strtrn", cols=["round(sum(stt_qty), 2)",
             "round(sum(stt_cost), 2)"], where=whr, limit=1)
         if not cbal:
             cbal = [0, 0]
@@ -9398,42 +9288,15 @@
         if not cbal[1]:
             cbal[1] = 0
         data.extend([obal, move, cbal])
-        # Last and Average cost prices
-        whr = copyList(where)
-        whr.append(("stt_type", "in", (1, 3)))
-        lcst = self.sql.getRec("strtrn", cols=["stt_qty", "stt_cost",
-            "stt_sell"], where=whr, order="stt_trdt desc, stt_seq desc",
-            limit=1)
-        if not lcst:
-            lcst = 0
-            lsel = 0
-        else:
-            qty = CCD(lcst[0], "SD", 11.2)
-            cst = CCD(lcst[1], "SD", 11.2)
-            sel = CCD(lcst[2], "SD", 11.2)
-            if qty.work == 0:
-                lcst = 0
-                lsel = 0
-            else:
-                lcst = round((cst.work / qty.work), 2)
-                lsel = round((sel.work / qty.work), 2)
-        whr = copyList(where)
-        whr.append(("stt_type", "in", (1, 3, 5)))
-        acst = self.sql.getRec("strtrn", cols=["round(sum(stt_qty), 2)",
-            "round(sum(stt_cost), 2)"], where=where, limit=1)
-        if not acst[0]:
-            acst[0] = 0
-        if not acst[1]:
-            acst[1] = 0
-        qty = CCD(acst[0], "SD", 11.2)
-        cst = CCD(acst[1], "SD", 11.2)
-        if qty.work <= 0:
-            acst = lcst
-        else:
-            acst = round((cst.work / qty.work), 2)
-        data.extend([acst, lcst, lsel])
-        # Transactions
+        # Average and Last Cost Prices
+        cost = getCost(self.sql, self.conum, self.group, self.code,
+            loc=self.loc, ind="AL")
+        data.extend(cost)
+        # Last selling price
+        data.append(getSell(self.sql, self.conum, self.group, self.code,
+            self.loc, ind="L"))
         if trans == "Y":
+            # Transactions
             whr = copyList(where)
             whr.append(("stt_curdt", "between", start, self.curdt))
             odr = "stt_trdt, stt_type, stt_ref1"
@@ -10160,10 +10023,6 @@
             self.pb.closeProgress()
 
     def setVariables(self):
-        self.sql = Sql(self.mf.dbm, ["ctlmst", "ctldep", "genbal", "genbud",
-            "gendtm", "gendtt", "genmst", "genrpt", "gentrn"], prog=__name__)
-        if self.sql.error:
-            return
         """
         self.pers: Dictionary of current period and 3 previous periods:
 
@@ -10173,6 +10032,10 @@
         d_per = Number of months over 12
         s_per = Starting period in 12 month period
         """
+        self.sql = Sql(self.mf.dbm, ["ctlmst", "ctldep", "genbal", "genbud",
+            "gendtm", "gendtt", "genmst", "genrpt", "gentrn"], prog=__name__)
+        if self.sql.error:
+            return
         self.pers = {0: {}, 1: {}, 2: {}, 3: {}}
         # Current Period
         self.pers[0]["o_dte"] = self.period[1][0]
@@ -10348,12 +10211,10 @@
             if self.s_print == "+" and amt < 0:
                 self.clearData()
                 continue
-            elif self.s_print == "-" and amt >= 0:
+            if self.s_print == "-" and amt >= 0:
                 self.clearData()
                 continue
-            elif self.s_print == "N":
-                pass
-            else:
+            if self.s_print == "Y":
                 self.printLine()
             self.accumTotals(self.s_acbal)
             if self.s_store == "Y":
@@ -10983,14 +10844,13 @@
                 mth_d[13] = float(ASD(mth_d[13]) + ASD(cyr))
             if curdt == self.curdt:
                 break
-            else:
-                y = int(curdt / 100)
-                m = curdt % 100
-                m += 1
-                if m > 12:
-                    y += 1
-                    m = m - 12
-                curdt = (y * 100) + m
+            y = int(curdt / 100)
+            m = curdt % 100
+            m += 1
+            if m > 12:
+                y += 1
+                m = m - 12
+            curdt = (y * 100) + m
         if val_d[2] == 0:
             val_p[1] = 0
         else:
@@ -11248,8 +11108,8 @@
                         showError(self.mf.body, "Control Record Error",
                             self.errs[table] % conum)
                 return None
-            for x in xrange(0, len(col)):
-                dics["%s" % col[x].lower()] = recs[0][x]
+            for x, c in enumerate(col):
+                dics["%s" % c.lower()] = recs[0][x]
             return dics
 
     def chkRec(self, conum, ctlctl, ctls):
@@ -12021,8 +11881,7 @@
                 if mrgcod == "deliver_to":
                     if not self.deliver:
                         continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.deliver
+                    nl[tdc.index("tpd_text")] = self.deliver
                 else:
                     nl[tdc.index("tpd_text")] = self.doGetData(mrgcod)
             if key == "document_type_C00":
@@ -12402,8 +12261,7 @@
                 if mrgcod == "deliver_to":
                     if not self.deliver:
                         continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.deliver
+                    nl[tdc.index("tpd_text")] = self.deliver
                 else:
                     nl[tdc.index("tpd_text")] = self.doGetData(mrgcod)
             if key == "document_type_C00":
@@ -12579,7 +12437,14 @@
                 count = self.doHeader(page, tdc)
             ldic = {}
             for cod in self.form.body:
-                if cod != "line_value":
+                if cod == "line_unit":
+                    desc = item[ttc.index("brt_udesc")].strip()
+                    room = int(item[ttc.index("brt_uroom")])
+                    if room:
+                        desc = "%s - Room %s" % (desc, room)
+                    ldic[cod] = CCD(desc, self.form.tptp[cod][0][1],
+                        self.form.tptp[cod][0][2])
+                elif cod != "line_value":
                     ldic[cod] = CCD(item[ttc.index(cod)],
                         self.form.tptp[cod][0][1],
                         self.form.tptp[cod][0][2])
@@ -12746,8 +12611,7 @@
                 if mrgcod == "deliver_to":
                     if not self.deliver:
                         continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.deliver
+                    nl[tdc.index("tpd_text")] = self.deliver
                 else:
                     nl[tdc.index("tpd_text")] = self.doGetData(mrgcod)
             if key == "document_type_C00":
@@ -13108,12 +12972,8 @@
                 dat = "Total"
             else:
                 y4 = y3 + mm
-                end = x + 1
-                if (self.skins == "Y" and not end % self.sends):
-                    fill = True
-                else:
-                    fill = False
-                dat = end
+                dat = end = x + 1
+                fill = bool(self.skins == "Y" and not end % self.sends)
             for nam in self.form.body:
                 fld = "%s_C%02i" % (nam, x)
                 if fld in self.form.newdic:
@@ -13162,11 +13022,11 @@
             return "* Bye *"
 
 class PrintDraw(object):
-    def __init__(self, mf, conum, date, time, **args):
+    def __init__(self, mf, conum, date, dtim, **args):
         self.mf = mf
         self.conum = conum
         self.date = date
-        self.time = time
+        self.time = dtim
         defaults = {
             "takings": "y",
             "listing": "n",
@@ -13447,329 +13307,6 @@
             self.fpdf.drawText(w=w,h=5,txt=txt,border="TBLR",fill=1)
             self.fpdf.setFont(style="", size=14)
 
-class PrintTransfer(object):
-    def __init__(self, mf, conum, conam, dtyp="I", docs=None, **args):
-        self.mf = mf
-        self.conum = conum
-        self.conam = conam
-        self.dtyp = dtyp
-        if docs is None:
-            self.docs = []
-        elif type(docs) in (int, str):
-            self.docs = [[docs]]
-        else:
-            self.docs = docs
-        defaults = {
-            "crcoy": conum,
-            "tname": "branch_transfer",
-            "repprt": ["N", "V", "view"],
-            "repeml": ["N", "N", "", "", "Y"],
-            "copy": "n",
-            "splash": True}
-        for nam in args:
-            if nam in ("repprt", "repeml"):
-                defaults[nam] = copyList(args[nam])
-            else:
-                defaults[nam] = args[nam]
-        for nam in defaults:
-            setattr(self, nam, defaults[nam])
-        if self.setVariables():
-            self.doProcess()
-
-    def setVariables(self):
-        self.sql = Sql(self.mf.dbm, ["ctlmst", "ibtmst", "ibttrn"],
-            prog=__name__)
-        if self.sql.error:
-            return False
-        gc = GetCtl(self.mf)
-        ibtctl = gc.getCtl("ibtctl", self.conum)
-        if not ibtctl:
-            return
-        self.fromad = ibtctl["cbt_emadd"]
-        if self.repeml:
-            self.emadd = self.repeml[2]
-        else:
-            self.emadd = ""
-        return True
-
-    def doProcess(self):
-        imc = self.sql.ibtmst_col
-        itc = self.sql.ibttrn_col
-        cmc = self.sql.ctlmst_col
-        self.form = DrawForm(self.mf.dbm, self.tname)
-        txt = self.form.sql.tpldet_col.index("tpd_text")
-        tdc = self.form.sql.tpldet_col
-        self.doLoadStatic()
-        self.form.doNewDetail()
-        for doc in self.docs:
-            self.docno = CCD(doc[0], "UI", 9.0)
-            ibm = self.sql.getRec(tables="ibtmst", where=[("ibm_cono", "=",
-                self.conum), ("ibm_docno", "=", self.docno.work)], limit=1)
-            if self.dtyp == "I":
-                mtyp = 1
-            else:
-                mtyp = 2
-            ibt = self.sql.getRec(tables="ibttrn", where=[("ibt_cono",
-                "=", self.conum), ("ibt_docno", "=", self.docno.work),
-                ("ibt_type", "=", mtyp)], order="ibt_seq")
-            if not ibm or not ibt:
-                continue
-            if self.splash:
-                sp = SplashScreen(self.mf.body,
-                    "Generating Forms\n\n   Please Wait...")
-            for fld in imc:
-                if fld in self.form.tptp:
-                    self.form.tptp[fld][1] = ibm[imc.index(fld)]
-            ctm = self.sql.getRec("ctlmst", where=[("ctm_cono", "=",
-                ibm[imc.index("ibm_branch")])], limit=1)
-            eml = ctm[cmc.index("ctm_email")]
-            for fld in cmc:
-                if fld in self.form.tptp:
-                    d = "%s_C00" % fld
-                    self.form.newdic[d][txt] = ctm[cmc.index(fld)]
-            self.form.account_details("ctm", cmc, ctm, 0)
-            if "deliver_to" in self.form.tptp:
-                if ctm[cmc.index("ctm_sadd1")]:
-                    dat = ctm[cmc.index("ctm_sadd1")]
-                    if ctm[cmc.index("ctm_sadd2")]:
-                        dat = "%s\n%s" % (dat, ctm[cmc.index("ctm_sadd2")])
-                    if ctm[cmc.index("ctm_sadd3")]:
-                        dat = "%s\n%s" % (dat, ctm[cmc.index("ctm_sadd3")])
-                    if ctm[cmc.index("ctm_spcode")]:
-                        dat = "%s\n%s\n " % (dat, ctm[cmc.index("ctm_spcode")])
-                    else:
-                        dat = "%s\n " % dat
-                    self.deliver = dat
-                else:
-                    self.deliver = False
-            if "supplier" in self.form.tptp:
-                acc = self.sql.getRec("crsmst", cols=["crm_name"],
-                    where=[("crm_cono", "=", self.crcoy), ("crm_acno",
-                    "=", ibm[imc.index("ibm_supp")])], limit=1)
-                if acc:
-                    self.supplier = acc[0]
-                else:
-                    self.supplier = False
-            if "transporter" in self.form.tptp:
-                acc = self.sql.getRec("crsmst", cols=["crm_name"],
-                    where=[("crm_cono", "=", self.crcoy), ("crm_acno",
-                    "=", ibm[imc.index("ibm_tran")])], limit=1)
-                if acc:
-                    self.transporter = acc[0]
-                else:
-                    self.transporter = False
-            if self.dtyp == "I":
-                self.form.document_date(ibm[imc.index("ibm_date")])
-            else:
-                self.form.document_date(ibm[imc.index("ibm_cdte")])
-            self.doBody(itc, ibt, tdc)
-            self.doTotal(tdc)
-            self.doTail(tdc)
-            if self.splash:
-                sp.closeSplash()
-            if self.repeml[1] == "Y" and not self.emadd:
-                self.repeml[2] = eml
-                self.doPrint()
-        if self.repeml[1] == "N" or self.emadd:
-            self.repeml[2] = self.emadd
-            self.doPrint()
-
-    def doBody(self, itc, ibt, tdc):
-        page = 0
-        count = 0
-        self.total_taxable = 0
-        self.total_nontaxable = 0
-        self.total_tax = 0
-        self.total_value = 0
-        for item in ibt:
-            if not count:
-                page += 1
-                count = self.doHeader(str(page), tdc)
-            if count == self.form.maxlines:
-                page = self.doCfwd(page)
-                count = self.doHeader(page, tdc)
-            ldic = {}
-            for cod in self.form.body:
-                if cod == "line_value":
-                    continue
-                if cod == "ibt_desc":
-                    des = self.form.doSplitText("ibt_desc_C00",
-                        item[itc.index(cod)])
-                    if not des[-1]:
-                        del des[-1]
-                else:
-                    ldic[cod] = CCD(item[itc.index(cod)],
-                        self.form.tptp[cod][0][1],
-                        self.form.tptp[cod][0][2])
-            value = ldic["ibt_value"].work
-            self.total_value = float(ASD(self.total_value) + ASD(value))
-            for n, l in enumerate(des):
-                if count == self.form.maxlines:
-                    page = self.doCfwd(page)
-                    count = self.doHeader(page, tdc)
-                if n == 0 and len(des) == 1:
-                    incl = copyList(self.form.body)
-                elif n == 0:
-                    incl = ["ibt_code"]
-                elif n + 1 == len(des):
-                    incl = copyList(self.form.body)
-                    incl.remove("ibt_code")
-                else:
-                    incl = []
-                for code in self.form.body:
-                    seq = "%s_C%02i" % (code, count)
-                    if code == "ibt_desc":
-                        data = l
-                    elif code in incl:
-                        data = ldic[code].work
-                    else:
-                        data = "BLANK"
-                    self.form.newdic[seq][tdc.index("tpd_text")] = data
-                    self.form.doDrawDetail(self.form.newdic[seq])
-                count += 1
-        for x in xrange(count, self.form.maxlines):
-            for cod in self.form.body:
-                seq = "%s_C%02i" % (cod, x)
-                self.form.newdic[seq][tdc.index("tpd_text")] = "BLANK"
-                self.form.doDrawDetail(self.form.newdic[seq])
-
-    def doTotal(self, tdc):
-        for c in self.form.total:
-            line = None
-            if c in self.form.newdic:
-                line = self.form.newdic[c]
-            else:
-                t = "%s_T00" % c
-                if t in self.form.newdic:
-                    line = self.form.newdic[t]
-            if line:
-                self.form.doDrawDetail(line)
-            d = "%s_C00" % c
-            if d in self.form.newkey:
-                line = self.form.newdic[d]
-                mrgcod = line[tdc.index("tpd_mrgcod")]
-                line[tdc.index("tpd_text")] = getattr(self, "%s" % mrgcod)
-                self.form.doDrawDetail(line)
-
-    def doTail(self, tdc):
-        for c in self.form.tail:
-            line = None
-            if c in self.form.newdic:
-                line = self.form.newdic[c]
-            else:
-                t = "%s_T00" % c
-                if t in self.form.newdic:
-                    line = self.form.newdic[t]
-            if line:
-                self.form.doDrawDetail(line)
-            d = "%s_C00" % c
-            if d in self.form.newdic:
-                line = self.form.newdic[d]
-                mrgcod = line[tdc.index("tpd_mrgcod")]
-                line[tdc.index("tpd_text")] = self.doGetData(mrgcod)
-                self.form.doDrawDetail(line, fmat=False)
-
-    def doPrint(self):
-        if self.repeml[1] == "Y" and not self.emadd:
-            head = "Invoice %s" % self.docno.work
-            pdfnam = getModName(self.mf.rcdic["wrkdir"], "Invoice",
-                "%s_%s" % (self.conum, self.docno.work), ext="pdf")
-        else:
-            if len(self.docs) == 1:
-                head = "Invoice %s" % self.docno.work
-            else:
-                head = ""
-                for doc in self.docs:
-                    if not head:
-                        head = "Invoices %s" % doc[0]
-                    else:
-                        head += ", %s" % doc[0]
-            pdfnam = getModName(self.mf.rcdic["wrkdir"], "Invoice",
-                "%s_all" % self.conum, ext="pdf")
-        if self.form.page:
-            self.form.output(pdfnam, "F")
-            doPrinter(mf=self.mf, conum=self.conum, pdfnam=pdfnam,
-                fromad=self.fromad, header=head, repprt=self.repprt,
-                repeml=self.repeml)
-        if self.repeml[1] == "Y" and not self.emadd:
-            self.form = DrawForm(self.mf.dbm, self.tname)
-            self.doLoadStatic()
-            self.form.doNewDetail()
-
-    def doLoadStatic(self):
-        cmc = self.sql.ctlmst_col
-        ctm = self.sql.getRec("ctlmst", where=[("ctm_cono", "=",
-            self.conum)], limit=1)
-        for fld in cmc:
-            dat = ctm[cmc.index(fld)]
-            if fld in self.form.tptp:
-                if fld == "ctm_logo":
-                    self.form.letterhead(cmc, ctm, fld, dat)
-                    continue
-                self.form.tptp[fld][1] = dat
-        if "letterhead" in self.form.tptp:
-            self.form.letterhead(cmc, ctm, "letterhead", None)
-        if "document_type" in self.form.tptp:
-            if self.dtyp == "C":
-                self.form.tptp["document_type"][1] = "CREDIT NOTE"
-            elif self.dtyp == "E":
-                self.form.tptp["document_type"][1] = "AMENDED INVOICE"
-            else:
-                self.form.tptp["document_type"][1] = "INVOICE"
-
-    def doHeader(self, page, tdc):
-        self.form.add_page()
-        for key in self.form.newkey:
-            line = self.form.newdic[key]
-            if line[tdc.index("tpd_place")] != "A":
-                continue
-            nl = copyList(line)
-            if nl[tdc.index("tpd_detseq")] == "page_number_C00":
-                nl[tdc.index("tpd_text")] = str(page)
-            elif nl[tdc.index("tpd_type")] == "T" and \
-                        nl[tdc.index("tpd_ttyp")] == "H":
-                mrgcod = nl[tdc.index("tpd_mrgcod")]
-                if mrgcod and mrgcod == "deliver_to" and not self.deliver:
-                    continue
-                if mrgcod and self.form.tptp[mrgcod][0][1][0] == "S":
-                    txt = nl[tdc.index("tpd_text")]
-                    nl[tdc.index("tpd_text")] = "%s " % txt
-            elif nl[tdc.index("tpd_type")] == "C":
-                mrgcod = nl[tdc.index("tpd_mrgcod")]
-                if mrgcod == "deliver_to":
-                    if not self.deliver:
-                        continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.deliver
-                elif mrgcod == "supplier":
-                    if not self.supplier:
-                        continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.supplier
-                elif mrgcod == "transporter":
-                    if not self.transporter:
-                        continue
-                    else:
-                        nl[tdc.index("tpd_text")] = self.transporter
-                else:
-                    nl[tdc.index("tpd_text")] = self.doGetData(mrgcod)
-            if key == "document_type_C00":
-                self.form.doDrawDetail(nl, fmat=False)
-            else:
-                self.form.doDrawDetail(nl)
-        return 0
-
-    def doCfwd(self, page):
-        line = copyList(self.form.cfwd)
-        line[5] = "Continued on Page %i" % (page + 1)
-        self.form.doDrawDetail(line)
-        return page + 1
-
-    def doGetData(self, mrgcod):
-        if mrgcod and mrgcod in self.form.tptp and self.form.tptp[mrgcod][1]:
-            return self.form.tptp[mrgcod][1]
-        return ""
-
 class PwdConfirm(object):
     """
     mf          The mainframe class
@@ -14034,8 +13571,7 @@
                     showError(self.mf.body, "File Error %s" % fname,
                         "The File Must Contain the Bank Account Number.")
                     return
-                else:
-                    continue
+                continue
             if line.count("<BANKTRANLIST>"):
                 # Beginning of Transactions
                 start = True
@@ -14050,7 +13586,7 @@
                 if self.getDate(self.removeTag("DTEFF", line)):
                     return
                 continue
-            elif line.count("<DTPOSTED>"):
+            if line.count("<DTPOSTED>"):
                 # Version 200 Date
                 if self.date.work:
                     self.addTrans()
@@ -14058,7 +13594,7 @@
                 if self.getDate(self.removeTag("DTPOSTED", line)):
                     return
                 continue
-            elif line.count("<FITID>"):
+            if line.count("<FITID>"):
                 # Version 200 Reference
                 ref = self.removeTag("FITID", line)
                 if len(ref) > 9:
@@ -14197,9 +13733,8 @@
             if dat[2] in ("ACC-NO", "ACC NO"):
                 if int(self.bankac) == int(dat[1]):
                     continue
-                else:
-                    err = "Invalid Bank Account Number"
-                    break
+                err = "Invalid Bank Account Number"
+                break
             date = CCD(int(dat[1]), "D1", 10)
             err = date.err
             if err:
@@ -14367,25 +13902,25 @@
         self.align = []
         if self.heads:
             heads = []
-            for h in self.heads:
-                if type(h) in (tuple, list):
+            for hdr in self.heads:
+                if type(hdr) in (tuple, list):
                     font = False
                     align = False
-                    for i in xrange(0, len(h)):
+                    for i, h in enumerate(hdr):
                         if not i:
-                            heads.append(h[i])
-                        elif type(h[i]) == int:
-                            self.fonts.append(h[i])
+                            heads.append(h)
+                        elif type(h) == int:
+                            self.fonts.append(h)
                             font = True
                         else:
-                            self.align.append(h[i])
+                            self.align.append(h)
                             align = True
                     if not font:
                         self.fonts.append(None)
                     if not align:
                         self.align.append("L")
                 else:
-                    heads.append(h)
+                    heads.append(hdr)
                     self.fonts.append(None)
                     self.align.append("L")
             self.heads = heads
@@ -14532,8 +14067,7 @@
         self.dend = False
         self.expforms = []
         self.expcolsh = [[]]
-        for x in xrange(0, len(fn)):
-            nam = fn[x]
+        for x, nam in enumerate(fn):
             if self.trtp and nam == self.trtp[0]:
                 fsiz = 3
                 d = "Typ"
@@ -14557,7 +14091,7 @@
                     cf = cf + "\n"
                 d = str(self.fd[nam][2])
                 if not d:
-                    n = fn[x].split("_", 1)
+                    n = nam.split("_", 1)
                     d = n[len(n)-1]
                 d = d[:fsiz]
                 if self.fd[nam][0] == "UI" or self.fd[nam][0] == "UD":
@@ -14719,14 +14253,14 @@
                     lpp = lpp + self.margin
                 if lpp <= self.fpdf.lpp:
                     self.fpdf.lpp = lpp
-        for x in xrange(0, len(recs)):
+        for x, rec in enumerate(recs):
             if self.pbar:
                 pb.displayProgress(x)
                 if pb.quit:
                     break
-            if self.ttype == "D" and recs[x] == ["BLANK"]:
+            if self.ttype == "D" and rec == ["BLANK"]:
                 if self.repprt[2] == "export":
-                    self.expdatas.append(recs[x])
+                    self.expdatas.append(rec)
                 else:
                     self.fpdf.drawText()
                     self.pglin += 1
@@ -14741,12 +14275,12 @@
                 if t == "TX" and self.repprt[2] != "export":
                     t = "NA"
                 s = self.fd[nam][1]
-                if not recs[x][num]:
+                if not rec[num]:
                     d = ""
                 else:
-                    d = recs[x][num]
+                    d = rec[num]
                 if t == "HA":
-                    d = b64Convert("decode", recs[x][num])
+                    d = b64Convert("decode", rec[num])
                 if self.refmt:
                     if self.trtp and nam == self.trtp[0]:
                         d = self.trtp[1][int(d) - 1][0]
@@ -14811,12 +14345,9 @@
         self.grandTotal()
         try:
             if self.repprt[2] == "export":
-                err = doWriteExport(rcdic=self.mf.rcdic,
-                    xtype=self.repprt[1], name=self.expnam,
-                    heads=self.expheads, colsh=self.expcolsh,
+                doWriteExport(rcdic=self.mf.rcdic, xtype=self.repprt[1],
+                    name=self.expnam, heads=self.expheads, colsh=self.expcolsh,
                     forms=self.expforms, datas=self.expdatas)
-                if err:
-                    showError(self.mf.body, "Export Error", err)
             else:
                 if self.tails:
                     self.fpdf.setFont(style="B")
@@ -15147,9 +14678,10 @@
     """
     This class is used to add, delete and amend Tartan users
     """
-    def __init__(self, mf, sys, mod):
+    def __init__(self, mf, usr, sys, mod):
         self.mf = mf
-        self.systems = sys
+        self.user = usr
+        self.syss = sys
         self.mod = mod
         if self.setVariables():
             self.doUser()
@@ -15198,7 +14730,7 @@
             "stype": "C",
             "titl": "Available Systems",
             "head": ("System", "Cd"),
-            "data": self.systems,
+            "data": self.syss,
             "index": 1}
         sprg = {
             "stype": "C",
@@ -15261,8 +14793,7 @@
 
     def doUserName(self, frt, pag, r, c, p, i, w):
         self.unam = w
-        usr = self.sql.getRec("ctlpwu", where=[("usr_name", "=", w)],
-            limit=1)
+        usr = self.sql.getRec("ctlpwu", where=[("usr_name", "=", w)], limit=1)
         if not usr:
             self.new_usr = "y"
             if self.unam == "admin":
@@ -15291,6 +14822,12 @@
         if self.unam == "admin":
             return "sk1"
 
+    def doDelUser(self):
+        if self.unam == "admin" or self.unam == self.user:
+            return "Not Allowed to Delete yourself"
+        self.sql.delRec("ctlpwu", where=[("usr_name", "=", self.unam)])
+        self.sql.delRec("ctlpwm", where=[("mpw_usr", "=", self.unam)])
+
     def doFullName(self, frt, pag, r, c, p, i, w):
         self.fnam = w
 
@@ -15338,18 +14875,18 @@
     def doValCoy(self, frt, pag, r, c, p, i, w):
         self.acoy = ""
         if w and w != "All":
-            for c in w.replace(" ", "").split(","):
+            for ck in w.replace(" ", "").split(","):
                 try:
                     chk = self.sql.getRec("ctlmst", where=[("ctm_cono",
-                        "=", int(c))], limit=1)
+                        "=", int(ck))], limit=1)
                     if not chk:
                         raise Exception
                     if self.acoy:
-                        self.acoy = "%s,%s" % (self.acoy, c)
+                        self.acoy = "%s,%s" % (self.acoy, ck)
                     else:
-                        self.acoy = "%s" % c
+                        self.acoy = "%s" % ck
                 except:
-                    return "Invalid Company Number (%s)" % c
+                    return "Invalid Company Number (%s)" % ck
             self.df.loadEntry(frt, pag, i, data=self.acoy)
         else:
             self.df.loadEntry(frt, pag, i, data="All")
@@ -15357,18 +14894,18 @@
     def doDisCoy(self, frt, pag, r, c, p, i, w):
         self.dcoy = ""
         if w and w != "None":
-            for c in w.replace(" ", "").split(","):
+            for ck in w.replace(" ", "").split(","):
                 try:
                     chk = self.sql.getRec("ctlmst", where=[("ctm_cono",
-                        "=", int(c))], limit=1)
+                        "=", int(ck))], limit=1)
                     if not chk:
                         raise Exception
                     if self.dcoy:
-                        self.dcoy = "%s,%s" % (self.dcoy, c)
+                        self.dcoy = "%s,%s" % (self.dcoy, ck)
                     else:
-                        self.dcoy = "%s" % c
+                        self.dcoy = "%s" % ck
                 except:
-                    return "Invalid Company Number (%s)" % c
+                    return "Invalid Company Number (%s)" % ck
             self.df.loadEntry(frt, pag, i, data=self.dcoy)
         else:
             self.df.loadEntry(frt, pag, i, data="None")
@@ -15404,12 +14941,6 @@
                     self.sql.insRec("ctlpwm", data=rec)
             self.doLoadMods()
 
-    def doDelUser(self):
-        if self.unam == "admin":
-            return "Not Allowed to Delete admin"
-        self.sql.delRec("ctlpwu", where=[("usr_name", "=", self.unam)])
-        self.sql.delRec("ctlpwm", where=[("mpw_usr", "=", self.unam)])
-
     def doCoy(self, frt, pag, r, c, p, i, w):
         if w and self.acoy:
             coys = self.acoy.split(",")
@@ -15423,7 +14954,7 @@
 
     def doSys(self, frt, pag, r, c, p, i, w):
         s = False
-        for sss in self.systems:
+        for sss in self.syss:
             if w == sss[1]:
                 s = True
         if not s:
@@ -15506,6 +15037,7 @@
         if not usr:
             self.sql.insRec("ctlpwm", data=dat)
         else:
+            dat.append(usr[self.sql.ctlpwm_col.index("mpw_xflag")])
             self.sql.updRec("ctlpwm", data=dat, where=whr)
         self.doLoadMods()
 
@@ -15545,9 +15077,9 @@
         mode - B(ackup), (R)store.
         csys - The ctlsys detail.
         ver  - The tartan version.
-        bar  - Whether to display a progressbar,
+        pbar - Whether to display a progressbar,
     """
-    def __init__(self, mf, mode="B", csys=None, ver=None, bar=True):
+    def __init__(self, mf, mode="B", csys=None, ver=None, pbar=True):
         self.mf = mf
         self.mode = mode
         self.budays = 0
@@ -15558,7 +15090,7 @@
                     wrkdir=self.mf.rcdic["wrkdir"]):
                 self.smtp = csys[1:]
         self.ver = ver
-        self.bar = bar
+        self.pbar = pbar
         if self.setVariables():
             if self.mode == "B":
                 if self.mf.window and self.smtp and self.smtp[0]:
@@ -15848,7 +15380,13 @@
                 self.mf.closeLoop()
             return
         self.bu.closeProcess()
-        if self.mode == "R" and self.full == "Y":
+        ok = askQuestion(self.mf.body, "Restore", "Are You Certain this is "\
+            "what you want to do?\n\nExisting Data in the Database Will be "\
+            "Replaced and will Not be Recoverable.", default="no")
+        if ok == "no":
+            self.mf.closeLoop()
+            return
+        if self.full == "Y":
             self.doFullRestore()
             self.mf.closeLoop()
             return
@@ -15950,15 +15488,15 @@
             if self.mf.window:
                 p1.txtlab.configure(text="Backing Up Company %s" % coy[0])
                 p1.displayProgress(cn)
-            elif self.bar and TBAR:
-                p2 = tqdm(total=len(tabs), desc="Company %s" % coy[0])
+            elif self.pbar and TBAR:
+                p2 = Bar("Company %s" % coy[0], max=len(tabs))
             for tn, tab in enumerate(tabs):
                 sql = Sql(self.mf.dbm, ["ffield", tab], prog=__name__)
                 if self.mf.window:
                     p2.txtlab.configure(text="Backing Up Table %s" % tab)
                     p2.displayProgress(tn)
-                elif self.bar and TBAR:
-                    p2.update()
+                elif self.pbar and TBAR:
+                    p2.next()
                 fld = sql.getRec("ffield", cols=["ff_name"],
                     where=[("ff_tabl", "=", tab), ("ff_seq", "=", 0)],
                     limit=1)
@@ -15991,8 +15529,8 @@
         if self.mf.window:
             p1.closeProgress()
             p2.closeProgress()
-        elif self.bar and TBAR:
-            p2.close()
+        elif self.pbar and TBAR:
+            p2.finish()
 
     def doFullRestore(self):
         # Restore the Files
@@ -16081,7 +15619,7 @@
     xcol     - The x-axis's column labels
     """
     def __init__(self, mf, conum, conam, periods, title, achart, mchart, xlab=None, ylab=None, xcol=None):
-        if not PYCHART and not PYGAL:
+        if not PYGAL:
             return
         self.mf = mf
         self.conum = conum
@@ -16119,19 +15657,24 @@
             ("Bar Normal","B"),
             ("Bar Stacked","S"),
             ("Pie Chart","P"))
+        r3s = (("PDF","P"),("SVG","S"))
+        r4s = (("Yes","Y"),("No","N"))
         fld = [
             (("T",0,0,0),("IRB",r1s),0,"Action","Select Action",
                 "M","N",self.doAct,None,None,None,None),
             (("T",0,1,0),("IRB",r2s),0,"Select Chart","",
                 "L","N",self.doCht,None,None,None,None)]
-        if (PYCHART and PYGAL) or (PYGAL and CVTSVG):
-            r3s = [("PDF","P"),("SVG","S")]
+        if PYGAL and CVTSVG:
             fld.append((("T",0,2,0),("IRB",r3s),0,"View As","",
                 "P","N",self.doVwr,None,None,None,None))
-        elif PYCHART:
-            self.vwr = "P"
+            idx = 3
         else:
             self.vwr = "S"
+            idx = 2
+        fld.append((("T",0,idx,0),("IRB",r4s),0,"Show Labels","",
+            "Y","N",self.doLab,None,None,None,None))
+        fld.append((("T",0,idx+1,0),("IRB",r4s),0,"Show Legends","",
+            "Y","N",self.doLeg,None,None,None,None))
         self.dc = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
             tend=((self.doChtEnd, "y"),), txit=(self.doChtExit,),
             mail=("Y","N"))
@@ -16169,6 +15712,12 @@
     def doVwr(self, frt, pag, r, c, p, i, w):
         self.vwr = w
 
+    def doLab(self, frt, pag, r, c, p, i, w):
+        self.lab = bool(w == "Y")
+
+    def doLeg(self, frt, pag, r, c, p, i, w):
+        self.leg = bool(w == "Y")
+
     def doChtEnd(self):
         self.repprt = ["Y", "V", "view"]
         self.repeml = copyList(self.dc.repeml)
@@ -16203,156 +15752,18 @@
                 if m > 12:
                     y += 1
                     m = 1
-        if self.vwr == "P" and PYCHART:
-            self.doPyChart(labs)
-        else:
-            self.doPyGal()
-        doPrinter(mf=self.mf, conum=self.conum, pdfnam=self.pdfnam,
-            header=self.title[0], repprt=self.repprt, repeml=self.repeml)
-        self.dc.focusField("T", 0, 1)
-
-    def doPyChart(self, labs):
-        def axisFormat(axis):
-            return "{:,}".format(axis)
-
-        pychart_theme.use_color = 1
-        pychart_theme.reinitialize()
-        self.pdfnam = getModName(self.mf.rcdic["wrkdir"], "chart",
-            self.conum, ext="pdf")
-        cnv = pychart_canvas.init(fname=self.pdfnam, format="pdf")
-        if self.cht == "P":
-            cnv.show(250, 550,"/14/hC/vT%s - %s" % tuple(self.title[0]))
-            cnv.show(250, 530, "/12/hC/vT%s for Period %s to %s (%s)" % \
-                (self.chart[0][1], self.s_per.disp, self.e_per.disp,
-                self.title[1]))
-        else:
-            if self.cht == "L":
-                w = 200
-            else:
-                w = 300
-            cnv.show(w, 550,"/14/hC/vT%s" % self.title[0][0])
-            cnv.show(w, 530, "/12/hC/vT%s for Period %s to %s (%s)" % \
-                (self.title[0][1], self.s_per.disp, self.e_per.disp,
-                self.title[1]))
-
-        data = []
-        mins = 0
-        maxs = 0
-        tots = 0
-        for num, col in enumerate(self.xcol):
-            dat = [col]
-            for cht in self.chart:
-                dat.append(cht[num + 2])
-                if self.cht == "S":
-                    tots += cht[num + 2]
-                else:
-                    if cht[num + 2] < mins:
-                        mins = cht[num + 2]
-                    if cht[num + 2] > maxs:
-                        maxs = cht[num + 2]
-            if self.cht == "S":
-                if tots < mins:
-                    mins = tots
-                if tots > maxs:
-                    maxs = tots
-                tots = 0
-            if self.cht == "P" and not dat[1]:
-                continue
-            data.append(dat)
-        if self.cht == "P":
-            are = area.T(size=(500, 500), legend=None, x_grid_style=None,
-                y_grid_style=None)
-            plot = pie_plot.T(data=data, center=(250, 250), radius=190,
-                arc_offsets=[], label_offset=25, arrow_style=arrow.a0)
-            are.add_plot(plot)
-        else:
-            tots = maxs + (0 - mins)
-            tic = 100
-            num = int(tots / tic)
-            while num > 9:
-                tic = tic * 10
-                num = int(tots / tic)
-            th = int(tic * .1)
-            while int((tots / tic)) < 6 and tic != th:
-                tic -= th
-            if maxs:
-                chk = int(maxs / tic)
-                if (tic * chk) < maxs:
-                    chk += 1
-                maxs = tic * chk
-            if mins:
-                chk = int(mins / tic)
-                if (tic * chk) > maxs:
-                    chk += 1
-                mins = tic * chk
-            if self.cht in ("B", "S"):
-                if len(data) == 1:
-                    are = area.T(size=(600, 500), loc=(10, 0),
-                        x_coord=category_coord.T(data, 0),
-                        x_axis=axis.X(label=self.xlab),
-                        y_range=(mins, maxs),
-                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
-                            format=axisFormat),
-                        y_grid_interval=tic, legend=None)
-                else:
-                    are = area.T(size=(600, 500), loc=(10, 0),
-                        x_coord=category_coord.T(data, 0),
-                        x_axis=axis.X(label=self.xlab),
-                        y_range=(mins, maxs),
-                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
-                            format=axisFormat),
-                        y_grid_interval=tic)
-                if (len(data) * len(self.chart)) > 36:
-                    width = 5
-                else:
-                    width = 10
-                chart_object.set_defaults(bar_plot.T, data=data, width=width)
-                t = len(labs)
-                for n, d in enumerate(labs):
-                    if self.cht == "B":
-                        plot = bar_plot.T(label=d, hcol=n+1, cluster=(n, t-1))
-                    else:
-                        if not n:
-                            plot = bar_plot.T(label=d, hcol=n+1)
-                        else:
-                            stak = plot
-                            plot = bar_plot.T(label=d, hcol=n+1, stack_on=stak)
-                    are.add_plot(plot)
-            elif self.cht == "L":
-                if len(data) == 1:
-                    are = area.T(size=(400, 500), loc=(0, 0),
-                        x_coord=category_coord.T(data, 0),
-                        x_axis=axis.X(label=self.xlab),
-                        y_range=(mins, maxs),
-                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
-                            format=axisFormat),
-                        y_grid_interval=tic, legend=None)
-                else:
-                    are = area.T(size=(400, 500), loc=(0, 0),
-                        x_coord=category_coord.T(data, 0),
-                        x_axis=axis.X(label=self.xlab),
-                        y_range=(mins, maxs),
-                        y_axis=axis.Y(label=self.ylab, tic_interval=tic,
-                            format=axisFormat),
-                        y_grid_interval=tic)
-                chart_object.set_defaults(line_plot.T, data=data)
-                for n, d in enumerate(labs):
-                    plot = line_plot.T(label=d, ycol=n+1)
-                    are.add_plot(plot)
-        are.draw(cnv)
-        cnv.close()
-
-    def doPyGal(self):
+        # Generate Chart
         flenam = getModName(self.mf.rcdic["wrkdir"], "chart",
             self.conum, ext="svg")
         if self.cht == "B":
-            chart = pygal.Bar()
+            chart = pygal.Bar(print_labels=self.lab, show_legend=self.leg)
         elif self.cht == "S":
-            chart = pygal.StackedBar()
+            chart = pygal.StackedBar(print_labels=self.lab,
+                show_legend=self.leg)
         elif self.cht == "L":
-            chart = pygal.Line()
+            chart = pygal.Line(print_labels=self.lab, show_legend=self.leg)
         elif self.cht == "P":
-            chart = pygal.Pie(print_labels=True, show_legend=False)
+            chart = pygal.Pie(print_labels=self.lab, show_legend=self.leg)
         if self.cht == "P":
             titl = "%s - %s" % tuple(self.title[0])
             titl = "%s\n%s for Period %s to %s (%s)" % (titl, self.chart[0][1],
@@ -16375,10 +15786,16 @@
                 chart.add(l[1], l[2:])
         chart.render_to_file(flenam)
         if CVTSVG and self.vwr == "P":
+            # Convert to PDF
             self.pdfnam = flenam.replace("svg", "pdf")
-            # renderPDF.drawToFile(svg2rlg(flenam), self.pdfnam)
+            renderPDF.drawToFile(svg2rlg(flenam), self.pdfnam)
         else:
             self.pdfnam = flenam
+        # Print or Display the Chart
+        doPrinter(mf=self.mf, conum=self.conum, pdfnam=self.pdfnam,
+            header=self.title[0], repprt=self.repprt, repeml=self.repeml)
+        # Return focus
+        self.dc.focusField("T", 0, 1)
 
     def doChtExit(self):
         self.dc.closeProcess()
@@ -16652,13 +16069,6 @@
         self.df.closeProcess()
         self.mf.closeLoop()
 
-class GrowingList(list):
-    # http://stackoverflow.com/a/4544699/1846474
-    def __setitem__(self, index, value):
-        if index >= len(self):
-            self.extend([None]*(index + 1 - len(self)))
-        list.__setitem__(self, index, value)
-
 class FileImport(object):
     """
     This is a file import class.
@@ -16957,8 +16367,11 @@
                                         self.workbk.datemode)
                                     dat = (dte[0]*10000)+(dte[1]*100)+dte[2]
                                 except:
-                                    dat = 0
-                                    col[2] = "d1"
+                                    try:
+                                        dat = int(dat)
+                                    except:
+                                        dat = 0
+                                        col[2] = "d1"
                             d = CCD(dat, col[2], col[3])
                             if d.err:
                                 raise Exception
@@ -17068,17 +16481,15 @@
                 if self.def_orientation == "P":
                     if self.width > portrait[0]:
                         continue
-                    else:
-                        self.font = [family, siz, self.chgt]
-                        self.lpp = int(portrait[1] / self.chgt)
-                        break
+                    self.font = [family, siz, self.chgt]
+                    self.lpp = int(portrait[1] / self.chgt)
+                    break
                 if self.def_orientation == "L":
                     if self.width > portrait[1]:
                         continue
-                    else:
-                        self.font = [font, siz, self.chgt]
-                        self.lpp = int(portrait[0] / self.chgt)
-                        break
+                    self.font = [font, siz, self.chgt]
+                    self.lpp = int(portrait[0] / self.chgt)
+                    break
             if not self.font:
                 if self.def_orientation == "P":
                     self.def_orientation = "L"
@@ -17086,16 +16497,15 @@
                     print("Invalid head length", len(head))
                     sys.exit()
 
-    def drawText(self, txt="", x=0, y=0, w=0, h=0, font=None, border=0, ln=1, align="", fill=0, ctyp="S"):
+    def drawText(self, txt="", x=0, y=0, w=0, h=0, font=None, border=0, ln=1, align="", fill=0, link="", ctyp="S"):
         if type(txt) not in (str, unicode):
             txt = str(txt)
         if x and y:
             self.set_xy(x, y)
-        else:
-            if x:
-                self.set_x(x)
-            if y:
-                self.set_y(y)
+        elif x:
+            self.set_x(x)
+        elif y:
+            self.set_y(y)
         if font:
             if type(font) in (list, tuple) and len(font) == 3:
                 family, style, size = font
@@ -17117,13 +16527,8 @@
             self.cell(w=w, h=h, ln=ln, txt=txt, border=border, align=align,
                 fill=fill)
         else:
-            # Change to fpdf in python 3, ln default changed
-            try:
-                self.multi_cell(w=w, h=h, txt=txt, border=border, align=align,
-                    fill=fill, ln=2)
-            except:
-                self.multi_cell(w=w, h=h, txt=txt, border=border, align=align,
-                    fill=fill)
+            self.multi_cell(w=w, h=h, txt=txt, border=border, align=align,
+                fill=fill)
 
     def setFont(self, family="", style="", size=0, default=False):
         if not family:
@@ -17137,12 +16542,15 @@
             else:
                 size = 10
         try:
-            self.set_font(family, style, size)
+            if style:
+                self.set_font(family, style, size)
+            else:
+                self.set_font(family, size=size)
             self.cwth = self.get_string_width("X")
             if default:
                 self.font = [family, size, self.font_size]
-        except:
-            pass
+        except Exception as err:
+            print(err, family, style, size)
 
     def underLine(self, t="S", x=0, y=0, h=0, w=0, txt=""):
         if txt.count(self.suc):
@@ -17326,7 +16734,7 @@
                     self.tptp[mrgcod] = [[fld[0], fld[1], fld[2], ""], []]
         return True
 
-    def doText(self, x1=0, y1=0, x2=0, y2=0, text="", font="courier", size=10, colour=0, bold=False, italic=False, uline=False, align="", border=0, ln=1, fill=0, *args, **kwargs):
+    def doText(self, x1=0, y1=0, x2=0, y2=0, text="", font="courier", size=10, colour=0, bold=False, italic=False, uline=False, align="", border=0, ln=1, fill=0):
         if text:
             if text != str:
                 text = str(text)
@@ -17347,7 +16755,7 @@
             self.cell(w=x2-x1, h=y2-y1, txt=text, border=border, ln=ln,
                 align=align, fill=fill)
 
-    def doMultiText(self, x1=0, y1=0, x2=0, y2=0, text="", font="courier", size=10, colour=0, bold=False, italic=False, uline=False, align="", border=0, ln=1, fill=0, *args, **kwargs):
+    def doMultiText(self, x1=0, y1=0, x2=0, y2=0, text="", font="courier", size=10, colour=0, bold=False, italic=False, uline=False, align="", border=0, ln=1, fill=0):
         if text:
             font = font.strip().lower()
             if self.text_color != rgb(colour):
@@ -17364,7 +16772,7 @@
             self.multi_cell(w=x2-x1, h=y2-y1, txt=text, border=border,
                 fill=fill)
 
-    def doLine(self, x1=0, y1=0, x2=0, y2=0, font="courier", colour=0, thick=0, *args, **kwargs):
+    def doLine(self, x1=0, y1=0, x2=0, y2=0, font="courier", colour=0, thick=0):
         font = font.strip().lower()
         if self.draw_color != rgb(colour):
             self.set_draw_color(*rgb(colour))
@@ -17373,14 +16781,14 @@
         self.line(x1, y1, x2, y2)
         self.set_line_width(0)
 
-    def doRect(self, x1=0, y1=0, x2=0, y2=0, thick=0, colour=0, *args, **kwargs):
+    def doRect(self, x1=0, y1=0, x2=0, y2=0, thick=0, colour=0):
         if self.draw_color != rgb(colour):
             self.set_draw_color(*rgb(colour))
         self.set_line_width(thick)
         self.rect(x1, y1, x2-x1, y2-y1)
         self.set_line_width(0)
 
-    def doImage(self, x1=0, y1=0, x2=0, y2=0, text="", *args, **kwargs):
+    def doImage(self, x1=0, y1=0, x2=0, y2=0, text=""):
         if x2:
             w = x2 - x1
         else:
@@ -17391,7 +16799,7 @@
             h = 0
         self.image(text, x1, y1, w, h, type="", link="")
 
-    def doBarcode(self, x1=0, y1=0, x2=0, y2=0, text="", font="interleaved 2of5 nt", size=1, colour=0, *args, **kwargs):
+    def doBarcode(self, x1=0, y1=0, x2=0, y2=0, text="", font="interleaved 2of5 nt", size=1, colour=0):
         if self.draw_color != rgb(colour):
             self.set_draw_color(*rgb(colour))
         font = font.lower().strip()
@@ -17711,31 +17119,18 @@
                 self.newdic["name_init"][tdc.index("tpd_text")] = dat
 
     def changeSize(self, pdfnam):
-        if not PyPDF:
-            return
-        in_f = open(pdfnam, "rb")
-        page = PdfFileReader(in_f).getPage(0)
-        ul = float(page.mediaBox.getUpperLeft_y())
-        newy = float(ul - (self.get_y() * 3))
-        ll = list(page.mediaBox.getLowerLeft())
-        lr = list(page.mediaBox.getLowerRight())
-        ll[1] = lr[1] = newy
-        page.cropBox.lowerLeft = ll
-        page.cropBox.lowerRight = lr
-        output = PdfFileWriter()
-        output.addPage(page)
-        try:
-            newpdf = pdfnam.replace(os.path.basename(pdfnam), "tesfle.pdf")
-            out_f = open(newpdf, "wb")
-            output.write(out_f)
-            in_f.close()
-            out_f.close()
-            os.rename(newpdf, pdfnam)
-        except Exception as e:
-            showError(None, "Error", "Cannot Re-Size PDF File\n\n%s" % e)
+        doc = fitz.open(pdfnam)
+        mbox = doc[0].MediaBox
+        mbox[1] = float(mbox[3] - (self.get_y() * 3))
+        doc[0].setMediaBox(mbox)
+        doc2 = fitz.open()
+        doc2.insertPDF(doc, from_page=0, to_page=0)
+        doc2.save(pdfnam)
+        doc.close()
+        doc2.close()
 
 class ToolTip(object):
-    def __init__(self, widget, text, font=None, color=("black", "light yellow"), pause=5000):
+    def __init__(self, widget, text, font=None, color=("black","light yellow")):
         self.widget = widget
         self.text = text
         if not font:
@@ -17743,7 +17138,10 @@
         else:
             self.font = font
         self.color = color
-        self.pause = pause
+        if widget.winfo_class() == "TButton":
+            self.pause = None
+        else:
+            self.pause = len(text) * 40
         self.tipwindow = None
         self.x = self.y = 0
         self.widget.bind("<Enter>", self.showTip)
@@ -17764,11 +17162,16 @@
         y = self.widget.winfo_rooty() + self.widget.winfo_height()
         self.tipwindow = tw = tk.Toplevel(self.widget)
         tw.wm_overrideredirect(True)
-        tw.wm_geometry("+%d+%d" % (x, y))
         label = MyLabel(tw, color=self.color, text=self.text, justify="left",
             relief="solid", borderwidth=2, font=self.font, wraplength=400)
         label.pack(ipadx=1, ipady=2)
-        label.after(self.pause, self.hideTip)
+        tw.update_idletasks()
+        ww = label.winfo_reqwidth()
+        if x + ww > label.winfo_screenwidth():
+            x = x - ww
+        tw.wm_geometry("+%d+%d" % (x, y))
+        if self.pause:
+            label.after(self.pause, self.hideTip)
 
     def hideTip(self, event=None):
         tw = self.tipwindow
@@ -17795,7 +17198,7 @@
 
 Paul Malherbe
 
-Phone:        27-21-6710071
+Phone:        27-28-3165036
 Mobile:       27-82-9005260
 Email:    paul@tartan.co.za
 
@@ -17822,7 +17225,7 @@
     def linkAbout(self, *args):
         try:
             web = "https://www.tartan.co.za"
-            webbrowser.open(web)
+            webbrowser.open_new(web)
             self.exitAbout()
         except:
             showError(self.mf.window, "Browser Error",
@@ -17890,7 +17293,7 @@
         self.text.config(cursor="hand2")
 
     def _leave(self, event):
-        self.text.config(cursor="")
+        self.text.config(cursor="arrow")
 
     def _click(self, event):
         for tag in self.text.tag_names("current"):
@@ -18229,6 +17632,8 @@
     def doEnd(self):
         if "args" not in self.opts:
             self.df.closeProcess()
+        if os.path.exists(self.nam):
+            os.remove(self.nam)
         rcdic = loadRcFile(self.nam, default=True)
         rcdic["dbname"] = self.nam
         rcdic["dbdir"] = self.dir
@@ -18292,6 +17697,7 @@
         if not num:
             self.sqt.delRec(tab)
         cols = getattr(self.sqf, "%s_col" % tab)
+        flds = getattr(self.sqf, "%s_fld" % tab)
         pfx = cols[0].split("_")[0]
         xfl = "%s_xflag" % pfx
         if cono and tab != "genrpt":
@@ -18300,13 +17706,20 @@
                 whr = [("ctm_cono", "in", (1, cono))]
             else:
                 whr = [(cols[0], "=", cono)]
-            recs = self.sqf.getRec(tables=tab, where=whr)
         else:
-            recs = self.sqf.getRec(tables=tab)
+            whr = None
+        recs = self.sqf.getRec(tables=tab, where=whr)
         for rec in recs:
-            if xfl in cols:
-                rec[cols.index(xfl)] = "Y"
-            self.sqt.sqlRec("Insert into %s values %s" % (tab, tuple(rec)))
+            try:
+                if xfl in cols:
+                    rec[cols.index(xfl)] = "Y"
+                for chg in ("mlm_idnum", "wgm_idno"):
+                    if chg in cols:
+                        rec[cols.index(chg)] = int(rec[cols.index(chg)])
+                self.dbm.cu.execute("Insert into %s (%s) values %s" %
+                    (tab, flds, tuple(rec)))
+            except:
+                pass
 
     def doExit(self):
         self.df.closeProcess()
@@ -18392,10 +17805,10 @@
                 elif c2[0] != c[1]:
                     err.append((c[0], c[1], c2[0]))
             if err:
-                txt = "Different Company Names:\n\n"
-                txt += "%3s %-30s %-30s" % ("Num", "Original", "Importing")
-                for e in err:
-                    txt += "%03i %-30s %-30s" % e
+                txt = "Different Company Names for Company %03i\n" % err[0][0]
+                txt += "---------------------------------------\n"
+                txt += "Original:  %-s\n" % err[0][1]
+                txt += "Importing: %-s" % err[0][2]
                 raise Exception
             if self.dbm.checkTable("delrec"):
                 self.tabs.insert(0, "delrec")
@@ -18414,7 +17827,7 @@
                 ask = True
             self.opts["mf"].dbm.commitDbase(ask=ask)
             if self.opts["mf"].dbm.commit == "yes":
-                # If db to is committed then commit db from
+                # If db 'to' is committed then commit db 'from'
                 self.dbm.dropTable("delrec")
                 self.dbm.commitDbase()
             self.dbm.closeDbase()
@@ -18458,4 +17871,998 @@
         self.df.closeProcess()
         self.opts["mf"].closeLoop()
 
+class MakeManual(object):
+    def __init__(self, docfle, vwr=""):
+        if self.setVariables():
+            self.fpdf.add_page()
+            self.pmax = 200
+            head1 = False
+            head2 = False
+            head3 = False
+            head4 = False
+            head5 = False
+            table = False
+            skips = False
+            tcont = False
+            conts = []
+            paras = []
+            if type(docfle) == str:
+                lines = open(docfle, "r").readlines()
+            else:
+                lines = docfle.readlines()
+            for num, line in enumerate(lines):
+                if skips:
+                    skips = False
+                    continue
+                # Remove suffixes
+                line = line.rstrip()
+                # Remove hyperlinks
+                if line and line[:4] == ".. _":
+                    continue
+                # Replace links with blank
+                line = line.replace("`", "")
+                line = line.replace("_", "")
+                # Remove | lines
+                if line and line[0] == "|":
+                    skips = True
+                    continue
+                if line and line.count("PageBreak"):
+                    self.fpdf.add_page()
+                    continue
+                if line.count(".. contents::"):
+                    if vwr:
+                        link = self.fpdf.add_link()
+                        tcont = line.split("::")[1].strip()
+                        tcont = (tcont.replace("**", ""), link)
+                        self.fpdf.drawText(tcont[0], w=20 * self.fpdf.cwth,
+                            h=10, fill=True, font=self.fonts["head3"],
+                            border="TLRB", link=link)
+                    else:
+                        txt = "F2 for Table of Contents"
+                        self.fpdf.drawText(txt, w=25 * self.fpdf.cwth,
+                            h=10, fill=True, font=self.fonts["head3"],
+                            border="TLRB")
+                    continue
+                if line.count(".. csv-table::"):
+                    table = True
+                    self.heads = []
+                    self.widths = []
+                    self.table = []
+                    continue
+                if table:
+                    chk = line.strip().split()
+                    if chk and chk[0] == ":header:":
+                        self.heads = chk[1:]
+                        continue
+                    if chk and chk[0] == ":widths:":
+                        self.widths = chk[1:]
+                        continue
+                    if chk and self.heads and self.widths:
+                        self.table.append(line.strip())
+                        continue
+                    if self.table:
+                        self.printTable()
+                        table = False
+                    else:
+                        continue
+                if head2:
+                    head2 = False
+                    continue
+                if head3:
+                    head3 = False
+                    continue
+                if head4:
+                    head4 = False
+                    continue
+                if head5:
+                    head5 = False
+                    continue
+                if head1 and line.count("===="):
+                    head1 = False
+                    continue
+                if line.count("===="):
+                    head1 = True
+                    continue
+                if head1:
+                    self.fpdf.drawText(line, font=self.fonts["head1"],
+                        align="C")
+                    self.fpdf.drawText()
+                    continue
+                if (num + 1) < len(lines) and lines[num + 1].count("===="):
+                    head1 = True
+                    self.fpdf.drawText(line, font=self.fonts["head1"],
+                        align="C")
+                    self.fpdf.drawText()
+                    continue
+                if (num + 1) < len(lines) and lines[num + 1].count("----"):
+                    head2 = True
+                    line = line.split(" (")[0]
+                    link = self.fpdf.add_link()
+                    self.fpdf.set_link(link, -1, -1)
+                    conts.append((line.strip(), self.fpdf.page_no(), 1, link))
+                    self.fpdf.drawText(line, font=self.fonts["head2"],
+                        align="L", link=link)
+                    self.fpdf.drawText()
+                    continue
+                if (num + 1) < len(lines) and lines[num + 1].count("...."):
+                    head3 = True
+                    line = line.split(" (")[0]
+                    link = self.fpdf.add_link()
+                    self.fpdf.set_link(link, -1, -1)
+                    conts.append((line.strip(), self.fpdf.page_no(), 2, link))
+                    self.fpdf.drawText(line, font=self.fonts["head3"],
+                        align="L", link=link)
+                    self.fpdf.drawText()
+                    continue
+                if (num + 1) < len(lines) and lines[num + 1].count("++++"):
+                    head4 = True
+                    line = line.split(" (")[0]
+                    link = self.fpdf.add_link()
+                    self.fpdf.set_link(link, -1, -1)
+                    conts.append((line.strip(), self.fpdf.page_no(), 3, link))
+                    self.fpdf.drawText(line, font=self.fonts["head4"],
+                        align="L", link=link)
+                    self.fpdf.drawText()
+                    continue
+                if (num + 1) < len(lines) and lines[num + 1].count("~~~~"):
+                    head5 = True
+                    line = line.split(" (")[0]
+                    link = self.fpdf.add_link()
+                    self.fpdf.set_link(link, -1, -1)
+                    conts.append((line.strip(), self.fpdf.page_no(), 4, link))
+                    self.fpdf.drawText(line, font=self.fonts["head5"],
+                        align="L", link=link)
+                    self.fpdf.drawText()
+                    continue
+                if line.lstrip() and line.lstrip()[0] in ("+", ":"):
+                    paras.append(line)
+                    continue
+                if paras:
+                    if not line.strip() and \
+                            lines[num + 1].lstrip()[0] in ("+", ":"):
+                        # Blank line in a paragraph
+                        paras.append(line)
+                        continue
+                    self.printPara(paras)
+                    paras = []
+                if not line.strip() and not lines[num + 1].strip():
+                    # Two blank lines
+                    continue
+                self.fpdf.drawText(line.strip(), font=self.fonts["bodyn"],
+                    ctyp="M")
+            if paras:
+                self.printPara(paras)
+            if tcont and vwr:
+                # Table of Contents
+                self.fpdf.add_page()
+                self.fpdf.set_link(tcont[1], -1, -1)
+                self.fpdf.drawText(tcont[0], font=self.fonts["head1"],
+                    align="C", link=tcont[1])
+                self.fpdf.drawText()
+                for line in conts:
+                    fnt = self.fonts["bodyn"]
+                    if line[2] == 1:
+                        txt = line[0]
+                        fnt = self.fonts["bodyb"]
+                    elif line[2] == 2:
+                        txt = "    " + line[0]
+                    else:
+                        txt = "        " + line[0]
+                    self.fpdf.drawText(txt, w=100, font=fnt,
+                        ln=0, link=line[3])
+                    self.fpdf.drawText("%3s" % line[1],
+                        font=self.fonts["bodyn"], align="R")
+
+    def setVariables(self):
+        self.fonts = {
+            "head1": ("Arial", "B", 18),
+            "head2": ("Arial", "B", 16),
+            "head3": ("Arial", "B", 14),
+            "head4": ("Arial", "B", 12),
+            "head5": ("Arial", "B", 10),
+            "bodyb": ("Arial", "B", 10),
+            "bodyn": ("Arial", "", 10)}
+        self.fpdf = MyFpdf(name="Documents", head=80, font=self.fonts["bodyn"],
+            auto=True, foot=True)
+        return True
+
+    def printPara(self, paras):
+        indent = {}
+        lines = []
+        self.setFont("bodyb")
+        for line in paras:
+            if not line:
+                lines.append([])
+                continue
+            words = None
+            bold = False
+            try:
+                level = line.index("+")
+            except:
+                level = 0
+            if level not in indent:
+                indent[level] = 0
+            if line.count(":") and line.index(":") == 0:
+                words = line.split(":", 2)
+                bold = True
+            elif line.count("**") and line.index("**") in (2, 6, 10, 14, 18):
+                words = line.split("**", 2)
+                if level == 0:
+                    bold = True
+            elif line.count("*") and line.index("*") in (2, 6, 10, 14, 18):
+                words = line.split("*", 2)
+            elif line.count("#"):
+                words = line.split("#")
+            if words:
+                if len(words) == 3:
+                    if words[0]:
+                        text = "%s%s" % (words[0], words[1].strip())
+                    else:
+                        text = words[1].rstrip()
+                else:
+                    text = words[0].rstrip()
+                wdth = self.fpdf.get_string_width(text) + 1
+                if len(words) == 3:
+                    if words[2] and wdth > indent[level]:
+                        indent[level] = wdth
+                    lines.append((text, words[2], level, bold))
+                else:
+                    if words[1] and wdth > indent[level]:
+                        indent[level] = wdth
+                    lines.append((text, words[1].strip(), level, bold))
+            else:
+                lines.append((line, level, bold))
+        keys = list(indent.keys())
+        keys.sort()
+        for num, key in enumerate(keys):
+            if key == keys[-1]:
+                continue
+            if indent[keys[num + 1]] and indent[keys[num + 1]] < indent[key]:
+                indent[keys[num + 1]] = indent[key]
+        for line in lines:
+            if len(line) == 0:
+                self.fpdf.drawText()
+            elif len(line) == 4:
+                if line[3]:
+                    self.setFont("bodyb")
+                else:
+                    self.setFont("bodyn")
+                text = line[0].rstrip().replace("+ ", "%s " % chr(127))
+                self.fpdf.drawText(text, w=indent[line[2]], ln=0)
+                x = self.fpdf.get_x()
+                if line[1]:
+                    self.doRest(line[1], x)
+                else:
+                    self.fpdf.drawText()
+            else:
+                text = line[0].rstrip().replace("+ ", "%s " % chr(127))
+                self.doRest(text)
+
+    def doRest(self, line, x=0):
+        line = line.strip()
+        spc = False
+        for tst in ("- ", "%s " % chr(127)):
+            if line[:2] == tst:
+                spc = True
+                break
+        text = ""
+        for word in line.split():
+            if not text:
+                text = word
+            else:
+                self.setFont("bodyn")
+                chk = x + self.fpdf.get_string_width("%s %s" % (text, word))
+                if chk > self.pmax:
+                    self.fpdf.drawText(text, x=x, font=self.fonts["bodyn"])
+                    text = word
+                    if spc:
+                        if not x:
+                            x = self.fpdf.l_margin
+                        x += self.fpdf.get_string_width(tst)
+                        spc = False
+                else:
+                    text = "%s %s" % (text, word)
+        if text:
+            self.fpdf.drawText(text, x=x, font=self.fonts["bodyn"])
+
+    def setFont(self, font):
+        fam, sty, siz = self.fonts[font]
+        self.fpdf.setFont(fam, sty, siz)
+
+    def printTable(self):
+        for num, dat in enumerate(self.heads):
+            txt = dat.replace('",', "").replace('"', "")
+            wid = int(self.widths[num].replace(',', "")) * self.fpdf.cwth
+            self.fpdf.drawText(txt, w=wid, border="TLRB", fill=True, ln=0)
+        self.fpdf.drawText()
+        for line in self.table:
+            data = line.replace('"', "").split(", ")
+            for num, dat in enumerate(data):
+                wid = int(self.widths[num].replace(',', "")) * self.fpdf.cwth
+                self.fpdf.drawText(dat, w=wid, border="TLRB", ln=0)
+            self.fpdf.drawText()
+
+class ViewPDF(object):
+    """
+    This class is used to view pdf files using pymupdf
+    """
+    def __init__(self, mf=None, pdfnam=None):
+        self.mf = mf
+        if self.mf:
+            self.mf.window.withdraw()
+            self.win = MkWindow().newwin
+        else:
+            self.win = MkWindow(tk=True).newwin
+        try:
+            self.win.tk.call("wm", "iconphoto", self.win._w,
+                "-default", getImage("tartan"))
+        except:
+            pass
+        if pdfnam is None:
+            pdfnam = self.getPdfName()
+        if pdfnam and os.path.isfile(pdfnam):
+            self.win.title(pdfnam)
+            if self.mf:
+                vwr = mf.rcdic["vwr"]
+            else:
+                vwr = ""
+            self.pdfnam = pdfnam
+            if vwr and os.path.exists(vwr):
+                exe, cmd = parsePrg(vwr)
+                cmd.append(pdfnam)
+                subprocess.call(cmd)
+            elif not FITZ:
+                try:
+                    if sys.platform == "win32":
+                        os.startfile(pdfnam)
+                    else:
+                        subprocess.call(["xdg-open", pdfnam])
+                except:
+                    pass
+            else:
+                self.doDisplay()
+        if self.mf:
+            self.mf.window.deiconify()
+
+    def getPdfName(self):
+        dialog = FileDialog(**{
+            "title": "Select PDF File",
+            "ftype": (("PDF Files", "*.pdf"),),
+            "multi": False})
+        return dialog.askopenfilename()
+
+    def doFocus(self, event=None):
+        self.win.lift()
+        event.widget.focus_set()
+
+    def doDisplay(self):
+        # Window dimensions and Image sizes
+        self.win.resizable(0, 0)
+        self.win.configure(borderwidth=2)
+        self.sw = int(self.win.winfo_screenwidth() * .90)
+        self.sh = int(self.win.winfo_screenheight() * .90)
+        self.doc = fitz.open(self.pdfnam)
+        if self.doc.needsPass:
+            if not self.doPassword():
+                return
+        self.lastpg = self.doc.pageCount
+        rect = self.doc[0].MediaBox
+        if not self.doc[0].rotation:
+            self.siz = [int(rect[2]), int(rect[3])]
+        else:
+            self.siz = [int(rect[3]), int(rect[2])]
+        # Theme and fonts
+        self.style = ttk.Style()
+        if not self.mf:
+            self.style.theme_use("clam")
+        self.font = ["Helvetica", 12]
+        self.style.configure("pdf.TFrame", font=self.font)
+        self.style.configure("pdf.TLabel", font=self.font)
+        self.style.configure("pdf.TButton", font=self.font, padding=2)
+        self.style.configure("pdf.TEntry", font=self.font, height=5)
+        self.style.configure("pdfbold.TLabel", font=self.font + ["bold"])
+        self.style.configure("pdf.TRadiobutton", font=self.font)
+        # Widgets
+        self.frm = MyFrame(self.win)
+        self.frm.pack(fill="x")
+        self.bt1 = MyButton(self.frm, text="Goto", cmd=self.gotoPage,
+            style="pdf.TButton", underline=0)
+        ToolTip(self.bt1, "Jump To Page Number")
+        self.bt1.pack(padx=3, pady=3, side="left")
+        self.entsiz = len(str(self.lastpg))
+        self.pgd = MyEntry(self.frm, width=self.entsiz, maxsize=self.entsiz,
+            font=self.font)
+        self.pgd.bind("<Return>", self.enterPage)
+        self.pgd.bind("<KP_Enter>", self.enterPage)
+        self.pgd.pack(padx=3, pady=3, side="left")
+        lab = MyLabel(self.frm, text="of %s" % self.lastpg, color=False,
+            style="pdf.TLabel")
+        lab.pack(padx=3, pady=3, side="left")
+        self.bt2 = MyButton(self.frm, txt=False, text="Former",
+            cmd=self.priorPage, style="pdf.TButton", underline=0)
+        ToolTip(self.bt2, "Show Previous Page")
+        self.bt2.pack(padx=3, pady=3, side="left")
+        self.bt3 = MyButton(self.frm, txt=False, text="Next", cmd=self.nextPage,
+            style="pdf.TButton", underline=getUnderline(self.frm, "Next")[1])
+        ToolTip(self.bt3, "Show Next Page")
+        self.bt3.pack(padx=3, pady=3, side="left")
+        self.bt8 = MyButton(self.frm, text="Close", cmd=self.doClose,
+            style="pdf.TButton", underline=0)
+        ToolTip(self.bt8, "Close the Document and Exit")
+        self.bt8.pack(padx=3, pady=3, side="right")
+        self.bt7 = MyButton(self.frm, text="Help", cmd=self.doHelp,
+            style="pdf.TButton", underline=0)
+        ToolTip(self.bt7, "Show Key Bindings")
+        self.bt7.pack(padx=3, pady=3, side="right")
+        self.bt6 = MyButton(self.frm, text="Print", cmd=self.doPrint,
+            style="pdf.TButton", underline=0)
+        ToolTip(self.bt6, "Print Document")
+        self.bt6.pack(padx=3, pady=3, side="right")
+        self.bt5 = MyButton(self.frm, text="Rotate", cmd=self.doRotate,
+            style="pdf.TButton", underline=0)
+        ToolTip(self.bt5, "Rotate Document")
+        self.bt5.pack(padx=3, pady=3, side="right")
+        self.bt4 = MyButton(self.frm, text="Zoom", style="pdf.TButton")
+        self.bt4.bind("<Button-1>", self.doZoom)
+        self.bt4.bind("<Button-3>", self.doZoom)
+        ToolTip(self.bt4, "Left Button to Zoom in Increments of 25%. Right "\
+            "Button to UnZoom. Ctrl plus the Numeric Keypad +- Keys can "\
+            "also be used.")
+        self.bt4.pack(padx=3, pady=3, side="right")
+        self.frm.update_idletasks()
+        # Canvas
+        self.cv = tk.Canvas(self.win, highlightthickness=0)
+        # Create arrowless scrollbars
+        self.style.layout("h.TScrollbar", [
+            ("Horizontal.Scrollbar.trough", {
+                "children": [("Horizontal.Scrollbar.thumb", {
+                    "expand": "1",
+                    "sticky": "nswe"})],
+                "sticky": "ew"})])
+        self.horz = ttk.Scrollbar(self.win, orient="horizontal",
+            style="h.TScrollbar")
+        self.horz.config(command=self.cv.xview)
+        self.cv.config(xscrollcommand=self.horz.set)
+        self.horz.pack(fill="x", expand="no", side="bottom")
+        self.cv.pack(expand="yes")
+        if sys.platform == "win32":
+            self.cv.bind("<MouseWheel>", self.doWheel)
+        else:
+            self.cv.bind("<Button-4>", self.doWheel)
+            self.cv.bind("<Button-5>", self.doWheel)
+        self.cv.bind("<Escape>", self.doClose)
+        self.cv.bind("<F1>", self.doHelp)
+        self.cv.bind("<F2>", self.doContents)
+        self.cv.bind("<Home>", self.homePage)
+        self.cv.bind("<Next>", self.nextPage)
+        self.cv.bind("<Prior>", self.priorPage)
+        self.cv.bind("<End>", self.lastPage)
+        self.cv.bind("<Up>", self.doKey)
+        self.cv.bind("<Down>", self.doKey)
+        self.cv.bind("<Left>", self.doKey)
+        self.cv.bind("<Right>", self.doKey)
+        self.cv.bind("<Control-f>", self.doSearch)
+        self.cv.bind("<Control-n>", self.nextSearch)
+        self.cv.bind("<Control-e>", self.endSearch)
+        self.cv.bind("<Control-KP_Add>", self.doZoom)
+        self.cv.bind("<Control-KP_Subtract>", self.doZoom)
+        self.win.update_idletasks()
+        # Scale settings
+        self.scale = 1
+        self.mat = fitz.Matrix(1, 1)
+        self.zoom = self.scale
+        # Other settings
+        self.pgno = 1
+        self.pags = []
+        self.cont = False
+        self.help = False
+        self.prec = {}
+        self.search = ""
+        self.wsiz = []
+        # Display 1st page
+        self.showPage()
+        self.win.wait_window()
+
+    def doPassword(self):
+        def enterPwd(event=None):
+            self.pwd = ent.get()
+            frm.destroy()
+        frm = MyFrame()
+        frm.pack()
+        lab = MyLabel(frm, text="Enter Password")
+        lab.pack(side="left")
+        ent = MyEntry(frm)
+        ent.pack(side="left")
+        ent.bind("<Return>", enterPwd)
+        ent.bind("<KP_Enter>", enterPwd)
+        self.win.deiconify()
+        ent.focus_set()
+        frm.wait_window()
+        if not self.doc.authenticate(self.pwd):
+            self.win.destroy()
+            showError(None, "Error", "Invalid Password")
+            return
+        return True
+
+    def doWheel(self, event=None):
+        if sys.platform == "win32":
+            scroll = -1 if event.delta > 0 else 1
+        else:
+            scroll = -1 if event.num == 4 else 1
+        if scroll == 1:
+            self.doScroll("Down", scroll)
+        else:
+            self.doScroll("Up", scroll)
+
+    def doKey(self, event=None):
+        scroll = -1 if event.keysym in ("Up", "Left") else 1
+        self.doScroll(event.keysym, scroll)
+
+    def doScroll(self, key, scroll):
+        self.cv.update_idletasks()
+        if key == "Down" and self.cv.yview()[1] == 1:
+            self.nextPage()
+        elif key == "Up" and self.cv.yview()[0] == 0:
+            self.priorPage(pos="end")
+        elif key in ("Up", "Down") and self.cv.yview() != (0.0, 1.0):
+            self.cv.yview_scroll(scroll, "units")
+        elif self.cv.xview() != (0.0, 1.0):
+            self.cv.xview_scroll(scroll, "units")
+
+    def homePage(self, event=None):
+        self.pgno = 1
+        self.showPage("top")
+
+    def lastPage(self, event=None):
+        self.pgno = self.lastpg
+        self.showPage("top")
+
+    def nextPage(self, event=None):
+        if self.pgno == self.lastpg:
+            return
+        self.pgno += 1
+        self.showPage("top")
+
+    def priorPage(self, event=None, pos="top"):
+        if self.pgno == 1:
+            return
+        self.pgno -= 1
+        self.showPage(pos)
+
+    def gotoPage(self, event=None):
+        self.pgd.configure(state="normal")
+        self.pgd.selection_range(0, "end")
+        self.pgd.focus_set()
+
+    def enterPage(self, event=None):
+        pgno = int(self.pgd.get())
+        if pgno < 1 or pgno > self.lastpg:
+            self.pgd.selection_range(0, "end")
+            return
+        self.pgno = pgno
+        self.showPage("top")
+
+    def doZoom(self, event=None):
+        if event.num == 3 or event.keysym == "KP_Subtract":
+            if self.zoom > self.scale:
+                self.zoom = round((self.zoom - .25), 2)
+        elif self.zoom < (self.scale + 2):
+            while self.zoom <= self.mat[0]:
+                self.zoom = round((self.zoom + .25), 2)
+        self.wsiz = []
+        self.mat[0] = self.mat[3] = self.zoom
+        self.showPage()
+
+    def doRotate(self, event=None):
+        page = self.doc[self.pgno - 1]
+        rot = page.rotation
+        if rot == 270:
+            rot = 0
+        else:
+            rot += 90
+        page.setRotation(rot)
+        self.showPage()
+
+    def doSearch(self, event=None):
+        def getSearch(event=None):
+            self.search = ent.get()
+            self.pags = []
+            self.prec = {}
+            for page in self.doc:
+                annot = page.firstAnnot
+                while annot:
+                    annot = page.deleteAnnot(annot)
+                self.found = page.searchFor(self.search)
+                for inst in self.found:
+                    numb = (page.number + 1)
+                    if numb not in self.pags:
+                        self.pags.append(numb)
+                        self.prec[numb] = inst
+                    page.addHighlightAnnot(inst)
+            if self.pags:
+                self.pgno = self.pags[0]
+            frm.destroy()
+        def doQuit(event=None):
+            frm.destroy()
+        self.doUnbind()
+        frm = MyFrame(self.cv, bg="black", borderwidth=5)
+        tit = MyLabel(frm, text="Search For", anchor="c", relief="raised")
+        tit.pack(fill="x")
+        ent = MyEntry(frm, width=30)
+        if self.search:
+            ent.insert(0, self.search)
+            ent.selection_range(0, "end")
+        ent.pack(fill="x")
+        tt = ToolTip(ent, "Once you are in Search Mode these Keys Apply:\n"\
+            "<Ctrl-n> Scroll to Next Occurrence of Search String\n"\
+            "<Ctrl-e> Clear All Highlights and Exit Search Mode.")
+        tt.pause = None
+        ent.bind("<Escape>", doQuit)
+        ent.bind("<Return>", getSearch)
+        ent.bind("<KP_Enter>", getSearch)
+        frm.place(anchor="center", relx=0.5, rely=0.5)
+        ent.focus_set()
+        frm.wait_window()
+        if not self.found:
+            sp = SplashScreen(self.win, "Sorry, Not Found")
+            time.sleep(2)
+            sp.closeSplash()
+        self.doUnbind(False)
+        self.showPage()
+
+    def nextSearch(self, event=None):
+        if self.pags:
+            if self.pgno < self.pags[-1]:
+                for pag in self.pags:
+                    if pag > self.pgno:
+                        break
+            else:
+                pag = self.pags[0]
+            self.pgno = pag
+            self.showPage()
+
+    def endSearch(self, event=None):
+        self.pags = []
+        self.prec = {}
+        self.search = ""
+        for page in self.doc:
+            annot = page.firstAnnot
+            while annot:
+                annot = page.deleteAnnot(annot)
+        self.showPage()
+
+    def doUnbind(self, unbind=True, key=True, exc=None):
+        if unbind:
+            if key:
+                self.cvbinds = []
+                for bind in self.cv.bind():
+                    if bind != exc:
+                        self.cvbinds.append((bind, self.cv.bind(bind)))
+                        self.cv.unbind(bind)
+            for x in range(1, 8):
+                bt = getattr(self, "bt%s" % x)
+                bt.configure(state="disabled")
+        else:
+            if key:
+                for bind in self.cvbinds:
+                    self.cv.bind(bind[0], bind[1])
+            for x in range(1, 8):
+                bt = getattr(self, "bt%s" % x)
+                bt.configure(state="normal")
+        self.win.update_idletasks()
+
+    def showPage(self, pos=None):
+        self.cv.delete("all")
+        page = self.doc[self.pgno - 1]
+        dlist = page.getDisplayList()
+        self.pgd.configure(state="normal")
+        self.pgd.delete(0, "end")
+        self.pgd.insert(0, "%s" % CCD(self.pgno, "UI", self.entsiz).disp)
+        self.pgd.configure(state="disabled")
+        pix = dlist.getPixmap(matrix=self.mat, alpha=False)
+        self.ti = tk.PhotoImage(data=pix.getImageData("ppm"))
+        self.cv.create_image(0, 0, image=self.ti, anchor="nw", tags="img")
+        self.cv.configure(width=self.ti.width(), height=self.ti.height())
+        self.win.update_idletasks()
+        # Limit display size to 90% of screen size
+        wsiz = [self.win.winfo_reqwidth(), self.win.winfo_reqheight()]
+        if wsiz[0] > self.sw:
+            wsiz[0] = self.sw
+        if wsiz[1] > self.sh:
+            wsiz[1] = self.sh
+        if wsiz != self.wsiz:
+            # Re-size and place window
+            placeWindow(self.win, place="C", size=wsiz, expose=True)
+            self.cv.configure(scrollregion=self.cv.bbox("all"))
+            self.wsiz = wsiz
+        if pos and pos == "top":
+            # Scroll to top
+            self.cv.yview_moveto("0.0")
+        elif pos and pos == "end":
+            # Scroll to bottom
+            self.cv.yview_moveto("1.0")
+        elif self.pags or self.cont:
+            # Scroll to next highlighted text
+            self.cv.yview_moveto("0.0")
+            rect = self.prec[self.pgno]
+            if self.zoom != self.scale:
+                c1 = rect[1] * self.zoom
+            else:
+                c1 = rect[1]
+            y1, y2 = self.getVisibleArea()
+            while not y1 <= c1 <= y2:
+                self.doScroll("Down", 1)
+                y1, y2 = self.getVisibleArea()
+            if self.cont:
+                self.cont = False
+        self.win.update_idletasks()
+        self.cv.focus_set()
+
+    def getVisibleArea(self):
+        y1 = self.cv.canvasy(0)
+        if y1 == -1:
+            y1 = 0
+        y2 = self.cv.canvasy(self.cv.winfo_height())
+        if self.zoom !=self.scale:
+            y2 = y2 - (self.zoom * 20)
+        return (y1, y2)
+
+    def doHelp(self, event=None):
+        cols = (
+            (0, "Keys", 6, "NA", None),
+            (1, "Action", 35, "NA", None))
+        data = (
+            ("F1", "This help"),
+            ("F2", "A Table of Contents, if available"),
+            ("Alt g", "Go To Page"),
+            ("Alt f", "Former Page"),
+            ("Alt n", "Next Page"),
+            ("Alt p", "Print the Document"),
+            ("Alt h", "This help"),
+            ("Alt c", "Close the Document"),
+            ("Ctrl +", "Zoom"),
+            ("Ctrl -", "Reverse Zoom"),
+            ("Ctrl f", "Search for text"),
+            ("Ctrl n", "Next occurrence of text"),
+            ("Ctrl e", "Clear highlighted text"),
+            ("Arrows", "Scroll up, down, left and right"),
+            ("Esc", "Close the Current View"))
+        self.doUnbind(exc="<Key-F1>")
+        SelectChoice(self.cv, titl="Keyboard Bindings", deco=False, modal=True,
+            cols=cols, data=data, font=self.font, lines=len(data), sort=False,
+            scrl=False, live=False)
+        self.doUnbind(False)
+        self.cv.focus_force()
+
+    def doContents(self, event=None):
+        sp = SplashScreen(self.win, "Generating Table of Contents\n\n"\
+            "Please Wait...")
+        def getData(page):
+            txts = []
+            blocks = page.getText("dict")["blocks"]
+            for b in blocks:
+                if b["type"] == 0:
+                    for l in b["lines"]:
+                        txt = ""
+                        siz = 0
+                        for s in l["spans"]:
+                            t = s["text"]
+                            if t and not txt.count("Table of Contents"):
+                                if not siz:
+                                    siz = s["size"]
+                                if not txt:
+                                    txt = t
+                                else:
+                                    txt += t
+                        if txt:
+                            txts.append((siz, txt, page.number + 1))
+            return txts
+        sizs = {}
+        for page in self.doc:
+            for data in getData(page):
+                if data[0] not in sizs:
+                    sizs[data[0]] = 1
+                else:
+                    sizs[data[0]] += 1
+        if sizs:
+            cnts = [0, 0]
+            for siz in sizs:
+                if sizs[siz] > cnts[1]:
+                    cnts = [siz, sizs[siz]]
+            mxss = 0
+            tabs = []
+            spcs = list(sizs.keys())
+            spcs.remove(cnts[0])
+            spcs.sort(reverse=True)
+            for page in self.doc:
+                for data in getData(page):
+                    if data[0] <= cnts[0]:
+                        continue
+                    text = "%s%s" % ("  " * spcs.index(data[0]), data[1])
+                    tabs.append((text, data[2]))
+                    if len(text) > mxss:
+                        mxss = len(text)
+        if not sizs or not tabs:
+            sp.refreshSplash(text="Sorry, No Table Found")
+            time.sleep(2)
+            sp.closeSplash()
+            self.cv.focus_force()
+            return
+        sp.closeSplash()
+        cols = (
+            (0, "Description", mxss, "TX", "Y"),
+            (1, "Page", 4, "UI", None))
+        self.doUnbind()
+        sc = SelectChoice(self.cv, titl="Table of Contents", deco=False,
+            modal=True, cols=cols, data=tabs, font=self.font, sort=True)
+        self.doUnbind(False)
+        if sc.selection:
+            for page in self.doc:
+                annot = page.firstAnnot
+                while annot:
+                    annot = page.deleteAnnot(annot)
+            page = self.doc[int(sc.selection[2]) - 1]
+            found = page.searchFor(sc.selection[1])
+            page.addHighlightAnnot(found[0])
+            self.pgno = int(sc.selection[2])
+            self.prec[self.pgno] = found[0]
+            self.cont = True
+            self.showPage()
+        else:
+            self.cv.focus_force()
+
+    def doPrint(self):
+        def doDisable(event=None):
+            ent.delete(0, "end")
+            ent.configure(state="disabled")
+
+        def doPages(event=None):
+            ent.configure(state="normal")
+            ent.focus_set()
+
+        def doCancel(event=None):
+            win.destroy()
+            self.cv.focus_force()
+
+        def doExec(event=None):
+            try:
+                nam = lbx.get("active")
+                sel = var.get()
+                if sel == "A":
+                    fle = self.pdfnam
+                else:
+                    if sel == "P":
+                        wrk = ent.get().split(",")
+                        wrk = list(dict.fromkeys(wrk))
+                        pag = []
+                        for w in wrk:
+                            p = int(w) - 1
+                            if p in self.doc:
+                                pag.append(p)
+                        pag.sort()
+                    else:
+                        pag = [self.pgno - 1]
+                    if not pag:
+                        raise Exception("No Valid Pages Selected")
+                    tme = "%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3]
+                    fle = os.path.join(tempfile.gettempdir(), "%s.pdf" % tme)
+                    doc2 = fitz.open()
+                    for pg in pag:
+                        doc2.insertPDF(self.doc, from_page=pg, to_page=pg)
+                    doc2.save(fle)
+                    doc2.close()
+                cpy = int(spn.get())
+                printPDF(nam, fle, cpy)
+                doCancel()
+            except Exception as err:
+                doCancel()
+                if self.mf:
+                    wrk = self.mf.rcdic["wrkdir"]
+                else:
+                    wrk = tempfile.gettempdir()
+                showException(self.cv, wrk, err)
+
+        def getDevices():
+            dflt = None
+            prts = []
+            if sys.platform == "win32":
+                import win32print
+                dflt = win32print.GetDefaultPrinter()
+                lst = win32print.EnumPrinters(2)
+                for l in lst:
+                    prts.append(l[2].strip())
+            else:
+                proc = subprocess.Popen("lpstat -d", shell=True, bufsize=0,
+                    stdin=subprocess.PIPE, stdout=subprocess.PIPE,
+                    stderr=subprocess.PIPE, close_fds=True)
+                prt = proc.stdout.readline()
+                if type(prt) == bytes:
+                    prt = prt.decode("utf-8")
+                if prt.count(":"):
+                    dflt = prt.strip().split(":")[1]
+                proc = subprocess.Popen("lpstat -e", shell=True, bufsize=0,
+                    stdin=subprocess.PIPE, stdout=subprocess.PIPE,
+                    stderr=subprocess.PIPE, close_fds=True)
+                lst = proc.stdout.readlines()
+                for l in lst:
+                    if type(l) == bytes:
+                        l = l.decode("utf-8")
+                    prts.append(l.rstrip())
+            return (dflt, prts)
+
+        dflt, prts = getDevices()
+        if not prts:
+            return
+        self.doUnbind()
+        win = MkWindow(trans=self.cv, modal=True, decor=False).newwin
+        win.configure(bg="black", borderwidth=2)
+        win.bind("<Enter>", self.doFocus)
+        fr1 = MyFrame(win, relief="ridge", borderwidth=2,
+            style="pdf.TFrame")
+        fr1.pack(fill="both", expand="yes")
+        lb1 = MyLabel(fr1, color=False, text="Available Printers",
+            relief="raised", style="pdfbold.TLabel")
+        lb1.pack(fill="x")
+        lbx = tk.Listbox(fr1, font=self.font, width=10)
+        for prt in prts:
+            lbx.insert("end", prt)
+        if dflt in prts:
+            idx = prts.index(dflt)
+        else:
+            idx = 0
+        lbx.selection_set(idx)
+        lbx.activate(idx)
+        lbx.pack(fill="both", expand="yes")
+        fr2 = MyFrame(win, relief="ridge", borderwidth=2,
+            style="pdf.TFrame")
+        fr2.pack(fill="both", expand="yes")
+        fr2 = MyFrame(win, relief="ridge", borderwidth=2,
+            style="pdf.TFrame")
+        fr2.pack(fill="both", expand="yes")
+        fr3 = MyFrame(fr2, style="pdf.TFrame")
+        fr3.pack(side="left", fill="both", expand="yes")
+        lb2 = MyLabel(fr3, color=False, text="Range", style="pdfbold.TLabel")
+        lb2.grid(row=0, column=0, sticky="w", columnspan=2)
+        var = tk.StringVar()
+        var.set("A")
+        rb1 = ttk.Radiobutton(fr3, variable=var, text="All Pages",
+            value="A", command=doDisable, style="pdf.TRadiobutton")
+        rb1.grid(row=1, column=0, sticky="w")
+        rb2 = ttk.Radiobutton(fr3, variable=var, text="Current Page",
+            value="C", command=doDisable, style="pdf.TRadiobutton")
+        rb2.grid(row=2, column=0, sticky="w")
+        rb3 = ttk.Radiobutton(fr3, variable=var, text="Pages",
+            value="P", command=doPages, style="pdf.TRadiobutton")
+        rb3.grid(row=3, column=0, sticky="w")
+        ent = MyEntry(fr3, font=self.font)
+        ToolTip(ent, "Enter page numbers separated by commas.")
+        ent.bind("<Return>", doExec)
+        ent.bind("<KP_Enter>", doExec)
+        ent.configure(state="disabled")
+        ent.grid(row=3, column=1)
+        fr4 = MyFrame(fr2, style="pdf.TFrame")
+        fr4.pack(side="left", fill="both", expand="yes")
+        lb3 = MyLabel(fr4, text="Copies", style="pdfbold.TLabel", color=False)
+        lb3.pack(fill="x")
+        spn = tk.Spinbox(fr4, from_=1, to=10, font=self.font)
+        spn.pack(fill="x")
+        fr5 = MyFrame(win, style="pdf.TFrame")
+        fr5.pack(fill="x", expand="yes")
+        bt1 = MyButton(fr5, text="Cancel", cmd=doCancel, underline=0,
+            style="pdf.TButton")
+        bt1.pack(side="left", fill="x", expand="yes")
+        bt2 = MyButton(fr5, text="Print", cmd=doExec, underline=0,
+            style="pdf.TButton")
+        bt2.pack(side="left", fill="x", expand="yes")
+        placeWindow(win, self.cv, expose=True)
+        lbx.focus_set()
+        win.wait_window()
+        self.win.update_idletasks()
+        self.doUnbind(False)
+        self.showPage()
+
+    def doClose(self, event=None):
+        self.doc.close()
+        self.win.destroy()
+
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'ass/__init__.py'
=== modified file 'ass/ar1010.py' (properties changed: -x to +x)
--- old/ass/ar1010.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar1010.py	2020-04-23 07:28:48 +0000
@@ -124,7 +124,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["assmst", "D", "%03i%-3s%-7s" % \
             (self.opts["conum"], self.group, self.code), "", dte,
-            self.opts["capnm"], "", "", 0])
+            self.opts["capnm"], "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -132,7 +132,9 @@
         data = [self.opts["conum"]]
         for x in xrange(0, len(self.df.t_work[0][0]) - 1):
             data.append(self.df.t_work[0][0][x])
-        if data != self.old[:len(data)]:
+        col = self.sql.assmst_col
+        data.append(self.old[col.index("asm_xflag")])
+        if data != self.old:
             self.sql.updRec("assmst", data=data, where=[("asm_cono",
                 "=", self.opts["conum"]), ("asm_group", "=", self.group),
                 ("asm_code", "=", self.code)])
@@ -141,8 +143,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["assmst", "U",
                         "%03i%-3s%-7s" % (self.opts["conum"], self.group,
-                        self.code), self.sql.assmst_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.code), col[num], dte, self.opts["capnm"],
+                        str(dat), str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'ass/ar2010.py' (properties changed: -x to +x)
=== modified file 'ass/ar2020.py' (properties changed: -x to +x)
--- old/ass/ar2020.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar2020.py	2020-06-20 10:15:27 +0000
@@ -308,8 +308,7 @@
                 self.df.loadEntry(frt, pag, p+2, data=self.vatcode)
                 self.df.loadEntry(frt, pag, p+3, data=self.trnvat)
                 return "sk3"
-            else:
-                return "sk1"
+            return "sk1"
 
     def doRorAmt(self, frt, pag, r, c, p, i, w):
         if self.opts["rtn"] == 3 and self.trnmov == 5 and w > 0:

=== modified file 'ass/ar2030.py' (properties changed: -x to +x)
--- old/ass/ar2030.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar2030.py	2020-06-21 13:04:46 +0000
@@ -57,7 +57,7 @@
         self.lastp = assctl["cta_lastp"]
         self.sper = int(self.opts["period"][1][0] / 100)
         self.eper = int(self.opts["period"][2][0] / 100)
-        yr = self.lastp / 100
+        yr = int(self.lastp / 100)
         mt = (self.lastp % 100) + 1
         if mt > 12:
             yr += 1
@@ -110,67 +110,67 @@
             self.df.closeProcess()
             recs = self.sql.getRec("assmst", where=[("asm_cono", "=",
                 self.opts["conum"])])
-        abort = False
         if recs:
+            self.doRaiseAll(recs)
+        if "wait" not in self.opts:
+            self.opts["mf"].closeLoop()
+
+    def doRaiseAll(self, recs):
+        if not self.args:
+            p = ProgressBar(self.opts["mf"].body, mxs=len(recs),
+                typ="Raising Depreciation ... Please Wait")
+        for num, dat in enumerate(recs):
             if not self.args:
-                p = ProgressBar(self.opts["mf"].body, mxs=len(recs),
-                    typ="Raising Depreciation ... Please Wait")
-            for num, dat in enumerate(recs):
+                p.displayProgress(num)
+            self.group = CCD(dat[self.sql.assmst_col.index("asm_group")],
+                "UA", 3)
+            grp = self.sql.getRec("assgrp", where=[("asg_cono", "=",
+                self.opts["conum"]), ("asg_group", "=", self.group.work)],
+                limit=1)
+            if not grp:
                 if not self.args:
-                    p.displayProgress(num)
-                self.group = CCD(dat[self.sql.assmst_col.index("asm_group")],
-                    "UA", 3)
-                grp = self.sql.getRec("assgrp", where=[("asg_cono", "=",
-                    self.opts["conum"]), ("asg_group", "=", self.group.work)],
-                    limit=1)
-                if not grp:
-                    if not self.args:
-                        showError(self.opts["mf"].body, "Group Error",
-                            "Missing Group (%s) Record" % self.group.disp)
-                    abort = True
-                    break
-                self.depacc = grp[self.sql.assgrp_col.index("asg_depacc")]
-                self.expacc = grp[self.sql.assgrp_col.index("asg_expacc")]
-                self.code = dat[self.sql.assmst_col.index("asm_code")]
-                self.depcod = dat[self.sql.assmst_col.index("asm_depcod")]
-                bals = Balances(self.opts["mf"], "ASS", self.opts["conum"],
-                    self.sper, keys=(self.group.work, self.code))
-                asset = bals.doAssBals()
-                if not asset:
-                    continue
-                self.cap, cdp, rdp, cbl, rbl, mov = asset
-                # Raise depreciation from start period to curdt or sale date
-                self.lurdt = self.sper
-                sales = False
-                while not sales and self.lurdt <= self.curdt:
-                    trans = self.sql.getRec("asstrn", cols=["ast_mtyp",
-                        "round(sum(ast_amt1), 2)"], where=[("ast_cono", "=",
-                        self.opts["conum"]), ("ast_group", "=",
-                        self.group.work), ("ast_code", "=", self.code),
-                        ("ast_curdt", "=", self.lurdt), ("ast_mtyp", "<>", 4)],
-                        group="ast_mtyp")
-                    if trans:
-                        for mov, amt in trans:
-                            if mov == 5:
-                                sales = True
-                                self.cap = 0
-                                break
-                            self.cap = float(ASD(self.cap) + ASD(amt))
-                    if self.cap:
-                        self.doRaiseDep()
-                    self.lurdt = self.doIncrCurdt()
-            if not self.args:
-                p.closeProgress()
-            if abort:
-                self.opts["mf"].dbm.rollbackDbase()
-            else:
-                self.opts["mf"].dbm.commitDbase()
-        if not abort:
+                    showError(self.opts["mf"].body, "Group Error",
+                        "Missing Group (%s) Record" % self.group.disp)
+                abort = True
+                break
+            self.depacc = grp[self.sql.assgrp_col.index("asg_depacc")]
+            self.expacc = grp[self.sql.assgrp_col.index("asg_expacc")]
+            self.code = dat[self.sql.assmst_col.index("asm_code")]
+            self.depcod = dat[self.sql.assmst_col.index("asm_depcod")]
+            bals = Balances(self.opts["mf"], "ASS", self.opts["conum"],
+                self.sper, keys=(self.group.work, self.code))
+            asset = bals.doAssBals()
+            if not asset:
+                continue
+            self.cap, cdp, rdp, cbl, rbl, mov = asset
+            # Raise depreciation from start period to curdt or sale date
+            self.lurdt = self.sper
+            sales = False
+            while not sales and self.lurdt <= self.curdt:
+                trans = self.sql.getRec("asstrn", cols=["ast_mtyp",
+                    "round(sum(ast_amt1), 2)"], where=[("ast_cono", "=",
+                    self.opts["conum"]), ("ast_group", "=",
+                    self.group.work), ("ast_code", "=", self.code),
+                    ("ast_curdt", "=", self.lurdt), ("ast_mtyp", "<>", 4)],
+                    group="ast_mtyp")
+                if trans:
+                    for mov, amt in trans:
+                        if mov == 5:
+                            sales = True
+                            self.cap = 0
+                            break
+                        self.cap = float(ASD(self.cap) + ASD(amt))
+                if self.cap:
+                    self.doRaiseDep()
+                self.lurdt = self.doIncrCurdt()
+        if not self.args:
+            p.closeProgress()
+        if abort:
+            self.opts["mf"].dbm.rollbackDbase()
+        else:
             self.sql.updRec("assctl", cols=["cta_lastp"], data=[self.curdt],
                 where=[("cta_cono", "=", self.opts["conum"])])
             self.opts["mf"].dbm.commitDbase()
-        if "wait" not in self.opts:
-            self.opts["mf"].closeLoop()
 
     def doIncrCurdt(self):
         yr = int(self.lurdt / 100)

=== modified file 'ass/ar3010.py' (properties changed: -x to +x)
--- old/ass/ar3010.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar3010.py	2020-05-27 11:49:54 +0000
@@ -111,9 +111,8 @@
 
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%03u %-30s %49s %10s" %
-            (self.opts["conum"], self.opts["conam"], self.sysdttm,
-                self.__class__.__name__))
+        self.head = ("%03u %-30s %49s %10s" % (self.opts["conum"],
+            self.opts["conam"], self.sysdttm, self.__class__.__name__))
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.btot = [0, 0]
         self.pgnum = 0
@@ -165,8 +164,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)

=== modified file 'ass/ar3020.py' (properties changed: -x to +x)
--- old/ass/ar3020.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar3020.py	2020-06-20 12:29:26 +0000
@@ -226,8 +226,7 @@
             self.typeTotal()
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -309,13 +308,13 @@
         self.totind = "Y"
         self.pageHeading()
         tot = [0,0,0,0]
-        for x in xrange(0, len(artrtp)):
+        for x, t in enumerate(artrtp):
             cnt = CCD(self.gcnt[x], "SI", 7)
             mt1 = CCD(self.gmt1[x], "SD", 13.2)
             mt2 = CCD(self.gmt2[x], "SD", 13.2)
             vat = CCD(self.gvat[x], "SD", 13.2)
             self.fpdf.drawText("%-31s %s %s %s %s" % \
-                (artrtp[x][1], cnt.disp, mt1.disp, mt2.disp, vat.disp))
+                (t[1], cnt.disp, mt1.disp, mt2.disp, vat.disp))
             tot[0] = tot[0] + cnt.work
             tot[1] = float(ASD(tot[1]) + ASD(mt1.work))
             tot[2] = float(ASD(tot[2]) + ASD(mt2.work))

=== modified file 'ass/ar3030.py' (properties changed: -x to +x)
--- old/ass/ar3030.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar3030.py	2020-05-27 12:21:09 +0000
@@ -193,8 +193,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'ass/ar3040.py' (properties changed: -x to +x)
--- old/ass/ar3040.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar3040.py	2020-06-20 12:05:53 +0000
@@ -86,16 +86,16 @@
                 eper,"Y",self.doPeriod,None,None,("efld",))]
         if self.rordp == "Y":
             fld.append((("T",0,1,0),("IRB",r1s),0,"Report Type","",
-                "C","Y",self.doType,None,None,None))
+                "C","N",self.doType,None,None,None))
             seq = 2
         else:
             seq = 1
             self.rtype = "C"
         fld.extend([
             (("T",0,seq,0),"IUA",3,"Asset Group","",
-                "","Y",self.doGroup,grp,None,None),
+                "","N",self.doGroup,grp,None,None),
             (("T",0,seq+1,0),("IRB",r2s),0,"Ignore Zero Items","",
-                "N","Y",self.doZero,None,None,None)])
+                "Y","N",self.doZero,None,None,None)])
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
@@ -149,8 +149,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Asset Register Report as at %s" % self.sysdtd)
         self.expheads.append("Options: Report Period: %s Report Type: %s" % \
@@ -158,12 +157,12 @@
         self.expcolsh = [self.colsh]
         self.expforms = self.forms
         self.expdatas = []
-        for num, dat in enumerate(recs):
-            p.displayProgress(num)
+        for seq, dat in enumerate(recs):
+            p.displayProgress(seq)
             if p.quit:
                 p.closeProgress()
                 return
-            if not num:
+            if not seq:
                 desc = self.groupDesc(dat[0])
                 self.expdatas.append(["HEAD", ["", "Group %s %s" % (dat[0],
                     desc)]])
@@ -212,13 +211,12 @@
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head1)
         self.pgnum = 0
         self.pglin = 999
-        for num, dat in enumerate(recs):
-            p.displayProgress(num)
+        for seq, dat in enumerate(recs):
+            p.displayProgress(seq)
             if p.quit:
                 break
             grp = CCD(dat[0], "UA", 3)
@@ -294,9 +292,7 @@
         if woff or sold:
             vals[8] = vals[9]
             vals[9] = 0
-        if self.zero == "Y" and not vals[2] and not vals[3] and not \
-                vals[4] and not vals[5] and not vals[6] and not \
-                vals[7] and not vals[8] and not vals[9]:
+        if self.zero == "Y" and all(v == 0 for v in vals[2:10]):
             return
         return vals
 
@@ -329,8 +325,7 @@
             group)], limit=1)
         if not acc:
             return ""
-        else:
-            return acc[0]
+        return acc[0]
 
     def groupTotal(self):
         if self.df.repprt[2] == "export":

=== modified file 'ass/ar3050.py' (properties changed: -x to +x)
=== modified file 'ass/ar4010.py' (properties changed: -x to +x)
--- old/ass/ar4010.py	2020-04-21 08:42:36 +0000
+++ new/ass/ar4010.py	2020-05-27 12:21:38 +0000
@@ -295,8 +295,7 @@
         if opt == "N":
             return
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if self.rordp == "Y":
             self.head = ("%03u %-30s %51s %10s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, self.__class__.__name__))

=== modified file 'ass/ar6010.py' (properties changed: -x to +x)
=== modified file 'ass/arc110.py' (properties changed: -x to +x)
--- old/ass/arc110.py	2020-04-21 08:42:36 +0000
+++ new/ass/arc110.py	2020-06-20 10:32:44 +0000
@@ -94,7 +94,7 @@
             (("T",0,seq + 1,0),"Id2",7,"Last Dep Period","",
                 self.acc[3],"N",None,None,None,None),
             (("T",0,seq + 2,0),"ITX",50,"Email Address","",
-                self.acc[4],"N",None,None,None,None)])
+                self.acc[4],"N",None,None,None,("email",))])
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -121,8 +121,7 @@
             ("glm_acno", "=", acno)], limit=1)
         if acc:
             return acc[0]
-        else:
-            return ""
+        return ""
 
     def doGlint(self, frt, pag, r, c, p, i, w):
         if w == "N":
@@ -165,14 +164,16 @@
         if self.new:
             self.sql.insRec("assctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.assctl_col
+            data.append(self.acc[col.index("cta_xflag")])
             self.sql.updRec("assctl", data=data, where=[("cta_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["assctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.assctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]), 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'ass/arc210.py' (properties changed: -x to +x)
--- old/ass/arc210.py	2020-04-21 08:42:36 +0000
+++ new/ass/arc210.py	2020-04-23 10:40:14 +0000
@@ -158,9 +158,10 @@
                 if self.new == "Y":
                     self.sql.insRec("assdep", data=data)
                 elif data != self.acc[:len(data)]:
-                    self.sql.updRec("assdep", data=data,
-                        where=[("asd_cono", "=", self.opts["conum"]),
-                        ("asd_code", "=", self.code)])
+                    col = self.sql.assdep_col
+                    data.append(self.acc[col.index("asd_xflag")])
+                    self.sql.updRec("assdep", data=data, where=[("asd_cono",
+                        "=", self.opts["conum"]), ("asd_code", "=", self.code)])
                 self.opts["mf"].dbm.commitDbase()
                 self.df.focusField("T", 0, 1)
             else:

=== modified file 'ass/arc310.py' (properties changed: -x to +x)
--- old/ass/arc310.py	2020-04-21 08:42:36 +0000
+++ new/ass/arc310.py	2020-10-01 13:30:42 +0000
@@ -34,8 +34,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["assdep", "assgrp", "genmst"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["assdep", "assgrp", "assmst",
+            "genmst"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -107,9 +107,10 @@
             self.df.loadEntry(frt, pag, p+1, data=self.acc[2])
             self.df.loadEntry(frt, pag, p+2, data=self.acc[3])
             dep = self.sql.getRec("assdep", cols=["asd_desc"],
-                where=[("asd_cono", "=", self.opts["conum"]), ("asd_code", "=",
-                self.acc[3])], limit=1)
-            self.df.loadEntry(frt, pag, p+3, data=dep[0])
+                where=[("asd_cono", "=", self.opts["conum"]),
+                ("asd_code", "=", self.acc[3])], limit=1)
+            if dep:
+                self.df.loadEntry(frt, pag, p+3, data=dep[0])
             if self.glint == "N":
                 return
             self.df.loadEntry(frt, pag, p+4, data=self.acc[4])
@@ -184,6 +185,8 @@
         if self.new == "Y":
             self.sql.insRec("assgrp", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.assgrp_col
+            data.append(self.acc[col.index("asg_xflag")])
             self.sql.updRec("assgrp", data=data, where=[("asg_cono", "=",
                 self.opts["conum"]), ("asg_group", "=", self.group)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'ass/arc320.py' (properties changed: -x to +x)
--- old/ass/arc320.py	2020-03-01 12:48:20 +0000
+++ new/ass/arc320.py	2020-05-27 11:55:00 +0000
@@ -63,10 +63,9 @@
         odr = "asg_group"
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=col, order=odr, where=whr, conum=self.opts["conum"],
-            conam=self.opts["conam"], repprt=self.df.repprt,
-            repeml=self.df.repeml, fromad=self.fromad)
+            heads=heads, cols=col, where=whr, order=odr,
+            conum=self.opts["conum"], conam=self.opts["conam"],
+            repprt=self.df.repprt, repeml=self.df.repeml, fromad=self.fromad)
         self.df.enableButtonsTags(state=state)
         self.closeProcess()
 

=== added file 'bkm/__init__.py'
=== modified file 'bkm/bk1010.py' (properties changed: -x to +x)
--- old/bkm/bk1010.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk1010.py	2020-04-27 16:45:07 +0000
@@ -60,7 +60,6 @@
         self.newb = False
         udics = {}
         self.start = projectDate(self.sysdtw, -7)
-        self.start = 20160101
         bkm = self.sql.getRec("bkmmst", cols=["max(bkm_depart)"],
             where=[("bkm_cono", "=", self.opts["conum"]), ("bkm_state",
             "<>", "X")], limit=1)
@@ -78,7 +77,7 @@
             self.quit = True
             return
         col = self.sql.bkmunm_col
-        for unit in bkmunm:
+        for num, unit in enumerate(bkmunm):
             t = unit[col.index("bum_btyp")]
             c = unit[col.index("bum_code")]
             d = unit[col.index("bum_desc")]
@@ -86,8 +85,13 @@
             if t == "A" and c == "ALL":
                 continue
             udics["%s-%s" % (t, c)] = [d, CCD(m, "UI", 3).disp] + [""] * days
-        books = self.sql.getRec(
-            tables="bkmmst",
+        for x in range(num, 10):
+            t = "X"
+            c = x - num
+            d = ""
+            m = "   "
+            udics["%s-%s" % (t, c)] = [d, m] + [""] * days
+        books = self.sql.getRec(tables="bkmmst",
             cols=[
                 "bkm_number",
                 "bkm_btype",

=== modified file 'bkm/bk1020.py' (properties changed: -x to +x)
--- old/bkm/bk1020.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk1020.py	2020-06-21 10:06:32 +0000
@@ -401,8 +401,8 @@
                 else:
                     self.aunits[unt] = {"desc": des, "qty": qty, "rms": {}}
                     if typ == "A":
-                        for r in xrange(1, rms + 1):
-                            self.aunits[unt]["rms"][r] = True
+                        for rr in xrange(1, rms + 1):
+                            self.aunits[unt]["rms"][rr] = True
             bks = self.sql.getRec(tables=["bkmmst", "bkmrtt"],
                 cols=[
                     "bkm_arrive",
@@ -1062,14 +1062,16 @@
             self.newcon = False
         elif condat != self.oldcon[:len(condat)]:
             changed = True
+            col = self.sql.bkmcon_col
+            condat.append(self.oldcon[col.index("bkc_xflag")])
             self.sql.updRec("bkmcon", data=condat, where=[("bkc_cono", "=",
                 self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
             for num, dat in enumerate(self.oldcon):
                 if dat != condat[num]:
                     self.sql.insRec("chglog", data=["bkmcon", "U",
                         "%03i%-7s" % (self.opts["conum"], self.ccode),
-                        self.sql.bkmcon_col[num], trdt, self.opts["capnm"],
-                        str(dat), str(condat[num]), 0])
+                        col[num], trdt, self.opts["capnm"], str(dat),
+                        str(condat[num]), "", 0])
         mstdat = [self.opts["conum"]]
         for x in xrange(len(self.df.t_work[1][0])):
             if x in (6, 13):
@@ -1098,14 +1100,16 @@
             self.df.loadEntry("T", 1, 0, data=self.number)
         elif mstdat != self.oldmst[:len(mstdat)]:
             changed = True
+            col = self.sql.bkmmst_col
+            mstdat.append(self.oldmst[col.index("bkm_xflag")])
             self.sql.updRec("bkmmst", data=mstdat, where=[("bkm_cono", "=",
                 self.opts["conum"]), ("bkm_number", "=", self.number)])
             for num, dat in enumerate(self.oldmst):
                 if dat != mstdat[num]:
                     self.sql.insRec("chglog", data=["bkmmst", "U",
                         "%03i%7s" % (self.opts["conum"], self.number),
-                        self.sql.bkmmst_col[num], trdt, self.opts["capnm"],
-                        str(dat), str(mstdat[num]), 0])
+                        col[num], trdt, self.opts["capnm"], str(dat),
+                        str(mstdat[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         if self.rev:
             self.df.setWidget(self.df.mstFrame, state="hide")
@@ -1602,7 +1606,7 @@
                         args=[self.number])
                     self.df.setWidget(self.df.mstFrame, state="show")
                     break
-                elif rec.selection:
+                if rec.selection:
                     self.df.setWidget(self.df.mstFrame, state="hide")
                     if rec.selection[4] == 2:
                         PrintBookingInvoice(self.opts["mf"],
@@ -1713,8 +1717,7 @@
                         emess = ("Booking Cancellation - %s" % self.number,
                             "Dear %s\n\nAttached please find the expiry of "\
                             "your booking enquiry." % nam)
-                    if self.pr.repeml[3]:
-                        self.pr.repeml[3][0] = emess[0]
+                    self.pr.repeml[3] = emess
             if ln[tdc.index("tpd_detseq")] == 7:
                 if self.state in ("Q", "C"):
                     ln[tdc.index("tpd_text")] = "%-20s%60s" % \
@@ -1724,8 +1727,7 @@
         if not error:
             key = "%s_%s" % (self.opts["conum"], self.number)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                key, ext="pdf")
+                self.__class__.__name__, key, ext="pdf")
             if self.terms:
                 att = [getFileName(self.terms,
                     wrkdir=self.opts["mf"].rcdic["wrkdir"])]

=== modified file 'bkm/bk2010.py' (properties changed: -x to +x)
=== modified file 'bkm/bk3010.py' (properties changed: -x to +x)
--- old/bkm/bk3010.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk3010.py	2020-06-20 14:28:42 +0000
@@ -137,7 +137,7 @@
             if self.expired == "Y":
                 if dp1 and dt1 > self.sysdtw:
                     continue
-                elif not dp1 and dp2 and dt2 > self.sysdtw:
+                if not dp1 and dp2 and dt2 > self.sysdtw:
                     continue
             elif dp1 <= 0 and dp2 <= 0:
                 continue
@@ -180,8 +180,7 @@
                 self.printLine(rec[0], rec[1], rec[2], rec[3], rec[4], rec[5])
         if self.fpdf.page:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 header=self.head, pdfnam=pdfnam, repprt=self.df.repprt,

=== modified file 'bkm/bk3020.py' (properties changed: -x to +x)
--- old/bkm/bk3020.py	2020-03-01 12:48:20 +0000
+++ new/bkm/bk3020.py	2020-06-20 14:31:10 +0000
@@ -208,8 +208,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Bookings Manager Audit Trail for Period "\
             "%s to %s" % (self.sperd, self.eperd))
@@ -242,8 +241,7 @@
             self.head = ("%03u %-30s %91s %10s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, self.__class__.__name__))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.bqty = 0
         self.bdrs = 0
@@ -432,7 +430,7 @@
     def grandTotal(self):
         tot = [0, 0, 0, 0, 0]
         if self.df.repprt[2] == "export":
-            for x in xrange(0, len(bktrtp)):
+            for x, t in enumerate(bktrtp):
                 tot[0] = float(ASD(tot[0]) + ASD(self.gdr[x]))
                 tot[1] = float(ASD(tot[1]) + ASD(self.gcr[x]))
                 tot[2] = float(ASD(tot[2]) + ASD(self.gvt[x]))
@@ -443,7 +441,7 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(bktrtp)):
+        for x, t in enumerate(bktrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             dr = CCD(self.gdr[x], "SD", 13.2)
             cr = CCD(self.gcr[x], "SD", 13.2)
@@ -452,10 +450,10 @@
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-27s %s %s %s %s %s" % \
-                (bktrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-33s %s %s %s %s %s" % \
-                (bktrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))
             tot[2] = float(ASD(tot[2]) + ASD(cr.work))

=== modified file 'bkm/bk3030.py' (properties changed: -x to +x)
--- old/bkm/bk3030.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk3030.py	2020-05-27 12:22:09 +0000
@@ -219,8 +219,7 @@
             self.doHKeeping()
         if self.fpdf.page:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             subj = "%s - %s" % (self.cdes, self.hdes)
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'bkm/bk3040.py' (properties changed: -x to +x)
--- old/bkm/bk3040.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk3040.py	2020-05-27 12:22:19 +0000
@@ -115,8 +115,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Booking's Balances up to %s" % self.period)
         self.expheads.append("Booking Status: %s" % self.statusd)
@@ -177,8 +176,7 @@
         if self.fpdf.page and not p.quit:
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'bkm/bk3050.py' (properties changed: -x to +x)
--- old/bkm/bk3050.py	2020-03-01 12:48:20 +0000
+++ new/bkm/bk3050.py	2020-05-27 12:22:26 +0000
@@ -125,8 +125,7 @@
             p.closeProgress()
             if self.fpdf.page and not p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)

=== modified file 'bkm/bk3060.py' (properties changed: -x to +x)
=== modified file 'bkm/bk3070.py' (properties changed: -x to +x)
--- old/bkm/bk3070.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bk3070.py	2020-05-27 11:55:23 +0000
@@ -271,8 +271,7 @@
         else:
             key = "%s_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-            ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.sysdtd),

=== modified file 'bkm/bk3080.py' (properties changed: -x to +x)
=== modified file 'bkm/bk3090.py' (properties changed: -x to +x)
=== modified file 'bkm/bkc110.py' (properties changed: -x to +x)
--- old/bkm/bkc110.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bkc110.py	2020-04-29 15:59:55 +0000
@@ -149,7 +149,7 @@
             (("T",0,seq + 3,0),"ITX",50,"Terms and Conditions","",
                 self.acc[5],"N",None,trm,None,("fle","blank")),
             (("T",0,seq + 4,0),"ITX",50,"Email Address","",
-                self.acc[6],"N",None,None,None,None)])
+                self.acc[6],"N",None,None,None,("email",))])
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -237,14 +237,17 @@
         if self.new:
             self.sql.insRec("bkmctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.bkmctl_col
+            data.append(self.acc[col.index("cbk_xflag")])
             self.sql.updRec("bkmctl", data=data, where=[("cbk_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["bkmctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.bkmctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'bkm/bkc210.py' (properties changed: -x to +x)
--- old/bkm/bkc210.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bkc210.py	2020-04-23 13:07:20 +0000
@@ -117,13 +117,13 @@
     def doExpd(self, frt, pag, r, c, p, i, w):
         self.newx = True
         if not self.newr:
-            self.rtr = self.sql.getRec("bkmrtr", cols=["brr_rate"],
-                where=[("brr_cono", "=", self.opts["conum"]),
-                ("brr_type", "=", self.rtype), ("brr_code", "=", self.rcode),
-                ("brr_date", "=", w)], limit=1)
+            self.rtr = self.sql.getRec("bkmrtr", where=[("brr_cono",
+                "=", self.opts["conum"]), ("brr_type", "=", self.rtype),
+                ("brr_code", "=", self.rcode), ("brr_date", "=", w)], limit=1)
             if self.rtr:
                 self.newx = False
-                self.df.loadEntry(frt, pag, p+1, data=self.rtr[0])
+                rate = self.rtr[self.sql.bkmrtr_col.index("brr_rate")]
+                self.df.loadEntry(frt, pag, p+1, data=rate)
         self.date = w
 
     def doRate(self, frt, pag, r, c, p, i, w):
@@ -154,6 +154,8 @@
         if self.newr:
             self.sql.insRec("bkmrtm", data=data)
         elif data != self.rtm[:len(data)]:
+            col = self.sql.bkmrtm_col
+            data.append(self.rtm[col.index("brm_xflag")])
             self.sql.updRec("bkmrtm", data=data, where=[("brm_cono", "=",
                 self.opts["conum"]), ("brm_type", "=", self.rtype),
                 ("brm_code", "=", self.rcode)])
@@ -163,6 +165,8 @@
         if self.newx:
             self.sql.insRec("bkmrtr", data=data)
         elif data != self.rtr[:len(data)]:
+            col = self.sql.bkmrtr_col
+            data.append(self.rtr[col.index("brr_xflag")])
             self.sql.updRec("bkmrtr", data=data, where=[("brr_cono",
                 "=", self.opts["conum"]), ("brr_type", "=", self.rtype),
                 ("brr_code", "=", self.rcode), ("brr_date", "=", self.date)])

=== modified file 'bkm/bkc310.py' (properties changed: -x to +x)
--- old/bkm/bkc310.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bkc310.py	2020-04-24 10:56:15 +0000
@@ -44,7 +44,7 @@
             return
         self.glint = bkmctl["cbk_glint"]
         self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "genmst", "bkmmst",
-            "bkmunm", "bkmrtm"], prog=self.__class__.__name__)
+            "bkmunm", "bkmrtm", "bkmrtt"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         return True
@@ -209,6 +209,8 @@
         if self.new:
             self.sql.insRec("bkmunm", data=data)
         elif data != self.unm[:len(data)]:
+            col = self.sql.bkmunm_col
+            data.append(self.unm[col.index("bum_xflag")])
             self.sql.updRec("bkmunm", data=data, where=[("bum_cono", "=",
                 self.opts["conum"]), ("bum_btyp", "=", self.btyp),
                 ("bum_code", "=", self.ucod)])

=== modified file 'bkm/bkc410.py' (properties changed: -x to +x)
--- old/bkm/bkc410.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bkc410.py	2020-04-23 09:29:56 +0000
@@ -75,6 +75,8 @@
         if self.lnew:
             self.sql.insRec("bkmlet", data=data)
         elif data != self.let[:len(data)]:
+            col = self.sql.bkmlet_col
+            data.append(self.let[col.index("bkl_xflag")])
             self.sql.updRec("bkmlet", data=data, where=[("bkl_cono", "=",
                 self.opts["conum"]), ("bkl_code", "=", self.ltyp)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'bkm/bkc510.py' (properties changed: -x to +x)
--- old/bkm/bkc510.py	2020-04-21 08:42:36 +0000
+++ new/bkm/bkc510.py	2020-05-27 11:55:42 +0000
@@ -142,9 +142,9 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.delRec("bkmcon", where=[("bkc_cono", "=", self.opts["conum"]),
             ("bkc_ccode", "=", self.ccode)])
-        self.sql.insRec("chglog", data=["bkmcon", "D", "%03i%-7s" % \
+        self.sql.insRec("chglog", data=["bkmcon", "D", "%03i%-7s" %
             (self.opts["conum"], self.ccode), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -164,14 +164,16 @@
         if self.newcon:
             self.sql.insRec("bkmcon", data=data)
         elif data != self.oldcon[:len(data)]:
+            col = self.sql.bkmcon_col
+            data.append(self.oldcon[col.index("bkc_xflag")])
             self.sql.updRec("bkmcon", data=data, where=[("bkc_cono", "=",
                 self.opts["conum"]), ("bkc_ccode", "=", self.ccode)])
             for num, dat in enumerate(self.oldcon):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["bkmcon", "U",
                         "%03i%-7s" % (self.opts["conum"], self.ccode),
-                        self.sql.bkmcon_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== added file 'bks/__init__.py'
=== modified file 'bks/bs1010.py' (properties changed: -x to +x)
--- old/bks/bs1010.py	2020-04-21 08:42:36 +0000
+++ new/bks/bs1010.py	2020-04-29 12:27:17 +0000
@@ -263,22 +263,25 @@
         self.status = w
 
     def doEnd(self):
-        data = [self.opts["conum"], self.bcode,
-            self.df.t_work[0][0][1], self.df.t_work[0][0][2],
-            self.df.t_work[0][0][4], self.df.t_work[0][0][6],
-            self.df.t_work[0][0][7], self.df.t_work[0][0][8]]
+        data = [self.opts["conum"]]
+        for num, dat in enumerate(self.df.t_work[0][0]):
+            if num in (3, 5):
+                continue
+            data.append(dat)
         if self.newbk:
             self.sql.insRec("bksmst", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bksmst_col
+            data.append(self.old[col.index("bmf_xflag")])
             self.sql.updRec("bksmst", data=data, where=[("bmf_cono", "=",
-                self.opt["conum"]), ("bmf_code", "=", self.bcode)])
+                self.opts["conum"]), ("bmf_code", "=", self.bcode)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.old):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["bksmst", "U",
                         "%03i%04i" % (self.opts["conum"], self.bcode),
-                        self.sql.bksmst[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'bks/bs3010.py' (properties changed: -x to +x)
--- old/bks/bs3010.py	2020-04-21 08:42:36 +0000
+++ new/bks/bs3010.py	2020-07-13 10:43:57 +0000
@@ -26,7 +26,7 @@
 
 import os, requests, time
 from TartanClasses import CCD, MyFpdf, SplashScreen, Sql, TartanDialog
-from tartanFunctions import doPrinter, getModName, showError
+from tartanFunctions import doPrinter, getImage, getModName, showError
 
 class bs3010(object):
     def __init__(self, **opts):
@@ -42,8 +42,11 @@
             return
         t = time.localtime()
         self.curdt = time.strftime("%Y-%m", t)
-        self.image = os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-            "books.png")
+        self.image = os.path.join(self.opts["mf"].rcdic["wrkdir"], "books.png")
+        if not os.path.exists(self.image):
+            getImage("books", fle=self.image)
+        if not os.path.exists(self.image):
+            self.image = None
         return True
 
     def mainProcess(self):
@@ -188,8 +191,7 @@
                     pass
             sp.closeSplash()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         head = "Book List as at %s" % (self.curdt)
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
@@ -199,7 +201,7 @@
     def pageHeading(self, new=False):
         self.fpdf.setFont("Arial", "B", 15)
         x = self.fpdf.get_x()
-        if os.path.isfile(self.image):
+        if self.image:
             self.fpdf.image(self.image, 11, 10, 15, 20)
             self.fpdf.image(self.image, 185, 10, 15, 20)
             self.fpdf.cell(20)

=== modified file 'bks/bsc110.py' (properties changed: -x to +x)
--- old/bks/bsc110.py	2020-04-21 08:42:36 +0000
+++ new/bks/bsc110.py	2020-04-23 09:31:16 +0000
@@ -113,6 +113,8 @@
         if self.newown:
             self.sql.insRec("bksown", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bksown_col
+            data.append(self.old[col.index("bof_xflag")])
             self.sql.updRec("bksown", data=data, where=[("bof_cono", "=",
                 self.opts["conum"]), ("bof_code", "=", self.owner)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'bks/bsc210.py' (properties changed: -x to +x)
--- old/bks/bsc210.py	2020-04-21 08:42:36 +0000
+++ new/bks/bsc210.py	2020-04-23 14:19:19 +0000
@@ -97,10 +97,12 @@
                 return "An Author with this Name Already Exists"
 
     def doEnd(self):
-        data = self.df.t_work[0][0]
+        data = self.df.t_work[0][0][:]
         if self.newaut:
             self.sql.insRec("bksaut", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bksaut_col
+            data.append(self.old[col.index("baf_xflag")])
             self.sql.updRec("bksaut", data=data, where=[("baf_code", "=",
                 self.author)])
         self.opts["mf"].dbm.commitDbase()

=== added file 'bwl/__init__.py'
=== modified file 'bwl/bc1010.py' (properties changed: -x to +x)
--- old/bwl/bc1010.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc1010.py	2020-08-06 15:51:55 +0000
@@ -51,8 +51,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["chglog", "bwlent", "bwlgme",
-            "bwltab", "bwldrt", "bwlflm", "bwlflt", "memmst", "memkon"],
-            prog=self.__class__.__name__)
+            "bwltab", "bwldrt", "bwlflm", "bwlflt", "memmst", "memkon",
+            "memadd", "memcat"], prog=self.__class__.__name__)
         if self.sql.error:
             if self.sql.error == ["memmst", "memkon"]:
                 self.memmst = False
@@ -66,6 +66,7 @@
             return
         self.mlint = bwlctl["ctb_mlint"]
         self.samen = bwlctl["ctb_samen"]
+        self.mscat = bwlctl["ctb_mscat"]
         self.mstart = bwlctl["ctb_mstart"]
         self.fstart = bwlctl["ctb_fstart"]
         self.nstart = bwlctl["ctb_nstart"]
@@ -225,8 +226,8 @@
             memno = 0
         if memno:
             chk = self.doLoadMember(memno)
-            if not chk:
-                return "Member %s Does Not Exist" % memno
+            if chk:
+                return chk
             if self.dbase == "R":
                 return "sk13"
             return "sk12"
@@ -241,8 +242,8 @@
                 if chk:
                     return "Member Already Has a TAB"
             chk = self.doLoadMember(w)
-            if not chk:
-                return "Invalid Membership Number"
+            if chk:
+                return chk
             if self.newtab and not self.tab:
                 chk = self.getNextTab()
                 if not chk:
@@ -254,11 +255,20 @@
             return "Invalid Membership Number"
 
     def doLoadMember(self, memno):
+        # Check member
         acc = self.sql.getRec("memmst", cols=["mlm_surname",
             "mlm_names", "mlm_gender"], where=[("mlm_cono", "=",
             self.opts["conum"]), ("mlm_memno", "=", memno)], limit=1)
         if not acc:
-            return
+            return "Member %s Does Not Exist" % memno
+        # Check category
+        if self.mscat:
+            cat = self.sql.getRec("memcat", where=[("mlc_cono", "=",
+                self.opts["conum"]), ("mlc_memno", "=", memno),
+                ("mlc_type", "=", "C"), ("mlc_code", "=", self.mscat)],
+                limit=1)
+            if not cat:
+                return "Member %s is Not in the Bowls Category" % memno
         self.snam = acc[0]
         self.fnam = acc[1]
         self.gender = acc[2]
@@ -284,7 +294,6 @@
                 ("mlk_memno", "=", memno), ("mlk_code", "=", cod)], limit=1)
             if kk:
                 self.df.loadEntry("T", 0, num+9, data=kk[0])
-        return True
 
     def doSurname(self, frt, pag, r, c, p, i, w):
         self.sname = w
@@ -623,10 +632,10 @@
             else:
                 tit = "%s (Females Only)" % tit
             RepPrt(self.opts["mf"], name=self.__class__.__name__,
-                conum=self.opts["conum"],
-                conam=self.opts["conam"], heads=[tit], ttype="D",
-                tables=data, cols=cols, repprt=self.pr.repprt,
-                repeml=self.pr.repeml, fromad=self.fromad)
+                conum=self.opts["conum"], conam=self.opts["conam"],
+                heads=[tit], ttype="D", tables=data, cols=cols,
+                repprt=self.pr.repprt, repeml=self.pr.repeml,
+                fromad=self.fromad)
         self.df.setWidget(self.df.mstFrame, state="show")
         self.df.enableButtonsTags(state=state)
         self.df.window.focus_force()
@@ -688,8 +697,11 @@
         if self.newtab:
             self.sql.insRec("bwltab", data=tabdat)
         elif self.tabchg:
+            tabdat.append("")
             self.doTabChg(tabdat)
         elif tabdat != self.oldtab[:len(tabdat)]:
+            col = self.sql.bwltab_col
+            tabdat.append(self.oldtab[col.index("btb_xflag")])
             self.sql.updRec("bwltab", data=tabdat, where=[("btb_cono", "=",
                 self.opts["conum"]), ("btb_tab", "=", self.tab)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -697,8 +709,8 @@
                 if dat != tabdat[num]:
                     self.sql.insRec("chglog", data=["bwltab", "U",
                         "%03i%06s" % (self.opts["conum"], self.tab),
-                        self.sql.bwltab_col[num], dte, self.opts["capnm"],
-                        str(dat), str(tabdat[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(tabdat[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         if "args" in self.opts:
             self.doExit()

=== modified file 'bwl/bc1020.py' (properties changed: -x to +x)
--- old/bwl/bc1020.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc1020.py	2020-07-13 10:02:02 +0000
@@ -24,7 +24,6 @@
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
 
-import os
 from TartanClasses import TartanDialog, Sql
 from tartanFunctions import getNextCode
 
@@ -53,7 +52,6 @@
         fle = {
             "stype":  "F",
             "types":  "fle",
-            "initd": os.path.join(self.opts["mf"].rcdic["prgdir"], "img"),
             "ftype":  (("JPG Files", "*.jpg"),)}
         r1s = (("Male", "M"), ("Female", "F"), ("Mixed", "B"))
         r2s = (("Yes", "Y"), ("No", "N"))
@@ -145,6 +143,8 @@
         if self.newtyp:
             self.sql.insRec("bwlflf", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bwlflf_col
+            data.append(self.old[col.index("bff_xflag")])
             self.sql.updRec("bwlflf", data=data, where=[("bff_cono", "=",
                 self.opts["conum"]), ("bff_code", "=", self.code)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'bwl/bc1030.py' (properties changed: -x to +x)
--- old/bwl/bc1030.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc1030.py	2020-04-23 09:33:45 +0000
@@ -139,6 +139,8 @@
         if self.newfls:
             self.sql.insRec("bwlfls", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bwlfls_col
+            data.append(self.old[col.index("bfs_xflag")])
             self.sql.updRec("bwlfls", data=data, where=[("bfs_cono", "=",
                 self.opts["conum"]), ("bfs_fmat", "=", self.fmat),
                 ("bfs_code", "=", self.side)])

=== modified file 'bwl/bc1040.py' (properties changed: -x to +x)
--- old/bwl/bc1040.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc1040.py	2020-08-31 15:05:36 +0000
@@ -238,6 +238,8 @@
         if self.newtyp:
             self.sql.insRec("bwltyp", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bwltyp_col
+            data.append(self.old[col.index("bct_xflag")])
             self.sql.updRec("bwltyp", data=data, where=[("bct_cono", "=",
                 self.opts["conum"]), ("bct_code", "=", self.ctype)])
         self.perr = False
@@ -312,7 +314,7 @@
             ("bcp_ptyp", "=", ptyp)], limit=1)
         if acc:
             self.newpts = False
-            for num, dat in enumerate(acc[3:]):
+            for num, dat in enumerate(acc[3:-1]):
                 self.pf.loadEntry("T", 0, num, data=dat)
         else:
             self.newpts = True

=== modified file 'bwl/bc2010.py' (properties changed: -x to +x)
--- old/bwl/bc2010.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2010.py	2020-08-03 09:34:54 +0000
@@ -1333,8 +1333,9 @@
                     if mem:
                         dat[0] += 1
                         # Create player and remove from ndict
-                        dat.append([mem] + self.ndict.pop(mem))
-                        dat[1] += dat[-1][5]
+                        plr = self.ndict.pop(mem)
+                        dat.append([mem] + plr)
+                        dat[1] += plr[4]
                 temp.append(dat)
             if self.dtype == "S":
                 temp = sorted(temp, key=itemgetter(1))
@@ -1902,10 +1903,7 @@
         draws = []
         if self.dtype == "S":
             # Sort players for strength v strength
-            if self.order == "A":
-                rev = True
-            else:
-                rev = False
+            rev = bool(self.order == "A")
             self.skip2 = sorted(self.skip2, key=itemgetter(5), reverse=rev)
             self.third2 = sorted(self.third2, key=itemgetter(5), reverse=rev)
             self.second2 = sorted(self.second2, key=itemgetter(5), reverse=rev)
@@ -1978,8 +1976,8 @@
                         break
                 chk = 99
                 seq = 0
-                for x in xrange(len(draws)):
-                    if draws[x][0] != self.tsize:
+                for x, d0 in enumerate(draws):
+                    if d0[0] != self.tsize:
                         continue
                     if nsize == 3:
                         d1 = one[4][5]
@@ -1987,14 +1985,14 @@
                         for n in xrange(2, 5):
                             d1 += one[n][5]
                         for n in xrange(2, 6):
-                            d2 += draws[x][n][5]
+                            d2 += d0[n][5]
                     else:
                         d1 = 0
                         for n in xrange(2, 6):
                             d1 += one[n][5]
-                        d2 = draws[x][4][5]
+                        d2 = d0[4][5]
                         for n in xrange(2, 5):
-                            d2 += draws[x][n][5]
+                            d2 += d0[n][5]
                     df = d1 - d2
                     if df < 0:
                         df = 0 - df
@@ -2067,10 +2065,7 @@
             for r in self.adraw1[x + 1][2:]:
                 if r[0]:
                     two += 1
-            if two != one:
-                broken = True
-            else:
-                broken = False
+            broken = bool(two != one)
             side = "L"
             for y in xrange(2):
                 dat = self.adraw1[x + y]

=== modified file 'bwl/bc2020.py' (properties changed: -x to +x)
--- old/bwl/bc2020.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2020.py	2020-05-27 12:23:07 +0000
@@ -548,8 +548,7 @@
     def doPrint(self):
         self.pr.closeProcess()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            "select_%s" % self.date, ext="pdf")
+            self.__class__.__name__, "select_%s" % self.date, ext="pdf")
         fpdf = MyFpdf(name=self.__class__.__name__, head=90, foot=True)
         cw = fpdf.get_string_width("X")           # character width
         ld = 4.5                                  # line depth

=== modified file 'bwl/bc2030.py' (properties changed: -x to +x)
--- old/bwl/bc2030.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2030.py	2020-04-24 10:57:39 +0000
@@ -34,8 +34,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlflf", "bwlflm", "bwlflt"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["bwltab", "bwlflf", "bwlflm",
+            "bwlflt"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         self.skip = 0

=== modified file 'bwl/bc2040.py' (properties changed: -x to +x)
--- old/bwl/bc2040.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2040.py	2020-05-03 09:08:19 +0000
@@ -339,6 +339,7 @@
                         for rec in recs:
                             skips.append(rec[0])
                         self.doPopulate(skips)
+                data.append(self.cmp[self.sql.bwlcmp_col.index("bcm_xflag")])
                 self.sql.updRec("bwlcmp", data=data, where=[("bcm_cono", "=",
                     self.opts["conum"]), ("bcm_code", "=", self.ccod)])
             self.loadButton()

=== modified file 'bwl/bc2050.py' (properties changed: -x to +x)
--- old/bwl/bc2050.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2050.py	2020-06-21 11:23:03 +0000
@@ -376,8 +376,8 @@
                 ("bcg_game", "=", w - 1),
                 ("bcg_scod", "<", 900000),
                 ("bcg_ocod", "<", 900000),
-                ("bcg_shots_for", "=", 0),
-                ("bcg_shots_agt", "=", 0),
+                ("bcg_sfor", "=", 0),
+                ("bcg_sagt", "=", 0),
                 ("bcg_aflag", "in", ("", "D"))])
             res = self.sql.getRec("bwlgme", cols=col, where=wer, limit=1)
             if res[0]:
@@ -505,7 +505,7 @@
                 if self.cfmat == "T" and self.gtyp == "D":
                     if self.allocateRinks(final=False):
                         break
-                    elif x == int(repeat - 1):
+                    if x == int(repeat - 1):
                         self.allocateRinks(final=True)
                 else:
                     self.allocateRinks(final=True)
@@ -685,8 +685,8 @@
             col = [
                 "bcg_scod",
                 "sum(bcg_points) as pts",
-                "sum(bcg_shots_for - bcg_shots_agt) as diff",
-                "sum(bcg_shots_agt) as agt"]
+                "sum(bcg_sfor - bcg_sagt) as diff",
+                "sum(bcg_sagt) as agt"]
             whr = [
                 ("bcg_cono", "=", self.opts["conum"]),
                 ("bcg_ccod", "=", self.ccod)]
@@ -721,8 +721,8 @@
         self.skips = []
         for grp in groups:
             chk = self.sql.getRec("bwlgme", cols=["bcg_scod",
-                "sum(bcg_a_points) as pts", "sum(bcg_a_shots_agt) as agt",
-                "sum(bcg_a_shots_for - bcg_a_shots_agt) as diff"],
+                "sum(bcg_a_points) as pts", "sum(bcg_a_sagt) as agt",
+                "sum(bcg_a_sfor - bcg_a_sagt) as diff"],
                 where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
                 self.ccod), ("bcg_group", "in", (0, grp[0]))],
                 group="bcg_scod", order="pts desc, diff desc, agt asc")
@@ -746,10 +746,10 @@
     def doStrength(self, chk, fini):
         dun = copyList(self.lock)
         err = []
-        for x in xrange(0, len(chk)):
-            if chk[x][0] in dun or chk[x][0] in err:
+        for x, c in enumerate(chk):
+            if c[0] in dun or c[0] in err:
                 continue
-            one = chk[x][0]
+            one = c[0]
             done = False
             count = 0
             for s in chk:
@@ -863,10 +863,7 @@
                     cpydic[one] = (two, "BY")
                     continue
                 # Check if end rinker
-                if self.endrks and self.checkEnds(one, two):
-                    endr = True
-                else:
-                    endr = False
+                endr = bool(self.endrks and self.checkEnds(one, two))
                 random.shuffle(cpyrnk)
                 done = False
                 for rk in cpyrnk:
@@ -1027,8 +1024,8 @@
             for gam in chk:
                 skp = gam[self.sql.bwlgme_col.index("bcg_scod")]
                 gme = gam[self.sql.bwlgme_col.index("bcg_game")]
-                shf = gam[self.sql.bwlgme_col.index("bcg_shots_for")]
-                sha = gam[self.sql.bwlgme_col.index("bcg_shots_agt")]
+                shf = gam[self.sql.bwlgme_col.index("bcg_sfor")]
+                sha = gam[self.sql.bwlgme_col.index("bcg_sagt")]
                 pts = gam[self.sql.bwlgme_col.index("bcg_points")]
                 if gme in self.expunge:
                     shf = 0
@@ -1038,8 +1035,8 @@
                     shf = int(round(shf * self.percent / 100.0, 0))
                     sha = int(round(sha * self.percent / 100.0, 0))
                     pts = int(round(pts * self.percent / 100.0, 0))
-                self.sql.updRec("bwlgme", cols=["bcg_a_shots_for",
-                    "bcg_a_shots_agt", "bcg_a_points"], data=[shf, sha, pts],
+                self.sql.updRec("bwlgme", cols=["bcg_a_sfor",
+                    "bcg_a_sagt", "bcg_a_points"], data=[shf, sha, pts],
                     where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod",
                     "=", self.ccod), ("bcg_scod", "=", skp), ("bcg_game", "=",
                     gme)])
@@ -1132,8 +1129,7 @@
                     sql.append(0)
                 self.sql.insRec("bwltms", data=sql)
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-            heads=head,
-            cols=cols, ttype="D", repprt=self.df.repprt,
+            heads=head, cols=cols, ttype="D", repprt=self.df.repprt,
             repeml=self.df.repeml, fromad=self.fromad)
 
     def printKnockout(self):
@@ -1263,12 +1259,13 @@
                     temp.append(c[0])
                 random.shuffle(temp)
                 for p1 in self.seeds:
+                    # Pair seeded player with unseeded player
                     if p1 not in temp:
                         continue
-                    for x in xrange(len(temp)):
-                        if temp[x] in self.seeds:
-                            continue
-                        p2 = temp[x]
+                    for rec in temp:
+                        if rec not in self.seeds:
+                            p2 = rec
+                            break
                     temp.remove(p1)
                     temp.remove(p2)
                     self.sql.updRec("bwlgme", cols=["bcg_ocod"], data=[p2],
@@ -1307,20 +1304,19 @@
                     if len(skips) % self.prs:
                         p2[0] += 1
                     for sd, seed in enumerate(self.seeds):
-                        for num in xrange(len(skips)):
-                            if skips[num][0] == seed:
+                        for num, skp in enumerate(skips):
+                            if skp[0] == seed:
                                 pos = p1.pop(0)
                                 self.sql.updRec("bwlgme", cols=["bcg_seed",
                                     "bcg_pair"], data=[sd + 1, pos],
                                     where=[("bcg_cono", "=",
                                     self.opts["conum"]), ("bcg_ccod", "=",
-                                    self.ccod), ("bcg_scod", "=",
-                                    skips[num][0])])
+                                    self.ccod), ("bcg_scod", "=", skp[0])])
                                 p2[pos - 1] -= 1
                                 break
                     # Allocate rest into pair groups
-                    for num in xrange(len(skips)):
-                        if skips[num][0] in self.seeds:
+                    for num, skp in enumerate(skips):
+                        if skp[0] in self.seeds:
                             continue
                         for n, p in enumerate(p2):
                             if p:
@@ -1328,12 +1324,11 @@
                                     "bcg_pair"], data=[0, n + 1],
                                     where=[("bcg_cono", "=",
                                     self.opts["conum"]), ("bcg_ccod", "=",
-                                    self.ccod), ("bcg_scod", "=",
-                                    skips[num][0])])
+                                    self.ccod), ("bcg_scod", "=", skp[0])])
                                 p2[n] -= 1
                                 break
         self.two = 0
-        for grp in xrange(1, 3):
+        for grp in range(1, 3):
             skips = self.sql.getRec("bwlgme", cols=["bcg_scod",
                 "bcg_ocod", "bcg_seed", "bcg_pair"], where=[("bcg_cono",
                 "=", self.opts["conum"]), ("bcg_ccod", "=", self.ccod),
@@ -1346,15 +1341,13 @@
         if self.df.repprt[2] == "export":
             self.completeBracket()
             name = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"])
+                self.__class__.__name__, self.opts["conum"])
             doWriteExport(xtype="X", name=name, heads=[(self.cdes, 600, 360)],
                 colsh=self.colsh, forms=self.forms, datas=self.datas,
                 rcdic=self.opts["mf"].rcdic, wait=True)
         else:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             head = "%s Draw" % self.cdes
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
@@ -1811,8 +1804,8 @@
                 ("bcg_game", "=", rnd),
                 ("bcg_group", "=", grp),
                 ("bcg_scod", "=", skip[0])]
-            wins = self.sql.getRec("bwlgme", cols=["bcg_shots_for",
-                "bcg_shots_agt"], where=whr, limit=1)
+            wins = self.sql.getRec("bwlgme", cols=["bcg_sfor",
+                "bcg_sagt"], where=whr, limit=1)
             if not wins[0] and not wins[1]:
                 return ""
             elif wins[0] > wins[1]:
@@ -1822,8 +1815,8 @@
         col = [
             "bcg_scod",
             "bcg_ocod",
-            "bcg_shots_for",
-            "bcg_shots_agt",
+            "bcg_sfor",
+            "bcg_sagt",
             "bcg_seed"]
         whr = [
             ("bcg_cono", "=", self.opts["conum"]),
@@ -1916,8 +1909,7 @@
                 self.printLine(a.disp, " %s " % b.disp, c.disp, 4.7)
                 self.pglin += 1
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            "report", ext="pdf")
+            self.__class__.__name__, "report", ext="pdf")
         self.fpdf.output(pdfnam, "F")
         if self.game in (1, 21, 31, 41, 51, 61, 71, 81, 91):
             desc = "%sst" % self.game

=== modified file 'bwl/bc2060.py' (properties changed: -x to +x)
--- old/bwl/bc2060.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2060.py	2020-06-21 09:10:07 +0000
@@ -38,8 +38,8 @@
     def setVariables(self):
         t = time.localtime()
         self.today = ((t[0] * 10000) + (t[1] * 100) + t[2])
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwltab", "bwlgme"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlcmp", "bwltab", "bwlgme",
+            "bwltyp", "bwlent"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         return True
@@ -113,20 +113,20 @@
         if chk[0] in ("D", "K", "R"):
             return "Knockout and R/Robin Draws Cannot be Changed"
         chk = self.sql.getRec("bwlgme", cols=["bcg_game", "bcg_date",
-            "bcg_aflag", "sum(bcg_ocod)", "sum(bcg_shots_for)"],
+            "bcg_aflag", "sum(bcg_ocod)", "sum(bcg_sfor)"],
             where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
             w)], group="bcg_game, bcg_date, bcg_aflag")
         self.ccod = w
         self.game = 0
         self.draws = {}
         self.manual = False
-        for c in chk:
-            if c[2] == "A" or c[4]:
-                continue
-            if c[4]:
-                continue
-            if c[2] in ("", "D", "S") and c[3]:
-                self.draws[c[0]] = c[1:]
+        for ck in chk:
+            if ck[2] == "A" or ck[4]:
+                continue
+            if ck[4]:
+                continue
+            if ck[2] in ("", "D", "S") and ck[3]:
+                self.draws[ck[0]] = ck[1:]
         if not self.draws:
             ok = askQuestion(self.opts["mf"].body, "Manual Draw",
                 "Is this the First Game and is it going to be a "\
@@ -162,18 +162,18 @@
         self.rinks = []
         rinks = 0
         grns = w.split(",")
-        for n, g in enumerate(grns):
-            if len(g) == 1:
+        for gr in grns:
+            if len(gr) == 1:
                 for x in xrange(1, 7):
-                    self.rinks.append("%s%s" % (g[0], x))
+                    self.rinks.append("%s%s" % (gr[0], x))
                 rinks += 6
-            elif len(g) == 2 and g[1] == "7":
+            elif len(gr) == 2 and gr[1] == "7":
                 for x in xrange(1, 8):
-                    self.rinks.append("%s%s" % (g[0], x))
+                    self.rinks.append("%s%s" % (gr[0], x))
                 rinks += 7
             else:
-                for r in g[1:]:
-                    self.rinks.append("%s%s" % (g[0], r))
+                for rk in gr[1:]:
+                    self.rinks.append("%s%s" % (gr[0], rk))
                     rinks += 1
         if int(self.totskp / 2) > rinks:
             return "Not Enough Rinks"

=== modified file 'bwl/bc2070.py' (properties changed: -x to +x)
--- old/bwl/bc2070.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc2070.py	2020-06-21 09:11:17 +0000
@@ -74,7 +74,7 @@
                 ("btb_tab=bce_scod",),
                 ("bcg_cono=bce_cono",),
                 ("bcg_scod=bce_scod",),
-                ("bcg_shots_for=0 and bcg_shots_agt=0",)],
+                ("bcg_sfor=0 and bcg_sagt=0",)],
             "whera": [
                 ("T", "bce_ccod", 0, 0),
                 ("T", "bcg_ccod", 0, 0),
@@ -91,13 +91,13 @@
             (("C",0,0,0),"I@bcg_scod",0,"","",
                 "","N",self.doSkpCod,skp,None,("efld",)),
             (("C",0,0,0),"ONA",30,"Skp-Name"),
-            (("C",0,0,0),"I@bcg_shots_for",0,"","",
+            (("C",0,0,0),"I@bcg_sfor",0,"","",
                 "","N",self.doShots,None,None,("efld",)),
             (("C",0,0,0),"I@bcg_points",0,"","",
                 "","N",self.doPoints,None,None,("efld",)),
             (("C",0,0,0),"O@bcg_ocod",0,""),
             (("C",0,0,0),"ONA",30,"Opp-Name"),
-            (("C",0,0,0),"I@bcg_shots_agt",0,"","",
+            (("C",0,0,0),"I@bcg_sagt",0,"","",
                 "","N",self.doShots,None,None,("efld",)),
             (("C",0,0,0),"I@bcg_points",0,"","",
                 "","N",self.doPoints,None,None,("efld",)))
@@ -141,7 +141,7 @@
             self.games = bwltyp[self.sql.bwltyp_col.index("bct_games")]
         self.ends = bwltyp[self.sql.bwltyp_col.index("bct_ends")]
         chk = self.sql.getRec("bwlgme", cols=["bcg_game",
-            "sum(bcg_shots_for)", "sum(bcg_shots_agt)", "sum(bcg_points)"],
+            "sum(bcg_sfor)", "sum(bcg_sagt)", "sum(bcg_points)"],
             where=[("bcg_cono", "=", self.opts["conum"]), ("bcg_ccod", "=",
             self.ccod), ("bcg_aflag", "in", ("", "D"))],
             group="bcg_game", order="bcg_game")
@@ -159,15 +159,15 @@
             group="bcg_aflag")
         if not chk:
             return "Invalid Game Number"
-        for c in chk:
-            if not c[0] and not c[1]:
+        for ck in chk:
+            if not ck[0] and not ck[1]:
                 return "Invalid Game Number, Not Yet Drawn"
         if w != self.games:
             col = [
                 "bcg_game",
                 "bcg_type",
                 "sum(bcg_ocod)",
-                "sum(bcg_shots_for)",
+                "sum(bcg_sfor)",
                 "sum(bcg_points)"]
             whr = [
                 ("bcg_cono", "=", self.opts["conum"]),
@@ -181,8 +181,7 @@
                     if d[3] or d[4]:
                         drawn = "X"
                         break
-                    else:
-                        drawn.append(d[0])
+                    drawn.append(d[0])
             if drawn == "X":
                 showError(self.opts["mf"].body, "Error",
                     "Results Have Already Been Captured for Game %s" % d[0])
@@ -215,8 +214,8 @@
                 if self.groups == "Y" and w == self.grgame:
                     col.append("bcg_group")
                     dat.append(0)
-                col.extend(["bcg_shots_for", "bcg_shots_agt", "bcg_points",
-                    "bcg_a_shots_for", "bcg_a_shots_agt", "bcg_a_points",
+                col.extend(["bcg_sfor", "bcg_sagt", "bcg_points",
+                    "bcg_a_sfor", "bcg_a_sagt", "bcg_a_points",
                     "bcg_aflag"])
                 dat.extend([0, 0, 0, 0, 0, 0, ""])
                 whr = [
@@ -262,8 +261,8 @@
                         self.gcod)])
                 elif ok == 3:
                     self.sql.updRec("bwlgme", cols=["bcg_ocod", "bcg_rink",
-                        "bcg_shots_for", "bcg_shots_agt", "bcg_points",
-                        "bcg_a_shots_for", "bcg_a_shots_agt", "bcg_a_points",
+                        "bcg_sfor", "bcg_sagt", "bcg_points",
+                        "bcg_a_sfor", "bcg_a_sagt", "bcg_a_points",
                         "bcg_aflag"], data=[0, "", 0, 0, 0, 0, 0, 0, "A"],
                         where=[("bcg_cono", "=", self.opts["conum"]),
                         ("bcg_ccod", "=", self.ccod), ("bcg_game", "=",
@@ -289,7 +288,7 @@
 
     def doSkpCod(self, frt, pag, r, c, p, i, w):
         chk = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=["btb_surname",
-            "btb_names", "bcg_ocod", "bcg_shots_for", "bcg_shots_agt",
+            "btb_names", "bcg_ocod", "bcg_sfor", "bcg_sagt",
             "bcg_points"], where=[("bcg_cono", "=", self.opts["conum"]),
             ("bcg_ccod", "=", self.ccod), ("bcg_scod", "=", w), ("bcg_game",
             "=", self.gcod), ("btb_tab=bcg_scod",)], limit=1)
@@ -328,8 +327,8 @@
             chk = opp + [chk[4], chk[3], 0]
         else:
             chk = self.sql.getRec(tables=["bwlgme", "bwltab"],
-                cols=["btb_surname", "btb_names", "bcg_shots_for",
-                "bcg_shots_agt", "bcg_points"], where=[("bcg_cono",
+                cols=["btb_surname", "btb_names", "bcg_sfor",
+                "bcg_sagt", "bcg_points"], where=[("bcg_cono",
                 "=", self.opts["conum"]), ("bcg_ccod", "=", self.ccod),
                 ("bcg_scod", "=", self.opp), ("bcg_game", "=", self.gcod),
                 ("btb_tab=bcg_scod",)], limit=1)
@@ -421,8 +420,8 @@
             else:
                 aflag = ""
             col = [
-                "bcg_shots_for", "bcg_shots_agt", "bcg_points",
-                "bcg_a_shots_for", "bcg_a_shots_agt", "bcg_a_points",
+                "bcg_sfor", "bcg_sagt", "bcg_points",
+                "bcg_a_sfor", "bcg_a_sagt", "bcg_a_points",
                 "bcg_aflag"]
             whr = [
                 ("bcg_cono", "=", self.opts["conum"]),
@@ -453,8 +452,8 @@
         if self.ponly == "Y":
             whr.append(("bcg_points", ">", 0))
         else:
-            whr.append(("(", "bcg_shots_for", ">", 0, "or",
-                "bcg_shots_agt", ">", 0, ")"))
+            whr.append(("(", "bcg_sfor", ">", 0, "or",
+                "bcg_sagt", ">", 0, ")"))
         recs = self.sql.getRec("bwlgme", cols=["bcg_scod", "bcg_ocod"],
             where=whr, order="bcg_scod")
         if not recs:
@@ -469,7 +468,7 @@
             skips.extend(rec)
             col = [
                 "btb_surname", "btb_names",
-                "bcg_shots_for", "bcg_shots_agt", "bcg_points"]
+                "bcg_sfor", "bcg_sagt", "bcg_points"]
             skp = self.sql.getRec(tables=["bwlgme", "bwltab"],
                 cols=col, where=[("bcg_cono", "=", self.opts["conum"]),
                 ("bcg_ccod", "=", self.ccod), ("bcg_scod", "=", rec[0]),
@@ -524,8 +523,8 @@
                         ("bcg_game", "=", self.gcod), ("bcg_scod",
                         "=", ocod)], limit=1)[0]
                 else:
-                    fors = c[self.sql.bwlgme_col.index("bcg_shots_for")]
-                    agts = c[self.sql.bwlgme_col.index("bcg_shots_agt")]
+                    fors = c[self.sql.bwlgme_col.index("bcg_sfor")]
+                    agts = c[self.sql.bwlgme_col.index("bcg_sagt")]
                 if not fors and not agts:
                     self.df.focusField(self.df.frt, self.df.pag, self.df.col,
                         err="Missing Score Card for Skips %s and %s" % (scod,
@@ -560,12 +559,12 @@
                             rec2 = copyList(recs[num + 1])
                         skp1 = rec1[g.index("bcg_scod")]
                         opp1 = rec1[g.index("bcg_ocod")]
-                        for1 = rec1[g.index("bcg_shots_for")]
-                        agt1 = rec1[g.index("bcg_shots_agt")]
+                        for1 = rec1[g.index("bcg_sfor")]
+                        agt1 = rec1[g.index("bcg_sagt")]
                         skp2 = rec2[g.index("bcg_scod")]
                         opp2 = rec2[g.index("bcg_ocod")]
-                        for2 = rec2[g.index("bcg_shots_for")]
-                        agt2 = rec2[g.index("bcg_shots_agt")]
+                        for2 = rec2[g.index("bcg_sfor")]
+                        agt2 = rec2[g.index("bcg_sagt")]
                         if opp1 > 900000:
                             pl1 = skp1
                         elif for1 > agt1:
@@ -596,7 +595,7 @@
             ("bcg_game", "=", self.gcod),
             ("bcg_scod", "<", 900000),
             ("bcg_ocod", "<", 900000),
-            ("bcg_shots_for=0 and bcg_shots_agt=0",)]
+            ("bcg_sfor=0 and bcg_sagt=0",)]
         chk = self.sql.getRec("bwlgme", cols=col, where=whr, limit=1)
         if chk[0]:
             ok = askQuestion(self.opts["mf"].body, "Quit Capture",

=== modified file 'bwl/bc3010.py' (properties changed: -x to +x)
=== modified file 'bwl/bc3020.py' (properties changed: -x to +x)
--- old/bwl/bc3020.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3020.py	2020-07-13 10:44:14 +0000
@@ -26,8 +26,8 @@
 
 import os, time
 from TartanClasses import CCD, GetCtl, MyFpdf, Sql, TartanDialog
-from tartanFunctions import doPrinter, getModName, getSingleRecords, copyList
-from tartanFunctions import mthendDate
+from tartanFunctions import doPrinter, copyList, getImage, getModName
+from tartanFunctions import getSingleRecords, mthendDate
 
 class bc3020(object):
     def __init__(self, **opts):
@@ -50,8 +50,11 @@
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
         self.curdt = time.strftime("%Y-%m", t)
-        self.image = os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-            "bowls.png")
+        self.image = os.path.join(self.opts["mf"].rcdic["wrkdir"], "bowls.png")
+        if not os.path.exists(self.image):
+            getImage("bowls", fle=self.image)
+        if not os.path.exists(self.image):
+            self.image = None
         self.drawn = "Y"
         self.bounce = "N"
         self.teams = "N"
@@ -253,8 +256,7 @@
                     self.fpdf.cell(cwth*5, 8, "%5s " % right[x][0], 0, 0, "R")
                     self.fpdf.cell(cwth*20, 8, right[x][1], 0, 1, "L")
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         head = "Tabs Draw Summary for the period %s to %s" % (self.start.disp,
             self.end.disp)

=== modified file 'bwl/bc3030.py' (properties changed: -x to +x)
--- old/bwl/bc3030.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3030.py	2020-05-27 12:23:34 +0000
@@ -36,9 +36,9 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bwlflf", "bwlflm",
-            "bwlflo", "bwltab", "bwlfls", "bwlflt"],
-                prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "bwlclb", "bwlflf",
+            "bwlflm", "bwlflo", "bwltab", "bwlfls", "bwlflt"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -184,8 +184,7 @@
                 cards.append(["", "", "", "", "", "", "", ""])
         # Print
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            "assess_%s" % self.date, ext="pdf")
+            self.__class__.__name__, "assess_%s" % self.date, ext="pdf")
         fpdf = MyFpdf(name=self.__class__.__name__, head=90)
         cw = fpdf.get_string_width("X")
         ld = 4.5

=== modified file 'bwl/bc3040.py' (properties changed: -x to +x)
--- old/bwl/bc3040.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3040.py	2020-05-27 12:24:34 +0000
@@ -36,9 +36,9 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, tables=["ctlmst", "bwlflf",
-            "bwlflm", "bwlflo", "bwltab", "bwlfls", "bwlflt"],
-                prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, tables=["ctlmst", "bwlclb",
+            "bwlflf", "bwlflm", "bwlflo", "bwltab", "bwlfls", "bwlflt"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -103,8 +103,7 @@
     def doEnd(self):
         self.df.closeProcess()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            "declare_%s" % self.date, ext="pdf")
+            self.__class__.__name__, "declare_%s" % self.date, ext="pdf")
         fpdf = MyFpdf(name=self.__class__.__name__, head=90, foot=True)
         cw = fpdf.get_string_width("X")             # character width
         ld = 4.3                                    # line depth

=== modified file 'bwl/bc3050.py' (properties changed: -x to +x)
--- old/bwl/bc3050.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3050.py	2020-06-21 09:13:32 +0000
@@ -35,8 +35,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["bwlflf", "bwlflm", "bwlflt",
-            "bwltab"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["bwlflf", "bwlflm", "bwlfls",
+            "bwlflt", "bwltab"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -124,8 +124,8 @@
                     ("bft_type", "=", self.ftyp), ("bft_date", "=", self.date),
                     ("bft_skip", "=", player[0]), ("btb_cono=bft_cono",),
                     ("btb_tab=bft_player",)], order="bft_position")
-                for x in xrange(len(names)):
-                    names[x][0] = self.getName(names[x][0], names[x].pop(1))
+                for nm in names:
+                    nm[0] = self.getName(nm[0], nm.pop(1))
             sc = self.sql.getRec("bwlflt", cols=["bft_rating%s" % pos],
                 where=[("bft_cono", "=", self.opts["conum"]), ("bft_fmat", "=",
                 self.fmat), ("bft_type", "=", self.ftyp), ('bft_date', '=',
@@ -180,8 +180,7 @@
                 ["m", "UD", 4.1, " ATD",    "y"],
                 ["n", "NA",  70, "Remarks", "y"]])
             RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-                heads=head,
-                cols=cols, ttype="D", repprt=self.df.repprt,
+                heads=head, cols=cols, ttype="D", repprt=self.df.repprt,
                 repeml=self.df.repeml, fromad=self.fromad)
         self.opts["mf"].closeLoop()
 

=== modified file 'bwl/bc3060.py' (properties changed: -x to +x)
--- old/bwl/bc3060.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3060.py	2020-05-27 11:57:03 +0000
@@ -35,7 +35,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["bwlflf", "bwlflm", "bwlflt",
-            "bwltab"], prog=self.__class__.__name__)
+            "bwlfls", "bwltab"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -206,9 +206,8 @@
                 ["l", "UD", 4.1, "HA",     "y"],
                 ["m", "UD", 4.1, "NA",     "y"]])
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-            heads=head,
-            cols=cols, ttype="D", blank=True, repprt=self.df.repprt,
-            repeml=self.df.repeml, fromad=self.fromad)
+            heads=head, cols=cols, ttype="D", blank=True,
+            repprt=self.df.repprt, repeml=self.df.repeml, fromad=self.fromad)
         self.opts["mf"].closeLoop()
 
     def doExit(self):

=== modified file 'bwl/bc3070.py' (properties changed: -x to +x)
--- old/bwl/bc3070.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3070.py	2020-07-13 10:44:43 +0000
@@ -26,7 +26,7 @@
 
 import os, time
 from TartanClasses import CCD, GetCtl, MyFpdf, Sql, TartanDialog
-from tartanFunctions import getModName, doPrinter
+from tartanFunctions import getImage, getModName, doPrinter
 
 class bc3070(object):
     def __init__(self, **opts):
@@ -47,8 +47,11 @@
         self.fromad = bwlctl["ctb_emadd"]
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
-        self.image = os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-            "bowls.png")
+        self.image = os.path.join(self.opts["mf"].rcdic["wrkdir"], "bowls.png")
+        if not os.path.exists(self.image):
+            getImage("bowls", fle=self.image)
+        if not os.path.exists(self.image):
+            self.image = None
 
     def mainProcess(self):
         com = {
@@ -116,8 +119,7 @@
                 self.fpdf.drawText(txt=rec[4], w=cwth*41, h=5, ln=0)
                 self.fpdf.drawText(txt=rec[5], w=cwth*2, h=5, ln=1)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             head = "%s - Entered Teams" % self.cnam
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'bwl/bc3080.py' (properties changed: -x to +x)
--- old/bwl/bc3080.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3080.py	2020-07-13 10:45:30 +0000
@@ -26,7 +26,7 @@
 
 import os, time
 from TartanClasses import GetCtl, MyFpdf, Sql, TartanDialog
-from tartanFunctions import copyList, getModName, doPrinter
+from tartanFunctions import copyList, getImage, getModName, doPrinter
 
 class bc3080(object):
     def __init__(self, **opts):
@@ -57,9 +57,10 @@
         self.fromad = bwlctl["ctb_emadd"]
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
-        self.image = os.path.join(self.opts["mf"].rcdic["prgdir"],
-            "img", "bowls.png")
-        if not os.path.isfile(self.image):
+        self.image = os.path.join(self.opts["mf"].rcdic["wrkdir"], "bowls.png")
+        if not os.path.exists(self.image):
+            getImage("bowls", fle=self.image)
+        if not os.path.exists(self.image):
             self.image = None
         self.card = True
         return True
@@ -141,8 +142,7 @@
             eml = None
         self.drawFormat()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], pdfnam=pdfnam, header=hdr,
             repprt=prt, fromad=self.fromad, repeml=eml)

=== modified file 'bwl/bc3090.py' (properties changed: -x to +x)
--- old/bwl/bc3090.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3090.py	2020-05-27 11:57:12 +0000
@@ -120,15 +120,15 @@
         col = ["bce_scod", "btb_surname", "btb_names"]
         if lgame <= self.grgame:
             col.extend([
-                "sum(bcg_shots_for) as sfor",
-                "sum(bcg_shots_agt) as sagt",
-                "sum(bcg_shots_for - bcg_shots_agt) as agg",
+                "sum(bcg_sfor) as sfor",
+                "sum(bcg_sagt) as sagt",
+                "sum(bcg_sfor - bcg_sagt) as agg",
                 "sum(bcg_points) as pts"])
         else:
             col.extend([
-                "sum(bcg_a_shots_for) as sfor",
-                "sum(bcg_a_shots_agt) as sagt",
-                "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
+                "sum(bcg_a_sfor) as sfor",
+                "sum(bcg_a_sagt) as sagt",
+                "sum(bcg_a_sfor - bcg_a_sagt) as agg",
                 "sum(bcg_a_points) as pts"])
         whr = [
             ("bce_cono", "=", self.opts["conum"]),
@@ -212,8 +212,7 @@
             repprt = self.df.repprt
             repeml = self.df.repprt
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-            heads=head,
-            cols=cols, ttype="D", pages=False, repprt=repprt,
+            heads=head, cols=cols, ttype="D", pages=False, repprt=repprt,
             repeml=repeml, fromad=self.fromad)
         if "wait" not in self.opts:
             self.opts["mf"].closeLoop()

=== modified file 'bwl/bc3100.py' (properties changed: -x to +x)
--- old/bwl/bc3100.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3100.py	2020-06-21 09:15:19 +0000
@@ -24,7 +24,6 @@
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
 
-import os
 from TartanClasses import ASD, CCD, GetCtl, MyFpdf, TartanDialog, Sql
 from tartanFunctions import askQuestion, copyList, doPrinter, getModName
 
@@ -101,8 +100,8 @@
             self.games = chk[self.sql.bwltyp_col.index("bct_games")]
         self.groups = chk[self.sql.bwltyp_col.index("bct_groups")]
         self.grgame = chk[self.sql.bwltyp_col.index("bct_grgame")]
-        col = ["bcg_game", "bcg_aflag", "sum(bcg_shots_for)",
-            "sum(bcg_shots_agt)", "sum(bcg_points)"]
+        col = ["bcg_game", "bcg_aflag", "sum(bcg_sfor)",
+            "sum(bcg_sagt)", "sum(bcg_points)"]
         game = self.sql.getRec("bwlgme", cols=col, where=[("bcg_cono",
             "=", self.opts["conum"]), ("bcg_ccod", "=", self.ccod)],
             group="bcg_game, bcg_aflag", order="bcg_game")
@@ -150,21 +149,21 @@
             ("bcp_ptyp", "=", ptyp)], limit=1)
         self.ponly = pts[self.sql.bwlpts_col.index("bcp_p_only")]
         non = []
-        for c in chk:
-            scod = c[self.sql.bwlgme_col.index("bcg_scod")]
-            ocod = c[self.sql.bwlgme_col.index("bcg_ocod")]
+        for ck in chk:
+            scod = ck[self.sql.bwlgme_col.index("bcg_scod")]
+            ocod = ck[self.sql.bwlgme_col.index("bcg_ocod")]
             if scod > 900000 or ocod > 900000:
                 continue
             if self.ponly == "Y":
-                fors = c[self.sql.bwlgme_col.index("bcg_points")]
+                fors = ck[self.sql.bwlgme_col.index("bcg_points")]
                 agts = self.sql.getRec("bwlgme",
                     cols=["bcg_points"], where=[("bcg_cono", "=",
                     self.opts["conum"]), ("bcg_ccod", "=", self.ccod),
-                    ("bcg_game", "=", game), ("bcg_scod",
-                    "=", ocod)], limit=1)[0]
+                    ("bcg_game", "=", game), ("bcg_scod", "=", ocod)],
+                    limit=1)[0]
             else:
-                fors = c[self.sql.bwlgme_col.index("bcg_shots_for")]
-                agts = c[self.sql.bwlgme_col.index("bcg_shots_agt")]
+                fors = ck[self.sql.bwlgme_col.index("bcg_sfor")]
+                agts = ck[self.sql.bwlgme_col.index("bcg_sagt")]
             if not fors and not agts:
                 if scod not in non:
                     non.append(scod)
@@ -252,9 +251,9 @@
                 whr.append(("bcg_group", "=", gcod))
                 col = [
                     "bcg_scod", "btb_surname", "btb_names",
-                    "sum(bcg_a_shots_for) as sfor",
-                    "sum(bcg_a_shots_agt) as sagt",
-                    "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
+                    "sum(bcg_a_sfor) as sfor",
+                    "sum(bcg_a_sagt) as sagt",
+                    "sum(bcg_a_sfor - bcg_a_sagt) as agg",
                     "sum(bcg_a_points) as pts"]
                 recs = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=col,
                     where=whr, group="bcg_scod, btb_surname, btb_names",
@@ -279,8 +278,7 @@
                         break
             self.doMatchWin()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            "report", ext="pdf")
+            self.__class__.__name__, "report", ext="pdf")
         self.fpdf.output(pdfnam, "F")
         if self.df.repeml[1] == "Y":
             if not self.df.repeml[2]:
@@ -313,9 +311,9 @@
                 ("bcg_scod", "in", self.grps[grp][0]),
                 ("bcg_game", "=", self.pgame)])
             col.extend([
-                "sum(bcg_shots_for) as sfor",
-                "sum(bcg_shots_agt) as sagt",
-                "sum(bcg_shots_for - bcg_shots_agt) as agg",
+                "sum(bcg_sfor) as sfor",
+                "sum(bcg_sagt) as sagt",
+                "sum(bcg_sfor - bcg_sagt) as agg",
                 "sum(bcg_points) as pts"])
         else:
             whr.extend([
@@ -323,15 +321,15 @@
                 ("bcg_game", "<=", self.pgame)])
             if self.pgame <= self.grgame:
                 col.extend([
-                    "sum(bcg_shots_for) as sfor",
-                    "sum(bcg_shots_agt) as sagt",
-                    "sum(bcg_shots_for - bcg_shots_agt) as agg",
+                    "sum(bcg_sfor) as sfor",
+                    "sum(bcg_sagt) as sagt",
+                    "sum(bcg_sfor - bcg_sagt) as agg",
                     "sum(bcg_points) as pts"])
             else:
                 col.extend([
-                    "sum(bcg_a_shots_for) as sfor",
-                    "sum(bcg_a_shots_agt) as sagt",
-                    "sum(bcg_a_shots_for - bcg_a_shots_agt) as agg",
+                    "sum(bcg_a_sfor) as sfor",
+                    "sum(bcg_a_sagt) as sagt",
+                    "sum(bcg_a_sfor - bcg_a_sagt) as agg",
                     "sum(bcg_a_points) as pts"])
         recs = self.sql.getRec(tables=["bwlgme", "bwltab"], cols=col,
             where=whr, group="btb_tab, btb_surname, btb_names",
@@ -407,9 +405,9 @@
         for gme in xrange(1, self.games + 1):
             col = [
                 "bcg_scod", "btb_surname", "btb_names",
-                "sum(bcg_shots_for) as sfor",
-                "sum(bcg_shots_agt) as sagt",
-                "sum(bcg_shots_for - bcg_shots_agt) as agg",
+                "sum(bcg_sfor) as sfor",
+                "sum(bcg_sagt) as sagt",
+                "sum(bcg_sfor - bcg_sagt) as agg",
                 "sum(bcg_points) as pts"]
             whr = copyList(self.where)
             whr.append(("bcg_game", "=", gme))
@@ -511,18 +509,10 @@
                 continue
             for num, skp in enumerate(self.wins[gcod]):
                 self.fpdf.add_page()
-                self.fpdf.image(
-                    os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-                    "bowls.png"), 90, 10, w=10)
-                self.fpdf.image(
-                    os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-                    "bowls.png"), 100, 10, w=10)
-                self.fpdf.image(os.path.join(
-                    self.opts["mf"].rcdic["prgdir"], "img",
-                    "bowls.png"), 110, 10, w=10)
                 self.fpdf.setFont(style="B", size=24)
-                self.fpdf.drawText(self.cdes, y=30, h=10, align="C")
+                self.fpdf.drawText(self.cdes, h=10, align="C")
                 self.fpdf.drawText()
+                self.fpdf.setFont(style="B", size=18)
                 if gcod:
                     self.fpdf.drawText("GROUP %s" % self.grpcod[gcod],
                         h=10, align="C")

=== modified file 'bwl/bc3110.py' (properties changed: -x to +x)
--- old/bwl/bc3110.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc3110.py	2020-05-27 12:25:04 +0000
@@ -98,8 +98,7 @@
                 fpdf.drawText()
                 fpdf.drawText()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], pdfnam=pdfnam, repprt=self.df.repprt)
         self.opts["mf"].closeLoop()

=== modified file 'bwl/bc6010.py' (properties changed: -x to +x)
=== modified file 'bwl/bc6020.py' (properties changed: -x to +x)
=== modified file 'bwl/bc6030.py' (properties changed: -x to +x)
--- old/bwl/bc6030.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bc6030.py	2020-06-21 09:16:01 +0000
@@ -86,7 +86,7 @@
                 comps = self.sql.getRec("bwlcmp", cols=["bcm_code"],
                     where=[("bcm_cono", "=", self.opts["conum"])],
                     order="bcm_code")
-                col = ["sum(bcg_shots_for)", "sum(bcg_shots_agt)",
+                col = ["sum(bcg_sfor)", "sum(bcg_sagt)",
                     "sum(bcg_points)"]
                 for comp in comps:
                     chk = self.sql.getRec("bwlgme", cols=col,
@@ -95,7 +95,7 @@
                     if not chk:
                         dels.append(comp[0])
                         continue
-                    elif not chk[0] and not chk[1] and not chk[2]:
+                    if not chk[0] and not chk[1] and not chk[2]:
                         dels.append(comp[0])
             if self.comps == "A" or dels:
                 tabs = [

=== modified file 'bwl/bcc110.py' (properties changed: -x to +x)
--- old/bwl/bcc110.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bcc110.py	2020-04-29 16:00:10 +0000
@@ -36,8 +36,9 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["memctl", "memctc", "bwlctl",
-            "bwltab", "chglog"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["memctl", "memctc", "memmst",
+            "memadd", "memkon", "bwlctl", "bwltab", "chglog"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             if self.sql.error == ["memctl"]:
                 self.memctl = False
@@ -117,7 +118,7 @@
             (("T",0,seq + 10,0),("IRB",r4s),0,"Draw Format","",
                 self.acc[14],"N",None,None,None,None),
             (("T",0,seq + 11,0),"ITX",50,"Email Address","",
-                self.acc[15],"N",None,None,None,None)])
+                self.acc[15],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -237,14 +238,17 @@
             if self.new:
                 self.sql.insRec("bwlctl", data=data)
             elif data != self.acc[:len(data)]:
+                col = self.sql.bwlctl_col
+                data.append(self.acc[col.index("ctb_xflag")])
                 self.sql.updRec("bwlctl", data=data, where=[("ctb_cono", "=",
                     self.opts["conum"])])
                 dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
                 for num, dat in enumerate(self.acc):
                     if dat != data[num]:
-                        self.sql.insRec("chglog", data=["bwlctl", "U", "%03i" %
-                            self.opts["conum"], self.sql.bwlctl_col[num], dte,
-                            self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.sql.insRec("chglog", data=["bwlctl", "U",
+                            "%03i" % self.opts["conum"], col[num], dte,
+                            self.opts["capnm"], str(dat), str(data[num]),
+                            "", 0])
             if self.chgint and self.oldint == "Y":
                 recs = self.sql.getRec("bwltab", cols=["btb_memno"],
                     where=[("btb_cono", "=", self.opts["conum"])])

=== modified file 'bwl/bcc210.py' (properties changed: -x to +x)
--- old/bwl/bcc210.py	2020-04-21 08:42:36 +0000
+++ new/bwl/bcc210.py	2020-04-24 14:17:25 +0000
@@ -81,9 +81,10 @@
                 self.df.loadEntry(frt, pag, num, data=fld)
 
     def doName(self, frt, pag, r, c, p, i, w):
-        if self.newclb and self.sql.getRec(
-                tables="bwlclb", where=[("bcc_name", "ilike", w)]):
-            return "A Club with this Name Already Exists"
+        if self.newclb:
+            chk = self.sql.getRec("bwlclb", where=[("bcc_name", "ilike", w)])
+            if chk:
+                return "A Club with this Name Already Exists"
 
     def doDelete(self):
         if self.newclb:
@@ -103,10 +104,12 @@
         self.opts["mf"].dbm.commitDbase()
 
     def doEnd(self):
-        data = self.df.t_work[0][0]
+        data = self.df.t_work[0][0][:]
         if self.newclb:
             self.sql.insRec("bwlclb", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.bwlclb_col
+            data.append(self.old[col.index("bcc_xflag")])
             self.sql.updRec("bwlclb", data=data, where=[("bcc_code", "=",
                 self.club)])
         self.opts["mf"].dbm.commitDbase()

=== added file 'crs/__init__.py'
=== modified file 'crs/cr1010.py' (properties changed: -x to +x)
--- old/crs/cr1010.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr1010.py	2020-06-20 14:13:39 +0000
@@ -179,9 +179,9 @@
             self.new = False
             self.df.loadEntry("T", pag, p+1, data=self.old[2])
             d = 3
-            for pag in xrange(1, self.df.pgs+1):
-                for x in xrange(0, self.df.topq[pag]):
-                    self.df.loadEntry("T", pag, x, data=self.old[d])
+            for pge in range(1, self.df.pgs+1):
+                for x in range(0, self.df.topq[pge]):
+                    self.df.loadEntry("T", pge, x, data=self.old[d])
                     d = d + 1
 
     def doName(self, frt, pag, r, c, p, i, w):
@@ -228,7 +228,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["crsmst", "D", "%03i%-7s" % \
             (self.opts["conum"], self.acno), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -259,18 +259,19 @@
             data.extend(["N", ""])
             self.sql.insRec("crsmst", data=data)
         else:
-            data.append(self.old[self.sql.crsmst_col.index("crm_stat")])
+            col = self.sql.crsmst_col
+            data.append(self.old[col.index("crm_stat")])
+            data.append(self.old[col.index("crm_xflag")])
             if data != self.old[:len(data)]:
                 self.sql.updRec("crsmst", data=data, where=[("crm_cono", "=",
                     self.opts["conum"]), ("crm_acno", "=", self.acno)])
-                dte = long("%04i%02i%02i%02i%02i%02i" %
-                        time.localtime()[:-3])
+                dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
                 for num, dat in enumerate(self.old):
                     if dat != data[num]:
                         self.sql.insRec("chglog", data=["crsmst", "U",
                             "%03i%-7s" % (self.opts["conum"], self.acno),
-                            self.sql.crsmst_col[num], dte, self.opts["capnm"],
-                            str(dat), str(data[num]), 0])
+                            col[num], dte, self.opts["capnm"], str(dat),
+                            str(data[num]), "", 0])
         if "args" in self.opts:
             self.doQuit()
         else:

=== modified file 'crs/cr2010.py' (properties changed: -x to +x)
--- old/crs/cr2010.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr2010.py	2020-07-01 12:46:28 +0000
@@ -46,8 +46,8 @@
         # Create SQL Object
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "ctlvmf", "ctlvrf",
             "ctlvtf", "crsmst", "crstrn", "genint", "genmst", "gentrn",
-            "lonmf1", "lonmf2", "lonrte", "lontrn", "waglmf", "wagltf"],
-            prog=self.__class__.__name__)
+            "lonmf1", "lonmf2", "lonrte", "lontrn", "wagedc", "wagmst",
+            "waglmf", "wagltf"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         # Check for Company record
@@ -231,9 +231,11 @@
         if self.opts["rtn"] in (2, 5):
             fld[3][2] = 22
             fld.extend([
-                (("C",1,0,5),"ISD",13.2,"Discount",
-                    "Discount Amount","","N",self.doDisAmt,None,None,None),
-                [("C",1,0,6),"INA",(22,30),"Details","Transaction Details",
+                (("C",1,0,5),"ISD",13.2,"Discount","Discount Amount",
+                    "","N",self.doDisAmt,None,None,None,None,
+                    "Discount Amount to be Added to the Transaction Amount."),
+                (("C",1,0,6),"OSD",13.2,"Total-Amount"),
+                [("C",1,0,7),"INA",(22,30),"Details","Transaction Details",
                     "","N",self.doTrnDet,None,None,None]])
         elif self.glint == "Y":
             if self.glinp == "E":
@@ -311,9 +313,7 @@
                     self.taxdf,"N",self.doVatCode1,vtm,None,("notblank",)),
                 (("C",1,0,6),"ISD",13.2,"V.A.T","V.A.T Amount",
                     "","N",self.doVatAmt,None,None,None),
-                (("C",1,0,7),"IUD",6.2,"Disc-%","Discount Percent",
-                    "","N",self.doDisAmt,None,None,None),
-                [("C",1,0,8),"INA",(18,30),"Details","Transaction Details",
+                [("C",1,0,7),"INA",(18,30),"Details","Transaction Details",
                     "","N",self.doTrnDet,None,None,None]])
         but = (
             ("Interrogate",None,self.queryCrs,0,("C",1,1),("C",1,2),
@@ -359,9 +359,9 @@
 
     def doCrsAcc(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec("crsmst", cols=["crm_name", "crm_terms",
-            "crm_termsb", "crm_stday", "crm_pydis", "crm_glac", "crm_stat"],
-            where=[("crm_cono", "=", self.opts["conum"]), ("crm_acno", "=",
-            w)], limit=1)
+            "crm_vatno", "crm_termsb", "crm_stday", "crm_pydis",
+            "crm_glac", "crm_stat"], where=[("crm_cono", "=",
+            self.opts["conum"]), ("crm_acno", "=", w)], limit=1)
         if not acc:
             return "Invalid Account Number"
         if acc[6] == "X":
@@ -369,10 +369,11 @@
         self.cracno = w
         self.name = acc[0]
         self.term = acc[1]
-        self.base = acc[2]
-        self.stdt = acc[3]
-        self.pdis = acc[4]
-        self.glac = acc[5]
+        self.vatn = acc[2]
+        self.base = acc[3]
+        self.stdt = acc[4]
+        self.pdis = acc[5]
+        self.glac = acc[6]
         self.df.loadEntry(frt, pag, p+1, data=self.name)
 
     def doRef1(self, frt, pag, r, c, p, i, w):
@@ -396,6 +397,11 @@
         if self.glint == "Y" or self.opts["rtn"] in (2, 5):
             self.vatcode = "N"
             self.vatamt = 0
+        if self.opts["rtn"] not in (2, 5) and self.glint == "N":
+            if not self.vatn:
+                self.df.loadEntry(frt, pag, p+1, data="N")
+            else:
+                self.df.loadEntry(frt, pag, p+1, data=self.taxdf)
 
     def doVatCode1(self, frt, pag, r, c, p, i, w):
         vrte = getVatRate(self.sql, self.opts["conum"], w, self.trndat)
@@ -424,6 +430,8 @@
         else:
             self.disamt = w
         self.df.loadEntry(frt, pag, p, data=self.disamt)
+        totamt = float(ASD(self.trnamt) + ASD(self.disamt))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doTrnDet(self, frt, pag, r, c, p, i, w):
         self.trndet = w
@@ -607,7 +615,9 @@
         chk = chkGenAcc(self.opts["mf"], self.allcoy, w, ctl=ctl)
         if type(chk) is str:
             return chk
-        if not chk[2]:
+        if not self.vatn:
+            self.taxgl = "N"
+        elif not chk[2]:
             self.taxgl = self.taxdf
         else:
             self.taxgl = chk[2]

=== modified file 'crs/cr3010.py' (properties changed: -x to +x)
--- old/crs/cr3010.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3010.py	2020-05-27 12:25:12 +0000
@@ -168,8 +168,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'crs/cr3020.py' (properties changed: -x to +x)
--- old/crs/cr3020.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3020.py	2020-06-20 14:14:43 +0000
@@ -305,8 +305,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -452,7 +451,7 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(crtrtp)):
+        for x, t in enumerate(crtrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             dr = CCD(self.gdr[x], "SD", 15.2)
             cr = CCD(self.gcr[x], "SD", 15.2)
@@ -461,10 +460,10 @@
             vt = CCD(self.gvt[x], "SD", 15.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-27s %s %s %s %s %s" % \
-                (crtrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-34s %s %s %s %s %s" % \
-                (crtrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))
             tot[2] = float(ASD(tot[2]) + ASD(cr.work))

=== modified file 'crs/cr3030.py' (properties changed: -x to +x)
--- old/crs/cr3030.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3030.py	2020-06-20 10:44:00 +0000
@@ -169,25 +169,25 @@
                 ptyp = "E"
             else:
                 ptyp = "C"
-            col, recs = getTrn(self.opts["mf"].dbm, "crs", whr=[("crt_cono",
+            col, trns = getTrn(self.opts["mf"].dbm, "crs", whr=[("crt_cono",
                 "=", self.opts["conum"]), ("crt_acno", "=", acno.work),
                 ("crt_paydt", "<=", self.pdatw), ("crt_payind", "=", "Y")],
                 neg=False, zer="N")
-            if not recs:
+            if not trns:
                 continue
             if not self.pgnum:
                 self.pageHeading(acno.disp, name.disp, ptyp)
             else:
                 self.newAccount(acno.disp, name.disp, ptyp)
-            for rec in recs:
-                ref1 = CCD(rec[col.index("crt_ref1")], "Na", 9)
-                ref2 = CCD(rec[col.index("crt_ref2")], "Na", 9)
-                trtp = CCD(rec[col.index("crt_type")], "UI", 1)
-                trdt = CCD(rec[col.index("crt_trdt")], "d1", 10)
-                disper = CCD(rec[col.index("crt_disper")], "SD", 7.2)
-                tramt = CCD(rec[col.index("crt_tramt")], "SD", 13.2)
-                paid = CCD(rec[col.index("paid")], "SD", 13.2)
-                trbal = CCD(rec[col.index("balance")], "SD", 13.2)
+            for trn in trns:
+                ref1 = CCD(trn[col.index("crt_ref1")], "Na", 9)
+                ref2 = CCD(trn[col.index("crt_ref2")], "Na", 9)
+                trtp = CCD(trn[col.index("crt_type")], "UI", 1)
+                trdt = CCD(trn[col.index("crt_trdt")], "d1", 10)
+                disper = CCD(trn[col.index("crt_disper")], "SD", 7.2)
+                tramt = CCD(trn[col.index("crt_tramt")], "SD", 13.2)
+                paid = CCD(trn[col.index("paid")], "SD", 13.2)
+                trbal = CCD(trn[col.index("balance")], "SD", 13.2)
                 sett = round((trbal.work * disper.work / 100), 2)
                 sett = CCD(sett, "SD", 13.2)
                 nett = float(ASD(trbal.work) - ASD(sett.work))
@@ -216,8 +216,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'crs/cr3040.py' (properties changed: -x to +x)
--- old/crs/cr3040.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3040.py	2020-10-15 17:18:31 +0000
@@ -159,8 +159,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'crs/cr3050.py' (properties changed: -x to +x)
--- old/crs/cr3050.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3050.py	2020-05-27 12:25:39 +0000
@@ -195,8 +195,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Creditor's Age Analaysis up to %s" %
             self.opts["period"])
@@ -266,8 +265,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'crs/cr3060.py' (properties changed: -x to +x)
--- old/crs/cr3060.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3060.py	2020-05-27 12:25:44 +0000
@@ -158,8 +158,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'crs/cr3070.py' (properties changed: -x to +x)
=== modified file 'crs/cr3080.py' (properties changed: -x to +x)
--- old/crs/cr3080.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3080.py	2020-08-07 09:31:49 +0000
@@ -348,8 +348,8 @@
                 "balance", "crt_paydt", "crt_payind", "crt_payamt")
             for d in dat:
                 rec = []
-                for c in cols:
-                    rec.append(d[col.index(c)])
+                for cc in cols:
+                    rec.append(d[col.index(cc)])
                 data.append(rec)
         self.ex.colf[0][1][8]["where"] = data
 
@@ -470,8 +470,7 @@
         else:
             key = "%s_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-            ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Remittance Advice" % self.opts["conam"],

=== modified file 'crs/cr3090.py' (properties changed: -x to +x)
--- old/crs/cr3090.py	2020-03-01 12:48:20 +0000
+++ new/crs/cr3090.py	2020-05-27 12:25:50 +0000
@@ -127,8 +127,7 @@
             p.closeProgress()
             if self.fpdf.page and not p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)

=== modified file 'crs/cr3100.py' (properties changed: -x to +x)
=== modified file 'crs/cr3110.py' (properties changed: -x to +x)
--- old/crs/cr3110.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr3110.py	2020-05-27 12:26:00 +0000
@@ -111,8 +111,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Creditor's Purchase History for the 12 Months "\
             "Period to %s" % self.coffd)
@@ -173,8 +172,7 @@
             return
         self.grandTotal()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header=self.tit, repprt=self.df.repprt, fromad=self.fromad,

=== modified file 'crs/cr4010.py' (properties changed: -x to +x)
--- old/crs/cr4010.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr4010.py	2020-06-20 14:17:40 +0000
@@ -30,12 +30,6 @@
 from tartanFunctions import askChoice, getTrn
 from tartanWork import crtrtp, mthnam
 
-"""
-30/60 days etc is done by crt_curdt and cra_curdt
-last purchase date is done by last crt_trdt and crt_type = 1
-last payment date is done by last crt_trdt and crt_type = 5
-"""
-
 class cr4010(object):
     def __init__(self, **opts):
         self.opts = opts
@@ -66,7 +60,7 @@
 
     def mainProcess(self):
         self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
-                "Creditors Interrogation (%s)" % self.__class__.__name__)
+            "Creditors Interrogation (%s)" % self.__class__.__name__)
         crm = {
             "stype": "R",
             "tables": ("crsmst",),
@@ -351,9 +345,9 @@
             whr = [
                 ("crm_cono", "=", self.opts["conum"]),
                 ("crm_acno", "=", self.acno)]
-            rp = TabPrt(self.opts["mf"], self.opts["conum"],
-                self.opts["conam"], name=self.__class__.__name__, tabs=table,
-                where=whr, keys=[self.acno])
+            rp = TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+                name=self.__class__.__name__, tabs=table, where=whr,
+                keys=[self.acno])
             repprt = rp.repprt
             repeml = rp.repeml
             xits = rp.xits
@@ -396,10 +390,9 @@
                 prtdia = (("Y","V"),("Y","N"))
             rp = RepPrt(self.opts["mf"], conum=self.opts["conum"],
                 conam=self.opts["conam"], name=self.__class__.__name__,
-                    ttype="D",
-                tables=data, heads=heads, cols=cols, trtp=["crt_type",
-                crtrtp], gtots=gtots, prtdia=prtdia, repprt=repprt,
-                repeml=repeml, fromad=self.fromad)
+                ttype="D", tables=data, heads=heads, cols=cols,
+                trtp=["crt_type", crtrtp], gtots=gtots, prtdia=prtdia,
+                repprt=repprt, repeml=repeml, fromad=self.fromad)
         self.df.setWidget(self.df.mstFrame, state="show")
         self.df.enableButtonsTags(state=state)
 

=== modified file 'crs/cr6010.py' (properties changed: -x to +x)
=== modified file 'crs/cr6020.py' (properties changed: -x to +x)
--- old/crs/cr6020.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr6020.py	2020-06-20 14:19:06 +0000
@@ -25,9 +25,8 @@
 """
 
 import time
-from TartanClasses import AgeTrans, ASD, GetCtl, ProgressBar, Sql
-from TartanClasses import TartanDialog, tk
-from tartanFunctions import copyList, getTrn
+from TartanClasses import AgeTrans, GetCtl, ProgressBar, Sql, TartanDialog, tk
+from tartanFunctions import copyList, doAutoAge, getTrn
 
 class cr6020(object):
     def __init__(self, **opts):
@@ -54,6 +53,12 @@
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.curdt = int(self.sysdtw / 100)
+        check = self.sql.sqlRec("Select cra_acno from crsage where cra_acno "\
+            "in (Select cra_acno from crsage group by cra_acno having "\
+            "sum(cra_amnt) <> 0) group by cra_acno")
+        for self.acno in check:
+            self.doReAgeAuto()
+            self.opts["mf"].dbm.commitDbase()
         if "args" not in self.opts:
             self.agevar = tk.BooleanVar()
             self.agevar.set(False)
@@ -170,59 +175,17 @@
                 wid = getattr(self.df, "B%s" % b)
                 self.df.setWidget(wid, "disabled")
             self.opts["mf"].updateStatus("Re-Ageing .... Please Wait!")
-        self.sql.delRec("crsage", where=[("cra_cono", "=", self.opts["conum"]),
-            ("cra_acno", "=", self.acno)])
-        crc, cr = getTrn(self.opts["mf"].dbm, "crs", whr=[("crt_cono", "=",
-            self.opts["conum"]), ("crt_acno", "=", self.acno), ("crt_tramt",
-            "<", 0)], odr="crt_trdt", zer="N")
-        if cr:
-            drc, dr = getTrn(self.opts["mf"].dbm, "crs", whr=[("crt_cono",
-                "=", self.opts["conum"]), ("crt_acno", "=", self.acno),
-                ("crt_tramt", ">", 0)], odr="crt_trdt", neg=False, zer="N")
-            if dr:
-                if "args" not in self.opts:
-                    self.df.setWidget(self.df.mstFrame, state="hide")
-                    txt = "Re-Allocating ... Please Wait"
-                    pb = ProgressBar(self.opts["mf"].body, typ=txt, mxs=len(cr))
-                for cno, ctr in enumerate(cr):
-                    if "args" not in self.opts:
-                        pb.displayProgress(cno)
-                    ccdt = ctr[crc.index("crt_curdt")]
-                    cbal = ctr[crc.index("balance")]
-                    camt = cbal
-                    for dno, dtr in enumerate(dr):
-                        dbal = dtr[drc.index("balance")]
-                        if not dbal:
-                            continue
-                        damt = float(ASD(dbal) + ASD(camt))
-                        if damt < 0:
-                            camt = damt
-                            damt = 0.00
-                        else:
-                            camt = 0.00
-                        diff = float(ASD(dbal) - ASD(damt))
-                        dr[dno][drc.index("balance")] = damt
-                        if diff:
-                            self.sql.insRec("crsage", data=[self.opts["conum"],
-                                self.acno, dtr[drc.index("crt_type")],
-                                dtr[drc.index("crt_ref1")], ccdt,
-                                ctr[drc.index("crt_type")],
-                                ctr[drc.index("crt_ref1")], diff, 0])
-                        if not camt:
-                            break
-                    diff = float(ASD(cbal) - ASD(camt))
-                    if diff:
-                        self.sql.insRec("crsage", data=[self.opts["conum"],
-                            self.acno,
-                            ctr[drc.index("crt_type")],
-                            ctr[drc.index("crt_ref1")], ccdt,
-                            ctr[drc.index("crt_type")],
-                            ctr[drc.index("crt_ref1")], diff, 0])
-                if "args" not in self.opts:
-                    pb.closeProgress()
-                    self.df.setWidget(self.df.mstFrame, state="show")
-        if "args" not in self.opts:
+            self.df.setWidget(self.df.mstFrame, state="hide")
+            txt = "Re-Allocating ... Please Wait"
+            pb = ProgressBar(self.opts["mf"].body, typ=("G", txt))
+            doAutoAge(self.opts["mf"].dbm, "crs", self.opts["conum"],
+                acno=self.acno, pbar=pb)
+            pb.closeProgress()
+            self.df.setWidget(self.df.mstFrame, state="show")
             self.agevar.set(False)
+        else:
+            doAutoAge(self.opts["mf"].dbm, "crs", self.opts["conum"],
+                acno=self.acno, pbar=None)
 
     def endTop(self):
         self.df.clearEntry("T", 0, 2)

=== modified file 'crs/cr6030.py' (properties changed: -x to +x)
--- old/crs/cr6030.py	2020-04-21 08:42:36 +0000
+++ new/crs/cr6030.py	2020-08-04 12:19:45 +0000
@@ -136,8 +136,8 @@
                     where=[("crm_cono", "=", self.opts["conum"]),
                     ("crm_acno", "=", rec)])
                 key = "%03i%-7s" % (self.opts["conum"], rec)
-                self.sql.insRec("chglog", data=["crsmst", "U", key, "crm_stat",
-                dte, self.opts["capnm"], "N", "X", 0])
+                self.sql.insRec("chglog", data=["crsmst", "U", key,
+                    "crm_stat", dte, self.opts["capnm"], "N", "X", "", 0])
             p.closeProgress()
             mess = """%s Accounts Will be Flagged as Redundant.
 
@@ -178,16 +178,23 @@
             if bal[0]:
                 return "Balance Exists"
         self.acno = w
-        self.df.loadEntry(frt, pag, p+1, data=chk[4])
+        name = chk[self.sql.crsmst_col.index("crm_name")]
+        self.df.loadEntry(frt, pag, p+1, data=name)
 
     def endPage(self):
         if self.flag == "C":
-            typ = "X"
+            old = "N"
+            new = "X"
         else:
-            typ = "N"
-        self.sql.updRec("crsmst", cols=["crm_stat"], data=[typ],
+            old = "X"
+            new = "N"
+        self.sql.updRec("crsmst", cols=["crm_stat"], data=[new],
             where=[("crm_cono", "=", self.opts["conum"]),
             ("crm_acno", "=", self.acno)])
+        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        key = "%03i%-7s" % (self.opts["conum"], self.acno)
+        self.sql.insRec("chglog", data=["crsmst", "U", key, "crm_stat",
+            dte, self.opts["capnm"], old, new, 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.clearFrame("T", 0)
         self.flag = ""

=== modified file 'crs/crc110.py' (properties changed: -x to +x)
--- old/crs/crc110.py	2020-04-21 08:42:36 +0000
+++ new/crs/crc110.py	2020-04-29 16:00:21 +0000
@@ -132,7 +132,7 @@
             (("T",0,seq,0),"INA",20,"Remittance Template","",
                 self.acc[6],"N",self.doTplNam,tpm,None,("efld",)),
             (("T",0,seq + 1,0),"ITX",50,"Email Address","",
-                self.acc[7],"N",None,None,None,None)])
+                self.acc[7],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -225,14 +225,17 @@
         if self.new:
             self.sql.insRec("crsctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.crsctl_col
+            data.append(self.acc[col.index("ctc_xflag")])
             self.sql.updRec("crsctl", data=data, where=[("ctc_cono", "=",
                 self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["crsctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.crsctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== added file 'csh/__init__.py'
=== modified file 'csh/cs2010.py' (properties changed: -x to +x)
--- old/csh/cs2010.py	2020-04-21 08:42:36 +0000
+++ new/csh/cs2010.py	2020-06-21 10:08:41 +0000
@@ -36,7 +36,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["cshana", "cshcnt", "genmst"])
+        self.sql = Sql(self.opts["mf"].dbm, ["cshana", "cshcnt", "genmst"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         t = time.localtime()
@@ -177,16 +178,16 @@
             "=", self.date)])
         if rec and self.trtp == "P":
             self.amend = True
-        for r in rec:
-            self.etotal = float(ASD(self.etotal) + ASD(r[7]))
+        for rr in rec:
+            self.etotal = float(ASD(self.etotal) + ASD(rr[7]))
         self.df.loadEntry(frt, pag, p+1, data=self.etotal)
         rec = self.sql.getRec("cshana", where=[("can_cono",
             "=", self.opts["conum"]), ("can_type", "=", "T"), ("can_date",
             "=", self.date)])
         if rec and self.trtp == "T":
             self.amend = True
-        for r in rec:
-            self.itotal = float(ASD(self.itotal) + ASD(r[7]))
+        for rr in rec:
+            self.itotal = float(ASD(self.itotal) + ASD(rr[7]))
         self.df.loadEntry(frt, pag, p+2, data=self.itotal)
         self.rec = self.sql.getRec("cshcnt", where=[("cct_cono",
             "=", self.opts["conum"]), ("cct_type", "=", "T"), ("cct_date",

=== modified file 'csh/cs3010.py' (properties changed: -x to +x)
--- old/csh/cs3010.py	2020-04-21 08:42:36 +0000
+++ new/csh/cs3010.py	2020-05-27 12:26:34 +0000
@@ -128,8 +128,7 @@
                 self.doSummary()
         if not self.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'doc/ASS.rst' (properties changed: -x to +x)
--- old/doc/ASS.rst	2019-02-24 15:37:36 +0000
+++ new/doc/ASS.rst	2020-06-18 14:07:41 +0000
@@ -16,10 +16,10 @@
 +++++++++++++++++++++++
 Use this routine to create asset's register depreciation codes.
 
-+  **Code** - Enter a code which can be up to 3 alphanumeric characters.
-+  **Description** - Enter a description for the depreciation type.
-+  **Type** - Select the type of depreciation, straight line or diminishing balance, for company and receiver, if applicable.
-+  **Rates** - Enter the depreciation rates for company and receiver, if applicable, as follows:
++ **Code** - Enter a code which can be up to 3 alphanumeric characters.
++ **Description** - Enter a description for the depreciation type.
++ **Type** - Select the type of depreciation, straight line or diminishing balance, for company and receiver, if applicable.
++ **Rates** - Enter the depreciation rates for company and receiver, if applicable, as follows:
     + **Year 1** - The first year's rate
     + **Years 2-7** - The following year's rates if applicable
 
@@ -36,8 +36,8 @@
     + **Accum Account** - This is the B/S Accumulated Depreciation Account.
     + **Expense Account** - This is the P&L Depreciation Expense Account.
 
-Masterfile Records
-++++++++++++++++++
+Masterfile Records (AR)
++++++++++++++++++++++++
 Use this routine to edit an asset's description or depreciation code.
 
 + **Group** - Enter the asset group.
@@ -45,12 +45,8 @@
 + **Description** - Enter the asset description.
 + **Depreciation Code** - Enter the asset depreciation code.
 
-.. raw:: pdf
-
-   PageBreak
-
-Data Capture
-............
+Data Capture (AR)
+.................
 Opening Balances (AR)
 +++++++++++++++++++++
 Use this routine to capture all existing assets.
@@ -67,20 +63,20 @@
     + **Coy-Dep** - Enter the total company depreciation up to the take-on date,
     + **Rec-Dep** - Enter the total receiver depreciation, if applicable, up to the take-on date.
 
-Payments, Receipts and Journal Entries
-++++++++++++++++++++++++++++++++++++++
+Payments, Receipts and Journal Entries (AR)
++++++++++++++++++++++++++++++++++++++++++++
 Use these routines to capture all asset movements as and when required. In addition, if integrated with the G/L, assets can also be captured while capturing Payments and Receipts by allocating to the asset account as entered in `Group Records (AR)`_.
 
-Depreciation
-++++++++++++
+Depreciation (AR)
++++++++++++++++++
 Use this routine to raise depreciation, as and when required.
 
 + **Cut-off Period** - Enter the last month period to take into account. Once you have confirmed the cut-off period the system will automatically determine the last period for which depreciation has been raised and then raise depreciation for each following month up to the cut-off period.
 
-Reporting
-.........
-Groups Listing
-++++++++++++++
+Reporting (AR)
+..............
+Groups Listing (AR)
++++++++++++++++++++
 Use this routine to produce a report of all asset groups.
 
 Batch Error Listing (AR)
@@ -100,8 +96,8 @@
 + **Batch-Number** - The batch number or blank for all.
 + **Totals Only** - Yes or No.
 
-Asset Statements
-++++++++++++++++
+Asset Statements (AR)
++++++++++++++++++++++
 Use this routine to produce asset statements.
 
 + **Start Period** - The starting period.
@@ -109,8 +105,8 @@
 + **Product Group** - The asset group or blank for all.
 + **Asset per Page** - Whether or not to start each asset on a new page.
 
-Asset Register
-++++++++++++++
+Asset Register (AR)
++++++++++++++++++++
 Use this routine to print an asset register.
 
 + **Cut-Off Period** - The last month period to take into account.
@@ -128,7 +124,7 @@
 + **From Action Date** - The starting action date.
 + **To Action Date** - The ending action date.
 
-Toolbox (CR)
+Toolbox (AR)
 ............
 Change Asset Codes (AR)
 +++++++++++++++++++++++

=== modified file 'doc/BKM.rst' (properties changed: -x to +x)
--- old/doc/BKM.rst	2017-08-24 07:49:34 +0000
+++ new/doc/BKM.rst	2020-06-19 15:20:20 +0000
@@ -21,14 +21,14 @@
 +++++++++++++++++
 Use this routine to maintain unit records.
 
-+  **Booking Type** - Select the type of unit.
-+  **Unit Code** - Enter a code which can be up to 6 alphanumeric characters.
-+  **Description** - Enter a description for the unit.
-+  **Number of Rooms** - Enter the number of bookable rooms in the unit.
-+  **Total Capacity** - Enter the total booking capacity for the unit. Enter 999 for infinite capacity.
-+  **Default Rate** - The default rate code for the unit.
-+  **Vat Code** - Enter the vat code applicable to the unit.
-+  **Sales Account** - Enter the G/L sales account, if integrated.
++ **Booking Type** - Select the type of unit.
++ **Unit Code** - Enter a code which can be up to 6 alphanumeric characters.
++ **Description** - Enter a description for the unit.
++ **Number of Rooms** - Enter the number of bookable rooms in the unit.
++ **Total Capacity** - Enter the total booking capacity for the unit. Enter 999 for infinite capacity.
++ **Default Rate** - The default rate code for the unit.
++ **Vat Code** - Enter the vat code applicable to the unit.
++ **Sales Account** - Enter the G/L sales account, if integrated.
 
 Rate Records (BK)
 +++++++++++++++++
@@ -105,7 +105,7 @@
 + **First Label Row** - The row of the first available blank label, 1-24.
 + **First Label Column** - The column of the first available blank label, 1-24.
 
-Notes Listing (AR)
+Notes Listing (BK)
 ++++++++++++++++++
 Use this routine to print any notes on the asset records.
 

=== modified file 'doc/BKS.rst' (properties changed: -x to +x)
--- old/doc/BKS.rst	2019-04-13 11:46:28 +0000
+++ new/doc/BKS.rst	2020-06-10 08:43:41 +0000
@@ -1,5 +1,5 @@
-Book Club (BS)
---------------
+Book Clubs
+----------
 Member Records (BS)
 ...................
 This routine is used to create or amend member's details.
@@ -8,16 +8,16 @@
 
 + **Code Number** - This is the member's code. To enter a new member enter zero.
 
-Author Records
-..............
+Author Records (BS)
+...................
 This routine is used to create or amend author's details.
 
 While most of the fields are self explanatory the following are of note:
 
 + **Author's Number** - This is the author's code. To enter a new author enter zero.
 
-Book Records
-............
+Book Records (BS)
+.................
 This routine is used to create or amend member's details.
 
 While most of the fields are self explanatory the following are of note:
@@ -25,8 +25,8 @@
 + **Code** - This is the book's code. To enter a new book enter zero.
 + **Month** - This is the month the book was received in YYYYMM format.
 
-Books Listing
-.............
+Books Listing (BS)
+..................
 This routine is used to generate a list of books and a precis of new books received at or after the last meeting.
 
 + **Last Meeting** - The date of the last meeting in YYYYMM format.
@@ -39,16 +39,3 @@
     + **Email Address** - Enter an email address or leave blank for all members.
     + **Email Message** - Select whether to change the default message.
     + **View/Print Emailed Document** - Select whether to view or print the emailed list.
-
-Help
-----
-About
-.....
-This routine will display the copyright details, version and contact information for Tartan Systems.
-
-+ **Licence** - The Tartan licence details.
-+ **Changes** - The Tartan changes since version 4 to date.
-
-Reference Manual
-................
-This routine will display this manual, if available, or the on-line one using your default browser.

=== removed file 'doc/BKSMST.rst'
--- old/doc/BKSMST.rst	2020-03-25 07:25:02 +0000
+++ new/doc/BKSMST.rst	1970-01-01 00:00:00 +0000
@@ -1,287 +0,0 @@
-==================================
- Tartan Systems - Reference Manual
-==================================
-.. _GPL: http://www.gnu.org/licenses/gpl.html
-
-:Version:   5.11
-:Author:    Paul Malherbe
-:Contact:   paul@tartan.co.za
-:Home:      http://www.tartan.co.za
-:Copyright: Paul Malherbe (C) 2004-2019.
-:Licence:   Free use of this software and all it's modules is granted under the terms of the GNU General Public License (GPL_) as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
-
-:Note: This document is not intended as an accounting manual. It is primarily a manual for people with some accounting expertise to learn how to use Tartan as an accounting tool.
-
-.. contents:: **Table of Contents**
-
-.. raw:: pdf
-
-   PageBreak
-
-About
------
-Tartan Systems started out in 1981 as a suite of programs I wrote in COBOL and until 1994 ran on various platforms including CPM, RSX11M, MSDOS, AT&T UNIX and SCO.
-
-In 1994 I discovered LINUX and when iBCS2 became available I modified the systems to run under LINUX and continue doing so until today.
-
-In 2003 I started looking around for another programming language in which I could rewrite the systems to   run under LINUX as well as Windows without having to recompile etc. Also I was getting irritated with having to compile using SCO.
-
-Eventually I decided on the following:
-
-+ Python_ as the programming language
-+ Tkinter_ for the graphical user interface
-+ Reportlab_ to generate reports
-+ Pychart_ to generate charts and graphs
-+ PostgreSQL_, MySQL_, Firebird_ and Pysqlite_ as supported relational databases
-
-In 2005, version 3, I changed the graphical user interface to PyGtk, a python wrapper for the Gtk library.
-
-In 2011, version 4, I dropped support for windows 9x and also replaced reportlab with pyfpdf.
-
-In 2015, version 5, I replaced PyGtk with Tkinter and ttk.
-
-.. _Python: http://www.python.org
-.. _Tkinter: http://www.python.org/topics/tkinter
-.. _Reportlab: http://www.reportlab.org
-.. _Pychart: http://www.hpl.hp.com/personal/Yasushi_Saito/pychart
-.. _PostgreSQL: http://www.postgresql.org
-.. _MySQL: http://dev.mysql.com
-.. _Firebird: http://www.firebirdsql.org
-.. _Pysqlite: http://code.google.com/p/pysqlite
-
-Installation Procedure
-----------------------
-Linux and Source
-----------------
-Ensure that the following dependencies are installed on your system:
-
-+ python >= 2.7.5 and < 3.0.0
-
-Windows also requires pywin32 >= build 216 downloaded from:
-
-    https://sourceforge.net/projects/pywin32/files/pywin32/
-
-The following dependencies must be installed using pip:
-
-+ fpdf >= 1.7.0
-+ pillow >= 2.3.0
-+ requests
-
-Additionally, the following dependencies should also be installed using pip:
-
-+ ghostscript           # Bulk Mail - pdf to jpg convert
-+ markdown              # Bulk Mail - enable markdown format
-+ odfpy                 # ODS File Reader - file import
-+ ofxtools              # OFX File Reader - bank statements
-+ pyaes                 # Password Manager - pm1010
-+ pycrypto              # Password Manager - pm1010
-+ pygal                 # SVG Charts
-+ pysmb                 # Netbios file names
-+ python-chart          # PDF Charts
-+ python-escpos         # POS esc commands
-+ send2trash            # Move files to recycle bin
-+ tkinterhtml           # HTML Viewer
-+ xlrd                  # Excel Read
-+ xlwt                  # Excel Write
-
-And, depending on your database needs, one of:
-
-+ Postgresql - psycopg2
-+ MySQL - pymysql
-+ Firebird - fdb
-
-Then download the following file from ftp://ftp.tartan.co.za
-
-+ Bksclb_5.x.x.tar.gz
-
-Extract Bksclb_5.x.x.tar.gz into a directory of your choice as follows:
-
-+ cd your.directory && tar -xvzf Bksclb_5.x.x.tar.gz
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Windows Binary
---------------
-Download the following file from ftp://ftp.tartan.co.za or if you are in possession of a CD this is not necessary.
-
-+ Bksclb_5.x.x.exe
-
-Install Bksclb_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, agree to creating an icon on your desktop.
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Startup Procedure
------------------
-Linux and Source
-----------------
-Start Tartan by entering the following command:
-
-    `python -OO program_path/ms0000.py [options]`
-
-To find out what the available command line options are, use the -h option.
-
-Windows Binary
---------------
-.. NOTE::
-  Users must first perform the following steps:
-
-    1) Right click on the Tartan shortcut icon.
-    2) Select `Properties` on the menu. A dialogue box will appear on the screen.
-    3) Click the `Advanced` button under the Shortcut tab in the dialogue box.
-    4) Check the `Run as administrator` box.
-    5) Click the `OK` button (or press Enter on your keyboard if the button is highlighted by default).
-    6) Finish by clicking `Apply` and then `OK`. Your preferences have been saved. Next time you open the shortcut to the application you performed the task for your computer will no longer require administrative permission.
-
-Start Tartan by clicking on the shortcut icon on the desktop or by navigating to the `C:\\Tartan\\prg` directory and double clicking on the `ms0000[.exe]` file.
-
-Both
-----
-The first time you run Tartan you will automatically be taken to `Preferences`_ where you will have to enter various parameters relating to your installation. After saving the preferences and restarting Tartan you will be prompted to create the database.
-
-.. raw:: pdf
-
-   PageBreak
-
-Status Line
------------
-.. NOTE::
-  When using Tartan your available options will be highlighted on the status line at the bottom left hand side of the screen. Please read this carefully before asking for assistance.
-
-Common Keyboard Functions
--------------------------
-Throughout the various modules comprising **Tartan Systems** the following keys are used to perform certain functions. These options will always be highlighted in the `Status Line`_ at the bottom of the screen. The most common ones are:
-
-+ **Enter**  - Accept keyboard input.
-+ **Esc**    - Exit a module or go to a previous entry field.
-+ **F1**     - Record Selection used with most data input routines.
-+ **F5**     - Record Deletion used with record maintenance routines.
-+ **F9**     - Input Termination used with multi-line text input.
-
-In addition to the above keys all underlined characters on notebook tags and buttons can be used, in conjunction with the <Alt> key, as shortcuts e.g <Alt-s> to open the System menu.
-
-Common Routines
----------------
-There are various common routines. Rather than continually describing them they will be described once here only.
-
-Printer Selection
------------------
-Whenever a report is being produced you will have the opportunity of deciding on the output method i.e. viewing, printing, exporting it.
-
-+ **Output** - Select the required output option.
-+ **Printer Name** - If you selected `Print`, enter the printer name.
-
-Error Messages
---------------
-Should an error message occur and there is a file named *errors.txt* in the `Work Path` as created in `Preferences`_. Please email the file to errors@tartan.co.za after which you may delete it.
-
-Menus and Sub Menus
--------------------
-System
-------
-Please note that depending on the security level of the user some of these routines might not be available.
-
-Upgrade System
-..............
-Select this routine to check if there are upgrades to Tartan and if so to install them.
-
-+ **Update Type** - Select whether to check the Tartan ftp site or a local LAN location. If Local is selected you will be able to browse for a location which will default to whatever is set in the *Upgrade Path* directory as set during the `Preferences`_ routine.
-
-* If there is an update and you want to upgrade, click on the `Update` button.
-
-Update File Formats
-...................
-If you have performed an upgrade of Tartan you will have to perform this routine as well. This routine will automatically update all table formats in the database. If you have more than one database (rcfile), you must perform this routine for each database.
-
-Backup Database
-...............
-Select this routine to create a backup of the current database. These backups will reside in the *Backup Path* directory as created using the `Preferences`_ routine. Each backup will further reside in a sub directory named after the name of the database and a further sub directory named `arch`.
-
-Restore Database
-................
-Select this routine to restore a previous backup.
-
-+ **Type** - Select a Full or Partial restore.
-+ **Archive** - Select the relevant archive to restore from.
-+ **All Companies** - `Yes` or `Include/Exclude` some companies.
-+ **Companies** - Comma separated list of companies to include or exclude.
-+ **All Systems** - `Yes` or `Include/Exclude` some systems.
-+ **Systems** - Comma separated list of systems to include or exclude.
-
-Please note that unless you really know what you are doing it is very dangerous to restore individual systems as your data could become unbalanced because of integration and table relationships.
-
-If you are doing a full restore and the database already exists you will be asked whether to drop it first. Unless you are sure of what you are doing select No.
-
-Preferences
-...........
-Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.
-
-+ **Configuration File** - This is the full path of your configuration file. Every user can have his or her own file. This file, by default, is placed in the user's home directory or, in Windows, the root directory of the Tartan installation e.g. `C:\\Tartan`. If you want to change this default, you must set an environment variable as **TARTANRC=path-to-rcfile** or use the command line option **-r path-to-rcfile**.
-
-+ **Database**
-
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
-    + **Database Name** - This can be any single word name defaulting to **tartan**.
-    + **Host Name** - This is the host name of the Server. This is not used with SQLite.
-    + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
-    + **Port Number** - This is the port number the database uses. Leaving this blank will enable the database default port.
-    + **Administrator** - This is the name used to connect to the database. This is not used with SQLite.
-    + **Password** - This is the password of the user. This is not necessary with SQLite.
-
-+ **General**
-
-    + **Program Path** - This is the path where the programs reside.
-    + **Backup Path** - This is the path where backups of the database will be stored.
-    + **Work Path** - This is the path of the work directory. All temporary files will be created in this directory.
-    + **Upgrade Path** - This is the path where any upgrades will be stored.
-    + **PDF Viewer** - This is the full path of the program used to display pdf files.  The default for LINUX is **evince** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **Print Command** - This is the full path of the print program used to print postscript files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **PS Converter** - This is the full path of the program needed to convert pdf files to postscript. The LINUX default is **pdftops** and the Windows one is **blank**.  If this field is left blank, no conversion will take place and the print routine will have to be able to print pdf files directly e.g. where one of `SumatraPDF`, `Foxit Reader` or `Acrobat Reader` has been selected as the printer.
-    + **CSV Reader** - This is the full path of the program used to read csv and xls file formats.
-    + **Screen Geometry** - This defaults to the suggested geometry for your screen. Entering a zero will achieve the same result.
-    + **Screen Placement** - Where the Tartan Window must be placed on the monitor i.e. Left, Centre or Right.
-    + **Show Tartan Image** - Whether to display the Tartan image on the Main Menu screen.
-    + **Enforce Confirm** - Whether confirmation is required on the completion of data entry.
-    + **Auto-completion** - Whether auto-completion will be available. This means that as you enter data, and if there are available options, these will appear either `In-Line` or in a `List` below the entry field, for selection.
-    + **Tool-tips** - Whether tool-tips will display as you hover your cursor over certain entry fields.
-    + **Error Alarm** - Whether or not to sound an audible alarm with errors. This can be No, Yes or Multimedia. Use Multimedia if you do not have an internal speaker.
-    + **Work Files** - Select the default action for work files when exiting Tartan.
-        + **Trash** - Send the files to the *Recycle Bin*.
-        + **Delete** - Delete the files.
-        + **Keep** - Keep the files in the work directory.
-
-+ **Dialog**
-
-    + **Menu Font**
-        + **Name** - This is the font family to be used for all menu items.
-        + **Size** - This is font size to be used for all menu items.
-    + **Default Font**
-        + **Name** - This is the font family to be used in all other cases.
-        + **Size** - This is font size to be used in all other cases.
-    + **Theme** - The theme to be used. The default theme is `clam`.
-    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
-    + **Normal**
-        + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button background colour.
-    + **Focus**
-        + **FG** - The focused button foreground colour.
-        + **BG** - The focused button background colour.
-    + **Disable**
-        + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button background colour.
-    + **Booking Query**
-        + **FG** - The booking manager calendar query foreground colour.
-        + **BG** - The booking manager calendar query background colour.
-    + **Booking Confirmed**
-        + **FG** - The booking manager calendar confirm foreground colour.
-        + **BG** - The booking manager calendar confirm background colour.
-    + **Booking Settled**
-        + **FG** - The booking manager calendar settle foreground colour.
-        + **BG** - The booking manager calendar settle background colour.
-
-|
-
-If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Club Record`.
-
-Quit
-....
-Select this to exit Tartan.

=== modified file 'doc/BQS.rst' (properties changed: -x to +x)
=== modified file 'doc/BWL.rst' (properties changed: -x to +x)
--- old/doc/BWL.rst	2020-03-01 12:48:20 +0000
+++ new/doc/BWL.rst	2020-08-06 15:33:54 +0000
@@ -1,7 +1,7 @@
-Bowls Clubs (BC)
-----------------
-Tabs
-....
+Bowls Clubs
+-----------
+Tabs (BC)
+.........
 Control Record (BC)
 +++++++++++++++++++
 Use this routine to create the bowls control record.
@@ -28,7 +28,7 @@
 Use this routine to create, delete or amend tab records.
 
 + **Tab Number** - The number of the tab or zero for the next available number depending on the gender of the member.
-+ **Membership Number** - If the Member system is integrated enter the member's membership number and the details will be obtained from there.
++ **Membership Number** - If the Member system is integrated and, the numbers are not the same, enter the member's membership number and the details will be obtained from there.
 + **Surname** - The person's surname.
 + **Names** - The person's names.
 + **Gender** - The person's gender.
@@ -116,10 +116,6 @@
 + **Tabs Draw Board** - Print an emulation of a tabs draw board.
 + **Include Empty Rinks** - Whether to include or exclude empty rinks when printing a tabs draw board.
 
-.. raw:: pdf
-
-    PageBreak
-
 How the Draw Works (BC)
 +++++++++++++++++++++++
 All the tab numbers, names and ratings are stored in a relational database.
@@ -127,43 +123,25 @@
 When a draw is made the following takes place:
 
 + **Required Positions** - Based on the number of entered players and the selected team size i.e. 3 or 4, we now calculate the number of skips, thirds, seconds and leads required. This takes into consideration split rinks as well.
-
 + **Ratings Only** - If only ratings are being used, i.e. no positions, the required number of players by position will be allocated by strength i.e. the required number of skips will be the highest rated players and the required number of thirds the next highest rated etc.
-
 + **Positions Only** - If only positions are being used, i.e. no ratings, and the required number of players, by position, is short the additional players will be randomly selected from the lower positions, in order.
-
 + **Combination** - If a combination of positions and ratings is used and the required number of players, by position, is short the additional players will be the highest rated from the lower positions, in order. All players elevated to a higher position loses 10% of their rating, by position, for the current draw e.g. a third rated 18 could become a skip rated 16 or a second rated 20 could theoretically become a skip rated 16.
-
 + **Draw**
-
-  + **Random** - 5,000 *RANDOM* draws are now generated and the one with the least number of anomalies is selected.
-
-    + **Teams** - Teams are created by randomly selecting a skip, third, second and lead. This is repeated until all players have been placed.
-
-    + **Anomalies**
-      
-        + **When applying history** - If *Apply History* was selected the history period is the period entered on the bowls control record under *Weeks Between Draws* e.g. 4 weeks which equals 28 days.
-
-            + Skips that have played against each other during the history period
-            + Players that have played with the same players during the history period
-            + Players that have played in a broken rink during the history period
-
-        + **Always**
-            + Difference in team strengths
-
-|
-
-  + **Strength v Strength** - A single draw is generated as follows:
-
-    + **Teams** - Teams are created by placing the highest rated skip with the highest rated third with the highest rated second with the highest rated lead. This is repeated until all players have been placed.
-    + **Balance** - Teams are then paired and balanced i.e. players might be moved from one team to another to try and equalise the team strengths.
-
-.. raw:: pdf
-
-    PageBreak
-
-League
-......
+    + **Random** - 5,000 *RANDOM* draws are now generated and the one with the least number of anomalies is selected.
+        + **Teams** - Teams are created by randomly selecting a skip, third, second and lead. This is repeated until all players have been placed.
+        + **Anomalies**
+            + **When applying history** - If *Apply History* was selected the history period is the period entered on the bowls control record under *Weeks Between Draws* e.g. 4 weeks which equals 28 days.
+                + Skips that have played against each other during the history period
+                + Players that have played with the same players during the history period
+                + Players that have played in a broken rink during the history period
+            + **Always**
+                + Difference in team strengths
+    + **Strength v Strength** - A single draw is generated as follows:
+        + **Teams** - Teams are created by placing the highest rated skip with the highest rated third with the highest rated second with the highest rated lead. This is repeated until all players have been placed.
+        + **Balance** - Teams are then paired and balanced i.e. players might be moved from one team to another to try and equalise the team strengths.
+
+League (BC)
+...........
 Club Records (BC)
 +++++++++++++++++
 Use this routine to add, amend and delete club records. These records are used by the `League Selections` modules.
@@ -245,15 +223,15 @@
 + **Match Date** -  Enter the match date to capture.
 + **Number of Forms** - The number of forms per team.
 + For each completed form enter the following.
-    * **Skp** - The skip's tab code.
-    * **Plr** - If capturing 4 forms per team enter the player's tab code.
-    * **SF** - The number of shots the team scored.
-    * **SA** - The number of shots the opposition scored.
-    * **4** - The skip's rating.
-    * **3** - The third's rating.
-    * **2** - The second's rating.
-    * **1** - The lead's rating.
-    * **Remarks** - Any remarks.
+    + **Skp** - The skip's tab code.
+    + **Plr** - If capturing 4 forms per team enter the player's tab code.
+    + **SF** - The number of shots the team scored.
+    + **SA** - The number of shots the opposition scored.
+    + **4** - The skip's rating.
+    + **3** - The third's rating.
+    + **2** - The second's rating.
+    + **1** - The lead's rating.
+    + **Remarks** - Any remarks.
 
 Match Assessment Report (BC)
 ++++++++++++++++++++++++++++
@@ -271,12 +249,8 @@
 + **Type** - Select the type of match, Fixture or Practice.
 + **First Round Date** - Enter the date that the first round of the season was played.
 
-.. raw:: pdf
-
-    PageBreak
-
-Club Competitions
-.................
+Club Competitions (BC)
+......................
 Competition Types (BC)
 ++++++++++++++++++++++
 Use this routine to create competition type records as follows:
@@ -412,12 +386,8 @@
 ++++++++++++++++++++++++++
 Use this routine to print forms with player's missing contact details.
 
-.. raw:: pdf
-
-    PageBreak
-
-Toolbox
-.......
+Toolbox (BC)
+............
 Change Tab Numbers (BC)
 +++++++++++++++++++++++
 Use this routine to change Tab numbers.

=== removed file 'doc/BWLMST.rst'
--- old/doc/BWLMST.rst	2020-03-25 07:25:02 +0000
+++ new/doc/BWLMST.rst	1970-01-01 00:00:00 +0000
@@ -1,384 +0,0 @@
-==================================
- Tartan Systems - Reference Manual
-==================================
-.. _GPL: http://www.gnu.org/licenses/gpl.html
-
-:Version:   5.11
-:Author:    Paul Malherbe
-:Contact:   paul@tartan.co.za
-:Home:      http://www.tartan.co.za
-:Copyright: Paul Malherbe (C) 2004-2019.
-:Licence:   Free use of this software and all it's modules is granted under the terms of the GNU General Public License (GPL_) as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
-
-:Note: This document is not intended as an accounting manual. It is primarily a manual for people with some accounting expertise to learn how to use Tartan as an accounting tool.
-
-.. contents:: **Table of Contents**
-
-.. raw:: pdf
-
-   PageBreak
-
-About
------
-Tartan Systems started out in 1981 as a suite of programs I wrote in COBOL and until 1994 ran on various platforms including CPM, RSX11M, MSDOS, AT&T UNIX and SCO.
-
-In 1994 I discovered LINUX and when iBCS2 became available I modified the systems to run under LINUX and continue doing so until today.
-
-In 2003 I started looking around for another programming language in which I could rewrite the systems to   run under LINUX as well as Windows without having to recompile etc. Also I was getting irritated with having to compile using SCO.
-
-Eventually I decided on the following:
-
-+ Python_ as the programming language
-+ Tkinter_ for the graphical user interface
-+ Reportlab_ to generate reports
-+ Pychart_ to generate charts and graphs
-+ PostgreSQL_, MySQL_, Firebird_ and Pysqlite_ as supported relational databases
-
-In 2005, version 3, I changed the graphical user interface to PyGtk, a python wrapper for the Gtk library.
-
-In 2011, version 4, I dropped support for windows 9x and also replaced reportlab with pyfpdf.
-
-In 2015, version 5, I replaced PyGtk with Tkinter and ttk.
-
-.. _Python: http://www.python.org
-.. _Tkinter: http://www.python.org/topics/tkinter
-.. _Reportlab: http://www.reportlab.org
-.. _Pychart: http://www.hpl.hp.com/personal/Yasushi_Saito/pychart
-.. _PostgreSQL: http://www.postgresql.org
-.. _MySQL: http://dev.mysql.com
-.. _Firebird: http://www.firebirdsql.org
-.. _Pysqlite: http://code.google.com/p/pysqlite
-
-Installation Procedure
-----------------------
-Linux and Source
-----------------
-Ensure that the following dependencies are installed on your system:
-
-+ python >= 2.7.5 and < 3.0.0
-
-Windows also requires pywin32 >= build 216 downloaded from:
-
-    https://sourceforge.net/projects/pywin32/files/pywin32/
-
-The following dependencies must be installed using pip:
-
-+ fpdf >= 1.7.0
-+ pillow >= 2.3.0
-+ requests
-
-Additionally, the following dependencies should also be installed using pip:
-
-+ ghostscript           # Bulk Mail - pdf to jpg convert
-+ markdown              # Bulk Mail - enable markdown format
-+ odfpy                 # ODS File Reader - file import
-+ ofxtools              # OFX File Reader - bank statements
-+ pyaes                 # Password Manager - pm1010
-+ pycrypto              # Password Manager - pm1010
-+ pygal                 # SVG Charts
-+ pysmb                 # Netbios file names
-+ python-chart          # PDF Charts
-+ python-escpos         # POS esc commands
-+ send2trash            # Move files to recycle bin
-+ tkinterhtml           # HTML Viewer
-+ xlrd                  # Excel Read
-+ xlwt                  # Excel Write
-
-And, depending on your database needs, one of:
-
-+ Postgresql - psycopg2
-+ MySQL - pymysql
-+ Firebird - fdb
-
-Then download the following file from ftp://ftp.tartan.co.za
-
-+ Bwlclb_5.x.x.tar.gz
-
-Extract Bwlclb_5.x.x.tar.gz into a directory of your choice as follows:
-
-+ cd your.directory && tar -xvzf Bwlclb_5.x.x.tar.gz
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Windows Binary
---------------
-Download the following file from ftp://ftp.tartan.co.za or if you are in possession of a CD this is not necessary.
-
-+ Bwlclb_5.x.x.exe
-
-Install Bwlclb_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, agree to creating an icon on your desktop.
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Startup Procedure
------------------
-Linux and Source
-----------------
-Start Tartan by entering the following command:
-
-    `python -OO program_path/ms0000.py [options]`
-
-To find out what the available command line options are, use the -h option.
-
-Windows Binary
---------------
-.. NOTE::
-  Users must first perform the following steps:
-
-    1) Right click on the Tartan shortcut icon.
-    2) Select `Properties` on the menu. A dialogue box will appear on the screen.
-    3) Click the `Advanced` button under the Shortcut tab in the dialogue box.
-    4) Check the `Run as administrator` box.
-    5) Click the `OK` button (or press Enter on your keyboard if the button is highlighted by default).
-    6) Finish by clicking `Apply` and then `OK`. Your preferences have been saved. Next time you open the shortcut to the application you performed the task for your computer will no longer require administrative permission.
-
-Start Tartan by clicking on the shortcut icon on the desktop or by navigating to the `C:\\Tartan\\prg` directory and double clicking on the `ms0000[.exe]` file.
-
-Both
-----
-The first time you run Tartan you will automatically be taken to `Preferences`_ where you will have to enter various parameters relating to your installation. After saving the preferences and restarting Tartan you will be prompted to create the database. Once the database has been created you will have to create the System record as per `System Record`_ as well as a Company record as per `Club Master Record`_.
-
-.. raw:: pdf
-
-   PageBreak
-
-Status Line
------------
-.. NOTE::
-  When using Tartan your available options will be highlighted on the status line at the bottom left hand side of the screen. Please read this carefully before asking for assistance.
-
-Common Keyboard Functions
--------------------------
-Throughout the various modules comprising **Tartan Systems** the following keys are used to perform certain functions. These options will always be highlighted in the `Status Line`_ at the bottom of the screen. The most common ones are:
-
-+ **Enter**  - Accept keyboard input.
-+ **Esc**    - Exit a module or go to a previous entry field.
-+ **F1**     - Record Selection used with most data input routines.
-+ **F5**     - Record Deletion used with record maintenance routines.
-+ **F9**     - Input Termination used with multi-line text input.
-
-In addition to the above keys all underlined characters on notebook tags and buttons can be used, in conjunction with the <Alt> key, as shortcuts e.g <Alt-s> to open the System menu.
-
-Common Routines
----------------
-There are various common routines. Rather than continually describing them they will be described once here only.
-
-User Validation
----------------
-If no users have been created using the `User's Maintenance`_ routine on the `System`_ menu and no password has been allocated to the **admin** user, the system will automatically log in using **admin** as the user name. In all other cases a user must log in by entering a valid name and password. If no password exists for the **admin** user a password should be created as soon as possible using the `Change Password`_ routine on the System_ menu.
-
-Printer Selection
------------------
-Whenever a report is being produced you will have the opportunity of deciding on the output method i.e. viewing, printing, exporting and, in some cases, whether or not to email it.  Please note that the option to email the report will only be available if there is a valid `SMTP Server` in the `System Record`_ record.
-
-+ **Output** - Select the required output option.
-+ **Printer Name** - If you selected `Print`, enter the printer name.
-+ **E-Mail Report** - If available, select whether or not to email the report.
-+ **E-Mail Address** - If available, enter the email address, if more than one, comma separate them.
-+ **E-Mail Message** - If available, enter the email message as well as any additional attachments, if any.
-
-Error Messages
---------------
-Should an error message occur and there is a file named *errors.txt* in the `Work Path` as created in `Preferences`_. Please email the file to errors@tartan.co.za after which you may delete it.
-
-Menus and Sub Menus
--------------------
-Please note that depending on the system modules selected when creating the company records, as detailed in `Club Master Record`_, and the security level of the user, some of the menus detailed below might not appear.
-
-System
-------
-Please note that depending on the security level of the user some of these routines might not be available.
-
-Change User
-...........
-Use this routine to change the current user. Selecting it will log the current user out and the new user can then log in as per `User Validation`_.
-
-Change Password
-...............
-Select this routine to change the logged in user's password. The user can change the password by first entering the old password followed by the new password twice, for confirmation.
-
-User's Maintenance
-..................
-Use this routine to create or amend user's records, permissions etc.
-
-+ **User Name** - You must enter the user's login name. In the case of existing users the screen will be populated with existing data.
-+ **Full Name** - The full name of the user.
-+ **User Password** - It is not necessary to enter passwords as users must change their own using `Change Password`_, after logging in.
-+ **Copy Existing User** - Use this to copy all permissions of an existing user.
-+ **Valid Companies** - The valid company's field is for limiting a user's access to specific companies and is a comma separated list of company numbers e.g. 1,2,3,4.
-+ **Security Level** - The Security levels are as follows:
-
-    + **0** - Enquiries Only
-    + **1** - 0 plus Reporting
-    + **2** - 1 plus Data Capture
-    + **3** - 2 plus File Maintenance
-    + **4** - 3 plus Month End Routines
-    + **5** - 4 plus Control Routines
-    + **6** - 5 plus Financial Year End Routine
-    + **7** - 6 plus User and Module Password Maintenance
-    + **8** - 7 plus Update File Formats
-    + **9** - Supervisor level, Everything
-
-+ The following fields are used to control which companies, systems and modules are available, only by password, to this user:
-
-    + **Coy** - A company number or zero for all companies
-    + **SS** - The system code
-    + **Prog** - A program module or blank for all modules of a system
-    + **Password** - The password. If the password is left blank it is the same as denying the selection i.e. The user will not be able to select the module(s).
-    + **Check Password** - If the password is not blank then enter the password again for verification
-
-.. raw:: pdf
-
-   PageBreak
-
-**Examples**
-
-.. csv-table::
-  :header: "Coy", "SS", "Prog", "Password", "Meaning"
-  :widths: 5, 5, 6, 10, 50
-
-  "0", "gl", "    ", "    ", "All general ledger modules for all companies would be denied."
-  "0", "gl", "2032", "    ", "General ledger payments data capture for all companies would be denied."
-  "0", "gl", "    ", "abcd", "All general ledger modules for all companies would require the password `abcd`."
-  "0", "gl", "2032", "abcd", "General ledger payments data capture for all companies would require the password `abcd`."
-
-Upgrade System
-..............
-Select this routine to check if there are upgrades to Tartan and if so to install them.
-
-+ **Update Type** - Select whether to check the Tartan ftp site or a local LAN location. If Local is selected you will be able to browse for a location which will default to whatever is set in the *Upgrade Path* directory as set during the `Preferences`_ routine.
-
-* If there is an update and you want to upgrade, click on the `Update` button.
-
-Update File Formats
-...................
-If you have performed an upgrade of Tartan you will have to perform this routine as well. This routine will automatically update all table formats in the database. If you have more than one database (rcfile), you must perform this routine for each database.
-
-Backup Database
-...............
-Select this routine to create a backup of the current database. These backups will reside in the *Backup Path* directory as created using the `Preferences`_ routine. Each backup will further reside in a sub directory named after the name of the database and a further sub directory named `arch`.
-
-Restore Database
-................
-Select this routine to restore a previous backup.
-
-+ **Type** - Select a Full or Partial restore.
-+ **Archive** - Select the relevant archive to restore from.
-+ **All Companies** - `Yes` or `Include/Exclude` some companies.
-+ **Companies** - Comma separated list of companies to include or exclude.
-+ **All Systems** - `Yes` or `Include/Exclude` some systems.
-+ **Systems** - Comma separated list of systems to include or exclude.
-
-Please note that unless you really know what you are doing it is very dangerous to restore individual systems as your data could become unbalanced because of integration and table relationships.
-
-If you are doing a full restore and the database already exists you will be asked whether to drop it first. Unless you are sure of what you are doing select No.
-
-Preferences
-...........
-Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.
-
-+ **Configuration File** - This is the full path of your configuration file. Every user can have his or her own file. This file, by default, is placed in the user's home directory or, in Windows, the root directory of the Tartan installation e.g. `C:\\Tartan`. If you want to change this default, you must set an environment variable as **TARTANRC=path-to-rcfile** or use the command line option **-r path-to-rcfile**.
-
-+ **Database**
-
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
-    + **Database Name** - This can be any single word name defaulting to **tartan**.
-    + **Host Name** - This is the host name of the Server. This is not used with SQLite.
-    + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
-    + **Port Number** - This is the port number the database uses. Leaving this blank will enable the database default port.
-    + **Administrator** - This is the name used to connect to the database. This is not used with SQLite.
-    + **Password** - This is the password of the user. This is not necessary with SQLite.
-
-+ **General**
-
-    + **Program Path** - This is the path where the programs reside.
-    + **Backup Path** - This is the path where backups of the database will be stored.
-    + **Work Path** - This is the path of the work directory. All temporary files will be created in this directory.
-    + **Upgrade Path** - This is the path where any upgrades will be stored.
-    + **PDF Viewer** - This is the full path of the program used to display pdf files.  The default for LINUX is **evince** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **Print Command** - This is the full path of the print program used to print postscript files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **PS Converter** - This is the full path of the program needed to convert pdf files to postscript. The LINUX default is **pdftops** and the Windows one is **blank**.  If this field is left blank, no conversion will take place and the print routine will have to be able to print pdf files directly e.g. where one of `SumatraPDF`, `Foxit Reader` or `Acrobat Reader` has been selected as the printer.
-    + **CSV Reader** - This is the full path of the program used to read csv and xls file formats.
-    + **Screen Geometry** - This defaults to the suggested geometry for your screen. Entering a zero will achieve the same result.
-    + **Screen Placement** - Where the Tartan Window must be placed on the monitor i.e. Left, Centre or Right.
-    + **Show Tartan Image** - Whether to display the Tartan image on the Main Menu screen.
-    + **Enforce Confirm** - Whether confirmation is required on the completion of data entry.
-    + **Auto-completion** - Whether auto-completion will be available. This means that as you enter data, and if there are available options, these will appear either `In-Line` or in a `List` below the entry field, for selection.
-    + **Tool-tips** - Whether tool-tips will display as you hover your cursor over certain entry fields.
-    + **Error Alarm** - Whether or not to sound an audible alarm with errors. This can be No, Yes or Multimedia. Use Multimedia if you do not have an internal speaker.
-    + **Work Files** - Select the default action for work files when exiting Tartan.
-        + **Trash** - Send the files to the *Recycle Bin*.
-        + **Delete** - Delete the files.
-        + **Keep** - Keep the files in the work directory.
-
-+ **Dialog**
-
-    + **Menu Font**
-        + **Name** - This is the font family to be used for all menu items.
-        + **Size** - This is font size to be used for all menu items.
-    + **Default Font**
-        + **Name** - This is the font family to be used in all other cases.
-        + **Size** - This is font size to be used in all other cases.
-    + **Theme** - The theme to be used. The default theme is `clam`.
-    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
-    + **Normal**
-        + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button background colour.
-    + **Focus**
-        + **FG** - The focused button foreground colour.
-        + **BG** - The focused button background colour.
-    + **Disable**
-        + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button background colour.
-    + **Booking Query**
-        + **FG** - The booking manager calendar query foreground colour.
-        + **BG** - The booking manager calendar query background colour.
-    + **Booking Confirmed**
-        + **FG** - The booking manager calendar confirm foreground colour.
-        + **BG** - The booking manager calendar confirm background colour.
-    + **Booking Settled**
-        + **FG** - The booking manager calendar settle foreground colour.
-        + **BG** - The booking manager calendar settle background colour.
-
-|
-
-If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Club Record`.
-
-Quit
-....
-Select this to exit Tartan.
-
-Control
--------
-System Record
-.............
-This routine is used to create or amend a system control record by entering the following:
-
-    + **Years to Keep History** - Enter the number of years that historical data must be retained. Enter a 0 for infinity.
-    + **Enforce Passwords** - Select Yes or No.
-    + **Minimum Characters** - If you elected to enforce passwords enter the minimum number of characters that the passwords must consist of.
-    + **Maximum Life (Days)** - If you elected to enforce passwords enter the maximum number of days that the passwords will be valid for.
-    + **Backup History (Days)** - Enter the maximum number of days that backups will be retained. Enter 0 for infinity.
-    + **SMTP Server** - If you have email then enter your SMTP server's address e.g. smtp.mweb.co.za or smtp.saix.net or smtp.vodacom.co.za
-    + **SMTP Security** - Select the appropriate security method.
-    + **SMTP Authentication** - Select the appropriate authentication method.
-    + **SMTP Port Number** - Select the appropriate smtp port number.
-    + **SMTP Username** - If your smtp server requires a username enter it here.
-    + **SMTP Password** - If your smtp server requires a password enter it here.
-    + **SMS Service** - Select Yes or No. In order to use the SMS facility. You will first have to register with www.smsportal.co.za in order to get a username and password.
-    + **SMS Username** - Enter the user name for the service.
-    + **SMS Password** - Enter the password for the service.
-    + **G/L Departments** - Whether to allow departmental financial reporting.
-    + **Number of Digits** - The number of digits the department code uses in the account numbers i.e. if you enter 3 then the first 3 digits of the 7 digit account number will be reserved for the department code.
-
-Club Master Record
-..................
-This routine is used to create or amend company records, at least one company, number 1, must be created.
-
-While most of the fields are self explanatory the following are of note:
-
-+ **E-Mail Address** - Your default email address.
-
-Email Log Report
-................
-Use this routine to print a report of emails sent by the system.

=== removed file 'doc/BWLUTY.rst'
--- old/doc/BWLUTY.rst	2019-01-13 16:38:59 +0000
+++ new/doc/BWLUTY.rst	1970-01-01 00:00:00 +0000
@@ -1,115 +0,0 @@
-Utilities
----------
-Telephone Directory
-...................
-Use this routine to manage a telephone directory.
-
-All the fields are self explanatory with the exception of the following:
-
-+ **Directory Groups** - These are 3 letter group codes. If the code does not exist you will have to also enter the group description. This code can also be used in the bulk mailing module.
-
-+ **Directory Entries** - These are the individual directory entries. All the fields are self explanatory with the exception of the 'Contact Groups' which is a comma separated list of directory groups.
-
-+ **Buttons**
-    + **Back** - Select this button to display the previous directory entry.
-    + **Forward** - Select this button to display the next directory entry.
-    + **Import** - Select this button to import all contacts from other sources e.g. Creditors, Debtors, Members, Bookings etc.
-    + **Notes** - Select this button to maintain notes relating to this entry.
-    + **Print** - Select this button to print all entries or the current entry.
-    + **Apply** - Select this button to apply current addition or change.
-    + **Contacts** - Select this button to maintain contacts of the current entry.
-    + **Cancel** - Select this button to cancel any current additions or changes.
-    + **Quit** - Select this button to quit the application.
-
-Bulk Mail Utility
-.................
-Use this routine to send bulk MAIL or bulk SMSes. In order to use the MAIL facility you must enter a valid SMTP server in the `System Control Record`. In order to use the SMS facility you must register with www.smsportal.co.za and then enter your username and password in the `System Control Record` using `System Record`_.
-
-+ **Delivery Type** - The available delivery types will depend on what is entered in the `System Control Record` and can be either E-Mail, SMS or both.
-
-+ **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number. Please note that Creditors and Debtors do not have SMS capabilities.
-
-    + **Bookings** - This list accesses the tartan booking's contacts.
-        + **Individuals** - Allow selection of individual recipients.
-    + **Bowls** - This list accesses the tartan bowl's tabs.
-        + **Category** - Allow selection by category.
-        + **Gender** - Allow selection by gender.
-        + **Individuals** - Allow selection of individual recipients.
-    + **Creditors** - This list accesses the tartan creditor's masterfile.
-        + **Email To** - Select the recipient.
-        + **Individuals** - Allow selection of individual recipients.
-    + **Debtors** - This list accesses the tartan debtor's masterfile.
-        + **Email To** - Select the recipient.
-        + **Activity** - Allow selection by business activity.
-        + **Type** - Allow selection by business type.
-        + **Individuals** - Allow selection of individual recipients.
-    + **Members** - This list accesses the tartan member's masterfile.
-        + **Category** - Allow selection by membership category.
-        + **Gender** - Allow selection by gender.
-        + **Personalise** - Allow penalisation of the recipient.
-        + **Name Detail** - Select whether to use the names or initials.
-        + **Individuals** - Allow selection of individual recipients.
-    + **Directory** - This list accesses the tartan telephone directory.
-        + **Group Selection** - Allow selection by group.
-        + **Include Contacts** - Include the recipient's contacts.
-        + **Individuals** - Allow selection of individual recipients.
-    + **CSV and XLS File** - This is a csv or xls file containing a name, email address and/or a mobile number.
-        + **File Name** - The full path of the file to use.
-        + **Ignore Invalid Lines** - Select whether to ignore invalid lines.
-        + **Mobile/Email Column** - Enter the column of the mobile number or email address.
-        + **Personalise** - Allow penalisation of the recipient.
-        + **Title** - Select whether or not to use titles.
-        + **Title Column** - Enter the column of the title.
-        + **Surname Column** - Enter the column of the surname.
-        + **Names Column** - Enter the column of the names.
-        + **Name Detail** - Select whether to use the names or initials.
-+ **Skip Delivery Errors** - Select whether or not to skip invalid email addresses.
-+ **Subject** - The subject of the email.
-+ **In-line Attachment** - Any in-line image to be included in the email.
-+ **Separate Attachment** - Any attachment to be attached to the email.
-+ **Message** - Any text message. In order to get the recipients name in the message use one of the following methods:
-    + **{{name}}** - Use this method if the recipient has separate surname and names fields.
-    + **{{surname}}** - Use this method if the recipient has a single name field where the surname and names are comma separated e.g. Malherbe, Paul.
-
-.. raw:: pdf
-
-    PageBreak
-
-Report Generator
-................
-Use this routine to generate ad hoc SQL reports. It is not necessary to know the SQL language but it is beneficial.
-
-+ **Name** - A name for the report.
-+ **Description** - A description of the report.
-+ **Heading-1** - The first heading of the report.
-+ **Heading-2** - A second heading, if applicable.
-
-The following screens are now available:
-
-+ **Tables** - These are the tables to be used to generate the report. At least one table must be selected.
-    + **Table Sequence** - A sequential number of the line to enter or edit.
-        + **Tables** - The table name. F1 will give a list of available tables.
-+ **Joins** - These are further tables to be joined to the ones selected in `Tables`.
-    + **T** - The type of join. F1 gives a list of available types.
-    + **Tables** - The table which must be joined.
-    + **Join Columns** - The columns to be used for the join.
-+ **Columns** - These are the table columns to show in the report. If no columns are selected, all columns will be used.
-    + **Column Sequence** - A sequential number of the line to enter or edit.
-        + **T** - The type of column.
-            + **C** - An actual column in the table.
-                + **Label** - The column name. You will be shown a list of columns to select from.
-            + **E** - An expression e.g. Sum, Avg, Count etc.
-                + **Label** - You will have to type a name for the expression. You will then be offered a selection of expression types and depending on your choice a further selection of options.
-                + **Expression** - The generated expression will now be displayed and you can either accept or edit it.
-        + **Heading** - The column heading.
-        + **TP** - The type of column. F1 will show all available types.
-        + **Size** - The width of the column in characters.
-        + **G** - Whether or not to group the report on this column.
-        + **S** - Whether or not to print sub totals for this column.
-        + **Narration** - If sub totals was selected, enter the narration of the sub total.
-        + **P** - If sub totals was selected, select whether or not to start a new page after each sub total.
-        + **G** - If the column type is numeric, select whether or not to print a grand total for the column.
-        + **D** - Whether or not to actually display the column in the report or simply to use it for totals etc.
-+ **Variables**
-+ **Exceptions**
-+ **Order**

=== modified file 'doc/CRS.rst' (properties changed: -x to +x)
=== modified file 'doc/CSH.rst' (properties changed: -x to +x)
--- old/doc/CSH.rst	2019-04-13 11:46:28 +0000
+++ new/doc/CSH.rst	2020-06-10 08:45:54 +0000
@@ -1,7 +1,7 @@
-Cash Analysis (CS)
-------------------
-Capture Analysis
-................
+Cash Analysis
+-------------
+Capture Analysis (CS)
+.....................
 This routine is used to facilitate cashing up e.g. Petty Cash.
 
 + **Type** - Select the type of the transaction.
@@ -11,24 +11,24 @@
 
 + **Expenses**
     + **Trans-Date** - The date of the expense.
-    + **Acc-Num** - The account number of the expense. Entering zero will enable the expense code maintenance facility.
+    + **Acc-Num** - The account number of the expense. This is a general ledger account number. Entering zero will enable the general ledger account maintenance routine.
     + **Description** - The description of the expense.
     + **V** - The VAT code.
     + **Inc-Amount** - The inclusive amount of the expense.
-    + **VAT-Amount** - The vat amount of the expense.
+    + **VAT-Amount** - The vat amount of the expense or Enter to automatically calculate.
 + **Income**
     + **Trans-Date** - The date of the receipt.
-    + **Acc-Num** - The account number of the receipt. Entering zero will enable the expense code maintenance facility.
+    + **Acc-Num** - The account number of the receipt. This is a general ledger account number. Entering zero will enable the general ledger account maintenance routine.
     + **Description** - The description of the receipt.
     + **V** - The VAT code.
     + **Inc-Amount** - The inclusive amount of the receipt.
-    + **VAT-Amount** - The vat amount of the receipt.
+    + **VAT-Amount** - The vat amount of the receipt or Enter to automatically calculate..
 + **Cash**
     + **Cheques** - The total value of cheques received.
     + **Quant** - The quantity of the denominations received.
 
-List Analysis
-.............
+List Analysis (CS)
+..................
 This routine is used to generate a list of the analysis captured.
 
 + **From Date** - The starting date to take into account.
@@ -41,16 +41,3 @@
     + **Email Address** - Enter an email address or leave blank for all members.
     + **Email Message** - Select whether to change the default message.
     + **View/Print Emailed Document** - Select whether to view or print the emailed list.
-
-Help
-----
-About
-.....
-This routine will display the copyright details, version and contact information for Tartan Systems.
-
-+ **Licence** - The Tartan licence details.
-+ **Changes** - The Tartan changes since version 4 to date.
-
-Reference Manual
-................
-This routine will display this manual, if available, or the on-line one using your default browser.

=== removed file 'doc/CSHMST.rst'
--- old/doc/CSHMST.rst	2020-03-25 07:25:02 +0000
+++ new/doc/CSHMST.rst	1970-01-01 00:00:00 +0000
@@ -1,345 +0,0 @@
-==================================
- Tartan Systems - Reference Manual
-==================================
-.. _GPL: http://www.gnu.org/licenses/gpl.html
-
-:Version:   5.11
-:Author:    Paul Malherbe
-:Contact:   paul@tartan.co.za
-:Home:      http://www.tartan.co.za
-:Copyright: Paul Malherbe (C) 2004-2019.
-:Licence:   Free use of this software and all it's modules is granted under the terms of the GNU General Public License (GPL_) as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
-
-:Note: This document is not intended as an accounting manual. It is primarily a manual for people with some accounting expertise to learn how to use Tartan as an accounting tool.
-
-.. contents:: **Table of Contents**
-
-.. raw:: pdf
-
-   PageBreak
-
-About
------
-Tartan Systems started out in 1981 as a suite of programs I wrote in COBOL and until 1994 ran on various platforms including CPM, RSX11M, MSDOS, AT&T UNIX and SCO.
-
-In 1994 I discovered LINUX and when iBCS2 became available I modified the systems to run under LINUX and continue doing so until today.
-
-In 2003 I started looking around for another programming language in which I could rewrite the systems to   run under LINUX as well as Windows without having to recompile etc. Also I was getting irritated with having to compile using SCO.
-
-Eventually I decided on the following:
-
-+ Python_ as the programming language
-+ Tkinter_ for the graphical user interface
-+ Reportlab_ to generate reports
-+ Pychart_ to generate charts and graphs
-+ PostgreSQL_, MySQL_, Firebird_ and Pysqlite_ as supported relational databases
-
-In 2005, version 3, I changed the graphical user interface to PyGtk, a python wrapper for the Gtk library.
-
-In 2011, version 4, I dropped support for windows 9x and also replaced reportlab with pyfpdf.
-
-In 2015, version 5, I replaced PyGtk with Tkinter and ttk.
-
-.. _Python: http://www.python.org
-.. _Tkinter: http://www.python.org/topics/tkinter
-.. _Reportlab: http://www.reportlab.org
-.. _Pychart: http://www.hpl.hp.com/personal/Yasushi_Saito/pychart
-.. _PostgreSQL: http://www.postgresql.org
-.. _MySQL: http://dev.mysql.com
-.. _Firebird: http://www.firebirdsql.org
-.. _Pysqlite: http://code.google.com/p/pysqlite
-
-Installation Procedure
-----------------------
-Linux and Source
-----------------
-Ensure that the following dependencies are installed on your system:
-
-+ python >= 2.7.5 and < 3.0.0
-
-Windows also requires pywin32 >= build 216 downloaded from:
-
-    https://sourceforge.net/projects/pywin32/files/pywin32/
-
-The following dependencies must be installed using pip:
-
-+ fpdf >= 1.7.0
-+ pillow >= 2.3.0
-+ requests
-
-Additionally, the following dependencies should also be installed using pip:
-
-+ ghostscript           # Bulk Mail - pdf to jpg convert
-+ markdown              # Bulk Mail - enable markdown format
-+ odfpy                 # ODS File Reader - file import
-+ ofxtools              # OFX File Reader - bank statements
-+ pyaes                 # Password Manager - pm1010
-+ pycrypto              # Password Manager - pm1010
-+ pygal                 # SVG Charts
-+ pysmb                 # Netbios file names
-+ python-chart          # PDF Charts
-+ python-escpos         # POS esc commands
-+ send2trash            # Move files to recycle bin
-+ tkinterhtml           # HTML Viewer
-+ xlrd                  # Excel Read
-+ xlwt                  # Excel Write
-
-And, depending on your database needs, one of:
-
-+ Postgresql - psycopg2
-+ MySQL - pymysql
-+ Firebird - fdb
-
-Then download the following file from ftp://ftp.tartan.co.za
-
-+ Cshana_5.x.x.tar.gz
-
-Extract Cshana_5.x.x.tar.gz into a directory of your choice as follows:
-
-+ cd your.directory && tar -xvzf Cshana_5.x.x.tar.gz
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Windows Binary
---------------
-Download the following file from ftp://ftp.tartan.co.za or if you are in possession of a CD this is not necessary.
-
-+ Cshana_5.x.x.exe
-
-Install Cshana_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, agree to creating an icon on your desktop.
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Startup Procedure
------------------
-Linux and Source
-----------------
-Start Tartan by entering the following command:
-
-    `python -OO program_path/ms0000.py [options]`
-
-To find out what the available command line options are, use the -h option.
-
-Windows Binary
---------------
-.. NOTE::
-  Users must first perform the following steps:
-
-    1) Right click on the Tartan shortcut icon.
-    2) Select `Properties` on the menu. A dialogue box will appear on the screen.
-    3) Click the `Advanced` button under the Shortcut tab in the dialogue box.
-    4) Check the `Run as administrator` box.
-    5) Click the `OK` button (or press Enter on your keyboard if the button is highlighted by default).
-    6) Finish by clicking `Apply` and then `OK`. Your preferences have been saved. Next time you open the shortcut to the application you performed the task for your computer will no longer require administrative permission.
-
-Start Tartan by clicking on the shortcut icon on the desktop or by navigating to the `C:\\Tartan\\prg` directory and double clicking on the `ms0000[.exe]` file.
-
-Both
-----
-The first time you run Tartan you will automatically be taken to `Preferences`_ where you will have to enter various parameters relating to your installation. After saving the preferences and restarting Tartan you will be prompted to create the database.
-
-.. raw:: pdf
-
-   PageBreak
-
-Status Line
------------
-.. NOTE::
-  When using Tartan your available options will be highlighted on the status line at the bottom left hand side of the screen. Please read this carefully before asking for assistance.
-
-Common Keyboard Functions
--------------------------
-Throughout the various modules comprising **Tartan Systems** the following keys are used to perform certain functions. These options will always be highlighted in the `Status Line`_ at the bottom of the screen. The most common ones are:
-
-+ **Enter**  - Accept keyboard input.
-+ **Esc**    - Exit a module or go to a previous entry field.
-+ **F1**     - Record Selection used with most data input routines.
-+ **F5**     - Record Deletion used with record maintenance routines.
-+ **F9**     - Input Termination used with multi-line text input.
-
-In addition to the above keys all underlined characters on notebook tags and buttons can be used, in conjunction with the <Alt> key, as shortcuts e.g <Alt-s> to open the System menu.
-
-Common Routines
----------------
-There are various common routines. Rather than continually describing them they will be described once here only.
-
-Printer Selection
------------------
-Whenever a report is being produced you will have the opportunity of deciding on the output method i.e. viewing, printing, exporting it.
-
-+ **Output** - Select the required output option.
-+ **Printer Name** - If you selected `Print`, enter the printer name.
-
-Error Messages
---------------
-Should an error message occur and there is a file named *errors.txt* in the `Work Path` as created in `Preferences`_. Please email the file to errors@tartan.co.za after which you may delete it.
-
-Menus and Sub Menus
--------------------
-System
-------
-Please note that depending on the security level of the user some of these routines might not be available.
-
-Upgrade System
-..............
-Select this routine to check if there are upgrades to Tartan and if so to install them.
-
-+ **Update Type** - Select whether to check the Tartan ftp site or a local LAN location. If Local is selected you will be able to browse for a location which will default to whatever is set in the *Upgrade Path* directory as set during the `Preferences`_ routine.
-
-* If there is an update and you want to upgrade, click on the `Update` button.
-
-Update File Formats
-...................
-If you have performed an upgrade of Tartan you will have to perform this routine as well. This routine will automatically update all table formats in the database. If you have more than one database (rcfile), you must perform this routine for each database.
-
-Backup Database
-...............
-Select this routine to create a backup of the current database. These backups will reside in the *Backup Path* directory as created using the `Preferences`_ routine. Each backup will further reside in a sub directory named after the name of the database and a further sub directory named `arch`.
-
-Restore Database
-................
-Select this routine to restore a previous backup.
-
-+ **Type** - Select a Full or Partial restore.
-+ **Archive** - Select the relevant archive to restore from.
-+ **All Companies** - `Yes` or `Include/Exclude` some companies.
-+ **Companies** - Comma separated list of companies to include or exclude.
-+ **All Systems** - `Yes` or `Include/Exclude` some systems.
-+ **Systems** - Comma separated list of systems to include or exclude.
-
-Please note that unless you really know what you are doing it is very dangerous to restore individual systems as your data could become unbalanced because of integration and table relationships.
-
-If you are doing a full restore and the database already exists you will be asked whether to drop it first. Unless you are sure of what you are doing select No.
-
-Preferences
-...........
-Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.
-
-+ **Configuration File** - This is the full path of your configuration file. Every user can have his or her own file. This file, by default, is placed in the user's home directory or, in Windows, the root directory of the Tartan installation e.g. `C:\\Tartan`. If you want to change this default, you must set an environment variable as **TARTANRC=path-to-rcfile** or use the command line option **-r path-to-rcfile**.
-
-+ **Database**
-
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
-    + **Database Name** - This can be any single word name defaulting to **tartan**.
-    + **Host Name** - This is the host name of the Server. This is not used with SQLite.
-    + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
-    + **Port Number** - This is the port number the database uses. Leaving this blank will enable the database default port.
-    + **Administrator** - This is the name used to connect to the database. This is not used with SQLite.
-    + **Password** - This is the password of the user. This is not necessary with SQLite.
-
-+ **General**
-
-    + **Program Path** - This is the path where the programs reside.
-    + **Backup Path** - This is the path where backups of the database will be stored.
-    + **Work Path** - This is the path of the work directory. All temporary files will be created in this directory.
-    + **Upgrade Path** - This is the path where any upgrades will be stored.
-    + **PDF Viewer** - This is the full path of the program used to display pdf files.  The default for LINUX is **evince** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **Print Command** - This is the full path of the print program used to print postscript files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **PS Converter** - This is the full path of the program needed to convert pdf files to postscript. The LINUX default is **pdftops** and the Windows one is **blank**.  If this field is left blank, no conversion will take place and the print routine will have to be able to print pdf files directly e.g. where one of `SumatraPDF`, `Foxit Reader` or `Acrobat Reader` has been selected as the printer.
-    + **CSV Reader** - This is the full path of the program used to read csv and xls file formats.
-    + **Screen Geometry** - This defaults to the suggested geometry for your screen. Entering a zero will achieve the same result.
-    + **Screen Placement** - Where the Tartan Window must be placed on the monitor i.e. Left, Centre or Right.
-    + **Show Tartan Image** - Whether to display the Tartan image on the Main Menu screen.
-    + **Enforce Confirm** - Whether confirmation is required on the completion of data entry.
-    + **Auto-completion** - Whether auto-completion will be available. This means that as you enter data, and if there are available options, these will appear either `In-Line` or in a `List` below the entry field, for selection.
-    + **Tool-tips** - Whether tool-tips will display as you hover your cursor over certain entry fields.
-    + **Error Alarm** - Whether or not to sound an audible alarm with errors. This can be No, Yes or Multimedia. Use Multimedia if you do not have an internal speaker.
-    + **Work Files** - Select the default action for work files when exiting Tartan.
-        + **Trash** - Send the files to the *Recycle Bin*.
-        + **Delete** - Delete the files.
-        + **Keep** - Keep the files in the work directory.
-
-+ **Dialog**
-
-    + **Menu Font**
-        + **Name** - This is the font family to be used for all menu items.
-        + **Size** - This is font size to be used for all menu items.
-    + **Default Font**
-        + **Name** - This is the font family to be used in all other cases.
-        + **Size** - This is font size to be used in all other cases.
-    + **Theme** - The theme to be used. The default theme is `clam`.
-    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
-    + **Normal**
-        + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button background colour.
-    + **Focus**
-        + **FG** - The focused button foreground colour.
-        + **BG** - The focused button background colour.
-    + **Disable**
-        + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button background colour.
-    + **Booking Query**
-        + **FG** - The booking manager calendar query foreground colour.
-        + **BG** - The booking manager calendar query background colour.
-    + **Booking Confirmed**
-        + **FG** - The booking manager calendar confirm foreground colour.
-        + **BG** - The booking manager calendar confirm background colour.
-    + **Booking Settled**
-        + **FG** - The booking manager calendar settle foreground colour.
-        + **BG** - The booking manager calendar settle background colour.
-
-|
-
-If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Club Record`.
-
-Quit
-....
-Select this to exit Tartan.
-
-Control
--------
-System Record Maintenance
-.........................
-This routine is used to create or amend a system control record by entering the following:
-
-    + **Years to Keep History** - Enter the number of years that historical data must be retained. Enter a 0 for infinity.
-    + **Enforce Passwords** - Select Yes or No.
-    + **Minimum Characters** - If you elected to enforce passwords enter the minimum number of characters that the passwords must consist of.
-    + **Maximum Life (Days)** - If you elected to enforce passwords enter the maximum number of days that the passwords will be valid for.
-    + **Backup History (Days)** - Enter the maximum number of days that backups will be retained. Enter 0 for infinity.
-    + **SMTP Server** - If you have email then enter your SMTP server's address e.g. smtp.mweb.co.za or smtp.saix.net or smtp.vodacom.co.za
-    + **SMTP Security** - Select the appropriate security method.
-    + **SMTP Authentication** - Select the appropriate authentication method.
-    + **SMTP Port Number** - Select the appropriate smtp port number.
-    + **SMTP Username** - If your smtp server requires a username enter it here.
-    + **SMTP Password** - If your smtp server requires a password enter it here.
-    + **SMS Service** - Select Yes or No. In order to use the SMS facility. You will first have to register with www.smsportal.co.za in order to get a username and password.
-    + **SMS Username** - Enter the user name for the service.
-    + **SMS Password** - Enter the password for the service.
-    + **G/L Departments** - Whether to allow departmental financial reporting.
-    + **Number of Digits** - The number of digits the department code uses in the account numbers i.e. if you enter 3 then the first 3 digits of the 7 digit account number will be reserved for the department code.
-
-Club Records Maintenance
-........................
-This routine is used to create or amend company records, at least one company, number 1, must be created.
-
-While most of the fields are self explanatory the following are of note:
-
-+ **E-Mail Address** - Your default email address.
-+ **V.A.T. Default** - Any alphanumeric character. If the code, except **N** which is used for no V.A.T., has not previously been created you will be prompted to create one as in `V.A.T. Records Maintenance`_.
-+ **Systems** - You must tick all the systems that you would like to enable otherwise they will not appear on your menu.
-+ **Logo** - You can select an image file to be used as the letterhead for invoices, statements and remittance advices. this file should be a jpg file.
-
-V.A.T. Records Maintenance
-..........................
-Use this routine to create, amend or delete value added tax records. Please note that you can have multiple rate records for a code e.g. Code 'I' could have a rate record starting at 2014/01/01 @ 14% and another one starting at 2016/01/01 @ 15% etc. The system will then automatically apply the correct rate depending on the transaction date of entries.
-
-+ **V,A.T. Code** - A single character V.A.T. code.
-+ **Description** - A description of the code.
-+ **Category** - The category of the code as follows:
-
-    + **C** for Capital Items
-    + **N** for Non Vattable Items
-    + **S** for Standard V.A.T. Codes
-    + **X** for X Rated Items
-    + **Z** for Zero Rated Items
-
-+ **Date** - The starting date of the current or new rate.
-+ **Rate** - The current or new rate.
-
-The following buttons are applicable:
-
-+ **Print** - Click this button to produce a report of all codes.
-+ **Add** - Use this button to add additional rate records.
-+ **Edit** - Use this button to edit existing codes and or rates. Please note that no codes or dates can be modified if any transactions have already been created using the code.
-+ **Exit** - Use this button to exit the selected code.

=== modified file 'doc/CTL.rst' (properties changed: -x to +x)
--- old/doc/CTL.rst	2020-04-20 12:42:42 +0000
+++ new/doc/CTL.rst	2020-06-19 09:12:10 +0000
@@ -4,22 +4,22 @@
 .........................
 This routine is used to create or amend a system control record by entering the following:
 
-    + **Years to Keep History** - Enter the number of years that historical data must be retained. Enter a 0 for infinity.
-    + **Enforce Passwords** - Select Yes or No.
-    + **Minimum Characters** - If you elected to enforce passwords enter the minimum number of characters that the passwords must consist of.
-    + **Maximum Life (Days)** - If you elected to enforce passwords enter the maximum number of days that the passwords will be valid for.
-    + **Backup History (Days)** - Enter the maximum number of days that backups will be retained. Enter 0 for infinity.
-    + **SMTP Server** - If you have email then enter your SMTP server's address e.g. smtp.mweb.co.za or smtp.saix.net or smtp.vodacom.co.za
-    + **SMTP Security** - Select the appropriate security method.
-    + **SMTP Authentication** - Select the appropriate authentication method.
-    + **SMTP Port Number** - Select the appropriate smtp port number.
-    + **SMTP Username** - If your smtp server requires a username enter it here.
-    + **SMTP Password** - If your smtp server requires a password enter it here.
-    + **SMS Service** - Select Yes or No. In order to use the SMS facility. You will first have to register with www.smsportal.co.za in order to get a username and password.
-    + **SMS Username** - Enter the user name for the service.
-    + **SMS Password** - Enter the password for the service.
-    + **G/L Departments** - Whether to allow departmental financial reporting.
-    + **Number of Digits** - The number of digits the department code uses in the account numbers i.e. if you enter 3 then the first 3 digits of the 7 digit account number will be reserved for the department code.
++ **Years to Keep History** - Enter the number of years that historical data must be retained. Enter a 0 for infinity.
++ **Enforce Passwords** - Select Yes or No.
++ **Minimum Characters** - If you elected to enforce passwords enter the minimum number of characters that the passwords must consist of.
++ **Maximum Life (Days)** - If you elected to enforce passwords enter the maximum number of days that the passwords will be valid for.
++ **Backup History (Days)** - Enter the maximum number of days that backups will be retained. Enter 0 for infinity.
++ **SMTP Server** - If you have email then enter your SMTP server's address e.g. smtp.mweb.co.za or smtp.saix.net or smtp.vodacom.co.za
++ **SMTP Security** - Select the appropriate security method.
++ **SMTP Authentication** - Select the appropriate authentication method.
++ **SMTP Port Number** - Select the appropriate smtp port number.
++ **SMTP Username** - If your smtp server requires a username enter it here.
++ **SMTP Password** - If your smtp server requires a password enter it here.
++ **SMS Service** - Select Yes or No. In order to use the SMS facility. You will first have to register with www.smsportal.co.za in order to get a username and password.
++ **SMS Username** - Enter the user name for the service.
++ **SMS Password** - Enter the password for the service.
++ **G/L Departments** - Whether to allow departmental financial reporting.
++ **Number of Digits** - The number of digits the department code uses in the account numbers i.e. if you enter 3 then the first 3 digits of the 7 digit account number will be reserved for the department code.
 
 Company Records Maintenance
 ...........................

=== modified file 'doc/Changes.rst' (properties changed: -x to +x)
=== modified file 'doc/Contact.rst' (properties changed: -x to +x)
--- old/doc/Contact.rst	2018-08-29 15:51:52 +0000
+++ new/doc/Contact.rst	2020-12-03 13:35:47 +0000
@@ -1,10 +1,10 @@
 Address
 =======
-| 1 Waterford Green
-| 43 Main Street
-| Newlands, Cape Town
+| 7 Onrus Manor
+| Chanteclair Avenue
+| Onrus River, Onrus
 | South Africa
-| 7700
+| 7201
 
 Other
 =====
@@ -13,6 +13,6 @@
   :header: "Description", "Detail"
   :widths: 12, 20
 
-  "Phone", "27-21-6710071"
+  "Phone", "27-28-3165036
   "Mobile", "27-82-9005260"
   "E-Mail", "paul@tartan.co.za"

=== modified file 'doc/DRS.rst' (properties changed: -x to +x)
--- old/doc/DRS.rst	2019-12-31 08:37:40 +0000
+++ new/doc/DRS.rst	2020-06-10 08:46:26 +0000
@@ -12,6 +12,7 @@
 + **G/L Input Method** - If integrated, select whether allocations to general ledger accounts are entered inclusive or exclusive of VAT.
 + **Chain Stores** - Select whether to enable chain store groups.
 + **Statement Template** - The default template to use for statements.
++ **Statement Ageing** - Select whether to print Aged Balances on the Statement or only an Account Balance.
 + **Email Address** - The email address of the person in charge of debtors, if not the default email address in the company record.
 
 Chain Stores (DR)

=== modified file 'doc/Downloads.rst' (properties changed: -x to +x)
--- old/doc/Downloads.rst	2020-04-20 12:42:42 +0000
+++ new/doc/Downloads.rst	2020-12-12 11:18:21 +0000
@@ -11,17 +11,17 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.11 and was released on the 25th March, 2020.
+The latest version of Tartan is 5.12 and was released on the 12th December, 2020.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Manual: http://www.tartan.co.za/cgi-bin/simple_web.py/Manual
-.. _Tartan-5.11-lnx: ftp://tartan.co.za/Tartan_5.11.tgz
+.. _Tartan-5.12-lnx: ftp://tartan.co.za/Tartan_5.12.tgz
 .. _Tartan-5.5-lnx: ftp://tartan.co.za/Tartan_5.5.tgz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.14.tgz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tgz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tgz
-.. _Tartan-5.11-win: ftp://tartan.co.za/Tartan_5.11.exe
+.. _Tartan-5.12-win: ftp://tartan.co.za/Tartan_5.12.exe
 .. _Tartan-5.5-win: ftp://tartan.co.za/Tartan_5.5.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.14.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
@@ -31,13 +31,13 @@
 =============
 New Installation
 ----------------
-Download the latest version of Tartan, Tartan-5.11-lnx_, and then follow the installation instructions in the Manual_.
+Download the latest version of Tartan, Tartan-5.12-lnx_, and then follow the installation instructions in the Manual_.
 
 Upgrade Existing Installation
 -----------------------------
 If your current version is less than 4.1.10 you must upgrade as follows:
 
-    * If your current version is less than 2.5.11
+    * If your current version is less than 2.5.12
         - Make a backup.
         - Download the last release of version 2, Tartan-2-lnx_
         - Extract the downloaded version into your Tartan/prg directory.
@@ -57,7 +57,7 @@
         - Download version 5.5, Tartan-5.5-lnx_
         - Extract the downloaded version into your Tartan/prg directory.
         - Login to Tartan and run `Update File Formats`
-    * Download the latest version, Tartan-5.11-lnx_
+    * Download the latest version, Tartan-5.12-lnx_
         - Make a backup.
         - Extract the downloaded version into your Tartan/prg directory.
         - Login to Tartan and run `Update File Formats`
@@ -65,7 +65,7 @@
 otherwise:
 
     * Make a backup.
-    * Execute `Upgrade System` from the System menu or download the latest version of Tartan, Tartan-5.11-lnx_, and extract it into your Tartan/prg directory.
+    * Execute `Upgrade System` from the System menu or download the latest version of Tartan, Tartan-5.12-lnx_, and extract it into your Tartan/prg directory.
     * Login to Tartan and run `Update File Formats`
 
 Old Versions
@@ -81,13 +81,13 @@
 
 New Installation
 ----------------
-Download the latest version of Tartan, Tartan-5.11-win_, and then follow the installation instructions in the Manual_.
+Download the latest version of Tartan, Tartan-5.12-win_, and then follow the installation instructions in the Manual_.
 
 Upgrade Existing Installation
 -----------------------------
 If your current version is less than 5.0.0 you must upgrade as follows:
 
-    * If your current version is less than 2.5.11
+    * If your current version is less than 2.5.12
         - Make a backup.
         - Download the last release of version 2, Tartan-2-win_
         - Execute the downloaded version by double clicking on it.
@@ -107,7 +107,7 @@
         - Download version 5.5, Tartan-5.5-win_
         - Execute the downloaded version by double clicking on it.
         - Login to Tartan and run `Update File Formats`
-    * Download the latest version, Tartan-5.11-win_
+    * Download the latest version, Tartan-5.12-win_
         - Make a backup.
         - Execute the downloaded version by double clicking on it.
         - Login to Tartan and run `Update File Formats`
@@ -115,7 +115,7 @@
 otherwise:
 
     * Make a backup.
-    * Execute `Upgrade System` from the System menu or download the latest update of Tartan, Tartan-5.11-win_, and run it.
+    * Execute `Upgrade System` from the System menu or download the latest update of Tartan, Tartan-5.12-win_, and run it.
     * Login to Tartan and run `Update File Formats`
 
 Old Versions

=== modified file 'doc/GEN.rst' (properties changed: -x to +x)
--- old/doc/GEN.rst	2019-04-30 09:07:25 +0000
+++ new/doc/GEN.rst	2020-07-24 10:30:20 +0000
@@ -461,7 +461,7 @@
 
 + **Process Bank Data** - This routine is to continue an import which was suspended for whatever reason. This is also the procedure for capturing unallocated transactions from the previous option i.e. `Import Bank File`. A screen showing all the unallocated transactions will display.
 
-  Select a transaction to process by clicking on it or moving the cursor to it and hitting the `Enter` key.  Continue from the `Details` field in the following section.
+  Select a transaction to process by clicking on it or moving the cursor to it. You can now either hit the `Enter` key and  Continue from the `Details` field in the following section or click *Create Import Record* and follow the same procedure as outlined above in *Bank Import Control* and then click *Process Bank Data* again.
 
 + **Manual Entries** - Use this procedure to enter the bank statement manually. If there are unallocated records from a previous import then this will be highlighted and you will first have to allocated these using the `Process Bank Data` routine, before continuing.
 
@@ -532,7 +532,7 @@
     + **Custom** - Customised Report
 + **Consolidate Companies** - Select whether or not to print a consolidated report. This is only applicable in a multi company installation.
 + **Report Number** - The relevant report number as created using `Report Generator (GL)`_.
-+ **General Report** - Select whether or not the report is a general report.
++ **General Report** - Select whether or not the report is a general report i.e. applies to all companies.
 + **Contents** - Select which values to use in the report.
 + **Detail Code** - If `Detail` was selected above, enter the detail code as created using `Detail Records (GL)`_.
 + **Variance** - Select which values to use as a variance or None for no variances.
@@ -629,6 +629,7 @@
 
 Interrogation (GL)
 ..................
+Use this routine to interrogate accounts.
 
 + **Normal** - Use this routine for querying individual general ledger accounts.
 + **Financials** - Use this routine for querying individual general ledger accounts by report. The report will appear in spreadsheet format and individual month's transactions can be viewed by double clicking on the Actual balance.

=== modified file 'doc/HLP.rst' (properties changed: -x to +x)
=== removed file 'doc/IBT.rst'
--- old/doc/IBT.rst	2017-08-24 07:49:34 +0000
+++ new/doc/IBT.rst	1970-01-01 00:00:00 +0000
@@ -1,96 +0,0 @@
-Inter Branch Transfers
-----------------------
-File Maintenance (IB)
-.....................
-Control Record (IB)
-+++++++++++++++++++
-Use this routine to create and amend the loan's control record.
-
-+ **Invoice Template** - The template to be used for invoices.
-+ **Creditor's Company** - The company number of the creditor's ledger.
-+ **Email Address** - The email address of the person in charge of transfers, if not the default email address in the company record.
-
-Data Capture (IB)
-.................
-Sales Invoices (IB)
-+++++++++++++++++++
-Use this routine to generate inter branch invoices for products delivered.
-
-+ **Template Name** - The template to be used for invoices.
-+ **Document date** - The date of the invoices.
-
-For each delivery enter the following:
-
-+ **Our Reference** - The local reference number e.g. Order Number.
-+ **Branch** - The branch number to be invoiced.
-+ **D/Note** - The delivery note number.
-+ **D/Date** - The delivery date.
-+ **Supplier-1** - The first supplier's account number.
-+ **Supplier-2** - The second supplier's account number, if applicable.
-+ **Transporter** - The transporter's account number.
-
-For each product enter the following:
-
-+ **Product-Cd** - The product's code.
-+ **Description** - The product's description if it does not already exist.
-+ **Price** - The product's price.
-+ **Quantity** - The quantity delivered.
-+ **Value** - The line value.
-
-Buttons:
-
-+ **Accept** - Use this button to finalise the invoice.
-+ **Edit** - Use this button to edit an existing invoice or the current invoice.
-+ **Cancel** - Use this button to cancel the current invoice or any editing.
-
-.. raw:: pdf
-
-    PageBreak
-
-Creditor's Invoices (IB)
-++++++++++++++++++++++++
-Use this routine to capture supplier's and transporter's invoices.
-
-+ **Purchase Journal** - The purchases journal number being captured.
-
-For each invoice in the purchase journal enter the following:
-
-+ **T** - The creditor's product type, S (Supplier) or T (Transporter).
-+ **Acc-Num** - The creditor's account number.
-+ **D** - The creditor's document type, I (Invoices) or C (Credit Notes).
-+ **Reference** - The document number.
-
-For each inter branch invoice relating to the creditor's invoice enter the following:
-
-+ **I.B.T-Inv** - The inter branch invoice number.
-
-Reporting (IB)
-..............
-Reprint Sales Invoices (IB)
-+++++++++++++++++++++++++++
-Use this routine to reprint any sales invoices.
-
-+ **Template Name** - The template to be used for invoices.
-+ **Documents** - Select range or individual invoices.
-+ **From Number** - If range was selected enter the first number of the range.
-+ **To Number** - If range was selected enter the last number of the range.
-
-Purchases Journals (IB)
-+++++++++++++++++++++++
-Use this routine to print lists of inter branch invoices by branch.
-
-+ **Reprints** - Select whether to reprint previously printed journals.
-    + **Yes**
-        + **Branch Code** - The branch to reprint else 0 for all branches.
-        + **Start Number** - The first journal to reprint.
-        + **End Number** - The last journal to reprint.
-    + **No**
-        + **Preview Only** - Select whether to only *preview* journals.
-
-Sales Report (IB)
-+++++++++++++++++
-Use this routine to produce a sales report.
-
-+ **Branch Code** - The branch to reprint else 0 for all branches.
-+ **From Period** - The first financial period to include.
-+ **To Period** - The last financial period to include.

=== modified file 'doc/LON.rst' (properties changed: -x to +x)
--- old/doc/LON.rst	2017-08-24 07:49:34 +0000
+++ new/doc/LON.rst	2020-06-10 08:47:12 +0000
@@ -1,5 +1,5 @@
-Loan's Ledger
--------------
+Loans Ledger
+------------
 File Maintenance (LN)
 .....................
 Control Record (LN)
@@ -11,14 +11,14 @@
 + **Interest Received** - If integrated, enter the general ledger account number for the `Interest Received` account.
 + **Interest Paid** - If integrated, enter the general ledger account number for the `Interest Paid` account.
 + **Interest Method** - The method for raising interest as follows:
-  + **Daily** - Interest is raised on daily balance.
-  + **Monthly** - Interest is raised on monthly balance.
+    + **Daily** - Interest is raised on daily balance.
+    + **Monthly** - Interest is raised on monthly balance.
 + **Capitalisation Base** - What capitalisation of interest is based on:
-  + **Anniversary** - Using the anniversary of the loan as the basis.
-  + **Financial** - Using the financial period as the basis.
+    + **Anniversary** - Using the anniversary of the loan as the basis.
+    + **Financial** - Using the financial period as the basis.
 + **Capitalisation Freq** - When capitalisation takes place:
-  + **Annual** - Interest get capitalised every 12 months from the base.
-  + **Bi-Annual** - Interest get capitalised every 6 months from the base.
+    + **Annual** - Interest get capitalised every 12 months from the base.
+    + **Bi-Annual** - Interest get capitalised every 6 months from the base.
 + **Debit Rate** - The default interest rate on debit balances.
 + **Credit Rate** - The default interest rate on credit balances.
 + **Last Interest Date** - The last date interest was raised.

=== modified file 'doc/MEM.rst' (properties changed: -x to +x)
--- old/doc/MEM.rst	2019-01-13 16:38:59 +0000
+++ new/doc/MEM.rst	2020-06-19 15:08:55 +0000
@@ -1,5 +1,5 @@
-Member's Ledger
----------------
+Members Ledger
+--------------
 File Maintenance (ML)
 .....................
 Control Record (ML)
@@ -12,15 +12,14 @@
 + **Bonus Days** - The number of days leeway for for raising charges.
 + **Last Month End** - The date the last month end was performed.
 + **Photo's Path** - Where the members photographs are stored.
-+ **Access Control** - Whether or not to integrate with an access control system.
-+ **Access Host** - The name of the server running the system.
-+ **Access Database** - The database name of the system.
-+ **Access Username** - The user's name to access the system.
-+ **Access Password** - The user's password to access the system.
++ **Club Logo Image** - The path to the club's logo file.
++ **Card Front Template** - The membership card's front template.
++ **Card Back Template** - The membership card's back template.
++ **Statement Template** - The member's statement template.
 + **Email Address** - The email address of the person in charge of members, if not the default email address in the company record.
 
-Category Records
-++++++++++++++++
+Category Records (ML)
++++++++++++++++++++++
 This routine is used to create or amend membership category records.
 
 + **Category Type** - Select the type of category record.
@@ -47,24 +46,24 @@
 + **Pro-Rata** - Whether or not the fees are to be pro-rata'd based on months till anniversary. This can be either No, the number of months to skip or Manual.
 + **Month 1-12** - The V.A.T. inclusive fee to be raised. In the case of manual pro-rata, you must calculate the various splits manually.
 
-Message Records
-+++++++++++++++
+Message Records (ML)
+++++++++++++++++++++
 Use this routine to create, amend or delete message records. These records are used by `Statements (ML)`_.
 
-Contact Records
-+++++++++++++++
+Contact Records (ML)
+++++++++++++++++++++
 Use this routine to create, amend or delete message records. These records are used to parameterise the contact details of members.
 
 + **Code** - Numeric code.
 + **Contact Type (E,F,M,T)** - The type of contact code i.e. E-mail, Fax, Mobile or Telephone.
 + **Contact Description** - The description on the contact code.
 
-Data Capture
-............
+Data Capture (ML)
+.................
 For all data capture routines first enter the batch details using `Batch Details`_.
 
-Invoices
-++++++++
+Invoices (ML)
++++++++++++++
 For each invoice enter the following fields:
 
 + **Mem-No** - The membership number.
@@ -88,8 +87,8 @@
 + **All-Amt** - The exclusive amount to be allocated to this account.
 + **Details** - The details of this allocation.
 
-Payments
-++++++++
+Payments (ML)
++++++++++++++
 For each payment enter the following fields:
 
 + **Mem-No** - The membership number.
@@ -100,16 +99,16 @@
 + **Details** - The details of the payment.
 + Age the payment using `Ageing Transactions`_.
 
-Journals
-++++++++
-For each journal enter enter all fields as per `Invoices`_ above except that you will have to age the journal using `Ageing Transactions`_ after the first *Details* field.
-
-Credit Note's
-+++++++++++++
-For each credit note enter all fields as per `Invoices`_ above except that you will have to age the credit note using `Ageing Transactions`_ after the first *Details* field.
-
-Receipts
-++++++++
+Journals (ML)
++++++++++++++
+For each journal enter enter all fields as per `Invoices (ML)`_ above except that you will have to age the journal using `Ageing Transactions`_ after the first *Details* field.
+
+Credit Notes (ML)
++++++++++++++++++
+For each credit note enter all fields as per `Invoices (ML)`_ above except that you will have to age the credit note using `Ageing Transactions`_ after the first *Details* field.
+
+Receipts (ML)
++++++++++++++
 For each receipt or deposit slip enter the following:
 
 + **Reference** - The receipt or deposit slip number.
@@ -124,8 +123,8 @@
 + **Discount** - The discount amount for this member.
 + Age the receipt using `Ageing Transactions`_.
 
-Reporting
-.........
+Reporting (ML)
+..............
 Batch Error Listing (ML)
 ++++++++++++++++++++++++
 Use this routine to print any unbalanced batches.
@@ -146,8 +145,8 @@
 + **Batch-Number** - The batch number or blank for all.
 + **Totals Only** - Yes or No.
 
-Age Analysis
-++++++++++++
+Age Analysis (ML)
++++++++++++++++++
 Use this routine to print an aged analysis of all member's accounts.
 
 + **Cut Off Period** - The last period to include in the report.
@@ -186,8 +185,8 @@
 + **From Action Date** - The starting action date.
 + **To Action Date** - The ending action date.
 
-Category Changes
-++++++++++++++++
+Category Changes (ML)
++++++++++++++++++++++
 Use this report to print any membership category changes.
 
 + **Report Type** - Actual or pending changes.
@@ -197,8 +196,8 @@
 + **Category** - The membership category to print or all.
 + **Code** - The code of the selected category or all.
 
-Master Report
-+++++++++++++
+Master Report (ML)
+++++++++++++++++++
 Use this report to print a selective master list of members.
 
 + **Report Date** - The date of the report.
@@ -214,15 +213,15 @@
 + **To Status** - If a status was selected include members who's status was effective on or before this date.
 + Once you have selected the output options you will be able to select what data you would like on your report.
 
-Suspension Report
-+++++++++++++++++
+Suspension Report (ML)
+++++++++++++++++++++++
 Use this report to print a list of potential suspensions due to non payment.
 
 + **Sort Order** - Sort by membership number or surname.
 + **Include Pay Plan** - Include members who have arranged terms.
 
-Update Details Request
-++++++++++++++++++++++
+Update Details Request (ML)
++++++++++++++++++++++++++++
 Use this report to email requests to all members to update their details.
 
 + **Category** - The membership category to further filter the report.
@@ -230,8 +229,8 @@
 + **First Member Number** - To only print a selected range of members.
 + **Last Member Number** - To only print a selected range of members.
 
-Birthday Report
-+++++++++++++++
+Birthday Report (ML)
+++++++++++++++++++++
 Use this report to print a list of members whose birthday falls between two dates.
 
 + **Category** - The membership category to further filter the report.
@@ -240,8 +239,8 @@
 + **From Date** - Include members who's birthday is on or after this date.
 + **To Date** - Include members who's birthday is on or before this date.
 
-Name and Address Labels
-+++++++++++++++++++++++
+Name and Address Labels (ML)
+++++++++++++++++++++++++++++
 Use this report to print name and address labels.
 
 + **Status** - The member's status to filter the report.
@@ -252,19 +251,19 @@
 + **First Label Row** - The first available blank label row.
 + **First Label Column** - The first available blank label column.
 
-Toolbox
-.......
-Transaction Reallocations
-+++++++++++++++++++++++++
-Synchronise Access Control
-++++++++++++++++++++++++++
+Toolbox (ML)
+............
+Transaction Reallocations (ML)
+++++++++++++++++++++++++++++++
+Synchronise Access Control (ML)
++++++++++++++++++++++++++++++++
 
 Member Records (ML)
 ...................
 Use this routine to create, edit and interrogate member's records.
 
-New Records
-+++++++++++
+New Records (ML)
+++++++++++++++++
 Click on the **New** button to create a new member's record and then enter all relevant fields on all the available pages:
 
 + **Personal**
@@ -275,12 +274,12 @@
 
 Once all available data has been entered click on the **Update** button to create the new record or the **Reset** button to exit without creating the record.
 
-Edit Records
-++++++++++++
+Edit Records (ML)
++++++++++++++++++
 Enter a valid membership number followed by the Enter key. All details of the member will be displayed. Click on the **Edit** button to edit the member's record. Once all details have been altered click on the **Update** button to update the record or the **Reset** button to exit without updating the record.
 
-Month End Routine
-.................
+Month End Routine (ML)
+......................
 This routine must be run at the end of each and every month as it is the routine which raises charges and controls membership categories.
 
 + **This Month End Date** - The last day of the relevant month. If it is the financial year end you will be asked for confirmation.

=== modified file 'doc/POS.rst' (properties changed: -x to +x)
--- old/doc/POS.rst	2019-12-31 08:37:40 +0000
+++ new/doc/POS.rst	2020-07-29 10:39:07 +0000
@@ -30,8 +30,8 @@
 +++++++++++++++++++++++++++
 The point of sales screen's buttons and actions are for the most part self explanatory however the normal procedure would be as follows:
 
-Item Selection Screen
-*********************
+Item Selection Screen (PS)
+~~~~~~~~~~~~~~~~~~~~~~~~~~
 + Select the relevant pink group button. If necessary select the Left or Right button to show more groups.
 + Select the relevant blue item button. If necessary select the Left or Right button to show more items.
 + In both cases a search facility is available by clicking in the Description column on the left hand side of the screen.
@@ -41,8 +41,8 @@
 + Continue until all items have been entered.
 + Select the required button. In the case of all buttons, excepting *Void*, the payment allocation screen will appear.
 
-Payment Allocation Screen
-*************************
+Payment Allocation Screen (PS)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 + **Discount** - To enter a discount select the discount button and then enter the percentage by selecting the relevant numeral buttons and ending by selecting the *Enter* button.
 + **Voucher** - To enter a voucher select the voucher button and then enter the voucher value by selecting the relevant numeral buttons and ending by selecting the *Enter* button.
 + **C/Card** - To pay by credit card select the c/card button.

=== modified file 'doc/QST.rst' (properties changed: -x to +x)
--- old/doc/QST.rst	2020-04-20 12:42:42 +0000
+++ new/doc/QST.rst	2020-08-06 15:18:08 +0000
@@ -11,18 +11,16 @@
 
   To find out what the available command line options are, use the -h option.
 
++ The first time Tartan is started you will be taken to `Preferences` where you will have to set up your preferences regarding database, paths, utilities and various other choices. You will then have to enter the System record as well as a Company/Club record. For most SOHO installations there will only be one Company, however there is provision for up to 999 integrated companies. While creating the Company record you will be able to choose which systems you want to activate.
+
 |
 
-+ Login using **admin** as the user name and a password if prompted.
-
-+ The first time Tartan is started you will be taken to `Preferences` where you will have to set up your preferences regarding database, paths, utilities and various other choices. You will then have to enter the system record using `System Record Maintenance` as well as a company record using `Company Records Maintenance`. For most SOHO installations there will only be one company, however there is provision for up to 999 integrated companies.
-
 General Ledger
 ..............
 If you are going to use the `General Ledger` you must perform the following procedures in order:
 
 + Create the chart of accounts using `Masterfile Records`.
-+ Create control accounts using `Control Accounts`.
++ Create control accounts using `Control Accounts`. Select the `Populate` button to automatically populate a company's set of accounts.
 + Capture the account's opening balances using `Opening Balances`.
 + Print a trial balance using `Trial Balance` and ensure that your accounts balance. If not, recapture the incorrect ones.
 + Capture the account's budgets using `Budgets` if required.
@@ -51,16 +49,10 @@
 
 The Booking's Manager system is at this stage fully functional and you can capture bookings and booking's movements.
 
-.. raw:: pdf
-
-   PageBreak
-
 Bowling Clubs
 .............
-If you are going to use `Bowling Clubs` you must first of all ensure that the `System and Company` records have been created.
+If you are going to use `Bowling Clubs` the following options are available.
 
-+ Create a systems record, by selecting `System Record Maintenance` from the Control menu.
-+ Create a company/club record, by selecting `Company Records Maintenance` from the Control menu.
 + **Tabs**
     * Create a Control record by selecting `Control Record` from the menu.
     * Create Tab records by selecting `Tabs Maintenance` from the menu.
@@ -105,10 +97,6 @@
 
 Please also note that within the Creditor's system all balances are stored as positive even though they are stored as credits in the General Ledger.  Therefore to increase a supplier's balance you would capture a Journal Credit and to decrease a supplier's balance you would capture a Journal Debit.
 
-.. raw:: pdf
-
-   PageBreak
-
 Debtor's Ledger
 ...............
 If you are going to use the `Debtor's Ledger` you must perform the following procedures in order:
@@ -160,10 +148,6 @@
 
 The Rental's Ledger (Standard) system is at this stage fully functional and you can capture payments, receipts and journal entries.
 
-.. raw:: pdf
-
-   PageBreak
-
 Store's Ledger
 ..............
 If you are going to use the `Store's Ledger` you must perform the following procedures in order:

=== modified file 'doc/RCA.rst' (properties changed: -x to +x)
--- old/doc/RCA.rst	2017-08-24 07:49:34 +0000
+++ new/doc/RCA.rst	2020-06-10 08:53:04 +0000
@@ -1,5 +1,5 @@
-Rental's Ledger (Extended)
---------------------------
+Rentals Ledger (Extended)
+-------------------------
 File Maintenance (RC)
 .....................
 Control Record (RC)
@@ -89,8 +89,8 @@
 
 + **Prm-Cod** - The premises code foe which we are capturing transactions.
 
-Owner
-+++++
+Owner (RC)
+++++++++++
 
 + **Acc-Num** - The owner's account number. This is automatically obtained from the premises record.
 + **Reference** - The transaction reference number.
@@ -101,8 +101,8 @@
 + **V.A.T.** - The v.a.t. amount, if applicable.
 + **Details** - The details of the transaction.
 
-Tenant
-++++++
+Tenant (RC)
++++++++++++
 
 + **Acc-Num** - The tenant's account number.
 + **Seq** - The lease sequence number being dealt with.
@@ -112,8 +112,8 @@
 + **Amount** - The transaction amount.
 + **Details** - The details of the transaction.
 
-Allocation
-++++++++++
+Allocation (RC)
++++++++++++++++
 For all tenant transactions, excluding rentals raised, movement types must be allocated.
 
 + **M** - The movement type i.e. rental, deposit, contract fee, services or repairs.
@@ -160,8 +160,8 @@
 ++++++++++++++++++++++++++++
 This routine is used to produce a listing of deposits.
 
-Statement Messages
-++++++++++++++++++
+Statement Messages (RC)
++++++++++++++++++++++++
 This routine is used to produce a listing of statement messages.
 
 Interrogation (RC)
@@ -176,16 +176,16 @@
 
 Toolbox (RC)
 ............
-CSV Masterfile Importing
-++++++++++++++++++++++++
+CSV Masterfile Importing (RC)
++++++++++++++++++++++++++++++
 This routine is used to import masterfile records from a comma separated file.
 
-CSV Transaction Importing
-+++++++++++++++++++++++++
+CSV Transaction Importing (RC)
+++++++++++++++++++++++++++++++
 This routine is used to import transactions from a comma separated file.
 
-Check for Missing Records
-+++++++++++++++++++++++++
+Check for Missing Records (RC)
+++++++++++++++++++++++++++++++
 This routine is used to check for missing records.
 
 Month End Routine (RC)

=== modified file 'doc/RTL.rst' (properties changed: -x to +x)
--- old/doc/RTL.rst	2017-08-24 07:49:34 +0000
+++ new/doc/RTL.rst	2020-06-10 08:53:56 +0000
@@ -1,5 +1,5 @@
-Rental's Ledger (Standard)
---------------------------
+Rentals Ledger (Standard)
+-------------------------
 File Maintenance (RT)
 .....................
 Control Record (RT)
@@ -43,12 +43,12 @@
 
 Data Capture (RT)
 .................
-Receipts
-++++++++
+Receipts (RT)
++++++++++++++
 This routine is used to capture receipts.
 
-Payments
-++++++++
+Payments (RT)
++++++++++++++
 This routine is used to capture payments.
 
 Reporting (RT)
@@ -75,8 +75,8 @@
 
 Toolbox (RT)
 ............
-Change Account Numbers
-++++++++++++++++++++++
+Change Account Numbers (RT)
++++++++++++++++++++++++++++
 This routine is used to change account numbers.
 
 Interrogation (RT)

=== renamed file 'doc/SEC.rst' => 'doc/SCP.rst' (properties changed: -x to +x)
--- old/doc/SEC.rst	2020-03-01 12:48:20 +0000
+++ new/doc/SCP.rst	2020-06-19 15:59:33 +0000
@@ -1,22 +1,14 @@
 Sectional Competitions
 ----------------------
-District Record
-...............
-This routine is used to create or amend the district record.
-
-While most of the fields are self explanatory the following are of note:
-
-+ **E-Mail Address** - Your default email address.
-
-Club Records
-............
+Club Records (SC)
+.................
 Use this routine to add, amend and delete clubs.
 
 + **Club Code** - The applicable club's code. A zero code will automatically select the next available code.
 + **Club Name** - The name of the club.
 
-Member Records
-..............
+Member Records (SC)
+...................
 Use this routine to create, delete or amend member's records.
 
 + **Member's Code** - The membership number of the member or zero for the next available number.
@@ -27,10 +19,10 @@
 + **Email Address** - The member's email address.
 + **Phone Number** - The member's phone number.
 
-Competitions
-............
-Capture Entries
-+++++++++++++++
+Competitions (SC)
+.................
+Capture Entries (SC)
+++++++++++++++++++++
 Use this routine to create a new competition and to capture entries to the competition.
 
 + **Code** - The relevant competition code or zero for the next available code.
@@ -42,19 +34,19 @@
 
 Enter the Codes of the Entered Members.
 
-+ **Skip** - The skip's code as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
-+ **Lead** - The partner's code, in the case of pairs, as created in `Member Records`_ or you can enter a zero to enter a new player as per `Member Records`_.
++ **Skip** - The skip's code as created in `Member Records (SC)`_ or you can enter a zero to enter a new player as per `Member Records (SC)`_.
++ **Lead** - The partner's code, in the case of pairs, as created in `Member Records (SC)`_ or you can enter a zero to enter a new player as per `Member Records (SC)`_.
 
-List Entries
-++++++++++++
+List Entries (SC)
++++++++++++++++++
 Use this routine to generate a list of entered players.
 
 + **Code** - The relevant competition code.
 + **Output** - Select whether to view or print the draw.
 + **Printer Name** - The printer to use for printing.
 
-Competition Draw
-++++++++++++++++
+Competition Draw (SC)
++++++++++++++++++++++
 Once all the entries have been captured you can perform the draw for the competition as follow:
 
 + **Competition Code** - The relevant competition code.
@@ -68,8 +60,8 @@
 + **Output** - Select whether to view or print the draw.
 + **Printer Name** - The printer to use for printing.
 
-Capture Results
-+++++++++++++++
+Capture Results (SC)
+++++++++++++++++++++
 Use this routine to capture completed games of Round Robin matches as follows:
 
 + **Competition Code** - The relevant competition code.
@@ -81,16 +73,3 @@
 + **S-Code** - The skips code.
 + **SF** - Shots scored by the skip's side.
 + **SA** - Shots scored by the opposing side.
-
-Help
-----
-About
-.....
-This routine will display the copyright details, version and contact information for Tartan Systems.
-
-+ **Licence** - The Tartan licence details.
-+ **Changes** - The Tartan changes since version 4 to date.
-
-Reference Manual
-................
-This routine will display this manual, if available, or the on-line one using your default browser.

=== removed file 'doc/SECMST.rst'
--- old/doc/SECMST.rst	2020-03-25 07:25:02 +0000
+++ new/doc/SECMST.rst	1970-01-01 00:00:00 +0000
@@ -1,287 +0,0 @@
-==================================
- Tartan Systems - Reference Manual
-==================================
-.. _GPL: http://www.gnu.org/licenses/gpl.html
-
-:Version:   5.11
-:Author:    Paul Malherbe
-:Contact:   paul@tartan.co.za
-:Home:      http://www.tartan.co.za
-:Copyright: Paul Malherbe (C) 2004-2019.
-:Licence:   Free use of this software and all it's modules is granted under the terms of the GNU General Public License (GPL_) as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
-
-:Note: This document is not intended as an accounting manual. It is primarily a manual for people with some accounting expertise to learn how to use Tartan as an accounting tool.
-
-.. contents:: **Table of Contents**
-
-.. raw:: pdf
-
-   PageBreak
-
-About
------
-Tartan Systems started out in 1981 as a suite of programs I wrote in COBOL and until 1994 ran on various platforms including CPM, RSX11M, MSDOS, AT&T UNIX and SCO.
-
-In 1994 I discovered LINUX and when iBCS2 became available I modified the systems to run under LINUX and continue doing so until today.
-
-In 2003 I started looking around for another programming language in which I could rewrite the systems to   run under LINUX as well as Windows without having to recompile etc. Also I was getting irritated with having to compile using SCO.
-
-Eventually I decided on the following:
-
-+ Python_ as the programming language
-+ Tkinter_ for the graphical user interface
-+ Reportlab_ to generate reports
-+ Pychart_ to generate charts and graphs
-+ PostgreSQL_, MySQL_, Firebird_ and Pysqlite_ as supported relational databases
-
-In 2005, version 3, I changed the graphical user interface to PyGtk, a python wrapper for the Gtk library.
-
-In 2011, version 4, I dropped support for windows 9x and also replaced reportlab with pyfpdf.
-
-In 2015, version 5, I replaced PyGtk with Tkinter and ttk.
-
-.. _Python: http://www.python.org
-.. _Tkinter: http://www.python.org/topics/tkinter
-.. _Reportlab: http://www.reportlab.org
-.. _Pychart: http://www.hpl.hp.com/personal/Yasushi_Saito/pychart
-.. _PostgreSQL: http://www.postgresql.org
-.. _MySQL: http://dev.mysql.com
-.. _Firebird: http://www.firebirdsql.org
-.. _Pysqlite: http://code.google.com/p/pysqlite
-
-Installation Procedure
-----------------------
-Linux and Source
-----------------
-Ensure that the following dependencies are installed on your system:
-
-+ python >= 2.7.5 and < 3.0.0
-
-Windows also requires pywin32 >= build 216 downloaded from:
-
-    https://sourceforge.net/projects/pywin32/files/pywin32/
-
-The following dependencies must be installed using pip:
-
-+ fpdf >= 1.7.0
-+ pillow >= 2.3.0
-+ requests
-
-Additionally, the following dependencies should also be installed using pip:
-
-+ ghostscript           # Bulk Mail - pdf to jpg convert
-+ markdown              # Bulk Mail - enable markdown format
-+ odfpy                 # ODS File Reader - file import
-+ ofxtools              # OFX File Reader - bank statements
-+ pyaes                 # Password Manager - pm1010
-+ pycrypto              # Password Manager - pm1010
-+ pygal                 # SVG Charts
-+ pysmb                 # Netbios file names
-+ python-chart          # PDF Charts
-+ python-escpos         # POS esc commands
-+ send2trash            # Move files to recycle bin
-+ tkinterhtml           # HTML Viewer
-+ xlrd                  # Excel Read
-+ xlwt                  # Excel Write
-
-And, depending on your database needs, one of:
-
-+ Postgresql - psycopg2
-+ MySQL - pymysql
-+ Firebird - fdb
-
-Then download the following file from ftp://ftp.tartan.co.za
-
-+ Seccmp_5.x.x.tar.gz
-
-Extract Seccmp_5.x.x.tar.gz into a directory of your choice as follows:
-
-+ cd your.directory && tar -xvzf Seccmp_5.x.x.tar.gz
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Windows Binary
---------------
-Download the following file from ftp://ftp.tartan.co.za or if you are in possession of a CD this is not necessary.
-
-+ Seccmp_5.x.x.exe
-
-Install Seccmp_5.x.x.exe by browsing to it and double clicking and then accept the defaults, except, agree to creating an icon on your desktop.
-
-Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
-
-Startup Procedure
------------------
-Linux and Source
-----------------
-Start Tartan by entering the following command:
-
-    `python -OO program_path/ms0000.py [options]`
-
-To find out what the available command line options are, use the -h option.
-
-Windows Binary
---------------
-.. NOTE::
-  Users must first perform the following steps:
-
-    1) Right click on the Tartan shortcut icon.
-    2) Select `Properties` on the menu. A dialogue box will appear on the screen.
-    3) Click the `Advanced` button under the Shortcut tab in the dialogue box.
-    4) Check the `Run as administrator` box.
-    5) Click the `OK` button (or press Enter on your keyboard if the button is highlighted by default).
-    6) Finish by clicking `Apply` and then `OK`. Your preferences have been saved. Next time you open the shortcut to the application you performed the task for your computer will no longer require administrative permission.
-
-Start Tartan by clicking on the shortcut icon on the desktop or by navigating to the `C:\\Tartan\\prg` directory and double clicking on the `ms0000[.exe]` file.
-
-Both
-----
-The first time you run Tartan you will automatically be taken to `Preferences`_ where you will have to enter various parameters relating to your installation. After saving the preferences and restarting Tartan you will be prompted to create the database.
-
-.. raw:: pdf
-
-   PageBreak
-
-Status Line
------------
-.. NOTE::
-  When using Tartan your available options will be highlighted on the status line at the bottom left hand side of the screen. Please read this carefully before asking for assistance.
-
-Common Keyboard Functions
--------------------------
-Throughout the various modules comprising **Tartan Systems** the following keys are used to perform certain functions. These options will always be highlighted in the `Status Line`_ at the bottom of the screen. The most common ones are:
-
-+ **Enter**  - Accept keyboard input.
-+ **Esc**    - Exit a module or go to a previous entry field.
-+ **F1**     - Record Selection used with most data input routines.
-+ **F5**     - Record Deletion used with record maintenance routines.
-+ **F9**     - Input Termination used with multi-line text input.
-
-In addition to the above keys all underlined characters on notebook tags and buttons can be used, in conjunction with the <Alt> key, as shortcuts e.g <Alt-s> to open the System menu.
-
-Common Routines
----------------
-There are various common routines. Rather than continually describing them they will be described once here only.
-
-Printer Selection
------------------
-Whenever a report is being produced you will have the opportunity of deciding on the output method i.e. viewing, printing, exporting it.
-
-+ **Output** - Select the required output option.
-+ **Printer Name** - If you selected `Print`, enter the printer name.
-
-Error Messages
---------------
-Should an error message occur and there is a file named *errors.txt* in the `Work Path` as created in `Preferences`_. Please email the file to errors@tartan.co.za after which you may delete it.
-
-Menus and Sub Menus
--------------------
-System
-------
-Please note that depending on the security level of the user some of these routines might not be available.
-
-Upgrade System
-..............
-Select this routine to check if there are upgrades to Tartan and if so to install them.
-
-+ **Update Type** - Select whether to check the Tartan ftp site or a local LAN location. If Local is selected you will be able to browse for a location which will default to whatever is set in the *Upgrade Path* directory as set during the `Preferences`_ routine.
-
-* If there is an update and you want to upgrade, click on the `Update` button.
-
-Update File Formats
-...................
-If you have performed an upgrade of Tartan you will have to perform this routine as well. This routine will automatically update all table formats in the database. If you have more than one database (rcfile), you must perform this routine for each database.
-
-Backup Database
-...............
-Select this routine to create a backup of the current database. These backups will reside in the *Backup Path* directory as created using the `Preferences`_ routine. Each backup will further reside in a sub directory named after the name of the database and a further sub directory named `arch`.
-
-Restore Database
-................
-Select this routine to restore a previous backup.
-
-+ **Type** - Select a Full or Partial restore.
-+ **Archive** - Select the relevant archive to restore from.
-+ **All Companies** - `Yes` or `Include/Exclude` some companies.
-+ **Companies** - Comma separated list of companies to include or exclude.
-+ **All Systems** - `Yes` or `Include/Exclude` some systems.
-+ **Systems** - Comma separated list of systems to include or exclude.
-
-Please note that unless you really know what you are doing it is very dangerous to restore individual systems as your data could become unbalanced because of integration and table relationships.
-
-If you are doing a full restore and the database already exists you will be asked whether to drop it first. Unless you are sure of what you are doing select No.
-
-Preferences
-...........
-Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.
-
-+ **Configuration File** - This is the full path of your configuration file. Every user can have his or her own file. This file, by default, is placed in the user's home directory or, in Windows, the root directory of the Tartan installation e.g. `C:\\Tartan`. If you want to change this default, you must set an environment variable as **TARTANRC=path-to-rcfile** or use the command line option **-r path-to-rcfile**.
-
-+ **Database**
-
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL, SQLite, MySQL or Firebird. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
-    + **Database Name** - This can be any single word name defaulting to **tartan**.
-    + **Host Name** - This is the host name of the Server. This is not used with SQLite.
-    + **Files Directory** - This is only used for SQLite and Firebird database engines and is the directory where the database will be created.
-    + **Port Number** - This is the port number the database uses. Leaving this blank will enable the database default port.
-    + **Administrator** - This is the name used to connect to the database. This is not used with SQLite.
-    + **Password** - This is the password of the user. This is not necessary with SQLite.
-
-+ **General**
-
-    + **Program Path** - This is the path where the programs reside.
-    + **Backup Path** - This is the path where backups of the database will be stored.
-    + **Work Path** - This is the path of the work directory. All temporary files will be created in this directory.
-    + **Upgrade Path** - This is the path where any upgrades will be stored.
-    + **PDF Viewer** - This is the full path of the program used to display pdf files.  The default for LINUX is **evince** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **Print Command** - This is the full path of the print program used to print postscript files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **PS Converter** - This is the full path of the program needed to convert pdf files to postscript. The LINUX default is **pdftops** and the Windows one is **blank**.  If this field is left blank, no conversion will take place and the print routine will have to be able to print pdf files directly e.g. where one of `SumatraPDF`, `Foxit Reader` or `Acrobat Reader` has been selected as the printer.
-    + **CSV Reader** - This is the full path of the program used to read csv and xls file formats.
-    + **Screen Geometry** - This defaults to the suggested geometry for your screen. Entering a zero will achieve the same result.
-    + **Screen Placement** - Where the Tartan Window must be placed on the monitor i.e. Left, Centre or Right.
-    + **Show Tartan Image** - Whether to display the Tartan image on the Main Menu screen.
-    + **Enforce Confirm** - Whether confirmation is required on the completion of data entry.
-    + **Auto-completion** - Whether auto-completion will be available. This means that as you enter data, and if there are available options, these will appear either `In-Line` or in a `List` below the entry field, for selection.
-    + **Tool-tips** - Whether tool-tips will display as you hover your cursor over certain entry fields.
-    + **Error Alarm** - Whether or not to sound an audible alarm with errors. This can be No, Yes or Multimedia. Use Multimedia if you do not have an internal speaker.
-    + **Work Files** - Select the default action for work files when exiting Tartan.
-        + **Trash** - Send the files to the *Recycle Bin*.
-        + **Delete** - Delete the files.
-        + **Keep** - Keep the files in the work directory.
-
-+ **Dialog**
-
-    + **Menu Font**
-        + **Name** - This is the font family to be used for all menu items.
-        + **Size** - This is font size to be used for all menu items.
-    + **Default Font**
-        + **Name** - This is the font family to be used in all other cases.
-        + **Size** - This is font size to be used in all other cases.
-    + **Theme** - The theme to be used. The default theme is `clam`.
-    + **Colour Scheme** - The colour scheme to be used. The default scheme is `Red`.
-    + **Normal**
-        + **FG** - The normal label and button foreground colour.
-        + **BG** - The normal label and button background colour.
-    + **Focus**
-        + **FG** - The focused button foreground colour.
-        + **BG** - The focused button background colour.
-    + **Disable**
-        + **FG** - The disabled button foreground colour.
-        + **BG** - The disabled button background colour.
-    + **Booking Query**
-        + **FG** - The booking manager calendar query foreground colour.
-        + **BG** - The booking manager calendar query background colour.
-    + **Booking Confirmed**
-        + **FG** - The booking manager calendar confirm foreground colour.
-        + **BG** - The booking manager calendar confirm background colour.
-    + **Booking Settled**
-        + **FG** - The booking manager calendar settle foreground colour.
-        + **BG** - The booking manager calendar settle background colour.
-
-|
-
-If this is a new installation you will be prompted to Create the Database after which you will need to create a `System Record` and at least one `Club Record`.
-
-Quit
-....
-Select this to exit Tartan.

=== modified file 'doc/SLN.rst' (properties changed: -x to +x)
--- old/doc/SLN.rst	2019-12-31 08:37:40 +0000
+++ new/doc/SLN.rst	2020-06-10 08:38:19 +0000
@@ -2,8 +2,8 @@
 -----------
 File Maintenance (SL)
 .....................
-Loans Masterfile
-++++++++++++++++
+Loans Masterfile (SL)
++++++++++++++++++++++
 Use this routine to amend loan records.
 
 Data Capture (SL)

=== modified file 'doc/SLS.rst' (properties changed: -x to +x)
=== modified file 'doc/STR.rst' (properties changed: -x to +x)
--- old/doc/STR.rst	2019-12-31 08:37:40 +0000
+++ new/doc/STR.rst	2020-06-19 13:35:23 +0000
@@ -1,5 +1,5 @@
-Store's Ledger
---------------
+Stores Ledger
+-------------
 File Maintenance (ST)
 .....................
 Control Record (ST)
@@ -7,11 +7,15 @@
 Use this routine to create and amend the store's control record.
 
 + **G/L Integration** - Select whether to integrate with the general ledger.
-+ **Stock on Hand** - If integrated this is the general ledger account number for the `Stock on Hand` account.
-+ **Stock Reconciliation** - If integrated this is the general ledger account number for the `Stock Reconciliation` account. This could also be referred to as the `Stock Adjustment` account.
+    + **Yes**
+        + **Stock on Hand** - If integrated this is the general ledger account number for the `Stock on Hand` account.
+        + **Stock Reconciliation** - If integrated this is the general ledger account number for the `Stock Reconciliation` account. This could also be referred to as the `Stock Adjustment` account.
+        + **P.O.S. Cash** - If integrated this is the general ledger account number for the `Cash Payments` account.
+        + **P.O.S. Credit Cards** - If integrated this is the general ledger account number for the `Credit Card Payments` account.
+        + **P.O.S. Vouchers** - If integrated this is the general ledger account number for the `Vouchers Cashed` account.
 + **Multiple Locations** - Select whether to allow multiple stores locations or warehouses.
 + **Number of Price Levels** - Select the number of price levels up to a maximum of five.
-+ **Automatic Markup** - Select whether to allow automatic markup of items received based on a percentage stored in the group or masterfile records.
++ **Automatic Markup** - Select whether to price items automatically based on percentages stored in the group and/or masterfile records. These can be overridden for specific items by creating a Price Record for the item by using `Fixed Selling Prices (ST)`_.
 + **Orders Template** - The template to use to purchases orders.
 + **Email Address** - The email address of the person in charge of stores, if not the default email address in the company record.
 
@@ -51,9 +55,9 @@
     + **Unit of Issue** - The unit of issue code relating to the item.
     + **Units Per Pack** - The number of units making up the pack. If applicable, the price for a single item would be the purchase or selling price divided by this number.
     + **Value Indicator** - Select the cost price value indicator as follows:
-      + **Average** - The cost price will be the value divided by the quantity.
-      + **Standard** - The cost will be a fixed cost price.
-      + **None** - The item will not have a cost print. This is normally used for goods which are not purchased and are not standard e.g. recipes, travelling, labour etc.
+        + **Average** - The cost price will be the value divided by the quantity.
+        + **Standard** - The cost will be a fixed cost price.
+        + **None** - The item will not have a cost print. This is normally used for goods which are not purchased and are not standard e.g. recipes, travelling, labour etc.
     + **VAT Code** - The default vat code for the item.
     + **Exclusive Chain Store** - If chain stores are enabled in the debtor's ledger and the item is exclusive to a Chain Store, this is the Chain Store code.
     + **Exclusive Account** - If the item is exclusive to a debtor's account, this is the debtor's account number.
@@ -62,21 +66,21 @@
 + **Basic-B**
     + **Bin Number** - The bin number for the item, if applicable.
     + **Re-Order Indicator** - Select how re-order levels are maintained:
-      + **Manual** - Manually entered.
-      + **Automatic** - Automatically generated.
-      + **Zero** - No re-order level nor re-order quantity.
+        + **Manual** - Manually entered.
+        + **Automatic** - Automatically generated.
+        + **Zero** - No re-order level nor re-order quantity.
     + **Re-Order Level** - The initial re-order level.
     + **Re-Order Quantity** - The initial re-order quantity.
     + **Selling Price Markup** - The default mark-up to calculate selling price.
 + **Recipes**
     + **If the item is a recipe enter all the items making up the recipe**
-      + **Grp** - The product group.
-      + **Code** - The product code.
-      + **Quantity** - The quantity of the item needed for the recipe.
+        + **Grp** - The product group.
+        + **Code** - The product code.
+        + **Quantity** - The quantity of the item needed for the recipe.
 
-Selling Prices (ST)
-+++++++++++++++++++
-Use this routine to create and amend product selling prices. Selling prices can also be automatically calculated when receiving stock.
+Fixed Selling Prices (ST)
++++++++++++++++++++++++++
+Use this routine to create and amend product selling prices. These prices will take preference where automatic markup selling prices have been enabled.
 
 + **Product Group** - The product group.
 + **Product Code** - The product code.
@@ -92,14 +96,13 @@
 + **Printer Selection**
     + **Template Name** - The template to be used for the purchase orders.
     + **Order Date** - The date of the orders.
-    + **Auto Markup** - Whether to automatically calculate new selling prices.
 
 + **Order Header**
     + **Action** - Select the applicable action to perform.
-      + **New** - Create a new order.
-      + **Amend** - Amend an existing order.
-      + **Receive** - Receive an existing order.
-      + **Cancel** - Cancel an existing order.
+        + **New** - Create a new order.
+        + **Amend** - Amend an existing order.
+        + **Receive** - Receive an existing order.
+        + **Cancel** - Cancel an existing order.
     + **Ord-No** - The order number of an existing order.
     + **Loc** - The location placing the order.
     + **Acc-No** - The creditor's account number.
@@ -138,12 +141,11 @@
     + **GRN Number** - Goods received number.
     + **Date** - Date received.
     + **Order Number** - Order number, if applicable.
-    + **Auto Markup** - Whether or not to automatically generate selling prices.
 + **Body**
     + **Grp** - The product group.
     + **Product Code** - The product code.
-    + **L** - the location code, if applicable.
-    + **Units** - The number of items ordered.
+    + **L** - The location code, if applicable.
+    + **Quantity** - The number of units ordered.
     + **Unit-Cost**- The cost price per unit.
     + **Dis-%** - The allowed discount, if applicable.
     + **Unit-Sell** - The selling price per unit.
@@ -195,13 +197,14 @@
     + **First Bin Number** - The starting bin number, if applicable.
     + **First Group** - The starting product group, if applicable.
     + **First Code** - The starting product code, if applicable.
-    + **Selling Prices** - Select whether selling prices must be changed.
-    + **Automatic Markup** - If selling prices are to be changed select whether it must be automatic or manual.
+    + **Cost Prices**
+        + **No** - Cost Prices will be shown but cannot be entered.
+        + **Last** - Last Cost Prices will be displayed and can be altered.
+        + **Average** - Average Cost Prices will be displayed and can be altered.
 + **Body**
     + **Grp** - The product group if not auto sequence.
     + **Product Code** - The product code if not auto sequence.
-    + **Unit Cost** - The unit cost price.
-    + **Unit Sell** - The unit selling price, if applicable.
+    + **Unit Cost** - The unit cost price, if applicable.
     + **Quantity** - The quantity in stock.
 
 Stock Take Variance Report (ST)
@@ -253,10 +256,8 @@
 + **Product Group** - The product group, if applicable.
 + **Ignore Out of Stock** - Select whether to ignore items with zero balances.
 + **Report Type** - Select the applicable report type. If `Cost Price` is selected no more details will be required.
-+ **Price Type** - Select the type of selling prices to print. Either level prices or calculated mark up prices.
-+ **Price Level** - If level prices select enter the required level or zero for all.
++ **Price Level** - If level prices are enabled select enter the required level or zero for all.
 + **Ignore Un-priced** - Select whether to ignore items without a selling price.
-+ **Use Last S/P** - If printing items without a selling price select whether to use the last selling price used.
 + **VAT Inclusive** - Print VAT inclusive or exclusive selling prices.
 + **Show Cost Price** - Select whether to include the cost price on the report.
 

=== modified file 'doc/SYS.rst' (properties changed: -x to +x)
--- old/doc/SYS.rst	2020-04-20 12:42:42 +0000
+++ new/doc/SYS.rst	2020-12-12 11:18:21 +0000
@@ -3,21 +3,17 @@
 ==================================
 .. _GPL: http://www.gnu.org/licenses/gpl.html
 
-:Version:   5.11
+:Version:   5.12
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za
-:Copyright: Paul Malherbe (C) 2004-2019.
+:Copyright: Paul Malherbe (C) 2004-2020.
 :Licence:   Free use of this software and all it's modules is granted under the terms of the GNU General Public License (GPL_) as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 
 :Note: This document is not intended as an accounting manual. It is primarily a manual for people with some accounting expertise to learn how to use Tartan as an accounting tool.
 
 .. contents:: **Table of Contents**
 
-.. raw:: pdf
-
-   PageBreak
-
 About
 -----
 Tartan Systems started out in 1981 as a suite of programs I wrote in COBOL and until 1994 ran on various platforms including CPM, RSX11M, MSDOS, AT&T UNIX and SCO.
@@ -49,14 +45,10 @@
 .. _PostgreSQL: http://www.postgresql.org
 .. _SQLite3: http://code.google.com/p/pysqlite
 
-.. raw:: pdf
-
-   PageBreak
-
 Installation Procedure
 ----------------------
 Linux and Source
-----------------
+................
 Ensure that the following dependencies are installed on your system:
 
 + python >= 2.7.5 and < 3.0.0
@@ -67,27 +59,27 @@
 
 The following dependencies must be installed using pip:
 
-+ fpdf >= 1.7.0
-+ pillow >= 2.3.0
-+ pywin32 for Windows only
++ fpdf                  # Used to create all documents
++ pillow                # Used by fpdf and imaging
++ pymupdf               # Used by the built-in PDF Viewer and Bulk Mail
++ pywin32               # Windows only
 
 Additionally, the following dependencies should also be installed using pip:
 
-+ ghostscript           # Bulk Mail - pdf to jpg convert
 + markdown              # Bulk Mail - enable markdown format
-+ odfpy                 # ODS File Reader - file import
++ odfpy                 # ODS File Reader - file imports
 + ofxtools              # OFX File Reader - bank statements
++ progress              # Curses progressbar
 + pyaes                 # Password Manager - pm1010
 + pycrypto              # Password Manager - pm1010
 + pygal                 # SVG Charts
 + pysmb                 # Netbios file names
-+ python-chart          # PDF Charts
 + python-escpos         # POS esc commands
 + requests              # Web scraping
 + send2trash            # Move files to recycle bin
 + tkinterhtml           # HTML Viewer
-+ xlrd                  # Excel Read
-+ xlwt                  # Excel Write
++ xlrd                  # Excel Read - file imports
++ xlwt                  # Excel Write - file exports
 
 And, depending on your database needs:
 
@@ -104,7 +96,7 @@
 Tartan should now be installed on your computer and you can continue with the `Startup Procedure`_.
 
 Windows Binary
---------------
+..............
 Download the following file from ftp://ftp.tartan.co.za or if you are in possession of a CD this is not necessary.
 
 + Tartan_5.x.x.exe
@@ -116,7 +108,7 @@
 Startup Procedure
 -----------------
 Linux and Source
-----------------
+................
 Start Tartan by entering the following command:
 
     `python -OO program_path/ms0000.py [options]`
@@ -124,11 +116,11 @@
 To find out what the available command line options are, use the -h option.
 
 Windows Binary
---------------
+..............
 Start Tartan by clicking on the shortcut icon on the desktop or by navigating to the `C:\\Tartan\\prg` directory and double clicking on the `ms0000[.exe]` file.
 
 Both
-----
+....
 The first time you run Tartan you will automatically be taken to `Preferences`_ where you will have to enter various parameters relating to your installation. After saving the preferences and restarting Tartan you will be prompted to create the database. Once the database has been created you will have to create the System record as per `System Record Maintenance`_ as well as a Company record as per `Company Records Maintenance`_.
 
 Status Line
@@ -153,15 +145,15 @@
 There are various common routines. Rather than continually describing them they will be described once here only.
 
 User Validation
----------------
+...............
 If no users have been created using the `User's Maintenance`_ routine on the `System`_ menu and no password has been allocated to the **admin** user, the system will automatically log in using **admin** as the user name. In all other cases a user must log in by entering a valid name and password. If no password exists for the **admin** user a password should be created as soon as possible using the `Change Password`_ routine on the System_ menu.
 
 Company Selection
------------------
+.................
 For every routine which is company specific and where you have more than 1 company, you will be required to select the relevant company. In some cases you will also have to enter a financial period. Please note that you will not always be prompted for the financial period as this only applies to routines which require it. Also note that for both selections there is a `F1 Record Selection` option as per `Common Keyboard Functions`_.
 
 Batch Details
--------------
+.............
 Most data capture routines require you to enter batch details. The reason for a batch is ease of balancing and the resolution of errors made during data capture. After you exit a data capture routine a totals summary will be displayed. If there is a discrepancy between the expected and entered values all the various systems have a routine to print the batch details thus enabling you to determine where the error is and therefore to correct it.
 
 + **Batch Number** - Any 7 character unique alphanumeric code.
@@ -175,7 +167,7 @@
 + **Bank Control** - For all batches in general ledger and other systems integrated with the general ledger, that affect the bank accounts, enter the bank control code.
 
 Ageing Transactions
--------------------
+...................
 While capturing transactions for various systems you will be required to allocate the amount to existing outstanding transactions for ageing purposes.
 
 There are four different methods of ageing a transaction:
@@ -192,12 +184,8 @@
 + **Automatic** - This will automatically allocate the amount against outstanding transactions, starting from the oldest transaction, until either the amount has been fully allocated or there are no more outstanding transactions in which case the balance will remain as unallocated.
 + **Current** - This will leave the full transaction as unallocated.
 
-.. raw:: pdf
-
-   PageBreak
-
 Printer Selection
------------------
+.................
 Whenever a report is being produced you will have the opportunity of deciding on the output method i.e. viewing, printing, exporting and, in some cases, whether or not to email it.  Please note that the option to email the report will only be available if there is a valid `SMTP Server` in the `System Record Maintenance`_ record.
 
 + **Output** - Select the required output option.
@@ -207,7 +195,7 @@
 + **E-Mail Message** - If available, enter the email message as well as any additional attachments, if any.
 
 Error Messages
---------------
+..............
 Should an error message occur and there is a file named *errors.txt* in the `Work Path` as created in `Preferences`_. Please email the file to errors@tartan.co.za after which you may delete it.
 
 Menus and Sub Menus
@@ -262,10 +250,10 @@
   :header: "Coy", "SS", "Prog", "Password", "Meaning"
   :widths: 5, 5, 6, 10, 50
 
-  "0", "gl", "    ", "    ", "All general ledger modules for all companies would be denied."
-  "0", "gl", "2032", "    ", "General ledger payments data capture for all companies would be denied."
-  "0", "gl", "    ", "abcd", "All general ledger modules for all companies would require the password `abcd`."
-  "0", "gl", "2032", "abcd", "General ledger payments data capture for all companies would require the password `abcd`."
+  "0", "gl", "    ", "    ", "All G/L modules for all companies would be denied."
+  "0", "gl", "2032", "    ", "G/L payments data capture for all companies would be denied."
+  "0", "gl", "    ", "abcd", "All G/L modules for all companies would require the password."
+  "0", "gl", "2032", "abcd", "G/L payments data capture for all companies would require the password."
 
 Upgrade System
 ..............
@@ -290,10 +278,6 @@
 ...............
 Select this routine to create a backup of the current database. These backups will reside in the *Backup Path* directory as created using the `Preferences`_ routine. Each backup will further reside in a sub directory named after the name of the database and a further sub directory named `arch`.
 
-.. raw:: pdf
-
-   PageBreak
-
 Restore Database
 ................
 Select this routine to restore a previous backup.
@@ -318,7 +302,8 @@
 
 ::
 
-    If the selected company or companies is/are linked to other companies you will be asked if all linked companies should be exported.
+    If the selected company or companies is/are linked to other companies you
+    will be asked if all linked companies should be exported.
 
 + **Directory** - Enter the directory where the exported file must be placed.
 + **Database Name** - Enter the name of the exported file or accept the default.
@@ -328,16 +313,20 @@
 + Copy the exported file to the target computer
 + Install Tartan on the target computer if it is not already installed
 + Execute Tartan with the following command:
-    + c:\Tartan\prg\ms0000.exe -r c:\Tartan\tartan001
+
+    + c:\\Tartan\\prg\\ms0000.exe -r c:\\Tartan\\tartan001
+
 + You will now be in the Tartan Preferences Routine
+
     + Hit enter to accept the Configuration File e.g. tartan001
     + Hit enter to accept the Database Engine i.e. SQLite
     + Enter the Database Name i.e. the name of the exported file e.g. tartan001.db and hit enter.
     + Hit enter to accept the Host Name i.e. localhost
     + Enter the Files Directory i.e. the directory where the exported file has been copied to.
     + Click on the Save button and the the Close button.
+
 + The Tartan menu should now be displaying.
-+ After exiting Tartan you can re-enter Tartan by executing the third step i.e. Execute Tartan with the following command......
++ After exiting Tartan you can re-enter Tartan by executing the third step i.e. Execute Tartan with the following command:
 
 Merge Database
 ..............
@@ -357,27 +346,21 @@
 Use this routine to configure Tartan, however, depending on your security level, some of the options might not be available to you.
 
 + **Configuration File** - This is the full path of your configuration file. Every user can have his or her own file. This file, by default, is placed in the user's home directory or, in Windows, the root directory of the Tartan installation e.g. `C:\\Tartan`. If you want to change this default, you must set an environment variable as **TARTANRC=path-to-rcfile** or use the command line option **-r path-to-rcfile**.
-
 + **Database**
-
-    + **Database Engine** - This is the database being used and must be one of PostgreSQL and SQLite. The recommended one for single user installations is SQLite and PostgreSQL for multi-user installations.
-    + **Database Name** - This can be any single word name defaulting to **tartan**.
-    + **Host Name** - This is the host name of the Server. This is not used with SQLite.
+    + **Database Engine** - This is the database being used and must be one of PostgreSQL and SQLite. The recommended one for single-user installations is SQLite and PostgreSQL for multi-user installations.
+    + **Database Name** - This can be any single word name which defaults to **tartan**.
     + **Files Directory** - This is only used for the SQLite database engine and is the directory where the database will be created.
-    + **Port Number** - This is the port number the database uses. Leaving this blank will enable the database default port.
-    + **Administrator** - This is the name used to connect to the database. This is not used with SQLite.
-    + **Password** - This is the password of the user. This is not necessary with SQLite.
-
+    + **Host Name** - This is only used for PgSQL databases and is the host name of the Server which defaults to **localhost**.
+    + **Port Number** - This is the port number to connect to the database. Leaving this blank will enable the default port.
+    + **Administrator** - This is the name used to connect to the database.
+    + **Password** - This is the password of the administrator.
 + **General**
-
-    + **Program Path** - This is the base directory where the programs reside.
     + **Backup Path** - This is the path where backups of the database will be stored.
     + **Work Path** - This is the path of the work directory. All temporary files will be created in this directory.
     + **Upgrade Path** - This is the path where any upgrades will be stored.
-    + **PDF Viewer** - This is the full path of the program used to display pdf files.  The default for LINUX is **evince** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **Print Command** - This is the full path of the print program used to print postscript files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Other recommended programs for windows are **Foxit Reader** and **AcroRd32** version 4.05.
-    + **PS Converter** - This is the full path of the program needed to convert pdf files to postscript. The LINUX default is **pdftops** and the Windows one is **blank**.  If this field is left blank, no conversion will take place and the print routine will have to be able to print pdf files directly e.g. where one of `SumatraPDF`, `Foxit Reader` or `Acrobat Reader` has been selected as the printer.
-    + **CSV Reader** - This is the full path of the program used to read csv and xls file formats.
+    + **PDF Viewer** - This is the full path of an External program used to display pdf files. The default is `Blank` for the built-in pdf viewer. External programme for LINUX is **evince** and for Windows **SumatraPDF** or  **Foxit Reader**.
+    + **Print Command** - This is the full path of the print program used to print pdf files. The LINUX default is **lpr** and Windows is **SumatraPDF**. Another recommended program for windows is **Foxit Reader**. If necessary use %p% for the printer name and %f% for the file name e.g. the print command for Sumatra could be `the-path-to\SumatraPDF.exe -print-to %p% %f%`.
+    + **Spreadsheet Reader** - This is the full path of the program used to read csv and xls file formats.
     + **Screen Geometry** - This defaults to the suggested geometry for your screen. Entering a zero will achieve the same result.
     + **Screen Placement** - Where the Tartan Window must be placed on the monitor i.e. Left, Centre or Right.
     + **Show Tartan Image** - Whether to display the Tartan image on the Main Menu screen.
@@ -389,9 +372,7 @@
         + **Trash** - Send the files to the *Recycle Bin*.
         + **Delete** - Delete the files.
         + **Keep** - Keep the files in the work directory.
-
 + **Dialog**
-
     + **Menu Font**
         + **Name** - This is the font family to be used for all menu items.
         + **Size** - This is font size to be used for all menu items.

=== modified file 'doc/Support.rst' (properties changed: -x to +x)
=== modified file 'doc/Testimonials.rst' (properties changed: -x to +x)
=== modified file 'doc/UTY.rst' (properties changed: -x to +x)
--- old/doc/UTY.rst	2020-04-20 12:42:42 +0000
+++ new/doc/UTY.rst	2020-07-27 10:24:42 +0000
@@ -26,9 +26,7 @@
 Use this routine to send bulk MAIL or bulk SMSes. In order to use the MAIL facility you must enter a valid SMTP server in the `System Record`. In order to use the SMS facility you must register with www.smsportal.co.za and then enter your username and password in the `System Record` using `System Record Maintenance`_.
 
 + **Delivery Type** - The available delivery types will depend on what is entered in the `System Record` and can be either E-Mail, SMS or both.
-
 + **List to Use** - The available lists will depend on the systems being used and can contain Bookings, Bowls, Creditors, Debtors, Members and Directory (Telephone). In addition to the lists, CSV or XLS files can also be used, as long as they contain a name and an email address and or a cell number. Please note that Creditors and Debtors do not have SMS capabilities.
-
     + **Bookings** - This list accesses the tartan booking's contacts.
         + **Individuals** - Allow selection of individual recipients.
     + **Bowls** - This list accesses the tartan bowl's tabs.
@@ -74,10 +72,6 @@
     + **{{name}}** - Use this method if the recipient has separate surname and names fields.
     + **{{surname}}** - Use this method if the recipient has a single name field where the surname and names are comma separated e.g. Malherbe, Paul.
 
-.. raw:: pdf
-
-    PageBreak
-
 Report Generator
 ................
 Use this routine to generate ad hoc SQL reports. It is not necessary to know the SQL language but it is beneficial.
@@ -117,10 +111,6 @@
 + **Exceptions**
 + **Order**
 
-.. raw:: pdf
-
-    PageBreak
-
 Report Stream
 .............
 Use this routine to print or mail various selected reports.
@@ -133,7 +123,7 @@
 
 A list of available reports will be displayed. Select the reports to generate and then click on *Accept*.
 
-Each report dialog will be displayed and at the end of the last report you will be prompted whether to actually *Print" or *Mail* the reports.
+Each report dialog will be displayed and at the end of the last report you will be prompted whether to actually *Print* or *Mail* the reports.
 
 In the event of Financial Statements (gl3050), if there are available Report Streams, you will be asked if you want to apply a report stream.
 
@@ -237,4 +227,14 @@
     + **Y1 Co-Ordinate** - The top position of the imported data in mm.
     + **Y2 Co-Ordinate** - The bottom position of the imported data in mm.
     + **Number of Lines** - The number of lines the imported data can contain e.g. a name and address could be 5 lines.
-    + **Repeats** - The number of time to repeat the imported data e.g. the number of lines in the body of a statement could be 30.
+    + **Repeats** - The number of times to repeat the imported data e.g. the number of lines in the body of a statement could be 30.
+
++ **Buttons**
+    + **Import** - Use this button to import a template file.
+    + **Copy** - Use this button to copy a template.
+    + **Export** - Use this button to export a template to a file.
+    + **Re-Sequence** - Use this button to re-sequence the line numbers of a template.
+    + **Print** - Use this button to print the lines of the template.
+    + **View PDF** - Use this button to get a preview of the document.
+    + **Exit** - Use this button to save and exit the template maintenance routine.
+    + **Quit** - Use this button to quit the template maintenance routine without saving it.

=== modified file 'doc/WAG.rst' (properties changed: -x to +x)
--- old/doc/WAG.rst	2017-08-24 07:49:34 +0000
+++ new/doc/WAG.rst	2020-06-16 12:20:41 +0000
@@ -46,18 +46,18 @@
 + **Employee Portion** - Amount if the portion is a monetary value or Rate if the portion is a rate.
     + **Base** - If you have indicated that the portion is a rate, you must now indicate the code of the base of the calculation, as follows:
 
-        + **1** - X \* Normal Rate of Pay * Factor
-        + **2** - Normal Pay * Factor
-        + **3** - Normal Pay * Factor / 100
-        + **4** - X \* Daily Rate of Pay * Factor
-        + **5** - X \* Hourly Rate of Pay * Factor
-        + **6** - U.I.F. Pay * Factor
+        + **1** - X \* Normal Rate of Pay * Value
+        + **2** - Normal Pay * Value
+        + **3** - Normal Pay * Value / 100
+        + **4** - X \* Daily Rate of Pay * Value
+        + **5** - X \* Hourly Rate of Pay * Value
+        + **6** - U.I.F. Pay * Value
         + **Where:**
             + **X** refers to a data captured period e.g. hours or days.
             + **\*** indicates multiplication.
             + **\/** indicates division
-            + **Factor** refers to the 'Amount' field below.
-        + **Amount** - The actual amount or rate to be used in the calculations.
+            + **Value** refers to the 'Value' field below.
+        + **Value** - The actual amount or rate to be used in the calculations.
         + **Limit** - The maximum amount allowed e.g. U.I.F. - 116.62.
         + **GL/Cono** - If integrated, the general ledger company number to be updated. This will take preference to the general ledger company number in the department record.
         + **GL/Acno** - If integrated, the general ledger account number to be updated. This will take preference to the general ledger account number in the department record.
@@ -112,10 +112,6 @@
 + **Tax-Amt** - The initial tax amount for the Inc-Fr column e.g. 0.
 + **Rate** - The rate for the income up to the Inc-To column e.g. 18.00.
 
-.. raw:: pdf
-
-   PageBreak
-
 Employee Masterfile (WG)
 ++++++++++++++++++++++++
 Use this routine to create, amend or delete employee masterfile records.
@@ -156,11 +152,6 @@
     + **Account Number**
     + **Account Holder's Name**
     + **Holder's Relationship**
-
-.. raw:: pdf
-
-   PageBreak
-
 + **Earnings**
     + **Cod** - The code of the earning to be automatically raised.
     + **Amnt/Rate** - The value or rate of the earning to be raised.

=== removed file 'doc/gmailsmtp.txt'
--- old/doc/gmailsmtp.txt	2018-02-17 07:36:43 +0000
+++ new/doc/gmailsmtp.txt	1970-01-01 00:00:00 +0000
@@ -1,14 +0,0 @@
-To set the mail server to use smtp.gmail.comm as the smtp server do:
-
-1) Create a gmail account
-2) Edit gmail account:
-    a) Go to Settings
-    b) Go to Accounts and Import
-    c) Add another email address
-    d) Enter your name and email address
-    e) Untick "Treat as Alias"
-    f) Enter "smtp.gmail.com" as SMTP Server
-    g) Enter gmail username and password
-    h) Click on Add Account
-3) Set the new account as default
-4) Select which address replys must come from

=== modified file 'doc/gnugpl.html' (properties changed: -x to +x)
=== modified file 'doc/gnugpl.md' (properties changed: -x to +x)
=== modified file 'doc/gnugpl.txt' (properties changed: -x to +x)
=== removed file 'doc/https.txt'
--- old/doc/https.txt	2019-07-03 13:49:08 +0000
+++ new/doc/https.txt	1970-01-01 00:00:00 +0000
@@ -1,17 +0,0 @@
-Edit /etc/apache2/sites-available/tartan.co.za.conf to be:
-
-<VirtualHost *:80>
-    ServerName tartan.co.za
-    ServerAlias www.tartan.co.za
-    ServerAdmin paul@tartan.co.za
-    DocumentRoot /var/www/tartan.co.za/
-    AddHandler cgi-script .py
-    Include /etc/apache2/sites-available/tartan.co.za.include
-
-apt install python-certbot-apache
-
-certbot --apache -m paul@tartan.co.za -d tartan.co.za -d www.tartan.co.za
-answers: A Y 2
-
-crontab -e
-0 1 * * * /usr/bin/certbot renew & > /dev/null

=== removed file 'doc/i18n.txt'
--- old/doc/i18n.txt	2018-08-19 10:44:06 +0000
+++ new/doc/i18n.txt	1970-01-01 00:00:00 +0000
@@ -1,28 +0,0 @@
-Internationalization
---------------------
-1) Edit modules and change "Text" to _("Text")
-2) Create .pot file
-    gettext pygettext -d base -o locales/base.pot module.py
-3) Edit locales/base.pot and change where needed especially:
-    "Content-Type: text/plain; charset=UTF-8\n"
-    "Content-Transfer-Encoding: 8bit\n"
-4) Create language directories:
-    mkdir locales/lang/LC_MESSAGES
-5) Copy locales/base.pot to each language directory
-6) Edit language files other than english and enter translations e.g.
-    msgid "Hello World"
-    msgstr "Hello Wreld"
-
-    I can use googletrans to achieve this:
-        pip install googletrans
-        translate "Hello world" -s en -d af
-7) Compile base.pt:
-    cd locales/lang/LC_MESSAGES
-    msgfmt -o base.mo base
-8) Edit base module.py and include:
-    import gettext
-    lang = rc.dic["lang"]
-    langs = {"en": "English", "af": "Afrikaans"}
-    ll = gettext.translation('base', localedir='locales', languages=[lang])
-    ll.install()
-    _ = ll.gettext

=== modified file 'doc/manual.css' (properties changed: -x to +x)
--- old/doc/manual.css	2014-03-28 07:32:49 +0000
+++ new/doc/manual.css	2020-06-11 14:44:24 +0000
@@ -16,15 +16,18 @@
 div.document a {
   text-decoration: none; }
 
+/*
 div.document a[href] {
   text-decoration: underline; }
+*/
 
 div.document h1.title {
   background-image: url("zope3logo.gif");
   background-position: -6px -4px;
   background-repeat: no-repeat;
   font-size: 150%;
-  min-height: 50px; }
+  min-height: 50px;
+  text-align: center }
 
 div.document div.section {
   margin: 0px 0px 1.5em 0px; }

=== modified file 'doc/mystylesheet' (properties changed: -x to +x)
=== removed file 'doc/openvpn.txt'
--- old/doc/openvpn.txt	2019-07-03 13:49:08 +0000
+++ new/doc/openvpn.txt	1970-01-01 00:00:00 +0000
@@ -1,57 +0,0 @@
-$ cd ~
-$ git clone https://github.com/Nyr/openvpn-install.git
-$ cd openvpn-install/
-$ ls -1
-    LICENSE.txt
-    README.md
-    openvpn-install.sh
-$ chmod +x openvpn-install.sh
-$ sudo ./openvpn-install.sh
-
-First, provide the IPv4 address of the network interface you want OpenVPN
-listening to.
-IP address: 192.168.10.2
-
-Which protocol do you want for OpenVPN connections?
-1) UDP (recommended)
-2) TCP
-Protocol [1-2]: 1
-
-What port do you want OpenVPN listening to?
-Port: 1194
-
-Which DNS do you want to use with the VPN?
-1) Current system resolvers
-2) 1.1.1.1
-3) Google
-4) OpenDNS
-5) Verisign
-DNS [1-5]: 1
-
-Finally, tell me your name for the client certificate.
-Please, use one word only, no special characters.
-Client name: client
-
-Okay, that was all I needed. We are ready to set up your OpenVPN server now.
-Press any key to continue... <Enter>
-
-Using configuration from ./openssl-easyrsa.cnf
-Check that the request matches the signature
-Signature ok
-The Subject's Distinguished Name is as follows
-commonName            :ASN.1 12:'client'
-Certificate is to be certified until Jul  4 07:53:27 2028 GMT (3650 days)
-
-Write out database with 1 new entries
-Data Base Updated
-Using configuration from ./openssl-easyrsa.cnf
-
-An updated CRL has been created.
-CRL file: /etc/openvpn/easy-rsa/pki/crl.pem
-
-394
-
-Finished!
-
-Your client configuration is available at: /root/client.ovpn
-If you want to add more clients, you simply need to run this script again!

=== removed file 'doc/rne_newcoy.rst'
--- old/doc/rne_newcoy.rst	2019-07-03 13:49:08 +0000
+++ new/doc/rne_newcoy.rst	1970-01-01 00:00:00 +0000
@@ -1,32 +0,0 @@
-Steps to Set Up a New Company
-=============================
-Company Record
---------------
-1. Go to *Control --> File Maintenance --> Company Records Maintenance*
-2. Enter the company details
-3. If a V.A.T. number has been entered enter the default V.A.T. Code
-4. If a V.A.T. code has been entered Enter the code details
-5. Enter through the Banking fields
-6. Enable the required System modules e.g. General Ledger, Assets and Loans
-7. Enter throught the Logo field
-8. Confirm the entries
-
-General Ledger Records
-----------------------
-1. Go to *General Ledger --> Toolbox --> Copy Masterfile Records*
-2. Enter the *New* company number
-3. Enter the company number of the company whose records you want to copy
-4. Tick *Yes* for Control Records
-5. Tick *No* for all following fields except the last one
-6. Tick *Yes* for Equalise Year Ends
-7. Confirm the entries
-8. When finished tick *Yes* to commit the data
-
-Inter Company Records
----------------------
-1. Go to *General Ledger --> File Maintenance --> Inter Company Records*
-2. Enter the *New* company number
-3. Enter 1 in the *Coy-Num* field
-4. Enter *9905801* in the *Acc-Num-1* field
-5. Enter the new company's account number in company 1
-6. Confirm the entries

=== removed file 'doc/stylesheet'
--- old/doc/stylesheet	2015-04-11 07:29:58 +0000
+++ new/doc/stylesheet	1970-01-01 00:00:00 +0000
@@ -1,584 +0,0 @@
-
-  # List any fonts you would like to embed in the PDF here
-  embeddedFonts: []
-
-  # Default page setup.  Can be overridden by including other
-  # stylesheets with -s
-
-  pageSetup:
-    size: A4
-    width: 0
-    height: 0
-    margin-top: 1cm
-    margin-bottom: 1cm
-    margin-left: 1cm
-    margin-right: 1cm
-    margin-gutter: 0cm
-    spacing-header: 5mm
-    spacing-footer: 5mm
-
-    # The first template is one of the 'pageTemplates"
-    # (See next section)
-
-    firstTemplate: oneColumn
-
-  # pageTemplates can be accessed with the .. raw:: pdf PageBreak command
-
-  pageTemplates:
-    coverPage:
-        frames: []
-            [0cm, 0cm, 100%, 100%]
-        showHeader : false
-        showFooter : false
-
-    emptyPage:
-        frames: []
-            [0cm, 0cm, 100%, 100%]
-        showHeader : false
-        showFooter : false
-
-    oneColumn:
-        frames: []
-            [0cm, 0cm, 100%, 100%]
-        showHeader : true
-        showFooter : true
-
-    twoColumn:
-        frames: []
-            [0cm, 0cm, 49%, 100%]
-            [51%, 0cm, 49%, 100%]
-        showHeader : true
-        showFooter : true
-
-    threeColumn:
-        frames: []
-            [2%, 0cm, 29.333%, 100%]
-            [35.333%, 0cm, 29.333%, 100%]
-            [68.666%, 0cm, 29.333%, 100%]
-        showHeader : true
-        showFooter : true
-
-    cutePage:
-        frames: []
-            [0%, 0%, 100%, 100%]
-        showHeader : true
-        showFooter : true
-        defaultFooter : ###Page###
-        defaultHeader : ###Section###
-
-  fontsAlias:
-    stdFont: Helvetica
-    stdBold: Helvetica-Bold
-    stdItalic: Helvetica-Oblique
-    stdBoldItalic: Helvetica-BoldOblique
-    stdSans: Helvetica
-    stdSansBold: Helvetica-Bold
-    stdSansItalic: Helvetica-Oblique
-    stdSansBoldItalic: Helvetica-BoldOblique
-    stdMono: Courier
-    stdMonoItalic: Courier-Oblique
-    stdMonoBold: Courier-Bold
-    stdMonoBoldItalic: Courier-BoldOblique
-    stdSerif: Times-Roman
-
-  linkColor: navy
-
-  styles:
-    base:
-      parent: null
-      fontName: stdFont
-      fontSize: 10
-      leading: 12
-      leftIndent: 0
-      rightIndent: 0
-      firstLineIndent: 0
-      alignment: TA_LEFT
-      spaceBefore: 0
-      spaceAfter: 0
-      bulletFontName: stdFont
-      bulletFontSize: 10
-      bulletIndent: 0
-      textColor: black
-      backColor: null
-      wordWrap: null
-      borderWidth: 0
-      borderPadding: 0
-      borderColor: null
-      borderRadius: null
-      allowWidows: false
-      allowOrphans: false
-      hyphenation: false
-      kerning: false
-      underline: false
-      strike: false
-      commands: []
-
-    normal:
-      parent: base
-
-    title-reference:
-      parent: normal
-      fontName: stdItalic
-
-    bodytext:
-      parent: normal
-      spaceBefore: 6
-      alignment: TA_JUSTIFY
-      hyphenation: true
-
-    toc:
-      parent: normal
-
-    blockquote:
-      parent: bodytext
-      leftIndent: 20
-
-    lineblock:
-      parent: bodytext
-
-    line:
-      parent: lineblock
-      spaceBefore: 0
-
-    toc1:
-      parent: toc
-      fontName: stdBold
-
-    toc2:
-      parent: toc
-      leftIndent: 20
-
-    toc3:
-      parent: toc
-      leftIndent: 40
-
-    toc4:
-      parent: toc
-      leftIndent: 60
-
-    toc5:
-      parent: toc
-      leftIndent: 80
-
-    toc6:
-      parent: toc
-      leftIndent: 100
-
-    toc7:
-      parent: toc
-      leftIndent: 100
-
-    toc8:
-      parent: toc
-      leftIndent: 100
-
-    toc9:
-      parent: toc
-      leftIndent: 100
-
-    toc10:
-      parent: toc
-      leftIndent: 100
-
-    toc11:
-      parent: toc
-      leftIndent: 100
-
-    toc12:
-      parent: toc
-      leftIndent: 100
-
-    toc13:
-      parent: toc
-      leftIndent: 100
-
-    toc14:
-      parent: toc
-      leftIndent: 100
-
-    toc15:
-      parent: toc
-      leftIndent: 100
-
-    footer:
-      parent: normal
-      alignment: TA_CENTER
-
-    header:
-      parent: normal
-      alignment: TA_CENTER
-
-    attribution:
-      parent: bodytext
-      alignment: TA_RIGHT
-
-    image:
-      parent: bodytext
-      alignment: TA_CENTER
-
-    figure:
-      parent: bodytext
-      alignment: TA_CENTER
-      commands: []
-             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-             [ALIGN, [ 0, 0 ], [ -1, -1 ], CENTER ]
-      colWidths: [100%]
-
-    figure-caption:
-      parent: bodytext
-      fontName: stdItalic
-      alignment: TA_CENTER
-
-    figure-legend:
-      parent: bodytext
-
-    bullet-list:
-      parent: bodytext
-      commands: []
-             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-             [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
-      colWidths: ["20", null]
-
-    bullet-list-item:
-      parent: bodytext
-
-    item-list:
-      parent: bodytext
-      commands: []
-             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-             [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
-      colWidths: [20pt,null]
-
-    item-list-item:
-      parent: bodytext
-
-    definition-list-term:
-      parent: normal
-      fontName: stdBold
-      spaceBefore: 4
-      spaceAfter: 0
-      keepWithNext: false
-
-    definition-list-classifier:
-      parent: normal
-      fontName: stdItalic
-
-    definition:
-      parent: bodytext
-      firstLineIndent: 0
-      bulletIndent: 0
-      spaceBefore: 0
-      colWidths: [20pt,null]
-      commands: []
-                    [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-                    [LEFTPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-                    [BOTTOMPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-                    [RIGHTPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-                    
-    fieldname:
-      parent: bodytext
-      alignment: TA_RIGHT
-      fontName: stdBold
-
-    fieldvalue:
-      parent: bodytext
-
-    rubric:
-      parent: bodytext
-      textColor: darkred
-      alignment: TA_CENTER
-
-    italic:
-      parent: bodytext
-      fontName: stdItalic
-
-    heading:
-      parent: normal
-      keepWithNext: true
-      spaceBefore: 12
-      spaceAfter: 6
-
-    title:
-      parent: heading
-      fontName: stdBold
-      fontSize: 200%
-      alignment: TA_CENTER
-      keepWithNext: false
-      spaceAfter: 10
-
-    subtitle:
-      parent: title
-      spaceBefore: 12
-      fontSize: 75%
-
-    heading1:
-      parent: heading
-      fontName: stdBold
-      fontSize: 175%
-
-    heading2:
-      parent: heading
-      fontName: stdBold
-      fontSize: 150%
-
-    heading3:
-      parent: heading
-      fontName: stdBoldItalic
-      fontSize: 125%
-
-    heading4:
-      parent: heading
-      fontName: stdBoldItalic
-
-    heading5:
-      parent: heading
-      fontName: stdBoldItalic
-
-    heading6:
-      parent: heading
-      fontName: stdBoldItalic
-
-    topic-title:
-      parent: heading3
-
-    sidebar-title:
-      parent: heading3
-
-    sidebar-subtitle:
-      parent: heading4
-
-    sidebar:
-      float: none
-      width: 100%
-      parent: normal
-      backColor: beige
-      borderColor: darkgray
-      borderPadding: 8
-      borderWidth: 0.5
-
-    admonition:
-      parent: normal
-      spaceBefore: 12
-      spaceAfter: 6
-      borderPadding: [16,16,16,16]
-      backColor: beige
-      borderColor: darkgray
-      borderWidth: 0.5
-      commands:[]
-             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-
-    attention:
-      parent: admonition
-
-    caution:
-      parent: admonition
-
-    danger:
-      parent: admonition
-
-    error:
-      parent: admonition
-
-    hint:
-      parent: admonition
-
-    important:
-      parent: admonition
-
-    note:
-      parent: admonition
-
-    tip:
-      parent: admonition
-
-    warning:
-      parent: admonition
-
-    admonition-title:
-      parent: heading3
-
-    admonition-heading:
-      parent: heading3
-
-    attention-heading:
-      parent: admonition-heading
-
-    caution-heading:
-      parent: admonition-heading
-
-    danger-heading:
-      parent: admonition-heading
-
-    error-heading:
-      parent: admonition-heading
-
-    hint-heading:
-      parent: admonition-heading
-
-    important-heading:
-      parent: admonition-heading
-
-    note-heading:
-      parent: admonition-heading
-
-    tip-heading:
-      parent: admonition-heading
-
-    warning-heading:
-      parent: admonition-heading
-
-    literal:
-      parent: normal
-      fontName: stdMono
-      firstLineIndent: 0
-      hyphenation: false
-      wordWrap: null
-
-    aafigure:
-      parent: literal
-
-    table:
-      spaceBefore:6
-      spaceAfter:0
-      alignment: TA_CENTER
-      commands: []
-             [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-             [INNERGRID, [ 0, 0 ], [ -1, -1 ], 0.25, black ]
-             [ROWBACKGROUNDS, [0, 0], [-1, -1], [white,#E0E0E0]]
-             [BOX, [ 0, 0 ], [ -1, -1 ], 0.25, black ]
-
-    table-title:
-      parent : heading4
-      keepWithNext: false
-      alignment : TA_CENTER
-
-    table-heading:
-      parent : heading
-      backColor : beige
-      alignment : TA_CENTER
-      valign : BOTTOM
-      borderPadding : 0
-
-    table-body:
-      parent : normal
-
-    dedication:
-      parent : normal
-
-    abstract:
-      parent : normal
-
-    contents:
-      parent : normal
-
-    tableofcontents:
-      parent : normal
-
-    code:
-      parent: literal
-      leftIndent: 0
-      spaceBefore: 8
-      spaceAfter: 8
-      backColor: beige
-      borderColor: darkgray
-      borderWidth: 0.5
-      borderPadding: 6
-
-    linenumber:
-      parent: code
-
-    right:
-      parent: bodytext
-      alignment: right
-
-    center:
-      parent: bodytext
-      alignment: center
-
-    pygments-n: parent: code
-    pygments-nx: parent: code
-    pygments-p: parent: code
-    pygments-hll: {parent: code, backColor: #ffffcc}
-    pygments-c: {textColor: #008800, parent: code}
-    pygments-err: {parent: code}
-    pygments-k: {textColor: #AA22FF, parent: code}
-    pygments-o: {textColor: #666666, parent: code}
-    pygments-cm: {textColor: #008800, parent: code}
-    pygments-cp: {textColor: #008800, parent: code}
-    pygments-c1: {textColor: #008800, parent: code}
-    pygments-cs: {textColor: #008800, parent: code}
-    pygments-gd: {textColor: #A00000, parent: code}
-    pygments-ge: {parent: code}
-    pygments-gr: {textColor: #FF0000, parent: code}
-    pygments-gh: {textColor: #000080, parent: code}
-    pygments-gi: {textColor: #00A000, parent: code}
-    pygments-go: {textColor: #808080, parent: code}
-    pygments-gp: {textColor: #000080, parent: code}
-    pygments-gs: {parent: code}
-    pygments-gu: {textColor: #800080, parent: code}
-    pygments-gt: {textColor: #0040D0, parent: code}
-    pygments-kc: {textColor: #AA22FF, parent: code}
-    pygments-kd: {textColor: #AA22FF, parent: code}
-    pygments-kn: {textColor: #AA22FF, parent: code}
-    pygments-kp: {textColor: #AA22FF, parent: code}
-    pygments-kr: {textColor: #AA22FF, parent: code}
-    pygments-kt: {textColor: #00BB00, parent: code}
-    pygments-m: {textColor: #666666, parent: code}
-    pygments-s: {textColor: #BB4444, parent: code}
-    pygments-na: {textColor: #BB4444, parent: code}
-    pygments-nb: {textColor: #AA22FF, parent: code}
-    pygments-nc: {textColor: #0000FF, parent: code}
-    pygments-no: {textColor: #880000, parent: code}
-    pygments-nd: {textColor: #AA22FF, parent: code}
-    pygments-ni: {textColor: #999999, parent: code}
-    pygments-ne: {textColor: #D2413A, parent: code}
-    pygments-nf: {textColor: #00A000, parent: code}
-    pygments-nl: {textColor: #A0A000, parent: code}
-    pygments-nn: {textColor: #0000FF, parent: code}
-    pygments-nt: {textColor: #008000, parent: code}
-    pygments-nv: {textColor: #B8860B, parent: code}
-    pygments-ow: {textColor: #AA22FF, parent: code}
-    pygments-w: {textColor: #bbbbbb, parent: code}
-    pygments-mf: {textColor: #666666, parent: code}
-    pygments-mh: {textColor: #666666, parent: code}
-    pygments-mi: {textColor: #666666, parent: code}
-    pygments-mo: {textColor: #666666, parent: code}
-    pygments-sb: {textColor: #BB4444, parent: code}
-    pygments-sc: {textColor: #BB4444, parent: code}
-    pygments-sd: {textColor: #BB4444, parent: code}
-    pygments-s2: {textColor: #BB4444, parent: code}
-    pygments-se: {textColor: #BB6622, parent: code}
-    pygments-sh: {textColor: #BB4444, parent: code}
-    pygments-si: {textColor: #BB6688, parent: code}
-    pygments-sx: {textColor: #008000, parent: code}
-    pygments-sr: {textColor: #BB6688, parent: code}
-    pygments-s1: {textColor: #BB4444, parent: code}
-    pygments-ss: {textColor: #B8860B, parent: code}
-    pygments-bp: {textColor: #AA22FF, parent: code}
-    pygments-vc: {textColor: #B8860B, parent: code}
-    pygments-vg: {textColor: #B8860B, parent: code}
-    pygments-vi: {textColor: #B8860B, parent: code}
-    pygments-il: {textColor: #666666, parent: code}
-
-    endnote:
-        parent: bodytext
-        commands: []
-            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-            [BOTTOMPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-            [RIGHTPADDING, [ 0, 0 ], [ 1, -1 ], 0 ]
-        colWidths: [3cm, null]
-
-    field-list:
-        parent: bodytext
-        commands: []
-            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-        colWidths: [3cm, null]
-        spaceBefore: 6
-
-    option-list:
-        commands: []
-            [VALIGN, [ 0, 0 ], [ -1, -1 ], TOP ]
-            [TOPPADDING, [ 0, 0 ], [ -1, -1 ], 0 ]
-        colWidths: [null,null]

=== removed file 'doc/tarlic.rst'
--- old/doc/tarlic.rst	2017-08-24 07:49:34 +0000
+++ new/doc/tarlic.rst	1970-01-01 00:00:00 +0000
@@ -1,65 +0,0 @@
-NOTICE TO USER:
-~~~~~~~~~~~~~~~
-Please, read this carefully. By using all or any portion of the Software you accept all the terms and conditions of this Agreement. If you do not agree, do not use this Software.
-
-1. GENERAL USE 
-~~~~~~~~~~~~~~
-You are granted a non-exclusive License to Use the downloaded/supplied Software for any purposes for an unlimited period of time.
-
-The software product under this License is provided free of charge. Even though a license fee is not paid for the use of such software, it does not mean that there are no conditions for using such software.
-
-1.1. The Software may be installed and Used by the Licensee for any legal purpose.
-
-1.2. The Software may be installed and Used by the Licensee on any number of systems.
-
-1.3. The Software can be copied and distributed under the condition that original copyright notice and disclaimer of warranty will stay intact and the Licensee will not charge money or fees for the Software product, except to cover distribution costs.
-
-1.4. The Licensee will not have any proprietary rights in and to the Software. The Licensee acknowledges and agrees that the Licensor retains all copyrights and other proprietary rights in and to the Software.
-
-1.5 Use within the scope of this License is free of charge and no royalty or licensing fees shall be paid by the Licensee.
-
-2. INTELLECTUAL PROPERTY RIGHTS
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-2.1 This License does not transmit any intellectual rights on the Software. The Software and any copies that the Licensee is authorised by the Licensor to make are the intellectual property of and are owned by the Licensor.
-
-2.2 The Software is protected by copyright, including without limitation by Copyright Law and international treaty provisions.
-
-2.3 Any copies that the Licensee is permitted to make pursuant to this Agreement must contain the same copyright and other proprietary notices that appear on or in the Software.
-
-2.4 The structure, organisation and code of the Software are the valuable trade secrets and confidential information of the Licensor. The Licensee agrees not to decompile, disassemble or otherwise attempt to discover the source code of the Software.
-
-2.5 Any attempts to reverse-engineer, copy, clone, modify or alter in any way the installer program without the Licensor's specific approval are strictly prohibited. The Licensee is not authorised to use any plug-in or enhancement that permits to save modifications to a file with software licensed and distributed by the Licensor.
-
-2.6 Trademarks shall be used in accordance with accepted trademark practice, including identification of trademarks owners' names. Trademarks can only be used to identify printed output produced by the Software and such use of any trademark does not give the Licensee any rights of ownership in that trademark.
-
-3. WARRANTY
-~~~~~~~~~~~
-3.1 The Licensor warrants that:
-
-  3.1.1 The Licensor owns the Software and documentation and/or is in possession of valid and existing licenses that support the terms of this Agreement;
-
-  3.1.2 the Software conforms to specifications and functionality as specified in Documentation;
-
-  3.1.3 to the best of the Licensor's knowledge, the Software does not infringe upon or violate any intellectual property right of any third party;
-
-  3.1.4 the Software does not contain any routine, intentionally designed by the Licensor to disable a computer program, or computer instructions that may alter, destroy or inhibit the processing environment.
-
-3.2 Except those warranties specified in section 3.1 above, the Software is being delivered to the Licensee "AS IS" and the Licensor makes no warranty as to its use or performance.
-
-The Licensor does not and cannot warrant the performance or results the Licensee may obtain by using the Software. The entire risk arising out of use or performance of the Software remains with the Licensee.
-
-The Licensor gives no warranty, express or implied, that:
-
-  (i) the Software will be of satisfactory quality, suitable for any particular purpose or for any particular use under specified conditions, notwithstanding that such purpose, use, or conditions may be known to the Licensor; or
-
-  (ii) that the Software will operate error free or without interruption or that any errors will be corrected.
-
-4. LIMITATION OF LIABILITY
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-In no event will the Licensor be liable for any damages, claims or costs whatsoever or any consequential, indirect, incidental damages, or any lost profits or lost savings, even if the Licensor has been advised of the possibility of such loss, damages, claims or costs or for any claim by any third party.
-
-In no event will the Licensee be liable to the Licensor on condition that the Licensee complies with all terms and conditions stated in this License.
-
-5. NON-WAIVER
-~~~~~~~~~~~~~
-If a portion of this agreement is held unenforceable, the remainder shall be valid. It means that if one section of the Agreement is not lawful, the rest of the Agreement is still in force. A party's failure to exercise any right under this Agreement will not constitute a waiver of (a) any other terms or conditions of this Agreement, or (b) a right at any time thereafter to require exact and strict compliance with the terms of this Agreement.

=== added file 'drs/__init__.py'
=== modified file 'drs/dr1010.py' (properties changed: -x to +x)
--- old/drs/dr1010.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr1010.py	2020-06-21 09:21:33 +0000
@@ -269,17 +269,17 @@
             self.new = False
             self.df.loadEntry("T", pag, p+1, data=self.old[3])
             d = 4
-            for pag in xrange(1, self.df.pgs+1):
-                for x in xrange(0, self.df.topq[pag]):
-                    if pag == 1 and x in (17, 19, 21):
-                        continue
-                    elif pag == 2 and x in (8, 10):
-                        continue
-                    elif pag == 2 and x == 11 and not self.old[d]:
+            for pg in xrange(1, self.df.pgs+1):
+                for x in xrange(0, self.df.topq[pg]):
+                    if pg == 1 and x in (17, 19, 21):
+                        continue
+                    if pg == 2 and x in (8, 10):
+                        continue
+                    if pg == 2 and x == 11 and not self.old[d]:
                         data = "N"
                     else:
                         data = self.old[d]
-                    self.df.loadEntry("T", pag, x, data=data)
+                    self.df.loadEntry("T", pg, x, data=data)
                     d += 1
             self.loadRep()
             self.loadAct()
@@ -338,11 +338,11 @@
                 "=", w)], limit=1)
             if not acc:
                 ok = askQuestion(self.opts["mf"].body, head="Delivery Address",
-                    mess="This Delivery Addres Does Not Exist, Would "\
+                    mess="This Delivery Address Does Not Exist, Would "\
                     "You Like to Create It Now?", default="no")
                 if ok == "no":
                     return "rf"
-                callModule(self.opts["mf"], self.df, "drc510",
+                callModule(self.opts["mf"], self.df, "drc410",
                     coy=(self.opts["conum"], self.opts["conam"]),
                     period=None, user=None, args=w)
                 acc = self.sql.getRec("drsdel", where=[("del_code",
@@ -415,7 +415,7 @@
             ("drm_chain", "=", self.chain), ("drm_acno", "=", self.acno)])
         self.sql.insRec("chglog", data=["drsmst", "D", "%03i%03i%-7s" % \
             (self.opts["conum"], self.chain, self.acno), "", dte,
-            self.opts["capnm"], "", "", 0])
+            self.opts["capnm"], "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -457,8 +457,10 @@
                 data.extend(["N", ""])
                 self.sql.insRec("drsmst", data=data)
             else:
-                data.append(self.old[self.sql.drsmst_col.index("drm_stat")])
-                if data != self.old[:len(data)]:
+                col = self.sql.drsmst_col
+                data.append(self.old[col.index("drm_stat")])
+                data.append(self.old[col.index("drm_xflag")])
+                if data != self.old:
                     self.sql.updRec("drsmst", data=data, where=[("drm_cono",
                         "=", self.opts["conum"]), ("drm_chain", "=",
                         self.chain), ("drm_acno", "=", self.acno)])
@@ -468,10 +470,9 @@
                         if dat != data[num]:
                             self.sql.insRec("chglog", data=["drsmst", "U",
                                 "%03i%03i%-7s" % (self.opts["conum"],
-                                self.chain, self.acno),
-                                self.sql.drsmst_col[num], dte,
+                                self.chain, self.acno), col[num], dte,
                                 self.opts["capnm"], str(dat),
-                                str(data[num]), 0])
+                                str(data[num]), "", 0])
             if "args" in self.opts:
                 self.doExit1()
             else:

=== modified file 'drs/dr1020.py' (properties changed: -x to +x)
--- old/drs/dr1020.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr1020.py	2020-04-23 09:43:36 +0000
@@ -275,6 +275,8 @@
             self.df.focusField("C", 0, self.nxt)
         else:
             if data != self.rcm[:len(data)]:
+                col = self.sql.drsrcm_col
+                data.append(self.rcm[col.index("dcm_xflag")])
                 self.sql.updRec("drsrcm", data=data, where=[("dcm_cono", "=",
                     self.opts["conum"]), ("dcm_num", "=", self.num)])
             self.doReload()
@@ -358,6 +360,8 @@
         if self.new_seq == "y":
             self.sql.insRec("drsrct", data=data)
         elif data != self.rct[:len(data)]:
+            col = self.sql.drsrct_col
+            data.append(self.rct[col.index("dct_xflag")])
             self.sql.updRec("drsrct", data=data, where=[("dct_cono", "=",
                 self.opts["conum"]), ("dct_num", "=", self.num), ("dct_seq",
                 "=", self.seq)])

=== modified file 'drs/dr2010.py' (properties changed: -x to +x)
--- old/drs/dr2010.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr2010.py	2020-04-26 09:52:39 +0000
@@ -187,8 +187,10 @@
             fld[4][2] = 20
             fld.extend([
                 [["C",1,0,6],"ISD",13.2,"Discount",
-                    "Discount Amount","","N",self.doDisAmt,None,None,None],
-                [["C",1,0,7],"INA",(20,30),"Details","Transaction Details",
+                    "Discount Amount","","N",self.doDisAmt,None,None,None,None,
+                    "Discout Amount to be Added to the Transaction Amount"],
+                [["C",1,0,7],"OSD",13.2,"Total-Amount"],
+                [["C",1,0,8],"INA",(20,30),"Details","Transaction Details",
                     "","N",self.doTrnDet,None,None,None]])
         elif self.glint == "Y":
             if self.glinp == "E":
@@ -332,6 +334,8 @@
         else:
             self.disamt = w
         self.df.loadEntry(frt, pag, p, data=self.disamt)
+        totamt = float(ASD(self.trnamt) + ASD(self.disamt))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doTrnDet(self, frt, pag, r, c, p, i, w):
         self.trndet = w

=== modified file 'drs/dr2020.py' (properties changed: -x to +x)
--- old/drs/dr2020.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr2020.py	2020-06-21 09:23:19 +0000
@@ -170,7 +170,9 @@
             (("C",2,0,4),"ISD",13.2,"Receipt","Receipt Amount",
                 "","N",self.doAllAmt,None,None,("efld",)),
             (("C",2,0,5),"ISD",13.2,"Discount","Discount Amount",
-                "","N",self.doDisAmt,None,None,("efld",))]
+                "","N",self.doDisAmt,None,None,("efld",),None,
+                "Discount Amount to be Added to the Receipt Amount"),
+            (("C",2,0,6),"OSD",13.2,"Total-Amount")]
         if self.glint == "Y" and self.incoac:
             fld[7][1] = "IUI"
         if self.chains == "N":
@@ -213,13 +215,13 @@
 
     def doRef1(self, frt, pag, r, c, p, i, w):
         if not w:
-            a = self.sql.getRec("drstrn", cols=["drt_ref1"],
+            trns = self.sql.getRec("drstrn", cols=["drt_ref1"],
                 where=[("drt_cono", "=", self.opts["conum"]), ("drt_ref1",
                 "like", "R________")], order="drt_ref1 desc")
             auto = False
-            for r in a:
+            for trn in trns:
                 try:
-                    w = "R%08i" % (int(r[0][1:]) + 1)
+                    w = "R%08i" % (int(trn[0][1:]) + 1)
                     auto = True
                     break
                 except:
@@ -357,6 +359,8 @@
         if ok != "yes":
             return "Invalid Discount Amount (Sign Error)"
         self.disamt = w
+        totamt = float(ASD(self.allamt) + ASD(self.disamt))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def checkSign(self):
         return askQuestion(self.opts["mf"].body, "Check Sign",

=== modified file 'drs/dr2030.py' (properties changed: -x to +x)
--- old/drs/dr2030.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr2030.py	2020-05-27 11:58:27 +0000
@@ -364,8 +364,7 @@
         else:
             key = "%s_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-             ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Invoice" % self.opts["conam"], repprt=self.df.repprt,

=== modified file 'drs/dr3010.py' (properties changed: -x to +x)
--- old/drs/dr3010.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3010.py	2020-05-27 12:26:39 +0000
@@ -169,8 +169,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'drs/dr3020.py' (properties changed: -x to +x)
--- old/drs/dr3020.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3020.py	2020-06-21 09:25:33 +0000
@@ -353,8 +353,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -501,7 +500,7 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(drtrtp)):
+        for x, t in enumerate(drtrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             dr = CCD(self.gdr[x], "SD", 13.2)
             cr = CCD(self.gcr[x], "SD", 13.2)
@@ -510,10 +509,10 @@
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-27s %s %s %s %s %s" % \
-                (drtrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-34s %s %s %s %s %s" % \
-                (drtrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))
             tot[2] = float(ASD(tot[2]) + ASD(cr.work))

=== modified file 'drs/dr3030.py' (properties changed: -x to +x)
--- old/drs/dr3030.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3030.py	2020-06-20 11:26:52 +0000
@@ -105,31 +105,31 @@
         self.gtots = [0,0,0]
         self.pgnum = 0
         self.pglin = 999
-        for num, rec in enumerate(mst):
-            p.displayProgress(num)
+        for seq, rec in enumerate(mst):
+            p.displayProgress(seq)
             if p.quit:
                 break
             chn = CCD(rec[0], "UI", 3)
             acno = CCD(rec[1], "NA", 7)
             name = CCD(rec[2], "NA", 30)
-            col, recs = getTrn(self.opts["mf"].dbm, "drs", whr=[("drt_cono",
+            col, trns = getTrn(self.opts["mf"].dbm, "drs", whr=[("drt_cono",
                 "=", self.opts["conum"]), ("drt_chain", "=", chn.work),
                 ("drt_acno", "=", acno.work), ("drt_trdt", "<=", self.pdatw)],
                 neg=False, zer="N")
-            if not recs:
+            if not trns:
                 continue
             if not self.pgnum:
                 self.pageHeading(chn.disp, acno.disp, name.disp)
             else:
                 self.newAccount(chn.disp, acno.disp, name.disp)
-            for rec in recs:
-                ref1 = CCD(rec[col.index("drt_ref1")], "Na", 9)
-                ref2 = CCD(rec[col.index("drt_ref2")], "Na", 9)
-                trtp = CCD(rec[col.index("drt_type")], "UI", 1)
-                trdt = CCD(rec[col.index("drt_trdt")], "d1", 10)
-                tramt = CCD(rec[col.index("drt_tramt")], "SD", 13.2)
-                paid = CCD(rec[col.index("paid")], "SD", 13.2)
-                trbal = CCD(rec[col.index("balance")], "SD", 13.2)
+            for trn in trns:
+                ref1 = CCD(trn[col.index("drt_ref1")], "Na", 9)
+                ref2 = CCD(trn[col.index("drt_ref2")], "Na", 9)
+                trtp = CCD(trn[col.index("drt_type")], "UI", 1)
+                trdt = CCD(trn[col.index("drt_trdt")], "d1", 10)
+                tramt = CCD(trn[col.index("drt_tramt")], "SD", 13.2)
+                paid = CCD(trn[col.index("paid")], "SD", 13.2)
+                trbal = CCD(trn[col.index("balance")], "SD", 13.2)
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading(chn.disp, acno.disp, name.disp)
                 self.fpdf.drawText("%s %s %s %s %s %s %s" % (ref1.disp,
@@ -149,8 +149,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'drs/dr3040.py' (properties changed: -x to +x)
--- old/drs/dr3040.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3040.py	2020-06-20 10:44:55 +0000
@@ -119,27 +119,27 @@
             chn = CCD(rec[0], "UI", 3)
             acno = CCD(rec[1], "NA", 7)
             name = CCD(rec[2], "NA", 30)
-            col, recs = getTrn(self.opts["mf"].dbm, "drs", dte=self.curdt,
+            col, trns = getTrn(self.opts["mf"].dbm, "drs", dte=self.curdt,
                 whr=[("drt_cono", "=", self.opts["conum"]), ("drt_chain", "=",
                 chn.work), ("drt_acno", "=", acno.work)], zer="N")
-            if not recs:
+            if not trns:
                 continue
             if not self.pgnum:
                 self.pageHeading(chn.disp, acno.disp, name.disp)
             else:
                 self.newAccount(chn.disp, acno.disp, name.disp)
-            for rec in recs:
-                ref1 = CCD(rec[col.index("drt_ref1")], "Na", 9)
-                ref2 = CCD(rec[col.index("drt_ref2")], "Na", 9)
-                trtp = CCD(rec[col.index("drt_type")], "UI", 2)
-                trdt = CCD(rec[col.index("drt_trdt")], "d1", 10)
-                if rec[col.index("drt_desc")] == name.work:
+            for trn in trns:
+                ref1 = CCD(trn[col.index("drt_ref1")], "Na", 9)
+                ref2 = CCD(trn[col.index("drt_ref2")], "Na", 9)
+                trtp = CCD(trn[col.index("drt_type")], "UI", 2)
+                trdt = CCD(trn[col.index("drt_trdt")], "d1", 10)
+                if trn[col.index("drt_desc")] == name.work:
                     desc = CCD("", "NA", 30)
                 else:
-                    desc = CCD(rec[col.index("drt_desc")], "NA", 30)
-                tramt = CCD(rec[col.index("drt_tramt")], "SD", 13.2)
-                paid = CCD(rec[col.index("paid")], "SD", 13.2)
-                trbal = CCD(rec[col.index("balance")], "SD", 13.2)
+                    desc = CCD(trn[col.index("drt_desc")], "NA", 30)
+                tramt = CCD(trn[col.index("drt_tramt")], "SD", 13.2)
+                paid = CCD(trn[col.index("paid")], "SD", 13.2)
+                trbal = CCD(trn[col.index("balance")], "SD", 13.2)
                 if self.pglin > self.fpdf.lpp:
                     self.pageHeading(chn.disp, acno.disp, name.disp)
                 self.fpdf.drawText("%s %s %s %s %s %s %s %s" % (ref1.disp,
@@ -163,8 +163,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'drs/dr3050.py' (properties changed: -x to +x)
--- old/drs/dr3050.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3050.py	2020-05-27 12:27:08 +0000
@@ -202,8 +202,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Debtor's Age Analaysis up to %s" %
             self.opts["period"])
@@ -247,8 +246,7 @@
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999

=== modified file 'drs/dr3060.py' (properties changed: -x to +x)
--- old/drs/dr3060.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3060.py	2020-09-22 10:58:10 +0000
@@ -26,7 +26,7 @@
 
 import time
 from TartanClasses import CCD, GetCtl, MyFpdf, ProgressBar, Sql, TartanDialog
-from tartanFunctions import getModName, doPrinter, showError
+from tartanFunctions import doWriteExport, doPrinter, getModName, showError
 
 class dr3060(object):
     def __init__(self, **opts):
@@ -50,6 +50,13 @@
         self.sysdtd = "%i/%02i/%02i" % (t[0], t[1], t[2])
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i)" % \
             (t[0], t[1], t[2], t[3], t[4])
+        self.colsh = ["Chn", "Acc-Num", "Name", "Address", "Code", "Tel-Number",
+            "Fax-Number", "Contact Details", "Deliver", "Rep", "Act", "Typ",
+            "P", "Rft", "C-Limit"]
+        self.forms = [("UI", 3), ("NA", 7), ("NA", 30), ("NA", 30),
+            ("NA", 4), ("NA", 12), ("NA", 12), ("NA", 40), ("Na", 7),
+            ("Na", 3), ("UA", 3), ("UA", 3), ("UI", 1), ("UI", 3),
+            ("UI", 3), ("UI", 7)]
         return True
 
     def mainProcess(self):
@@ -97,7 +104,7 @@
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
-            tend=tnd, txit=txt, view=("N","V"), mail=("Y","N"))
+            tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
 
     def doAct(self, frt, pag, r, c, p, i, w):
         self.act = w
@@ -152,10 +159,38 @@
         if not recs:
             showError(self.opts["mf"].body, "Selection Error",
             "No Records Selected")
+        elif self.df.repprt[2] == "export":
+            self.exportReport(recs)
         else:
             self.printReport(recs)
         self.closeProcess()
 
+    def exportReport(self, recs):
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
+            self.__class__.__name__, self.opts["conum"])
+        expheads = ["%03u %-30s %s %6s" % (self.opts["conum"],
+            self.opts["conam"], self.sysdttm, self.__class__.__name__)]
+        expheads.append("Debtors Master Code List as at %s" % self.sysdtd)
+        expcolsh = [self.colsh]
+        expforms = self.forms
+        expdatas = []
+        for num, dat in enumerate(recs):
+            p.displayProgress(num)
+            if p.quit:
+                p.closeProgress()
+                return
+            vals = self.getValues(dat)
+            expdatas.append(["BODY", [vals[0].work, vals[1].work,
+                vals[2].work, vals[3].work, vals[4].work, vals[5].work,
+                vals[6].work, vals[7].work, vals[8].work, vals[9].work,
+                vals[10].work, vals[11].work, vals[12].work, vals[13].work,
+                vals[14].work, vals[15].work]])
+        p.closeProgress()
+        doWriteExport(xtype=self.df.repprt[1], name=expnam,
+            heads=expheads, colsh=expcolsh, forms=expforms,
+            datas=expdatas, rcdic=self.opts["mf"].rcdic)
+
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         self.head = ("%03u %-30s %141s %6s" % \
@@ -164,62 +199,67 @@
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
-        col = self.sql.drsmst_col
         for num, dat in enumerate(recs):
             p.displayProgress(num)
             if p.quit:
                 break
-            chn = CCD(dat[col.index("drm_chain")], "UI", 3)
-            acno = CCD(dat[col.index("drm_acno")], "NA", 7)
-            name = CCD(dat[col.index("drm_name")], "NA", 30)
-            add1 = CCD(dat[col.index("drm_add1")], "NA", 30)
-            add2 = CCD(dat[col.index("drm_add2")], "NA", 30)
-            add3 = CCD(dat[col.index("drm_add3")], "NA", 30)
-            pcod = CCD(dat[col.index("drm_pcod")], "NA", 4)
-            tel = CCD(dat[col.index("drm_tel")], "NA", 12)
-            fax = CCD(dat[col.index("drm_fax")], "NA", 12)
-            if self.condet == "M":
-                contact = dat[col.index("drm_mgr")]
-                email = dat[col.index("drm_mgr_email")].split(",")
-            elif self.condet == "A":
-                contact = dat[col.index("drm_acc")]
-                email = dat[col.index("drm_acc_email")].split(",")
-            else:
-                contact = dat[col.index("drm_sls")]
-                email = dat[col.index("drm_sls_email")].split(",")
-            nameml = CCD("%s <%s>" % (contact, email[0]), "NA", 40)
-            delv = CCD(dat[col.index("drm_delivery")], "Na", 7)
-            rep = CCD(dat[col.index("drm_rep")], "Na", 3)
-            bact = CCD(dat[col.index("drm_bus_activity")], "UA", 3)
-            btyp = CCD(dat[col.index("drm_bus_type")], "UA", 3)
-            prices = CCD(dat[col.index("drm_plev")], "UI", 1)
-            rfterm = CCD(dat[col.index("drm_rfterms")], "UI", 3)
-            rjterm = CCD(dat[col.index("drm_rjterms")], "UI", 3)
-            limit = CCD(dat[col.index("drm_limit")], "UI", 7)
+            vals = self.getValues(dat)
             if self.pglin > self.fpdf.lpp:
                 self.pageHeading()
             self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s %s %s "\
-                "%s %s %s %s" % (chn.disp, acno.disp, name.disp,
-                add1.disp, pcod.disp, tel.disp, fax.disp, nameml.disp,
-                delv.disp, rep.disp, bact.disp, btyp.disp, prices.disp,
-                rfterm.disp, rjterm.disp, limit.disp))
-            if self.address == "Y" and add2.work:
-                self.fpdf.drawText("%42s %-30s" % ("", add2.disp))
+                "%s %s %s %s" % (vals[0].disp, vals[1].disp, vals[2].disp,
+                vals[3].disp, vals[4].disp, vals[5].disp, vals[6].disp,
+                vals[7].disp, vals[8].disp, vals[9].disp, vals[10].disp,
+                vals[11].disp, vals[12].disp, vals[13].disp, vals[14].disp,
+                vals[15].disp))
+            if self.address == "Y" and vals[16].work:
+                self.fpdf.drawText("%42s %-30s" % ("", vals[16].disp))
                 self.pglin += 1
-            if self.address == "Y" and add3.work:
-                self.fpdf.drawText("%42s %-30s" % ("", add3.disp))
+            if self.address == "Y" and vals[17].work:
+                self.fpdf.drawText("%42s %-30s" % ("", vals[17].disp))
                 self.pglin += 1
             self.pglin += 1
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
                 fromad=self.fromad, repeml=self.df.repeml)
 
+    def getValues(self, dat):
+        col = self.sql.drsmst_col
+        chn = CCD(dat[col.index("drm_chain")], "UI", 3)
+        acno = CCD(dat[col.index("drm_acno")], "NA", 7)
+        name = CCD(dat[col.index("drm_name")], "NA", 30)
+        add1 = CCD(dat[col.index("drm_add1")], "NA", 30)
+        pcod = CCD(dat[col.index("drm_pcod")], "NA", 4)
+        tel = CCD(dat[col.index("drm_tel")], "NA", 12)
+        fax = CCD(dat[col.index("drm_fax")], "NA", 12)
+        if self.condet == "M":
+            contact = dat[col.index("drm_mgr")]
+            email = dat[col.index("drm_mgr_email")].split(",")
+        elif self.condet == "A":
+            contact = dat[col.index("drm_acc")]
+            email = dat[col.index("drm_acc_email")].split(",")
+        else:
+            contact = dat[col.index("drm_sls")]
+            email = dat[col.index("drm_sls_email")].split(",")
+        nameml = CCD("%s <%s>" % (contact, email[0]), "NA", 40)
+        delv = CCD(dat[col.index("drm_delivery")], "Na", 7)
+        rep = CCD(dat[col.index("drm_rep")], "Na", 3)
+        bact = CCD(dat[col.index("drm_bus_activity")], "UA", 3)
+        btyp = CCD(dat[col.index("drm_bus_type")], "UA", 3)
+        prices = CCD(dat[col.index("drm_plev")], "UI", 1)
+        rfterm = CCD(dat[col.index("drm_rfterms")], "UI", 3)
+        rjterm = CCD(dat[col.index("drm_rjterms")], "UI", 3)
+        limit = CCD(dat[col.index("drm_limit")], "UI", 7)
+        add2 = CCD(dat[col.index("drm_add2")], "NA", 30)
+        add3 = CCD(dat[col.index("drm_add3")], "NA", 30)
+        return (chn, acno, name, add1, pcod, tel, fax, nameml, delv, rep,
+            bact, btyp, prices, rfterm, rjterm, limit, add2, add3)
+
     def pageHeading(self):
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")

=== modified file 'drs/dr3080.py' (properties changed: -x to +x)
--- old/drs/dr3080.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3080.py	2020-05-27 11:58:34 +0000
@@ -419,8 +419,7 @@
         else:
             key = "%s_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-            ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement for %s as at %s" % (self.opts["conam"],

=== modified file 'drs/dr3090.py' (properties changed: -x to +x)
--- old/drs/dr3090.py	2020-03-01 12:48:20 +0000
+++ new/drs/dr3090.py	2020-05-27 12:27:20 +0000
@@ -127,8 +127,7 @@
             p.closeProgress()
             if self.fpdf.page and not p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)

=== modified file 'drs/dr3100.py' (properties changed: -x to +x)
=== modified file 'drs/dr3110.py' (properties changed: -x to +x)
--- old/drs/dr3110.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3110.py	2020-06-21 09:26:03 +0000
@@ -147,8 +147,7 @@
     def exportReport(self, acs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(acs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Debtor's Sales History for the 12 Months "\
             "Period to %s" % self.coffd)
@@ -183,9 +182,9 @@
         for n, f in enumerate(self.forms):
             if self.rep == "Y" and n == 3:
                 continue
-            elif self.act == "Y" and n == 4:
+            if self.act == "Y" and n == 4:
                 continue
-            elif self.typ == "Y" and n == 5:
+            if self.typ == "Y" and n == 5:
                 continue
             chrs += int(f[1])
         if f[0][0].lower() == "s":
@@ -199,8 +198,7 @@
         pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999

=== modified file 'drs/dr3120.py' (properties changed: -x to +x)
--- old/drs/dr3120.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr3120.py	2020-05-27 12:27:38 +0000
@@ -147,8 +147,7 @@
         if self.fpdf.page and not p.quit:
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'drs/dr4010.py' (properties changed: -x to +x)
--- old/drs/dr4010.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr4010.py	2020-06-21 09:26:46 +0000
@@ -212,17 +212,17 @@
         self.name = acc[self.sql.drsmst_col.index("drm_name")]
         self.df.loadEntry("T",pag,p+1,data=acc[3])
         d = 3
-        for pag in xrange(1, 3):
-            for x in xrange(0, self.df.topq[pag]):
-                if pag == 1 and x in (18, 20, 22, 24):
-                    continue
-                elif pag == 2 and x in (8, 10):
-                    continue
-                elif pag == 2 and x == 11 and not acc[d]:
+        for pg in xrange(1, 3):
+            for x in xrange(0, self.df.topq[pg]):
+                if pg == 1 and x in (18, 20, 22, 24):
+                    continue
+                if pg == 2 and x in (8, 10):
+                    continue
+                if pg == 2 and x == 11 and not acc[d]:
                     data = "N"
                 else:
                     data = acc[d]
-                self.df.loadEntry("T", pag, x, data=data)
+                self.df.loadEntry("T", pg, x, data=data)
                 d = d + 1
         self.loadRep()
         self.loadAct()
@@ -516,9 +516,9 @@
                 ("drm_cono", "=", self.opts["conum"]),
                 ("drm_chain", "=", self.chain),
                 ("drm_acno", "=", self.acno)]
-            rp = TabPrt(self.opts["mf"], self.opts["conum"],
-                self.opts["conam"], name=self.__class__.__name__, tabs=tab,
-                where=whr, keys=[self.chain, self.acno])
+            rp = TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
+                name=self.__class__.__name__, tabs=tab, where=whr,
+                keys=[self.chain, self.acno])
             repprt = rp.repprt
             repeml = rp.repeml
             xits = rp.xits

=== modified file 'drs/dr6010.py' (properties changed: -x to +x)
--- old/drs/dr6010.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr6010.py	2020-06-21 09:29:17 +0000
@@ -85,15 +85,15 @@
         else:
             del drm["cols"][0]
         fld = [
-            (("T",0,0,0),"I@drm_chain",0,"Old Chain","Old Chain Number",
-                "","Y",self.doOldChn,chn,None,("efld",)),
-            (["T",0,0,12],"IRW",7,"Old Account","Old Account Number",
-                "","Y",self.doOldAcc,drm,None,("notblank",)),
-            (["T",0,0,30],"O@drm_name",0,""),
-            (("T",0,1,0),"I@drm_chain",0,"New Chain","New Chain Number",
-                "","Y",self.doNewChn,chn,None,("efld",)),
-            (["T",0,1,12],"I@drm_acno",0,"New Account","New Account Number",
-                "","Y",self.doNewAcc,None,None,("notblank",))]
+            [["T",0,0,0],"I@drm_chain",0,"Old Chain","Old Chain Number",
+                "","Y",self.doOldChn,chn,None,("efld",)],
+            [["T",0,0,12],"IRW",7,"Old Account","Old Account Number",
+                "","Y",self.doOldAcc,drm,None,("notblank",)],
+            [["T",0,0,30],"O@drm_name",0,""],
+            [["T",0,1,0],"I@drm_chain",0,"New Chain","New Chain Number",
+                "","Y",self.doNewChn,chn,None,("efld",)],
+            [["T",0,1,12],"I@drm_acno",0,"New Account","New Account Number",
+                "","Y",self.doNewAcc,None,None,("notblank",)]]
         if self.chains == "N":
             self.oldchn = self.newchn = 0
             del fld[0]

=== modified file 'drs/dr6020.py' (properties changed: -x to +x)
--- old/drs/dr6020.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr6020.py	2020-05-19 07:49:42 +0000
@@ -25,9 +25,8 @@
 """
 
 import time
-from TartanClasses import AgeTrans, ASD, GetCtl, ProgressBar, Sql
-from TartanClasses import TartanDialog, tk
-from tartanFunctions import copyList, getTrn
+from TartanClasses import AgeTrans, GetCtl, ProgressBar, Sql, TartanDialog, tk
+from tartanFunctions import copyList, doAutoAge, getTrn
 
 class dr6020(object):
     def __init__(self, **opts):
@@ -206,61 +205,17 @@
                 wid = getattr(self.df, "B%s" % b)
                 self.df.setWidget(wid, "disabled")
             self.opts["mf"].updateStatus("Re-Ageing .... Please Wait!")
-        self.sql.delRec("drsage", where=[("dra_cono", "=", self.opts["conum"]),
-            ("dra_chain", "=", self.chain), ("dra_acno", "=", self.acno)])
-        crc, cr = getTrn(self.opts["mf"].dbm, "drs", whr=[("drt_cono", "=",
-            self.opts["conum"]), ("drt_chain", "=", self.chain), ("drt_acno",
-            "=", self.acno), ("drt_tramt", "<", 0)], odr="drt_trdt", zer="N")
-        if cr:
-            drc, dr = getTrn(self.opts["mf"].dbm, "drs", whr=[("drt_cono",
-                "=", self.opts["conum"]), ("drt_chain", "=", self.chain),
-                ("drt_acno", "=", self.acno), ("drt_tramt", ">", 0)],
-                odr="drt_trdt", neg=False, zer="N")
-            if dr:
-                if "args" not in self.opts:
-                    self.df.setWidget(self.df.mstFrame, state="hide")
-                    txt = "Re-Allocating ... Please Wait"
-                    pb = ProgressBar(self.opts["mf"].body, typ=txt, mxs=len(cr))
-                for cno, ctr in enumerate(cr):
-                    if "args" not in self.opts:
-                        pb.displayProgress(cno)
-                    ccdt = ctr[crc.index("drt_curdt")]
-                    cbal = ctr[crc.index("balance")]
-                    camt = cbal
-                    for dno, dtr in enumerate(dr):
-                        dbal = dtr[drc.index("balance")]
-                        if not dbal:
-                            continue
-                        damt = float(ASD(dbal) + ASD(camt))
-                        if damt < 0:
-                            camt = damt
-                            damt = 0.00
-                        else:
-                            camt = 0.00
-                        diff = float(ASD(dbal) - ASD(damt))
-                        dr[dno][drc.index("balance")] = damt
-                        if diff:
-                            self.sql.insRec("drsage", data=[self.opts["conum"],
-                                self.chain, self.acno,
-                                dtr[drc.index("drt_type")],
-                                dtr[drc.index("drt_ref1")], ccdt,
-                                ctr[drc.index("drt_type")],
-                                ctr[drc.index("drt_ref1")], diff, 0])
-                        if not camt:
-                            break
-                    diff = float(ASD(cbal) - ASD(camt))
-                    if diff:
-                        self.sql.insRec("drsage", data=[self.opts["conum"],
-                            self.chain, self.acno,
-                            ctr[drc.index("drt_type")],
-                            ctr[drc.index("drt_ref1")], ccdt,
-                            ctr[drc.index("drt_type")],
-                            ctr[drc.index("drt_ref1")], diff, 0])
-                if "args" not in self.opts:
-                    pb.closeProgress()
-                    self.df.setWidget(self.df.mstFrame, state="show")
-        if "args" not in self.opts:
+            self.df.setWidget(self.df.mstFrame, state="hide")
+            txt = "Re-Allocating ... Please Wait"
+            pb = ProgressBar(self.opts["mf"].body, typ=("G", txt))
+            doAutoAge(self.opts["mf"].dbm, "drs", self.opts["conum"],
+                chain=self.chain, acno=self.acno, pbar=pb)
+            pb.closeProgress()
+            self.df.setWidget(self.df.mstFrame, state="show")
             self.agevar.set(False)
+        else:
+            doAutoAge(self.opts["mf"].dbm, "drs", self.opts["conum"],
+                chain=self.chain, acno=self.acno, pbar=None)
 
     def endTop(self):
         self.df.clearEntry("T", 0, 2)

=== modified file 'drs/dr6030.py' (properties changed: -x to +x)
--- old/drs/dr6030.py	2020-04-21 08:42:36 +0000
+++ new/drs/dr6030.py	2020-08-04 12:21:35 +0000
@@ -37,8 +37,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["drsmst", "drstrn", "chglog"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["drschn", "drsmst", "drstrn",
+            "chglog"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -152,8 +152,8 @@
                     where=[("drm_cono", "=", self.opts["conum"]),
                     ("drm_chain", "=", rec[0]), ("drm_acno", "=", rec[1])])
                 key = "%03i%03i%-7s" % (self.opts["conum"], rec[0], rec[1])
-                self.sql.insRec("chglog", data=["drsmst", "U", key, "drm_stat",
-                dte, self.opts["capnm"], "N", "X", 0])
+                self.sql.insRec("chglog", data=["drsmst", "U", key,
+                    "drm_stat", dte, self.opts["capnm"], "N", "X", "", 0])
             p.closeProgress()
             mess = """%s Accounts Will be Flagged as Redundant.
 
@@ -203,16 +203,23 @@
             if bal[0]:
                 return "Balance Exists"
         self.acno = w
-        self.df.loadEntry(frt, pag, p+1, data=chk[4])
+        name = chk[self.sql.drsmst_col.index("drm_name")]
+        self.df.loadEntry(frt, pag, p+1, data=name)
 
     def endPage(self):
         if self.flag == "C":
-            typ = "X"
+            old = "N"
+            new = "X"
         else:
-            typ = "N"
-        self.sql.updRec("drsmst", cols=["drm_stat"], data=[typ],
+            old = "X"
+            new = "N"
+        self.sql.updRec("drsmst", cols=["drm_stat"], data=[new],
             where=[("drm_cono", "=", self.opts["conum"]),
             ("drm_chain", "=", self.chain), ("drm_acno", "=", self.acno)])
+        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        key = "%03i%03i%-7s" % (self.opts["conum"], self.chain, self.acno)
+        self.sql.insRec("chglog", data=["drsmst", "U", key, "drm_stat",
+            dte, self.opts["capnm"], old, new, 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.clearFrame("T", 0)
         self.flag = ""

=== modified file 'drs/dr6040.py' (properties changed: -x to +x)
=== modified file 'drs/drc110.py' (properties changed: -x to +x)
--- old/drs/drc110.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc110.py	2020-04-29 16:00:33 +0000
@@ -115,9 +115,11 @@
             (("T",0,seq + 1,0),"INA",20,"Statement Template","",
                 self.acc[4],"N",self.doTplNam,tpm,None,None),
             (("T",0,seq + 2,0),("IRB",r1s),0,"Statement Ageing","",
-                self.acc[5],"N",None,None,None,None),
+                self.acc[5],"N",None,None,None,None,None,"Select whether "\
+                "to print Aged Balances at the End of the Statement "\
+                "or only a Total Balance."),
             (("T",0,seq + 3,0),"ITX",50,"Email Address","",
-                self.acc[6],"N",None,None,None,None)])
+                self.acc[6],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -195,14 +197,17 @@
         if self.new:
             self.sql.insRec("drsctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.drsctl_col
+            data.append(self.acc[col.index("ctd_xflag")])
             self.sql.updRec("drsctl", data=data, where=[("ctd_cono", "=",
                 self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["drsctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.drsctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'drs/drc210.py' (properties changed: -x to +x)
--- old/drs/drc210.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc210.py	2020-04-23 09:45:14 +0000
@@ -141,6 +141,8 @@
         if self.new == "Y":
             self.sql.insRec("drschn", data=dat)
         elif dat != self.acc[:len(dat)]:
+            col = self.sql.drschn_col
+            dat.append(self.acc[col.index("chm_xflag")])
             self.sql.updRec("drschn", data=dat, where=[("chm_cono", "=",
             self.opts["conum"]), ("chm_chain", "=", self.chain)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'drs/drc220.py' (properties changed: -x to +x)
--- old/drs/drc220.py	2020-03-01 12:48:20 +0000
+++ new/drs/drc220.py	2020-05-27 12:00:17 +0000
@@ -73,9 +73,9 @@
             if col == "chm_email":
                 dat[2] = 30
             cols.append(dat)
-        RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=["drschn"],
-            heads=heads,
-            cols=cols, where=[("chm_cono", "=", self.opts["conum"])],
+        RepPrt(self.opts["mf"], name=self.__class__.__name__,
+            tables=["drschn"], heads=heads, cols=cols,
+            where=[("chm_cono", "=", self.opts["conum"])],
             conum=self.opts["conum"], conam=self.opts["conam"],
             repprt=self.df.repprt, repeml=self.df.repeml, fromad=self.fromad)
         self.opts["mf"].closeLoop()

=== modified file 'drs/drc310.py' (properties changed: -x to +x)
--- old/drs/drc310.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc310.py	2020-04-23 12:48:32 +0000
@@ -64,15 +64,14 @@
 
     def doRep(self, frt, pag, r, c, p, i, w):
         self.rep = w
-        self.acc = self.sql.getRec("ctlrep", cols=["rep_name"],
-            where=[("rep_cono", "=", self.opts["conum"]), ("rep_code", "=", w)],
-            limit=1)
+        self.acc = self.sql.getRec("ctlrep", where=[("rep_cono",
+            "=", self.opts["conum"]), ("rep_code", "=", w)], limit=1)
         if not self.acc:
             self.new = "Y"
         else:
             self.new = "N"
-            for x in xrange(1, self.df.topq[pag]):
-                self.df.loadEntry(frt, pag, p+x, data=self.acc[x-1])
+            name = self.acc[self.sql.ctlrep_col.index("rep_name")]
+            self.df.loadEntry(frt, pag, p+1, data=name)
 
     def doDelete(self):
         self.sql.delRec("ctlrep", where=[("rep_cono", "=", self.opts["conum"]),
@@ -87,6 +86,8 @@
         if self.new == "Y":
             self.sql.insRec("ctlrep", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.ctlrep_col
+            data.append(self.acc[col.index("rep_xflag")])
             self.sql.updRec("ctlrep", data=data, where=[("rep_cono", "=",
             self.opts["conum"]), ("rep_code", "=", self.rep)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'drs/drc320.py' (properties changed: -x to +x)
=== modified file 'drs/drc410.py' (properties changed: -x to +x)
--- old/drs/drc410.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc410.py	2020-04-25 07:48:57 +0000
@@ -31,7 +31,10 @@
         self.opts = opts
         if self.setVariables():
             self.mainProcess()
-            self.opts["mf"].startLoop()
+            if "wait" in self.opts:
+                self.df.mstFrame.wait_window()
+            else:
+                self.opts["mf"].startLoop()
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, "drsdel",
@@ -93,6 +96,8 @@
         if self.new == "Y":
             self.sql.insRec("drsdel", data=dat)
         elif dat != self.acc[:len(dat)]:
+            col = self.sql.drsdel_col
+            dat.append(self.acc[col.index("del_xflag")])
             self.sql.updRec("drsdel", data=dat, where=[("del_code",
                 "=", self.code)])
         if "args" in self.opts:
@@ -114,6 +119,7 @@
 
     def doExit(self):
         self.df.closeProcess()
-        self.opts["mf"].closeLoop()
+        if "wait" not in self.opts:
+            self.opts["mf"].closeLoop()
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'drs/drc420.py' (properties changed: -x to +x)
--- old/drs/drc420.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc420.py	2020-06-21 09:30:39 +0000
@@ -63,17 +63,17 @@
     def printReport(self, recs):
         self.df.closeProcess()
         tables = []
-        for x in xrange(0, len(recs)):
+        for rec in recs:
             lin = []
-            lin.append(recs[x][0])
-            lin.append(recs[x][1])
-            lin.append(recs[x][2])
+            lin.append(rec[0])
+            lin.append(rec[1])
+            lin.append(rec[2])
             tables.append(lin)
             lin = []
-            if recs[x][3] or recs[x][4]:
+            if rec[3] or rec[4]:
                 lin.append("")
-                lin.append(recs[x][3])
-                lin.append(recs[x][4])
+                lin.append(rec[3])
+                lin.append(rec[4])
                 tables.append(lin)
             lin = []
             for _ in xrange(0, 3):
@@ -84,8 +84,7 @@
                 ["b","NA",30.0,"Address-Line"],
                 ["c","NA",30.0,"Address-Line"]]
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=cols, conum=self.opts["conum"], ttype="D",
+            heads=heads, cols=cols, conum=self.opts["conum"], ttype="D",
             conam=self.opts["conam"], repprt=self.df.repprt,
             repeml=self.df.repeml, fromad=self.fromad)
         self.opts["mf"].closeLoop()

=== modified file 'drs/drc510.py' (properties changed: -x to +x)
--- old/drs/drc510.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc510.py	2020-04-23 09:47:43 +0000
@@ -115,6 +115,8 @@
             if self.new == "Y":
                 self.sql.insRec("ctlmes", data=data)
             elif data != self.acc[:len(data)]:
+                col = self.sql.ctlmes_col
+                data.append(self.acc[col.index("mss_xflag")])
                 self.sql.updRec("ctlmes", data=data, where=[("mss_system",
                     "=", self.system), ("mss_message", "=", self.message)])
             self.opts["mf"].dbm.commitDbase()

=== modified file 'drs/drc520.py' (properties changed: -x to +x)
=== modified file 'drs/drc610.py' (properties changed: -x to +x)
--- old/drs/drc610.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc610.py	2020-04-23 12:43:18 +0000
@@ -63,14 +63,14 @@
 
     def doAct(self, frt, pag, r, c, p, i, w):
         self.code = w
-        self.acc = self.sql.getRec("drsact", cols=["dac_desc"],
-            where=[("dac_code", "=", self.code)], limit=1)
+        self.acc = self.sql.getRec("drsact", where=[("dac_code",
+            "=", self.code)], limit=1)
         if not self.acc:
             self.new = "Y"
         else:
             self.new = "N"
-            for x in xrange(1, self.df.topq[pag]):
-                self.df.loadEntry(frt, pag, p+x, data=self.acc[x-1])
+            desc = self.acc[self.sql.drsact_col.index("dac_desc")]
+            self.df.loadEntry(frt, pag, p+1, data=desc)
 
     def doDelete(self):
         acc = self.sql.getRec("drsmst", cols=["count(*)"],
@@ -88,6 +88,8 @@
         if self.new == "Y":
             self.sql.insRec("drsact", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.drsact_col
+            data.append(self.acc[col.index("dac_xflag")])
             self.sql.updRec("drsact", data=data, where=[("dac_code",
                 "=", self.code)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'drs/drc710.py' (properties changed: -x to +x)
--- old/drs/drc710.py	2020-04-21 08:42:36 +0000
+++ new/drs/drc710.py	2020-04-23 12:45:44 +0000
@@ -63,14 +63,14 @@
 
     def doCode(self, frt, pag, r, c, p, i, w):
         self.code = w
-        self.acc = self.sql.getRec("drstyp", cols=["dtp_desc"],
-            where=[("dtp_code", "=", self.code)], limit=1)
+        self.acc = self.sql.getRec("drstyp", where=[("dtp_code",
+            "=", self.code)], limit=1)
         if not self.acc:
             self.new = "Y"
         else:
             self.new = "N"
-            for x in xrange(1, self.df.topq[pag]):
-                self.df.loadEntry(frt, pag, p+x, data=self.acc[x-1])
+            desc = self.acc[self.sql.drstyp_col.index("dtp_desc")]
+            self.df.loadEntry(frt, pag, p+1, data=desc)
 
     def doDelete(self):
         acc = self.sql.getRec("drsmst", cols=["count(*)"],
@@ -88,6 +88,8 @@
         if self.new == "Y":
             self.sql.insRec("drstyp", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.drstyp_col
+            data.append(self.acc[col.index("dtp_xflag")])
             self.sql.updRec("drstyp", data=data, where=[("dtp_code",
                 "=", self.code)])
         self.opts["mf"].dbm.commitDbase()

=== added file 'gen/__init__.py'
=== modified file 'gen/gl1010.py' (properties changed: -x to +x)
--- old/gen/gl1010.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1010.py	2020-04-29 09:34:24 +0000
@@ -179,9 +179,9 @@
         self.sql.delRec("genbud", where=[("glb_cono", "=", self.opts["conum"]),
             ("glb_acno", "=", self.acno)])
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        self.sql.insRec("chglog", data=["genmst", "D", "%03i%07i" % \
+        self.sql.insRec("chglog", data=["genmst", "D", "%03i%07i" %
             (self.opts["conum"], self.acno), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -195,6 +195,8 @@
         if self.new:
             self.sql.insRec("genmst", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.genmst_col
+            data.append(self.old[col.index("glm_xflag")])
             self.sql.updRec("genmst", data=data, where=[("glm_cono", "=",
                 self.opts["conum"]), ("glm_acno", "=", self.acno)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -202,8 +204,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["genmst", "U",
                         "%03i%07i" % (self.opts["conum"], self.acno),
-                        self.sql.genmst_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.setWidget(self.df.B3, state="disabled")
         if "args" in self.opts:

=== modified file 'gen/gl1020.py' (properties changed: -x to +x)
--- old/gen/gl1020.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1020.py	2020-04-23 09:55:44 +0000
@@ -159,6 +159,8 @@
             self.df.loadEntry("C", 0, 0, data=1)
         else:
             if data != self.old[:len(data)]:
+                col = self.sql.genjlm_col
+                data.append(self.old[col.index("gjm_xflag")])
                 self.sql.updRec("genjlm", data=data, where=[("gjm_cono",
                     "=", self.opts["conum"]), ("gjm_num", "=", self.num)])
             self.doReload()
@@ -170,22 +172,26 @@
 
     def doSeq(self, frt, pag, r, c, p, i, w):
         self.seq = w
-        seq = self.sql.getRec("genjlt", where=[("gjt_cono", "=",
+        self.seqdat = self.sql.getRec("genjlt", where=[("gjt_cono", "=",
             self.opts["conum"]), ("gjt_num", "=", self.num), ("gjt_seq", "=",
             self.seq)], limit=1)
-        if not seq:
+        if not self.seqdat:
             self.new_seq = "y"
         else:
             self.new_seq = "n"
             col = self.sql.genjlt_col
-            acc = seq[col.index("gjt_acno")]
+            acc = self.seqdat[col.index("gjt_acno")]
             des = self.sql.getRec("genmst", cols=["glm_desc"],
                 where=[("glm_cono", "=", self.opts["conum"]),
                 ("glm_acno", "=", acc)], limit=1)[0]
-            self.df.loadEntry(frt, pag, p+1, data=acc)
-            self.df.loadEntry(frt, pag, p+2, data=des)
-            self.df.loadEntry(frt, pag, p+3, data=seq[col.index("gjt_vatc")])
-            self.df.loadEntry(frt, pag, p+4, data=seq[col.index("gjt_amnt")])
+            self.df.loadEntry(frt, pag, p+1,
+                    data=acc)
+            self.df.loadEntry(frt, pag, p+2,
+                    data=des)
+            self.df.loadEntry(frt, pag, p+3,
+                    data=self.seqdat[col.index("gjt_vatc")])
+            self.df.loadEntry(frt, pag, p+4,
+                    data=self.seqdat[col.index("gjt_amnt")])
 
     def doDelSeq(self):
         if self.new_seq == "y":
@@ -221,8 +227,10 @@
         if self.new_seq == "y":
             self.sql.insRec("genjlt", data=data)
         else:
-            self.sql.updRec("genjlt", data=data, where=[("gjt_cono", "=",
-                self.opts["conum"]), ("gjt_num", "=", self.num),
+            col = self.sql.genjlt_col
+            data.append(self.seqdat[col.index("gjt_xflag")])
+            self.sql.updRec("genjlt", data=data, where=[("gjt_cono",
+                "=", self.opts["conum"]), ("gjt_num", "=", self.num),
                 ("gjt_seq", "=", self.seq)])
         self.doReload()
         self.df.focusField("C", 0, self.nxtcol)

=== modified file 'gen/gl1030.py' (properties changed: -x to +x)
--- old/gen/gl1030.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1030.py	2020-08-07 09:31:57 +0000
@@ -655,8 +655,8 @@
         if self.newseq == "n":
             cl = self.genrpt_cl
             fld = self.doLoadTypes()
-            for x in xrange(0, len(fld)):
-                data = self.seq[cl.index(fld[x])]
+            for x, f in enumerate(fld):
+                data = self.seq[cl.index(f)]
                 self.df.loadEntry("T", pag, x, data=data)
         self.df.selPage(self.df.tags[pag - 1][0])
 
@@ -692,8 +692,8 @@
             "glr_print", "glr_norm", "glr_acbal", "glr_ignore",
             "glr_store", "glr_snum1", "glr_acstr", "glr_label"]
         grp = ""
-        for c in col:
-            grp = "%s%s," % (grp, c)
+        for cc in col:
+            grp = "%s%s," % (grp, cc)
         grp = grp[:-1]
         self.grp = self.sql.getRec("genrpt", cols=col,
             where=[("glr_cono", "=", self.selcoy), ("glr_repno", "=",
@@ -731,6 +731,7 @@
                 data.append("")
             else:
                 data.append(0)
+        data.append("")
         if self.newseq in ("c", "n"):
             self.doDelSeq()
         self.sql.insRec("genrpt", data=data)
@@ -744,6 +745,7 @@
                 data[2] = g[2]
                 data[8] = g[8]
                 data[9] = g[9]
+                data[29] = g[29]
                 self.sql.updRec("genrpt", data=data, where=[("glr_cono", "=",
                     self.selcoy), ("glr_repno", "=", self.repno), ("glr_group",
                     "=", self.gno), ("glr_seq", "=", g[2])])

=== modified file 'gen/gl1040.py' (properties changed: -x to +x)
--- old/gen/gl1040.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1040.py	2020-04-23 10:01:49 +0000
@@ -109,6 +109,8 @@
             self.df.focusField("C", 0, 1)
         else:
             if data != self.oldm[:len(data)]:
+                col = self.sql.gendtm_col
+                data.append(self.oldm[col.index("gdm_xflag")])
                 self.sql.updRec("gendtm", data=data, where=[("gdm_cono",
                     "=", self.opts["conum"]), ("gdm_code", "=", self.code)])
             self.df.focusField("C", 0, self.col)
@@ -142,9 +144,11 @@
         if self.newper == "y":
             self.sql.insRec("gendtt", data=data)
         elif data != self.oldt[:len(data)]:
-            self.sql.updRec("gendtt", data=data, where=[("gdt_cono", "=",
-            self.opts["conum"]), ("gdt_code", "=", self.code),
-            ("gdt_curdt", "=", self.per)])
+            col = self.sql.gendtt_col
+            data.append(self.oldt[col.index("gdt_xflag")])
+            self.sql.updRec("gendtt", data=data, where=[("gdt_cono",
+                "=", self.opts["conum"]), ("gdt_code", "=", self.code),
+                ("gdt_curdt", "=", self.per)])
         self.loadPeriods()
 
     def loadPeriods(self, focus=True):

=== modified file 'gen/gl1050.py' (properties changed: -x to +x)
--- old/gen/gl1050.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1050.py	2020-07-07 13:33:45 +0000
@@ -25,7 +25,7 @@
 """
 
 from TartanClasses import GetCtl, Sql, TartanDialog
-from tartanFunctions import showPrinters
+from tartanFunctions import getPrinters
 
 class gl1050(object):
     def __init__(self, **opts):
@@ -132,13 +132,16 @@
                 ("gdm_code", "", 0, "Cod"),
                 ("gdm_desc", "", 0, "Description")),
             "where": [("gdm_cono", "=", self.opts["conum"])]}
-        self.printers = showPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])
-        self.printers.insert(1, "Export")
+        prts = getPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])
+        data = prts[:]
+        if "Default" in data:
+            data.remove("Default")
+        prts.insert(1, "Export")
         prt = {
             "stype": "C",
             "titl": "Select Required Printer",
             "head": ("Name", "Description"),
-            "data": self.printers}
+            "data": data}
         cts = ("V", "B", "C", "X", "D")
         fld = (
             (("T",0,0,0),"IUI",3,"Stream-Number","Stream Number",
@@ -171,7 +174,7 @@
             (("C",0,0,11),"IUA",1,"N","Print Numbers (Y/N)",
                 "N","N",None,None,None,("in",("Y","N"))),
             (("C",0,0,12),"ITX",30,"Printer Name","Printer-Name",
-                "Default","N",self.doPrt,prt,None,None),
+                "Default","N",self.doPrt,prt,None,("in",prts)),
             (("C",0,0,13),"ITX",30,"E-Mail Address","E-Mail-Address",
                 "","N",None,None,None,("email",)))
         but = (
@@ -278,8 +281,6 @@
             return "Invalid Variance, Only B or P"
 
     def doPrt(self, frt, pag, r, c, p, i, w):
-        if w not in self.printers:
-            return "Invalid Printer"
         if w == "Export":
             self.df.loadEntry(frt, pag, p+1, data="")
             return "sk1"
@@ -306,8 +307,8 @@
         self.con = w[3]
         self.rep = w[4]
         self.gen = w[5]
-        for x in xrange(0, len(w)):
-            self.df.loadEntry(frt, pag, p+x, data=w[x])
+        for x, d in enumerate(w):
+            self.df.loadEntry(frt, pag, p+x, data=d)
         self.df.focusField(frt, pag, c+1)
 
     def doDelLin(self):
@@ -325,6 +326,8 @@
         if self.newlin == "y":
             self.sql.insRec("genstr", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.genstr_col
+            data.append(self.old[col.index("gls_xflag")])
             self.sql.updRec("genstr", data=data, where=[("gls_cono",
                 "=", self.opts["conum"]), ("gls_strm", "=", self.strm),
                 ("gls_seq", "=", self.seq)])

=== modified file 'gen/gl1060.py' (properties changed: -x to +x)
--- old/gen/gl1060.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl1060.py	2020-04-23 10:03:31 +0000
@@ -491,8 +491,10 @@
         if self.new == "y":
             self.sql.insRec("genrcc", data=data)
         elif data != self.old[:len(data)]:
-            self.sql.updRec("genrcc", data=data, where=[("grc_cono", "=",
-                self.opts["conum"]), ("grc_acno", "=", self.acno),
+            col = self.sql.genrcc_col
+            data.append(self.old[col.index("grc_xflag")])
+            self.sql.updRec("genrcc", data=data, where=[("grc_cono",
+                "=", self.opts["conum"]), ("grc_acno", "=", self.acno),
                 ("grc_memo", "=", self.memo)])
         if "args" in self.opts:
             self.doExit()

=== modified file 'gen/gl2010.py' (properties changed: -x to +x)
--- old/gen/gl2010.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl2010.py	2020-04-25 09:43:50 +0000
@@ -129,14 +129,15 @@
             return "Invalid Account Number"
         self.acc = w
         self.df.loadEntry(frt, pag, p+1, data=desc[0])
-        bals = self.sql.getRec("genbal", cols=["glo_cyr"],
-            where=[("glo_cono", "=", self.opts["conum"]), ("glo_acno", "=",
-            self.acc), ("glo_trdt", "=", self.start)], limit=1)
-        if not bals:
+        self.old = self.sql.getRec("genbal", where=[("glo_cono", "=",
+            self.opts["conum"]), ("glo_acno", "=", self.acc),
+            ("glo_trdt", "=", self.start)], limit=1)
+        if not self.old:
             self.new_acc = "y"
         else:
             self.new_acc = "n"
-            self.df.loadEntry(frt, pag, p+2, bals[0])
+            bal = self.old[self.sql.genbal_col.index("glo_cyr")]
+            self.df.loadEntry(frt, pag, p+2, data=bal)
 
     def doBal(self, frt, pag, r, c, p, i, w):
         self.bal = w
@@ -146,9 +147,11 @@
         if self.new_acc == "y":
             self.sql.insRec("genbal", data=data)
         elif data != self.old[:len(data)]:
-            self.sql.updRec("genbal", data=data, where=[("glo_cono", "=",
-                self.opts["conum"]), ("glo_acno", "=", self.acc), ("glo_trdt",
-                "=", self.start)])
+            col = self.sql.genbal_col
+            data.append(self.old[col.index("glo_xflag")])
+            self.sql.updRec("genbal", data=data, where=[("glo_cono",
+                "=", self.opts["conum"]), ("glo_acno", "=", self.acc),
+                ("glo_trdt", "=", self.start)])
         if det:
             return
         self.opts["mf"].dbm.commitDbase()

=== modified file 'gen/gl2020.py' (properties changed: -x to +x)
--- old/gen/gl2020.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl2020.py	2020-04-25 11:35:14 +0000
@@ -374,23 +374,22 @@
 
     def endData(self, det=False):
         if self.frq == "A":
-            mthamt = int(round(self.bud / 12.0, 0))
-            while mthamt * 12 < self.bud:
-                mthamt += 1
+            amts = [int(round(self.bud / 12.0, 0))] * 12
+            amts[0] += (self.bud - sum(amts))
             p = int(self.opts["period"][1][0] / 100)
             y = int(p / 100)
             m = p % 100
-            for _ in xrange(12):
+            for x in range(12):
                 per = (y * 100) + m
-                whr = [("glb_cono", "=", self.opts["conum"]), ("glb_acno", "=",
-                    self.acc), ("glb_curdt", "=", per)]
+                whr = [("glb_cono", "=", self.opts["conum"]), ("glb_acno",
+                    "=", self.acc), ("glb_curdt", "=", per)]
                 exst = self.sql.getRec("genbud", cols=["count(*)"],
                     where=whr, limit=1)
                 if exst[0]:
                     self.sql.updRec("genbud", cols=["glb_tramt"],
-                    data=[mthamt], where=whr)
+                        data=[amts[x]], where=whr)
                 else:
-                    data = [self.opts["conum"], self.acc, per, mthamt]
+                    data = [self.opts["conum"], self.acc, per, amts[x]]
                     self.sql.insRec("genbud", data=data)
                 m = m + 1
                 if m > 12:

=== modified file 'gen/gl2030.py' (properties changed: -x to +x)
--- old/gen/gl2030.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl2030.py	2020-06-20 13:20:20 +0000
@@ -72,7 +72,7 @@
         self.allcoy = self.opts["conum"]
         self.allnam = self.opts["conam"]
         # Get Enabled Modules
-        tab = ["ctlctl", "ctlmst", "ctlpwu", "ctlvmf", "ctlvrf", "ctlvtf",
+        tabs = ["ctlctl", "ctlmst", "ctlpwu", "ctlvmf", "ctlvrf", "ctlvtf",
             "genint", "genmst", "gentrn", "genrcc", "genrct"]
         mod = []
         for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
@@ -88,7 +88,7 @@
             if not ctl:
                 return
             if ctl["cta_glint"] == "Y":
-                tab.extend(["assgrp", "assmst", "asstrn"])
+                tabs.extend(["assgrp", "assmst", "asstrn"])
                 self.tags.append(("ASS", None, None, None, False))
                 page += 1
                 self.tagp["AR"] = page
@@ -97,7 +97,7 @@
             if not ctl:
                 return
             if ctl["cbk_glint"] == "Y":
-                tab.extend(["bkmcon", "bkmmst", "bkmtrn"])
+                tabs.extend(["bkmcon", "bkmmst", "bkmtrn"])
                 self.tags.append(("BKM", None, None, None, False))
                 page += 1
                 self.tagp["BK"] = page
@@ -113,7 +113,7 @@
                         "Account Will Not Balance!" % \
                         gltrtp[self.glrtn - 1][1])
                     return
-                tab.extend(["crsmst", "crstrn"])
+                tabs.extend(["crsmst", "crstrn"])
                 self.tags.append(("CRS", None, None, None, False))
                 page += 1
                 self.tagp["CR"] = page
@@ -129,7 +129,7 @@
                         "Account Will Not Balance!" % \
                         gltrtp[self.glrtn - 1][1])
                     return
-                tab.extend(["drsmst", "drstrn"])
+                tabs.extend(["drsmst", "drstrn"])
                 self.tags.append(("DRS", None, None, None, False))
                 page += 1
                 self.tagp["DR"] = page
@@ -138,7 +138,7 @@
             if not ctl:
                 return
             if ctl["cln_glint"] == "Y":
-                tab.extend(["lonmf1", "lonmf2", "lonrte", "lontrn"])
+                tabs.extend(["lonmf1", "lonmf2", "lonrte", "lontrn"])
                 self.tags.append(("LON", None, None, None, False))
                 page += 1
                 self.tagp["LN"] = page
@@ -149,7 +149,7 @@
             if not ctl:
                 return
             if ctl["mcm_glint"] == "Y":
-                tab.extend(["memmst", "memtrn"])
+                tabs.extend(["memmst", "memtrn"])
                 self.tags.append(("MEM", None, None, None, False))
                 page += 1
                 self.tagp["ML"] = page
@@ -158,7 +158,7 @@
             if not ctl:
                 return
             if ctl["cte_glint"] == "Y":
-                tab.extend(["rcaprm", "rcaowm", "rcaowt", "rcatnm",
+                tabs.extend(["rcaprm", "rcaowm", "rcaowt", "rcatnm",
                     "rcatnt", "rcacon"])
                 self.tags.append(("RCA", None, None, None, False))
                 page += 1
@@ -168,7 +168,7 @@
             if not ctl:
                 return
             if ctl["ctr_glint"] == "Y":
-                tab.extend(["rtlprm", "rtlmst", "rtlcon", "rtltrn"])
+                tabs.extend(["rtlprm", "rtlmst", "rtlcon", "rtltrn"])
                 self.tags.append(("RTL", None, None, None, False))
                 page += 1
                 self.tagp["RT"] = page
@@ -177,7 +177,7 @@
             if not ctl:
                 return
             if ctl["ctw_glint"] == "Y":
-                tab.extend(["wagmst", "waglmf", "wagltf"])
+                tabs.extend(["wagmst", "waglmf", "wagltf"])
                 self.tags.append(("SLN", None, None, None, False))
                 page += 1
                 self.tagp["SL"] = page
@@ -196,7 +196,7 @@
             if self.gc.chkRec(self.opts["conum"], self.ctlctl, ["crs_ctl"]):
                 return
         # Create SQL Object
-        self.sql = Sql(self.opts["mf"].dbm, tab, prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
         if self.sql.error:
             return
         # Check for Intercompany Facility
@@ -562,9 +562,11 @@
                     [["C",self.crspag,0,2],"INa",9,"Ref-Num-2","",
                         "i","N",self.doCrsRef,None,None,None],
                     [["C",self.crspag,0,3],"ISD",13.2,"Discount","",
-                        "","N",self.doCrsDis,None,None,("efld",)],
+                        "","N",self.doCrsDis,None,None,("efld",),None,
+                        "Discount Amount to be Added to the Amount."],
                     [["C",self.crspag,0,4],"ISD",13.2,"Amount","",
-                        "","N",self.doCrsAmt,None,None,("efld",)]])
+                        "","N",self.doCrsAmt,None,None,("efld",)],
+                    [["C",self.crspag,0,5],"OSD",13.2,"Total-Amount"]])
             elif tag == "DR":
                 self.drspag = self.tagp[tag]
                 fld.extend([
@@ -577,9 +579,11 @@
                     [["C",self.drspag,0,3],"INa",9,"Ref-Num-2","",
                         "i","N",self.doDrsRef,None,None,None],
                     [["C",self.drspag,0,4],"ISD",13.2,"Discount","",
-                        "","N",self.doDrsDis,None,None,("efld",)],
+                        "","N",self.doDrsDis,None,None,("efld",),None,
+                        "Discount Amount to be Added to the Amount."],
                     [["C",self.drspag,0,5],"ISD",13.2,"Amount","",
-                        "","N",self.doDrsAmt,None,None,("efld",)]])
+                        "","N",self.doDrsAmt,None,None,("efld",)],
+                    [["C",self.drspag,0,6],"OSD",13.2,"Total-Amount"]])
             elif tag == "LN":
                 self.lonpag = self.tagp[tag]
                 fld.extend([
@@ -608,9 +612,11 @@
                         "","N",self.doMemAcc,mlm,None,("notblank",)],
                     [["C",self.mempag,0,1],"ONA",30,"Name"],
                     [["C",self.mempag,0,2],"ISD",13.2,"Discount","",
-                        "","N",self.doMemDis,None,None,("efld",)],
+                        "","N",self.doMemDis,None,None,("efld",),None,
+                        "Discount Amount to be Added to the Amount."],
                     [["C",self.mempag,0,3],"ISD",13.2,"Amount","",
-                        "","N",self.doMemAmt,None,None,("efld",)]])
+                        "","N",self.doMemAmt,None,None,("efld",)],
+                    [["C",self.mempag,0,4],"OSD",13.2,"Total-Amount"]])
             elif tag == "RC":
                 self.rcapag = self.tagp[tag]
                 fld.extend([
@@ -687,16 +693,16 @@
                 cnd.append((self.endBkm, "y"))
                 cxt.append(None)
             elif tag == "CR":
-                cnd.append((self.endCrsDrsMem, "n"))
+                cnd.append((self.endCrsDrsMem, "y"))
                 cxt.append(None)
             elif tag == "DR":
-                cnd.append((self.endCrsDrsMem, "n"))
+                cnd.append((self.endCrsDrsMem, "y"))
                 cxt.append(None)
             elif tag == "LN":
                 cnd.append((self.endLon, "y"))
                 cxt.append(None)
             elif tag == "ML":
-                cnd.append((self.endCrsDrsMem, "n"))
+                cnd.append((self.endCrsDrsMem, "y"))
                 cxt.append(None)
             elif tag == "RC":
                 cnd.append((self.endRca, "y"))
@@ -815,74 +821,75 @@
         self.ip.closeProcess()
         bimp = BankImport(self.opts["mf"], self.impfmt, self.bankac,
             self.dtefmt)
-        if bimp.trans:
-            for date, memo, refno, payee, amount in bimp.trans:
-                date = CCD(date, "D1", 10)
-                memo = CCD(memo, "NA", 100)
-                refno = CCD(refno, "Na", 9)
-                payee = CCD(payee, "NA", 50)
-                amount = CCD(amount, "SD", 13.2)
-                if date.work < self.ifrom or date.work > self.ito:
-                    continue
-                autoref = False
-                if refno.work in ("", "        0", 0):
+        if not bimp.trans:
+            return
+        for date, memo, refno, payee, amount in bimp.trans:
+            date = CCD(date, "D1", 10)
+            memo = CCD(memo, "NA", 100)
+            refno = CCD(refno, "Na", 9)
+            payee = CCD(payee, "NA", 50)
+            amount = CCD(amount, "SD", 13.2)
+            if date.work < self.ifrom or date.work > self.ito:
+                continue
+            autoref = False
+            if refno.work in ("", "        0", 0):
+                autoref = True
+            else:
+                chk = self.sql.getRec("gentrn", cols=["count(*)"],
+                    where=[("glt_cono", "=", self.opts["conum"]),
+                    ("glt_acno", "=", self.bh.acc), ("glt_refno", "=",
+                    refno.work)], limit=1)
+                if chk[0]:
                     autoref = True
+            if autoref:
+                ref = memo.work.split()
+                if amount.work < 0 and ref[0] == "CHEQUE" and \
+                             len(ref) > 1 and ref[1] != "CASHED":
+                    # Nedbank cheque number
+                    refno = ref[1][1:8]
                 else:
-                    chk = self.sql.getRec("gentrn", cols=["count(*)"],
-                        where=[("glt_cono", "=", self.opts["conum"]),
-                        ("glt_acno", "=", self.bh.acc), ("glt_refno", "=",
-                        refno.work)], limit=1)
-                    if chk[0]:
-                        autoref = True
-                if autoref:
-                    ref = memo.work.split()
-                    if amount.work < 0 and ref[0] == "CHEQUE" and \
-                                 len(ref) > 1 and ref[1] != "CASHED":
-                        # Nedbank cheque number
-                        refno = ref[1][1:8]
-                    else:
-                        # Next automatic reference
-                        acc = self.sql.getRec("genrct",
-                            cols=["max(grt_refno)"], where=[("grt_cono", "=",
-                            self.opts["conum"]), ("grt_acno", "=",
-                            self.bh.acc), ("grt_refno", "like", "BS_______")],
-                            limit=1)
-                        if acc:
-                            try:
-                                auto = int(acc[0][2:]) + 1
-                            except:
-                                auto = 1
-                        else:
+                    # Next automatic reference
+                    acc = self.sql.getRec("genrct",
+                        cols=["max(grt_refno)"], where=[("grt_cono", "=",
+                        self.opts["conum"]), ("grt_acno", "=",
+                        self.bh.acc), ("grt_refno", "like", "BS_______")],
+                        limit=1)
+                    if acc:
+                        try:
+                            auto = int(acc[0][2:]) + 1
+                        except:
                             auto = 1
-                        refno = "BS%07d" % auto
-                    refno = CCD(refno, "Na", 9)
-                whr = [
-                    ("grt_cono", "=", self.opts["conum"]),
-                    ("grt_acno", "=", self.bh.acc),
-                    ("grt_date", "=", date.work),
-                    ("grt_memo", "=", memo.work),
-                    ("grt_payee", "=", payee.work),
-                    ("grt_amount", "=", amount.work)]
-                if not autoref:
-                    whr.append(("grt_refno", "=", refno.work))
-                acc = self.sql.getRec("genrct", where=whr)
-                if acc and autoref:
-                    ok = askQuestion(self.opts["mf"].body, head="Import Error",
-                        mess="This record seems to be duplicated,\n"\
-                            "  Date:      %s\n"\
-                            "  Payee:     %s\n"\
-                            "  Amount:    %s\n\n"\
-                            "  Import Anyway?" % \
-                            (date.disp, payee.disp, amount.disp),
-                        default="no")
-                    if ok == "no":
-                        continue
-                elif acc:
+                    else:
+                        auto = 1
+                    refno = "BS%07d" % auto
+                refno = CCD(refno, "Na", 9)
+            whr = [
+                ("grt_cono", "=", self.opts["conum"]),
+                ("grt_acno", "=", self.bh.acc),
+                ("grt_date", "=", date.work),
+                ("grt_memo", "=", memo.work),
+                ("grt_payee", "=", payee.work),
+                ("grt_amount", "=", amount.work)]
+            if not autoref:
+                whr.append(("grt_refno", "=", refno.work))
+            acc = self.sql.getRec("genrct", where=whr)
+            if acc and autoref:
+                ok = askQuestion(self.opts["mf"].body, head="Import Error",
+                    mess="This record seems to be duplicated,\n"\
+                        "  Date:      %s\n"\
+                        "  Payee:     %s\n"\
+                        "  Amount:    %s\n\n"\
+                        "  Import Anyway?" % \
+                        (date.disp, payee.disp, amount.disp),
+                    default="no")
+                if ok == "no":
                     continue
-                data = [self.opts["conum"], self.bh.acc, date.work, memo.work,
-                    refno.work, payee.work, amount.work, "N", 0]
-                self.sql.insRec("genrct", data=data)
-            self.opts["mf"].dbm.commitDbase()
+            elif acc:
+                continue
+            data = [self.opts["conum"], self.bh.acc, date.work, memo.work,
+                refno.work, payee.work, amount.work, "N", 0]
+            self.sql.insRec("genrct", data=data)
+        self.opts["mf"].dbm.commitDbase()
 
     def doImpExit(self):
         self.ip.closeProcess()
@@ -1033,21 +1040,12 @@
             for desc1, desc2, desc3, trtp, self.allcoy, self.accnum, \
                         acrs, achn, adrs, aage, self.vatcod in codes:
                 self.alldet = CCD(desc1, "NA", 30).work
-                if memo.find(desc1) != -1:
-                    if desc2:
-                        if memo.find(desc2) != -1:
-                            if desc3:
-                                if memo.find(desc3) != -1:
-                                    found = True
-                                else:
-                                    found = False
-                            else:
-                                found = True
-                        else:
-                            found = False
-                    else:
-                        found = True
-                else:
+                found = True
+                if desc1 not in memo:
+                    found = False
+                if found and desc2 and desc2 not in memo:
+                    found = False
+                if found and desc3 and desc3 not in memo:
                     found = False
                 if found:
                     # Check Control Details
@@ -1203,14 +1201,14 @@
 
     def doTrnRef(self, frt, pag, r, c, p, i, w):
         if self.pcash and not w:
-            a = self.sql.getRec("gentrn", cols=["glt_refno"],
+            refs = self.sql.getRec("gentrn", cols=["glt_refno"],
                 where=[("glt_cono", "=", self.opts["conum"]), ("glt_acno",
                 "=", self.conacc),("glt_refno", "like", "PC_______")],
                 group="glt_refno", order="glt_refno desc")
             auto = False
-            for r in a:
+            for ref in refs:
                 try:
-                    w = "PC%07i" % (int(r[0][2:]) + 1)
+                    w = "PC%07i" % (int(ref[0][2:]) + 1)
                     auto = True
                     break
                 except:
@@ -1421,7 +1419,7 @@
     def doAccNum(self, frt, pag, r, c, p, i, w):
         if not w:
             return "Invalid Account Number"
-        if self.allcoy == self.opts["conum"] and w == self.bh.acc:
+        if self.allcoy == self.opts["conum"] and w == self.conacc:
             return "Invalid Number, Same as Control"
         self.others = False
         self.othtot = 0
@@ -2080,6 +2078,8 @@
         if not self.othamt:
             self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
             self.df.loadEntry(frt, pag, p, data=self.othamt)
+        totamt = float(ASD(self.othamt) + ASD(self.othdis))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doNewCrs(self):
         callModule(self.opts["mf"], self.df, "cr1010", coy=(self.allcoy,
@@ -2121,6 +2121,8 @@
         if not self.othamt:
             self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
             self.df.loadEntry(frt, pag, p, data=self.othamt)
+        totamt = float(ASD(self.othamt) + ASD(self.othdis))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doNewDrs(self):
         callModule(self.opts["mf"], self.df, "dr1010", coy=(self.allcoy,
@@ -2256,6 +2258,8 @@
         if not self.othamt:
             self.othamt = float(ASD(self.allamt) - ASD(self.othtot))
             self.df.loadEntry(frt, pag, p, data=self.othamt)
+        totamt = float(ASD(self.othamt) + ASD(self.othdis))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doRcaPrm(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables=["rcaprm", "rcaowm"], cols=["rcp_desc",
@@ -2532,9 +2536,12 @@
             self.othvar.set(False)
 
     def endCrsDrsMem(self):
-        if (self.others == "crs" and self.glrtn == 2) or \
-                (self.others == "drs" and self.glrtn == 6) or \
-                (self.others == "mem" and self.glrtn == 6):
+        found = False
+        if self.others == "crs" and self.glrtn == 2:
+            found = True
+        elif self.others in ("drs", "mem") and self.glrtn == 6:
+            found = True
+        if found:
             self.tramt = float(ASD(0.0) - ASD(self.othamt))
             self.dsamt = float(ASD(0.0) - ASD(self.othdis))
         else:
@@ -2670,7 +2677,6 @@
         for b in xrange(self.beg, (self.beg + 4)):
             wid = getattr(self.df, "B%s" % b)
             self.df.setWidget(wid, "disabled")
-        self.opts["mf"].updateStatus("Select Transaction to Allocate Against")
         if self.others == "crs":
             age = AgeAll(self.opts["mf"], system="crs", agetyp=atype,
                 agekey=[self.allcoy, self.othacno, self.othrtn, self.allref,

=== modified file 'gen/gl2040.py' (properties changed: -x to +x)
--- old/gen/gl2040.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl2040.py	2020-05-10 10:30:25 +0000
@@ -47,7 +47,7 @@
         self.allcoy = self.opts["conum"]
         self.allnam = self.opts["conam"]
         # Get Enabled Modules
-        tab = ["ctlctl", "ctlmst", "ctlpwu", "ctlvmf", "ctlvrf", "ctlvtf",
+        tabs = ["ctlctl", "ctlmst", "ctlpwu", "ctlvmf", "ctlvrf", "ctlvtf",
             "genint", "genmst", "gentrn"]
         mod = []
         for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
@@ -61,7 +61,7 @@
             if not ctl:
                 return
             if ctl["cta_glint"] == "Y":
-                tab.extend(["assgrp", "assmst", "asstrn"])
+                tabs.extend(["assgrp", "assmst", "asstrn"])
                 self.tags.append(("ASS", None, None, None, False))
                 page += 1
                 self.tagp["AR"] = page
@@ -70,7 +70,7 @@
             if not ctl:
                 return
             if ctl["cbk_glint"] == "Y":
-                tab.extend(["bkmcon", "bkmmst", "bkmtrn"])
+                tabs.extend(["bkmcon", "bkmmst", "bkmtrn"])
                 self.tags.append(("BKM", None, None, None, False))
                 page += 1
                 self.tagp["BK"] = page
@@ -79,7 +79,7 @@
             if not ctl:
                 return
             if ctl["ctc_glint"] == "Y":
-                tab.extend(["crsmst", "crstrn"])
+                tabs.extend(["crsmst", "crstrn"])
                 self.tags.append(("CRS", None, None, None, False))
                 page += 1
                 self.tagp["CR"] = page
@@ -88,7 +88,7 @@
             if not ctl:
                 return
             if ctl["ctd_glint"] == "Y":
-                tab.extend(["drsmst", "drstrn"])
+                tabs.extend(["drsmst", "drstrn"])
                 self.tags.append(("DRS", None, None, None, False))
                 page += 1
                 self.tagp["DR"] = page
@@ -97,7 +97,7 @@
             if not ctl:
                 return
             if ctl["cln_glint"] == "Y":
-                tab.extend(["lonmf1", "lonmf2", "lonrte", "lontrn"])
+                tabs.extend(["lonmf1", "lonmf2", "lonrte", "lontrn"])
                 self.tags.append(("LON", None, None, None, False))
                 page += 1
                 self.tagp["LN"] = page
@@ -108,7 +108,7 @@
             if not ctl:
                 return
             if ctl["mcm_glint"] == "Y":
-                tab.extend(["memmst", "memtrn"])
+                tabs.extend(["memmst", "memtrn"])
                 self.tags.append(("MEM", None, None, None, False))
                 page += 1
                 self.tagp["ML"] = page
@@ -117,7 +117,7 @@
             if not ctl:
                 return
             if ctl["cte_glint"] == "Y":
-                tab.extend(["rcaprm", "rcaowm", "rcaowt", "rcatnm",
+                tabs.extend(["rcaprm", "rcaowm", "rcaowt", "rcatnm",
                     "rcatnt", "rcacon"])
                 self.tags.append(("RCA", None, None, None, False))
                 page += 1
@@ -127,7 +127,7 @@
             if not ctl:
                 return
             if ctl["ctr_glint"] == "Y":
-                tab.extend(["rtlprm", "rtlmst", "rtlcon", "rtltrn"])
+                tabs.extend(["rtlprm", "rtlmst", "rtlcon", "rtltrn"])
                 self.tags.append(("RTL", None, None, None, False))
                 page += 1
                 self.tagp["RT"] = page
@@ -136,7 +136,7 @@
             if not ctl:
                 return
             if ctl["ctw_glint"] == "Y":
-                tab.extend(["wagmst", "waglmf", "wagltf"])
+                tabs.extend(["wagmst", "waglmf", "wagltf"])
                 self.tags.append(("SLN", None, None, None, False))
                 page += 1
                 self.tagp["SL"] = page
@@ -146,7 +146,7 @@
         if not self.ctlctl:
             return
         # Create SQL Object
-        self.sql = Sql(self.opts["mf"].dbm, tab, prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
         if self.sql.error:
             return
         # Check for Intercompany Facility
@@ -430,7 +430,7 @@
                 "N","N",self.doVatCod,vat,None,("notblank",)),
             (("C",1,0,7),"ISD",13.2,"VAT-Amt","V.A.T. Amount",
                 "","N",self.doVatAmt,None,None,("efld",)),
-            (("C",1,0,8),"INA",(20,30),"Details","Details",
+            (("C",1,0,8),"INA",30,"Details","Details",
                 "r","N",self.doTrnDet,None,None,("notblank",))]
         tags = list(self.tagp.keys())
         tags.sort()
@@ -573,11 +573,11 @@
             self.allcoy = self.opts["conum"]
         but = [
             ("_Import File",None,self.doImport,0,("C",1,1),("C",1,2),
-            "Import a CSV or XLS File with the Correct Format i.e. Reference "\
-            "Number, Transaction Date, Company Number, Account Number, "\
-            "Transaction Amount, V.A.T. Code, V.A.T. Amount, Details. "\
-            "If there is a VAT Code with no VAT Amount, it will be "\
-            "Calculated."),
+                "Import a CSV or XLS File with the Correct Format i.e. "\
+                "Reference Number, Transaction Date, Company Number, "\
+                "Account Number, Transaction Amount, V.A.T. Code, "\
+                "V.A.T. Amount, Details. If there is a VAT Code with "\
+                "no VAT Amount, it will be Calculated."),
             ("View Entries",lst,None,0,("C",1,1),("C",1,2)),
             ("End Batch",None,self.exitPage,0,("C",1,1),("C",1,2)),
             ("Abort Batch",None,self.doAbort,1,None,None)]

=== modified file 'gen/gl2050.py' (properties changed: -x to +x)
--- old/gen/gl2050.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl2050.py	2020-04-23 16:21:49 +0000
@@ -51,9 +51,9 @@
         # Set Batch Indicator
         self.batind = "Y"
         # Create SQL Object
-        tab = ["ctlctl", "ctlmst", "ctlvmf", "ctlvrf", "ctlvtf", "genint",
+        tabs = ["ctlctl", "ctlmst", "ctlvmf", "ctlvrf", "ctlvtf", "genint",
             "genjlm", "genjlt", "genmst", "gentrn", "assgrp", "rtlprm"]
-        self.sql = Sql(self.opts["mf"].dbm, tab, prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
         if self.sql.error:
             return
         self.bh = Batches(self.opts["mf"], self.opts["conum"],

=== modified file 'gen/gl3010.py' (properties changed: -x to +x)
=== modified file 'gen/gl3020.py' (properties changed: -x to +x)
--- old/gen/gl3020.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl3020.py	2020-06-20 13:22:28 +0000
@@ -555,7 +555,7 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(gltrtp)):
+        for x, t in enumerate(gltrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             dr = CCD(self.gdr[x], "SD", 15.2)
             cr = CCD(self.gcr[x], "SD", 15.2)
@@ -563,10 +563,10 @@
             df = CCD(df, "SD", 15.2)
             vt = CCD(self.gvt[x], "SD", 15.2)
             if self.totsonly == "Y":
-                self.fpdf.drawText("%-27s %s %s %s %s %s" % (gltrtp[x][1],
+                self.fpdf.drawText("%-27s %s %s %s %s %s" % (t[1],
                     qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
-                self.fpdf.drawText("%-34s %s %s %s %s %s" % (gltrtp[x][1],
+                self.fpdf.drawText("%-34s %s %s %s %s %s" % (t[1],
                     qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))

=== modified file 'gen/gl3030.py' (properties changed: -x to +x)
=== modified file 'gen/gl3040.py' (properties changed: -x to +x)
--- old/gen/gl3040.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl3040.py	2020-12-09 11:47:43 +0000
@@ -54,8 +54,7 @@
         t = time.localtime()
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i) %6s" % (t[0],
             t[1], t[2], t[3], t[4], self.__class__.__name__)
-        self.head = ("%03u %-30s %s" % (self.opts["conum"], self.opts["conam"],
-            "%s"))
+        self.head1 = ("%03u %-30s" % (self.opts["conum"], self.opts["conam"]))
         self.colsh = ["Acc-Num", "T", "Description", "Debit", "Credit"]
         self.forms = [("UI", 7), ("UA", 1), ("NA", 40)] + [("SD", 14.2)] * 2
         self.s_per = int(self.opts["period"][1][0] / 100)
@@ -145,7 +144,7 @@
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
             self.__class__.__name__, self.opts["conum"])
-        expheads = [self.head % self.sysdttm]
+        expheads = [self.head1 + " %s" % self.sysdttm]
         if self.opebal == "Y":
             date = CCD(self.opts["period"][1][0], "D1", 10)
             expheads.append("General Ledger Opening Balances as at %s" % \
@@ -184,8 +183,6 @@
             chrs -= 2
         else:
             chrs -= 1
-        pad = chrs - 35 - len(self.sysdttm)
-        self.head1 = self.head % (" " * pad + self.sysdttm)
         if self.opebal == "Y":
             date = CCD(self.opts["period"][1][0], "D1", 10.0)
             self.head2 = "General Ledger Opening Balances as at %s%s" % \
@@ -193,14 +190,11 @@
         else:
             sdate = CCD(self.start, "D2", 7)
             edate = CCD(self.end, "D2", 7)
-            self.head2 = "General Ledger Trial Balance for Period %s to "\
-                "%s%s" % (sdate.disp, edate.disp, "%s%s")
-        pad = chrs - len(self.head2) + 4 - 11  # %s%s and ' Page     1'
-        self.head2 = self.head2 % (" " * pad, " Page %5s")
+            self.head2 = "General Ledger Trial Balance for Period %s to %s" % \
+                (sdate.disp, edate.disp)
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         if "args" not in self.opts or "noprint" in self.opts["args"]:
-            self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head1)
-        self.pgnum = 0
+            self.fpdf = MyFpdf(name=self.__class__.__name__, head=80, foot=True)
         self.pglin = 999
         for num, rec in enumerate(recs):
             p.displayProgress(num)
@@ -224,8 +218,6 @@
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.repprt,
                     repeml=self.repeml)
-        if "args" not in self.opts or "noprint" in self.opts["args"]:
-            self.closeProcess()
 
     def getValues(self, data):
         acno = CCD(data[0], "UI", 7)
@@ -279,11 +271,10 @@
 
     def pageHeading(self):
         self.fpdf.add_page()
-        self.pgnum += 1
         self.fpdf.setFont(style="B")
         self.fpdf.drawText(self.head1)
         self.fpdf.drawText()
-        self.fpdf.drawText(self.head2 % self.pgnum)
+        self.fpdf.drawText(self.head2)
         if self.opebal == "N":
             self.fpdf.drawText()
             self.fpdf.drawText("(Options: Opening Balances Included %s)" % \

=== modified file 'gen/gl3050.py' (properties changed: -x to +x)
--- old/gen/gl3050.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl3050.py	2020-06-20 13:44:04 +0000
@@ -284,8 +284,8 @@
             return "Invalid Report Number"
         self.rep = w
         self.gen = "N"
-        for c in chk:
-            if c[0] == 0:
+        for ck in chk:
+            if ck[0] == 0:
                 self.gen = "Y"
                 if self.con == "Y":
                     break
@@ -824,6 +824,8 @@
             if self.new:
                 self.sql.insRec("genrpc", data=data)
             elif data != self.old[:len(data)]:
+                col = self.sql.genrpc_col
+                data.append(self.old[col.index("glc_xflag")])
                 self.sql.updRec("genrpc", data=data, where=self.whr)
             self.opts["mf"].dbm.commitDbase()
             self.cr.closeProcess()
@@ -1347,7 +1349,7 @@
 
     def doValues(self, line):
         ldic = {}
-        typ = line[0]
+        ltp = line[0]
         acc = CCD(line[4], "UI", 7)
         if acc.work == 0:
             acc.disp = "       "
@@ -1374,7 +1376,7 @@
                     vmtper = CCD("", "NA", 7)
                 else:
                     bud = CCD(long(line[8][5]), "CI", 14)
-                    if typ == "P":
+                    if ltp == "P":
                         vmt = CCD("", "NA", 14)
                         vmtper = CCD("", "NA", 7)
                     else:
@@ -1399,7 +1401,7 @@
                 vtdper = CCD("", "NA", 7)
             else:
                 btd = CCD(long(line[8][7]), "CI", 14)
-                if typ == "P":
+                if ltp == "P":
                     vtd = CCD("", "NA", 14)
                     vtdper = CCD("", "NA", 7)
                 else:
@@ -1418,13 +1420,13 @@
                         vtdper = 0
                     vtdper = CCD(vtdper, "SD", 7.2)
         else:
-            for x in xrange(0, 14):
+            for x in range(14):
                 if self.val == "X" and sgn == "N":
                     line[9][x] = float(ASD(0) - ASD(line[9][x]))
                 ldic["mp%s" % x] = CCD(long(line[9][x]), "SL", 11)
                 ldic["mx%s" % x] = CCD(line[9][x], "SD", 14.2)
         if self.repprt[2] == "export":
-            if typ == "T":
+            if ltp == "T":
                 txt = "TOTAL"
             else:
                 txt = "BODY"
@@ -1621,16 +1623,16 @@
                 self.pglin += 1
                 self.last = True
                 if line[10]:
-                    self.achart.append([typ, line[10], ldic["mp1"].work,
+                    self.achart.append([ltp, line[10], ldic["mp1"].work,
                         ldic["mp2"].work, ldic["mp3"].work, ldic["mp4"].work,
                         ldic["mp5"].work, ldic["mp6"].work, ldic["mp7"].work,
                         ldic["mp8"].work, ldic["mp9"].work, ldic["mp10"].work,
                         ldic["mp11"].work, ldic["mp12"].work])
-                if typ in ("L", "T", "G") and des.work:
+                if ltp in ("L", "T", "G") and des.work:
                     dsc = des.work
                     for x in ("/", "{", "}"):
                         dsc = dsc.replace(x, "/%s" % x)
-                    self.mchart.append([typ, dsc, ldic["mp1"].work,
+                    self.mchart.append([ltp, dsc, ldic["mp1"].work,
                         ldic["mp2"].work, ldic["mp3"].work, ldic["mp4"].work,
                         ldic["mp5"].work, ldic["mp6"].work, ldic["mp7"].work,
                         ldic["mp8"].work, ldic["mp9"].work, ldic["mp10"].work,

=== modified file 'gen/gl3060.py' (properties changed: -x to +x)
=== modified file 'gen/gl3070.py' (properties changed: -x to +x)
=== modified file 'gen/gl3080.py' (properties changed: -x to +x)
--- old/gen/gl3080.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl3080.py	2020-05-21 15:15:35 +0000
@@ -79,8 +79,8 @@
             "like", "bank_%")], limit=1)
         if not acc:
             return "Invalid Bank Account Number"
-        self.acnow = w
-        self.acnod = self.df.t_disp[pag][r][p]
+        self.acno = w
+        self.name = acc[0]
 
     def doPer(self, frt, pag, r, c, p, i, w):
         self.perw = w
@@ -99,7 +99,7 @@
         col = ["glt_trdt", "glt_refno", "glt_desc", "glt_tramt"]
         whr = [
             ("glt_cono", "=", self.opts["conum"]),
-            ("glt_acno", "=", self.acnow),
+            ("glt_acno", "=", self.acno),
             ("glt_curdt", "<=", self.perw),
             ("(", "glt_recon", "=", 0, "or", "glt_recon", ">", self.perw, ")"),
             ("glt_type", "in", (2, 4))]
@@ -113,7 +113,7 @@
         col = ["glt_trdt", "glt_refno", "glt_desc", "glt_tramt"]
         whr = [
             ("glt_cono", "=", self.opts["conum"]),
-            ("glt_acno", "=", self.acnow),
+            ("glt_acno", "=", self.acno),
             ("glt_curdt", "<=", self.perw),
             ("(", "glt_recon", "=", 0, "or", "glt_recon", ">", self.perw, ")"),
             ("glt_type", "=", 6)]
@@ -128,7 +128,7 @@
         col = ["grt_date", "grt_refno", "grt_memo", "grt_amount"]
         whr = [
             ("grt_cono", "=", self.opts["conum"]),
-            ("grt_acno", "=", self.acnow),
+            ("grt_acno", "=", self.acno),
             ("grt_date", "<=", dte),
             ("grt_flag", "=", "N")]
         odr = "grt_date, grt_refno"
@@ -140,10 +140,8 @@
     def printReport(self):
         p = ProgressBar(self.opts["mf"].body,
             mxs=(len(self.pays) + len(self.recs) + len(self.imps)))
-        self.head = ("%03u %-30s %39s %10s" % (self.opts["conum"],
-            self.opts["conam"], self.sysdttm, self.__class__.__name__))
-        self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
-        self.pgnum = 0
+        self.head = ("%03u %-30s" % (self.opts["conum"], self.opts["conam"]))
+        self.fpdf = MyFpdf(name=self.__class__.__name__, head=90, foot=True)
         self.pglin = 999
         self.tot_chq = 0
         self.tot_dep = 0
@@ -228,8 +226,8 @@
 
     def extractBalance(self):
         o = self.sql.getRec("genbal", cols=["glo_cyr"],
-            where=[("glo_cono", "=", self.opts["conum"]), ("glo_acno", "=",
-            self.acnow), ("glo_trdt", "=", self.opts["period"][1][0])],
+            where=[("glo_cono", "=", self.opts["conum"]), ("glo_acno",
+            "=", self.acno), ("glo_trdt", "=", self.opts["period"][1][0])],
             limit=1)
         if o:
             b = CCD(o[0], "SD", 13.2)
@@ -238,7 +236,7 @@
         self.bal = b.work
         o = self.sql.getRec("gentrn", cols=["round(sum(glt_tramt), 2)"],
             where=[("glt_cono", "=", self.opts["conum"]), ("glt_acno", "=",
-            self.acnow), ("glt_curdt", ">=", self.s_per), ("glt_curdt", "<=",
+            self.acno), ("glt_curdt", ">=", self.s_per), ("glt_curdt", "<=",
             self.perw)], limit=1)
         if o[0]:
             b = CCD(o[0], "SD", 13.2)
@@ -249,13 +247,11 @@
     def pageHeading(self):
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")
-        self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-38s %-7s %13s %-7s %10s %5s" % \
-            ("General Ledger Bank Reconciliation for", self.acnod,
-            "up to Period", self.perd, "Page", self.pgnum))
-        self.fpdf.underLine(txt=self.head)
+        self.fpdf.drawText("Bank Reconciliation for %s (%s) up to Period %s" %
+            (self.name, self.acno, self.perd))
+        self.fpdf.underLine()
         self.fpdf.setFont()
         self.pglin = 4
 

=== modified file 'gen/gl3090.py' (properties changed: -x to +x)
--- old/gen/gl3090.py	2020-03-01 12:48:20 +0000
+++ new/gen/gl3090.py	2020-04-30 11:12:44 +0000
@@ -103,7 +103,8 @@
         if self.to:
             des = "%s to %s" % (des, self.df.t_disp[0][0][2])
         hds.append(des)
-        col = ["grt_date", "grt_memo", "grt_refno", "grt_payee", "grt_amount"]
+        col = ["grt_date", "grt_memo", "grt_refno", "grt_payee",
+            "grt_flag", "grt_amount"]
         whr = [
             ("grt_cono", "=", self.opts["conum"]),
             ("grt_acno", "=", self.acnow)]

=== modified file 'gen/gl4010.py' (properties changed: -x to +x)
--- old/gen/gl4010.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl4010.py	2020-10-02 10:22:46 +0000
@@ -137,7 +137,7 @@
                 nam = mthnam[mon][1]
                 nam = nam + (" " * (11-len(nam))) + str(yer)
                 self.df.colLabel[1][x].configure(text=nam)
-            if x != 0 and x != 13:
+            if x not in (0, 13):
                 mon = mon + 1
                 if mon > 12:
                     mon = mon - 12
@@ -210,39 +210,39 @@
             self.obal = 0
         yre = self.e_per % 100
         if gt:
-            for x in xrange(len(gt)):
-                cyr = int(gt[x][1] / 100)
-                mon = gt[x][1] % 100
+            for x, t in enumerate(gt):
+                cyr = int(t[1] / 100)
+                mon = t[1] % 100
                 if adc and cyr == sy and mon in adc:
                     col = 1
                 else:
                     col = mon - yre
                     if col <= 0:
                         col = col + 12
-                act[col] = float(ASD(act[col]) + ASD(float(gt[x][2])))
-                act[13] = float(ASD(act[13]) + ASD(float(gt[x][2])))
+                act[col] = float(ASD(act[col]) + ASD(float(t[2])))
+                act[13] = float(ASD(act[13]) + ASD(float(t[2])))
         if gb:
-            for x in xrange(len(gb)):
-                mon = int(str(gb[x][0])[4:6])
+            for x, t in enumerate(gb):
+                mon = int(str(t[0])[4:6])
                 col = mon - yre
                 if col <= 0:
                     col = col + 12
-                bud[col] = float(ASD(bud[col]) + ASD(float(gb[x][1])))
-                bud[13] = float(ASD(bud[13]) + ASD(float(gb[x][1])))
+                bud[col] = float(ASD(bud[col]) + ASD(float(t[1])))
+                bud[13] = float(ASD(bud[13]) + ASD(float(t[1])))
         if self.opts["period"][0] and gl:
-            for x in xrange(len(gl)):
-                cyr = int(gl[x][0] / 100)
-                mon = gl[x][0] % 100
+            for x, t in enumerate(gl):
+                cyr = int(t[0] / 100)
+                mon = t[0] % 100
                 if adl and cyr == sy and mon in adl:
                     col = 1
                 else:
                     col = mon - yre
                     if col <= 0:
                         col = col + 12
-                lyr[col] = float(ASD(lyr[col]) + ASD(float(gl[x][1])))
-                lyr[13] = float(ASD(lyr[13]) + ASD(float(gl[x][1])))
+                lyr[col] = float(ASD(lyr[col]) + ASD(float(t[1])))
+                lyr[13] = float(ASD(lyr[13]) + ASD(float(t[1])))
         p = 0
-        for x in xrange(14):
+        for x in range(14):
             i = 0
             self.df.loadEntry("C", 1, p, data=act[x])
             p = p + 1
@@ -265,11 +265,6 @@
     def doTrans1(self):
         self.df.focusField("T", 2, 1)
 
-    def doPeriod(self, frt, pag, r, c, p, i, w):
-        if w != 0 and (w < self.i_per or w > self.e_per):
-            return "Invalid Period"
-        self.trnper = w
-
     def doTrans2(self):
         tit = "Transactions for Account: %s - %s" % (self.acno, self.desc)
         gtt = ["gentrn"]
@@ -320,8 +315,7 @@
         state = self.df.disableButtonsTags()
         while True:
             rec = SRec(self.opts["mf"], screen=self.df.nb.Page2, title=tit,
-                tables=gtt, cols=gtc, where=data, wtype="D", sort=False,
-                rows=15)
+                tables=gtt, cols=gtc, where=data, wtype="D", sort=False)
             # Display all transaction details
             if rec.selection:
                 self.df.setWidget(self.df.mstFrame, state="hide")
@@ -355,7 +349,9 @@
         r1s = (("Info","I"), ("Trans","T"))
         fld = (
             (("T",0,1,0),("IRB",r1s),0,"Selection","",
-                "I","N",self.doPrtSel,None,None,None),)
+                "I","N",self.doPrtSel,None,None,None),
+            (("T",0,2,0),"Id2",7,"Period (YYYYMM)","Financial Period (0=All)",
+                self.trnper,"Y",self.doPeriod,None,None,None))
         self.pr = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=fld, tend=((self.doPrtEnd,"y"),), txit=(self.doPrtExit,),
             view=("Y","V"), mail=("Y","N"))
@@ -364,15 +360,13 @@
 
     def doPrtSel(self, frt, pag, r, c, p, i, w):
         self.sel = w
+        for x in (2, 3):
+            if bool(self.sel == "I"):
+                self.pr.setWidget(self.pr.topEntry[0][2][x][0], state="hide")
+            else:
+                self.pr.setWidget(self.pr.topEntry[0][2][x][0], state="show")
         if self.sel == "I":
-            hide = True
-        else:
-            hide = False
-        for x in (2, 3):
-            if hide:
-                self.pr.setWidget(self.pr.topEntry[0][1][x][0], state="hide")
-            else:
-                self.pr.setWidget(self.pr.topEntry[0][1][x][0], state="show")
+            return "sk1"
 
     def doPrtEnd(self):
         self.pr.closeProcess()
@@ -411,7 +405,7 @@
                 lyr = self.df.c_disp[1][x][3]
                 self.fpdf.drawText("%-15s %-20s %-20s %-20s %-20s" % (mon,
                     act, bud, var, lyr))
-                if x == 0 or x == 12:
+                if x in (0, 12):
                     self.fpdf.drawText()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
                 self.__class__.__name__, self.opts["conum"], ext="pdf")
@@ -476,6 +470,11 @@
     def doPrtExit(self):
         self.pr.closeProcess()
 
+    def doPeriod(self, frt, pag, r, c, p, i, w):
+        if w != 0 and (w < self.i_per or w > self.e_per):
+            return "Invalid Period"
+        self.trnper = w
+
     def pageHeading(self):
         self.fpdf.add_page()
         self.fpdf.setFont(style="B")

=== modified file 'gen/gl4020.py' (properties changed: -x to +x)
--- old/gen/gl4020.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl4020.py	2020-10-02 10:22:53 +0000
@@ -46,8 +46,9 @@
             return
         self.gldep = ctlsys["sys_gl_dep"]
         self.gldig = ctlsys["sys_gl_dig"]
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "genbal", "genbud",
-            "genmst", "genrpt", "gentrn"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "ctldep", "genbal",
+            "genbud", "genmst", "genrpt", "gentrn"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         if self.gldep == "Y":
@@ -89,6 +90,7 @@
                 ("glr_type", "in", ("P", "B", "O"))],
             "group": "glr_repno, glr_type, glr_desc"}
         r1s = (("Yes","Y"),("No","N"))
+        r2s = (("Budget","B"),("Last Year","L"))
         fld = [(("T",0,0,0),"ID2",7,"Ending Period","Ending Period (YYYYMM)",
             self.e_per,"Y",self.doRepPer,None,None,None)]
         if self.cons:
@@ -104,12 +106,14 @@
                 "Department Number or 0 for All Departments"))
             x += 1
         fld.extend([
-            (("T",0,x,0),"IUI",3,"Report Number","",
-                1,"Y",self.doRepNum,rpt,None,("notzero",)),
-            (("T",0,x+1,0),("IRB",r1s),0,"General Report","General Report",
+            (("T",0,x,0),("IRB",r2s),0,"Variance","",
+                "B","Y",self.doRepVar,None,None,None),
+            (("T",0,x+1,0),"IUI",3,"Report Number","",
+                1,"N",self.doRepNum,rpt,None,("notzero",)),
+            (("T",0,x+2,0),("IRB",r1s),0,"General Report","",
                 "N","N",self.doRepGen,None,None,None),
-            (("T",0,x+2,0),("IRB",r1s),0,"Ignore Zeros","",
-                "Y","Y",self.doIgnore,None,None,None)])
+            (("T",0,x+3,0),("IRB",r1s),0,"Ignore Zeros","",
+                "Y","N",self.doIgnore,None,None,None)])
         tnd = ((self.doMainEnd,"y"), )
         txt = (self.doMainExit, )
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
@@ -121,6 +125,17 @@
         self.end = w
         self.mths = dateDiff(self.opts["period"][1][0],
             mthendDate((self.end * 100) + 1), "months") + 1
+        bud = self.sql.getRec("genbud", where=[("glb_cono", "=",
+            self.opts["conum"]), ("glb_curdt", "between", self.s_per,
+            self.end)])
+        if self.cons:
+            x = 2
+        else:
+            x = 1
+        if bud:
+            self.df.topf[pag][x][5] = "B"
+        else:
+            self.df.topf[pag][x][5] = "L"
 
     def doCons(self, frt, pag, r, c, p, i, w):
         self.con = w
@@ -139,6 +154,9 @@
             self.depnam = chk[0]
         self.dep = w
 
+    def doRepVar(self, frt, pag, r, c, p, i, w):
+        self.repvar = w
+
     def doRepNum(self, frt, pag, r, c, p, i, w):
         if self.con == "Y":
             whr = [
@@ -155,8 +173,8 @@
             return "Invalid Report Number"
         self.rep = w
         self.gen = "N"
-        for c in chk:
-            if c[0] == 0:
+        for ck in chk:
+            if ck[0] == 0:
                 self.gen = "Y"
                 if self.con == "Y":
                     break
@@ -584,9 +602,15 @@
             self.lyr[1] = float(ASD(self.lyr[1]) + ASD(o_lyr))
             self.lyr[self.mths + 1] = float(ASD(self.lyr[self.mths + 1]) +
                 ASD(o_lyr))
-            self.var[1] = float(ASD(self.var[1]) - ASD(self.o_cyr))
-            self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) -
-                ASD(self.o_cyr))
+            if self.repvar == "B":
+                self.var[1] = float(ASD(self.var[1]) - ASD(self.o_cyr))
+                self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) -
+                    ASD(self.o_cyr))
+            else:
+                self.var[1] = float(ASD(self.var[1]) - ASD(self.o_cyr) +
+                    ASD(o_lyr))
+                self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) -
+                    ASD(self.o_cyr) + ASD(o_lyr))
             if not exists:
                 trn = [0, 0, int(self.opts["period"][1][0] / 100),
                     self.opts["period"][1][0], 4, "O/Balance", "B/Fwd",
@@ -615,9 +639,14 @@
             self.bud[mth] = float(ASD(self.bud[mth]) + ASD(bud))
             self.bud[self.mths + 1] = float(ASD(self.bud[self.mths + 1]) +
                 ASD(bud))
-            self.var[mth] = float(ASD(self.var[mth]) + ASD(bud) - ASD(cyr))
-            self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) +
-                ASD(bud) - ASD(cyr))
+            if self.repvar == "B":
+                self.var[mth] = float(ASD(self.var[mth]) + ASD(bud) - ASD(cyr))
+                self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) +
+                    ASD(bud) - ASD(cyr))
+            else:
+                self.var[mth] = float(ASD(self.var[mth]) + ASD(lyr) - ASD(cyr))
+                self.var[self.mths + 1] = float(ASD(self.var[self.mths + 1]) +
+                    ASD(lyr) - ASD(cyr))
             y = int(curdt / 100)
             m = (curdt % 100) + 1
             if m > 12:
@@ -818,7 +847,10 @@
         cols[0].append(("Year-Total", 3))
         for _ in xrange(0, self.mths + 1):
             cols[1].append(("%9s " % "Actual", ("SI", 11)))
-            cols[1].append(("%9s " % "Budget", ("SI", 11)))
+            if self.repvar == "B":
+                cols[1].append(("%9s " % "Budget", ("SI", 11)))
+            else:
+                cols[1].append(("%9s " % "Last-Year", ("SI", 11)))
             cols[1].append(("%9s " % "Variance", ("SI", 11)))
         self.data = []
         self.count = 0
@@ -868,11 +900,17 @@
         for x in xrange(1, self.mths + 2):
             if line[0] == "T":
                 col.append((line[2][x], None))
-                col.append((line[4][x], None))
+                if self.repvar == "B":
+                    col.append((line[4][x], None))
+                else:
+                    col.append((line[3][x], None))
                 col.append((line[5][x], None))
             else:
                 col.append((line[2][x], "actual"))
-                col.append((line[4][x], "budget"))
+                if self.repvar == "B":
+                    col.append((line[4][x], "budget"))
+                else:
+                    col.append((line[3][x], "budget"))
                 col.append((line[5][x], "variance"))
         self.data.append((lab, col))
 
@@ -933,7 +971,7 @@
                 dr, cr, acctot,
                 rec[glc.index("glt_desc")]])
         rec = SRec(self.opts["mf"], screen=None, title=tit, tables=gtt,
-            cols=gtc, where=data, wtype="D", sort=False, rows=15)
+            cols=gtc, where=data, wtype="D", sort=False)
 
     def doMainExit(self):
         self.df.closeProcess()

=== modified file 'gen/gl6010.py' (properties changed: -x to +x)
--- old/gen/gl6010.py	2020-04-21 08:42:36 +0000
+++ new/gen/gl6010.py	2020-04-25 14:15:53 +0000
@@ -46,6 +46,7 @@
             ("bkmunm", "bum_cono", "bum_slsa"),
             ("crsctl", "ctc_cono", "ctc_bankac"),
             ("crsmst", "crm_cono", "crm_glac"),
+            ("cshana", "can_cono", "can_code"),
             ("ctlctl", "ctl_cono", "ctl_conacc"),
             ("ctldep", "dep_dr_coy", "dep_dr_sal"),
             ("ctldep", "dep_dr_coy", "dep_dr_com"),

=== modified file 'gen/gl6020.py' (properties changed: -x to +x)
=== modified file 'gen/gl6030.py' (properties changed: -x to +x)
=== modified file 'gen/gl6040.py' (properties changed: -x to +x)
=== modified file 'gen/gl6050.py' (properties changed: -x to +x)
=== modified file 'gen/gl6060.py' (properties changed: -x to +x)
=== modified file 'gen/gl6070.py' (properties changed: -x to +x)
=== modified file 'gen/gl6080.py' (properties changed: -x to +x)
=== modified file 'gen/glc110.py' (properties changed: -x to +x)
--- old/gen/glc110.py	2020-04-21 08:42:36 +0000
+++ new/gen/glc110.py	2020-04-25 06:53:35 +0000
@@ -253,6 +253,7 @@
             self.dtefmt = "N"
             self.df.loadEntry(frt, pag, p+1, data=self.dtefmt)
             return "nd"
+        self.df.loadEntry(frt, pag, p+1, data="A")
 
     def doDteFmt(self, frt, pag, r, c, p, i, w):
         if w not in ("A", "B", "C"):
@@ -265,8 +266,10 @@
         if self.new == "y":
             self.sql.insRec("ctlctl", data=data)
         elif data != self.acc[:len(data)]:
-            self.sql.updRec("ctlctl", data=data, where=[("ctl_cono", "=",
-            self.opts["conum"]), ("ctl_code", "=", self.code)])
+            col = self.sql.ctlctl_col
+            data.append(self.acc[col.index("ctl_xflag")])
+            self.sql.updRec("ctlctl", data=data, where=[("ctl_cono",
+                "=", self.opts["conum"]), ("ctl_code", "=", self.code)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'gen/glc210.py' (properties changed: -x to +x)
--- old/gen/glc210.py	2020-04-21 08:42:36 +0000
+++ new/gen/glc210.py	2020-04-23 10:08:14 +0000
@@ -167,11 +167,15 @@
         if self.new1 == "y":
             self.sql.insRec("genint", data=data1)
         elif data1 != self.acc1[:len(data1)]:
+            col = self.sql.genint_col
+            data1.append(self.acc1[col.index("cti_xflag")])
             self.sql.updRec("genint", data=data1, where=[("cti_cono", "=",
                 self.opts["conum"]), ("cti_inco", "=", self.cono2)])
         if self.new2 == "y":
             self.sql.insRec("genint", data=data2)
         elif data2 != self.acc2[:len(data2)]:
+            col = self.sql.genint_col
+            data2.append(self.acc2[col.index("cti_xflag")])
             self.sql.updRec("genint", data=data2, where=[("cti_cono", "=",
                 self.cono2), ("cti_inco", "=", self.opts["conum"])])
         self.opts["mf"].dbm.commitDbase()

=== removed directory 'ibt'
=== removed directory 'img'
=== removed file 'img/about.png'
Binary files old/img/about.png	2019-01-13 16:38:59 +0000 and new/img/about.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/account.png'
Binary files old/img/account.png	2019-01-13 16:38:59 +0000 and new/img/account.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/age.png'
Binary files old/img/age.png	2019-01-13 16:38:59 +0000 and new/img/age.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/auto.png'
Binary files old/img/auto.png	2019-01-13 16:38:59 +0000 and new/img/auto.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/backup.png'
Binary files old/img/backup.png	2019-01-13 16:38:59 +0000 and new/img/backup.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/books.png'
Binary files old/img/books.png	2019-01-13 16:38:59 +0000 and new/img/books.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/bottom.png'
Binary files old/img/bottom.png	2019-01-13 16:38:59 +0000 and new/img/bottom.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/bounce.png'
Binary files old/img/bounce.png	2019-01-13 16:38:59 +0000 and new/img/bounce.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/bowls.png'
Binary files old/img/bowls.png	2019-01-13 16:38:59 +0000 and new/img/bowls.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/calendar.png'
Binary files old/img/calendar.png	2019-01-13 16:38:59 +0000 and new/img/calendar.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/cash.png'
Binary files old/img/cash.png	2019-01-13 16:38:59 +0000 and new/img/cash.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/ccard.png'
Binary files old/img/ccard.png	2020-03-01 12:48:20 +0000 and new/img/ccard.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/check.gif'
Binary files old/img/check.gif	2015-04-10 10:19:18 +0000 and new/img/check.gif	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/clear.png'
Binary files old/img/clear.png	2019-01-13 16:38:59 +0000 and new/img/clear.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/close.png'
Binary files old/img/close.png	2019-01-13 16:38:59 +0000 and new/img/close.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/connect.png'
Binary files old/img/connect.png	2019-01-13 16:38:59 +0000 and new/img/connect.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/convert.png'
Binary files old/img/convert.png	2019-01-13 16:38:59 +0000 and new/img/convert.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/copy.png'
Binary files old/img/copy.png	2019-01-13 16:38:59 +0000 and new/img/copy.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/cut.png'
Binary files old/img/cut.png	2019-01-13 16:38:59 +0000 and new/img/cut.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/disconnect.png'
Binary files old/img/disconnect.png	2019-01-13 16:38:59 +0000 and new/img/disconnect.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/discount.png'
Binary files old/img/discount.png	2019-02-24 15:37:36 +0000 and new/img/discount.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/down.png'
Binary files old/img/down.png	2019-01-13 16:38:59 +0000 and new/img/down.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/edit.png'
Binary files old/img/edit.png	2019-01-13 16:38:59 +0000 and new/img/edit.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/email.png'
Binary files old/img/email.png	2019-01-13 16:38:59 +0000 and new/img/email.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/end.png'
Binary files old/img/end.png	2019-01-13 16:38:59 +0000 and new/img/end.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/enter.png'
Binary files old/img/enter.png	2019-01-13 16:38:59 +0000 and new/img/enter.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/entries.png'
Binary files old/img/entries.png	2019-01-13 16:38:59 +0000 and new/img/entries.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/error.png'
Binary files old/img/error.png	2019-01-13 16:38:59 +0000 and new/img/error.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/execute.png'
Binary files old/img/execute.png	2019-01-13 16:38:59 +0000 and new/img/execute.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/exit.png'
Binary files old/img/exit.png	2019-01-13 16:38:59 +0000 and new/img/exit.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/export.png'
Binary files old/img/export.png	2019-01-13 16:38:59 +0000 and new/img/export.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/filter.png'
Binary files old/img/filter.png	2019-01-13 16:38:59 +0000 and new/img/filter.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/find.png'
Binary files old/img/find.png	2019-01-13 16:38:59 +0000 and new/img/find.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/first.png'
Binary files old/img/first.png	2019-01-13 16:38:59 +0000 and new/img/first.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/gnu-head.png'
Binary files old/img/gnu-head.png	2019-01-13 16:38:59 +0000 and new/img/gnu-head.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/groups.png'
Binary files old/img/groups.png	2019-01-13 16:38:59 +0000 and new/img/groups.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/gtk.png'
Binary files old/img/gtk.png	2019-01-13 16:38:59 +0000 and new/img/gtk.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/help.png'
Binary files old/img/help.png	2019-01-13 16:38:59 +0000 and new/img/help.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/home.png'
Binary files old/img/home.png	2019-01-13 16:38:59 +0000 and new/img/home.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/import.png'
Binary files old/img/import.png	2019-01-13 16:38:59 +0000 and new/img/import.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/info.png'
Binary files old/img/info.png	2019-01-13 16:38:59 +0000 and new/img/info.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/insert.png'
Binary files old/img/insert.png	2019-01-13 16:38:59 +0000 and new/img/insert.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/last.png'
Binary files old/img/last.png	2019-01-13 16:38:59 +0000 and new/img/last.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/ledger.png'
Binary files old/img/ledger.png	2019-01-13 16:38:59 +0000 and new/img/ledger.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/left.png'
Binary files old/img/left.png	2019-01-13 16:38:59 +0000 and new/img/left.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/message.png'
Binary files old/img/message.png	2019-01-13 16:38:59 +0000 and new/img/message.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/network.png'
Binary files old/img/network.png	2019-01-13 16:38:59 +0000 and new/img/network.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/new.png'
Binary files old/img/new.png	2019-01-13 16:38:59 +0000 and new/img/new.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/no.png'
Binary files old/img/no.png	2019-01-13 16:38:59 +0000 and new/img/no.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/ok.png'
Binary files old/img/ok.png	2019-01-13 16:38:59 +0000 and new/img/ok.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/open.png'
Binary files old/img/open.png	2019-01-13 16:38:59 +0000 and new/img/open.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/paste.png'
Binary files old/img/paste.png	2019-01-13 16:38:59 +0000 and new/img/paste.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/populate.png'
Binary files old/img/populate.png	2019-01-13 16:38:59 +0000 and new/img/populate.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/postgresql.png'
Binary files old/img/postgresql.png	2019-01-13 16:38:59 +0000 and new/img/postgresql.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/preferences.png'
Binary files old/img/preferences.png	2019-01-13 16:38:59 +0000 and new/img/preferences.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/preview.png'
Binary files old/img/preview.png	2019-01-13 16:38:59 +0000 and new/img/preview.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/print.png'
Binary files old/img/print.png	2019-01-13 16:38:59 +0000 and new/img/print.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/process.png'
Binary files old/img/process.png	2019-01-13 16:38:59 +0000 and new/img/process.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/question.png'
Binary files old/img/question.png	2019-01-13 16:38:59 +0000 and new/img/question.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/quit.png'
Binary files old/img/quit.png	2019-01-13 16:38:59 +0000 and new/img/quit.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/refund.png'
Binary files old/img/refund.png	2019-01-13 16:38:59 +0000 and new/img/refund.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/reorder.png'
Binary files old/img/reorder.png	2019-01-13 16:38:59 +0000 and new/img/reorder.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/restore.png'
Binary files old/img/restore.png	2019-01-13 16:38:59 +0000 and new/img/restore.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/results.png'
Binary files old/img/results.png	2019-01-13 16:38:59 +0000 and new/img/results.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/ribbon.png'
Binary files old/img/ribbon.png	2019-01-13 16:38:59 +0000 and new/img/ribbon.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/right.png'
Binary files old/img/right.png	2019-01-13 16:38:59 +0000 and new/img/right.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/save.png'
Binary files old/img/save.png	2019-01-13 16:38:59 +0000 and new/img/save.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/send.png'
Binary files old/img/send.png	2019-01-13 16:38:59 +0000 and new/img/send.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/show.png'
Binary files old/img/show.png	2019-01-13 16:38:59 +0000 and new/img/show.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/stop.png'
Binary files old/img/stop.png	2019-01-13 16:38:59 +0000 and new/img/stop.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/tartan.ico'
Binary files old/img/tartan.ico	2014-03-28 07:32:49 +0000 and new/img/tartan.ico	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/tartan.png'
Binary files old/img/tartan.png	2015-04-02 19:32:07 +0000 and new/img/tartan.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/tarupd.png'
Binary files old/img/tarupd.png	2019-01-13 16:38:59 +0000 and new/img/tarupd.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/tcltk.png'
Binary files old/img/tcltk.png	2019-01-13 16:38:59 +0000 and new/img/tcltk.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/teams.png'
Binary files old/img/teams.png	2019-01-13 16:38:59 +0000 and new/img/teams.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/top.png'
Binary files old/img/top.png	2019-01-13 16:38:59 +0000 and new/img/top.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/trash.png'
Binary files old/img/trash.png	2019-07-03 13:49:08 +0000 and new/img/trash.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/truck.png'
Binary files old/img/truck.png	2019-01-13 16:38:59 +0000 and new/img/truck.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/uncheck.gif'
Binary files old/img/uncheck.gif	2015-04-10 10:19:18 +0000 and new/img/uncheck.gif	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/undo.png'
Binary files old/img/undo.png	2019-01-13 16:38:59 +0000 and new/img/undo.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/up.png'
Binary files old/img/up.png	2019-01-13 16:38:59 +0000 and new/img/up.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/update.png'
Binary files old/img/update.png	2019-01-13 16:38:59 +0000 and new/img/update.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/users.png'
Binary files old/img/users.png	2019-01-13 16:38:59 +0000 and new/img/users.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/voucher.png'
Binary files old/img/voucher.png	2019-01-13 16:38:59 +0000 and new/img/voucher.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/warning.png'
Binary files old/img/warning.png	2019-01-13 16:38:59 +0000 and new/img/warning.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/white.png'
Binary files old/img/white.png	2019-01-13 16:38:59 +0000 and new/img/white.png	1970-01-01 00:00:00 +0000 differ
=== removed file 'img/yes.png'
Binary files old/img/yes.png	2019-01-13 16:38:59 +0000 and new/img/yes.png	1970-01-01 00:00:00 +0000 differ
=== added file 'lon/__init__.py'
=== modified file 'lon/ln1010.py' (properties changed: -x to +x)
--- old/lon/ln1010.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln1010.py	2020-04-24 11:10:20 +0000
@@ -39,7 +39,7 @@
                 self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "lonmf1"],
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "lonmf1", "lonmf2"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -143,9 +143,9 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.delRec("lonmf1", where=[("lm1_cono", "=", self.opts["conum"]),
             ("lm1_acno", "=", self.acno)])
-        self.sql.insRec("chglog", data=["lonmf1", "D", "%03i%-7s" % \
+        self.sql.insRec("chglog", data=["lonmf1", "D", "%03i%-7s" %
             (self.opts["conum"], self.acno), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -162,14 +162,16 @@
         if self.newacc:
             self.sql.insRec("lonmf1", data=data)
         elif data != self.oldacc[:len(data)]:
+            col = self.sql.lonmf1_col
+            data.append(self.oldacc[col.index("lm1_xflag")])
             self.sql.updRec("lonmf1", data=data, where=[("lm1_cono", "=",
                 self.opts["conum"]), ("lm1_acno", "=", self.acno)])
             for num, dat in enumerate(self.oldacc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["lonmf1", "U",
                         "%03i%-7s" % (self.opts["conum"], self.acno),
-                        self.sql.lonmf1_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         if "args" in self.opts:
             self.doExit()
         else:

=== modified file 'lon/ln2010.py' (properties changed: -x to +x)
--- old/lon/ln2010.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln2010.py	2020-07-28 08:27:23 +0000
@@ -100,7 +100,8 @@
             "tables": ("lonmf1",),
             "cols": (
                 ("lm1_acno", "", 0, "Acc-Num"),
-                ("lm1_name", "", 0, "Name", "Y"))}
+                ("lm1_name", "", 0, "Name", "Y")),
+            "where": [("lm1_cono", "=", self.opts["conum"])]}
         lm2 = {
             "stype": "R",
             "tables": ("lonmf2",),

=== modified file 'lon/ln2020.py' (properties changed: -x to +x)
=== modified file 'lon/ln2030.py' (properties changed: -x to +x)
=== modified file 'lon/ln3010.py' (properties changed: -x to +x)
--- old/lon/ln3010.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln3010.py	2020-05-27 12:28:33 +0000
@@ -167,8 +167,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'lon/ln3020.py' (properties changed: -x to +x)
--- old/lon/ln3020.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln3020.py	2020-05-27 12:28:45 +0000
@@ -172,8 +172,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Loans's Ledger Audit Trail for Period "\
             "%s to %s" % (self.sdatd, self.edatd))
@@ -262,8 +261,7 @@
             self.typeTotal()
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'lon/ln3030.py' (properties changed: -x to +x)
--- old/lon/ln3030.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln3030.py	2020-05-27 12:28:51 +0000
@@ -169,8 +169,7 @@
             else:
                 self.fpdf.drawText("%8s%-74s%13s" % ("", "Totals", ltot.disp))
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'lon/ln3040.py' (properties changed: -x to +x)
--- old/lon/ln3040.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln3040.py	2020-05-27 12:00:55 +0000
@@ -54,8 +54,9 @@
         self.curdt = int(self.sysdtw / 100)
         self.sper = int(self.opts["period"][1][0] / 100)
         self.eper = int(self.opts["period"][2][0] / 100)
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlmes", "ctlmst", "lonmf1",
-            "lonmf2", "lontrn", "tplmst"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmes", "ctlmst", "ctlynd",
+            "lonmf1", "lonmf2", "lontrn", "tplmst"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         return True
@@ -223,17 +224,17 @@
             if self.capb == "A":                        # Anniversary
                 fcap = [lm2[l2c.index("lm2_start")], 0]
                 if self.capf == "A":
-                    fcap[1] = projectDate(fcap[1], 1, typ="years")
+                    fcap[1] = projectDate(fcap[0], 1, typ="years")
                 else:
-                    fcap[1] = projectDate(fcap[1], 6, typ="months")
+                    fcap[1] = projectDate(fcap[0], 6, typ="months")
             else:                                       # Financial
                 periods = self.sql.getRec("ctlynd",
                     cols=["cye_period", "cye_start", "cye_end"],
                     where=[("cye_cono", "=", self.opts["conum"])],
                     order="cye_period")
                 fcap = [periods[0][1], periods[0][2]]
-            if self.capf == "B":                        # Bi-Annual
-                fcap[1] = projectDate(fcap[1], -6, typ="months")
+                if self.capf == "B":                    # Bi-Annual
+                    fcap[1] = projectDate(fcap[1], -6, typ="months")
             capdt = [copyList(fcap)]
             while fcap[1] < self.date.work:
                 if self.capf == "A":
@@ -323,8 +324,7 @@
         else:
             key = "%s_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-            ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.date.disp),

=== modified file 'lon/ln3050.py' (properties changed: -x to +x)
=== modified file 'lon/ln4010.py' (properties changed: -x to +x)
--- old/lon/ln4010.py	2020-04-21 08:42:36 +0000
+++ new/lon/ln4010.py	2020-05-27 12:28:56 +0000
@@ -297,8 +297,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
@@ -336,6 +335,10 @@
             self.fpdf.drawText("%-5s %-20s %-25s %s" % ("", "",
                 self.df.topf[1][x][3], self.df.t_disp[1][0][x]))
         self.fpdf.drawText()
+        for x in xrange(0, len(self.df.topf[2])):
+            self.fpdf.drawText("%-5s %-20s %-25s %s" % ("", "",
+                self.df.topf[2][x][3], self.df.t_disp[2][0][x]))
+        self.fpdf.drawText()
 
     def printTrans(self):
         whr = [

=== modified file 'lon/ln6010.py' (properties changed: -x to +x)
=== modified file 'lon/lnc110.py' (properties changed: -x to +x)
--- old/lon/lnc110.py	2020-04-21 08:42:36 +0000
+++ new/lon/lnc110.py	2020-04-29 16:00:45 +0000
@@ -129,7 +129,7 @@
             (("T",0,seq + 6,0),"INA",20,"Statement Template","",
                 self.acc[8],"N",self.doTplNam,tpm,None,("efld",)),
             (("T",0,seq + 7,0),"ITX",50,"Email Address","",
-                self.acc[9],"N",None,None,None,None)])
+                self.acc[9],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -206,14 +206,17 @@
         if self.new:
             self.sql.insRec("lonctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.lonctl_col
+            data.append(self.acc[col.index("cln_xflag")])
             self.sql.updRec("lonctl", data=data, where=[("cln_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["lonctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.lonctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== added file 'mem/__init__.py'
=== modified file 'mem/ml1010.py' (properties changed: -x to +x)
--- old/mem/ml1010.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml1010.py	2020-07-13 10:18:07 +0000
@@ -38,7 +38,7 @@
 from TartanClasses import TartanDialog
 from tartanFunctions import askChoice, askQuestion, callModule, copyList
 from tartanFunctions import dateDiff, doChkCatChg, doPrinter, getModName
-from tartanFunctions import getTrn, getVatRate, luhnFunc, mthendDate, showError
+from tartanFunctions import getTrn, getVatRate, mthendDate, showError
 from tartanFunctions import showWarning
 from tartanWork import countries, mltrtp
 
@@ -109,8 +109,6 @@
             self.photo = os.environ["PHOTODIR"]
         else:
             self.photo = memctl["mcm_photo"]
-        if not os.path.isdir(self.photo):
-            self.photo = os.path.join(self.opts["mf"].rcdic["prgdir"], "img")
         tst = self.sql.getRec("memmst", cols=["count(*)"],
             where=[("mlm_cono", "=", self.opts["conum"]),
             ("mlm_oldno", "<>", 0)], limit=1)
@@ -231,7 +229,7 @@
                 "","N",self.doDOB,None,None,("efld",)),
             (("T",1,3,37,40),"OUI",3,"Age"),
             (("T",1,4,0),"I@mlm_idnum",0,"","",
-                "","N",self.doID,None,None,("efld",)),
+                "","N",self.doID,None,None,("idno",)),
             (("T",1,5,0),"I@mlm_occup",0,"","",
                 "","N",self.doOccCode,occ,None,("efld",)),
             (("T",1,5,0),"INA",30,"","",
@@ -548,20 +546,20 @@
             "mck_desc", "mlk_detail"], where=[("mlk_cono", "=",
             self.opts["conum"]), ("mlk_memno", "=", self.memno),
             ("mck_code=mlk_code",)])
-        for n, c in enumerate(acc):
+        for n, a in enumerate(acc):
             self.df.loadEntry("C", 3, (n * 4), data=n)
-            self.df.loadEntry("C", 3, ((n * 4) + 1), data=c[0])
-            self.df.loadEntry("C", 3, ((n * 4) + 2), data=c[1])
-            self.df.loadEntry("C", 3, ((n * 4) + 3), data=c[2])
+            self.df.loadEntry("C", 3, ((n * 4) + 1), data=a[0])
+            self.df.loadEntry("C", 3, ((n * 4) + 2), data=a[1])
+            self.df.loadEntry("C", 3, ((n * 4) + 3), data=a[2])
             self.df.loadEntry("T", 3, 0, data=n+1)
         # memcat table
-        for n, c in enumerate(self.memcat):
-            ctyp = c[self.sql.memcat_col.index("mlc_type")]
-            code = c[self.sql.memcat_col.index("mlc_code")]
-            note = c[self.sql.memcat_col.index("mlc_note")]
-            start = c[self.sql.memcat_col.index("mlc_start")]
-            end = c[self.sql.memcat_col.index("mlc_end")]
-            last = c[self.sql.memcat_col.index("mlc_last")]
+        for n, m in enumerate(self.memcat):
+            ctyp = m[self.sql.memcat_col.index("mlc_type")]
+            code = m[self.sql.memcat_col.index("mlc_code")]
+            note = m[self.sql.memcat_col.index("mlc_note")]
+            start = m[self.sql.memcat_col.index("mlc_start")]
+            end = m[self.sql.memcat_col.index("mlc_end")]
+            last = m[self.sql.memcat_col.index("mlc_last")]
             acc = self.sql.getRec("memctc", cols=["mcc_freq",
                 "mcc_desc"], where=[("mcc_cono", "=", self.opts["conum"]),
                 ("mcc_type", "=", ctyp), ("mcc_code", "=", code)],
@@ -585,13 +583,13 @@
         memlnk = self.sql.getRec("memlnk", cols=["mll_lnkno"],
             where=[("mll_cono", "=", self.opts["conum"]), ("mll_memno", "=",
             self.memno)], order="mll_lnkno")
-        for n, c in enumerate(memlnk):
+        for n, k in enumerate(memlnk):
             acc = self.sql.getRec("memmst", cols=["mlm_title",
                 "mlm_surname", "mlm_names"], where=[("mlm_cono", "=",
-                self.opts["conum"]), ("mlm_memno", "=", c[0])], limit=1)
+                self.opts["conum"]), ("mlm_memno", "=", k[0])], limit=1)
             if acc:
                 self.df.loadEntry("C", 5, (n * 5), data=n)
-                self.df.loadEntry("C", 5, ((n * 5) + 1), data=c[0])
+                self.df.loadEntry("C", 5, ((n * 5) + 1), data=k[0])
                 self.df.loadEntry("C", 5, ((n * 5) + 2), data=acc[0])
                 self.df.loadEntry("C", 5, ((n * 5) + 3), data=acc[1])
                 self.df.loadEntry("C", 5, ((n * 5) + 4), data=acc[2])
@@ -671,10 +669,7 @@
             nxt = False
         else:
             dte = False
-            if self.ynd or freq == "M":
-                nxt = True
-            else:
-                nxt = False
+            nxt = bool(self.ynd or freq == "M")
             if not last:
                 if dateDiff(start, self.tme, "days") > self.ldays:
                     dte = True
@@ -790,10 +785,8 @@
         if not w and self.nation == "ZA":
             return "Invalid Identity Number 1"
         if w:
-            if self.dob % 1000000 != int(w / 10000000):
+            if self.dob % 1000000 != int(int(w) / 10000000):
                 return "Invalid Identity Number 2"
-            if not luhnFunc(w):
-                return "Invalid Identity Number 3"
             whr = [("mlm_cono", "=", self.opts["conum"])]
             if not self.new:
                 whr.append(("mlm_memno", "<>", self.memno))
@@ -1069,10 +1062,10 @@
                 self.df.disableTag(num)
 
     def doSetNextSeq(self):
-        for pag in xrange(3, 6):
-            d = self.df.c_work[pag]
-            for seq in xrange(0, len(d)):
-                if not d[seq][1]:
+        for pag in range(3, 6):
+            data = self.df.c_work[pag]
+            for seq, dat in enumerate(data):
+                if not dat[1]:
                     break
             self.df.loadEntry("T", pag, 0, data=seq)
 
@@ -1101,7 +1094,8 @@
                         self.df.selPage(self.df.tags[pag - 1][0])
                     self.df.focusField(frt, pag, (pos+1), err=mes)
                     return
-            if self.idnum and self.dob % 1000000 != int(self.idnum / 10000000):
+            if self.idnum and self.nation == "ZA" and \
+                    self.dob % 1000000 != int(int(self.idnum) / 10000000):
                 self.df.selPage("Personal")
                 self.df.focusField("T", 1, 7, err="Invalid Identity Number")
                 return
@@ -1130,15 +1124,16 @@
             if self.new:
                 self.sql.insRec("memmst", data=memmst)
             elif memmst != self.memmst[:len(memmst)]:
+                col = self.sql.memmst_col
+                memmst.append(self.memmst[col.index("mlm_xflag")])
                 self.sql.updRec("memmst", data=memmst, where=[("mlm_cono",
                     "=", self.opts["conum"]), ("mlm_memno", "=", self.memno)])
                 for num, dat in enumerate(self.memmst):
                     if dat != memmst[num]:
                         self.sql.insRec("chglog", data=["memmst", "U",
                             "%03i%06i" % (self.opts["conum"], self.memno),
-                            self.sql.memmst_col[num], dte,
-                            self.opts["capnm"], str(dat),
-                            str(memmst[num]), 0])
+                            col[num], dte, self.opts["capnm"], str(dat),
+                            str(memmst[num]), "", 0])
             # memcto table
             if self.newocc:
                 self.sql.insRec("memcto", data=[self.occup, self.newocc])
@@ -1182,8 +1177,8 @@
                         new[7] = old[7]
                         break
                 self.sql.insRec("memcat", data=new)
-            memcat = self.sql.getRec("memcat", where=[("mlc_cono",
-                "=", self.opts["conum"]), ("mlc_memno", "=", self.memno)],
+            memcat = self.sql.getRec("memcat", where=[("mlc_cono", "=",
+                self.opts["conum"]), ("mlc_memno", "=", self.memno)],
                 order="mlc_type, mlc_code")
             if memcat != self.memcat:
                 newcat = copyList(memcat)
@@ -1198,24 +1193,24 @@
                                     "U", "%03i%06i%1s%02i" % (ocono, omemno,
                                     otype, ocode), "mlc_start", dte,
                                     self.opts["capnm"], str(ostart),
-                                    str(nstart), 0])
+                                    str(nstart), "", 0])
                             if oend != nend:
                                 self.sql.insRec("chglog", data=["memcat",
                                     "U", "%03i%06i%1s%02i" % (ocono, omemno,
                                     otype, ocode), "mlc_end", dte,
                                     self.opts["capnm"], str(oend),
-                                    str(nend), 0])
+                                    str(nend), "", 0])
                             oldcat.remove(old)
                             memcat.remove(new)
                             break
                 for cono, memno, ctype, code, note, start, end, x, y in oldcat:
                     self.sql.insRec("chglog", data=["memcat", "D",
-                        "%03i%06i%1s%02i" % (cono, memno, ctype, code),
-                        "", dte, self.opts["capnm"], str(start), str(end), 0])
+                        "%03i%06i%1s%02i" % (cono, memno, ctype, code), "",
+                        dte, self.opts["capnm"], str(start), str(end), "", 0])
                 for cono, memno, ctype, code, note, start, end, x, y in memcat:
                     self.sql.insRec("chglog", data=["memcat", "N",
-                        "%03i%06i%1s%02i" % (cono, memno, ctype, code),
-                        "", dte, self.opts["capnm"], str(start), str(end), 0])
+                        "%03i%06i%1s%02i" % (cono, memno, ctype, code), "",
+                        dte, self.opts["capnm"], str(start), str(end), "", 0])
             # memlnk table
             self.sql.delRec("memlnk", where=[("mll_cono", "=",
                 self.opts["conum"]), ("mll_memno", "=", self.memno)])
@@ -1433,7 +1428,7 @@
                 ("mlm_memno", "=", self.memno)]
             TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
                 name=self.__class__.__name__, tabs=table, where=whr,
-                    keys=[self.memno])
+                keys=[self.memno])
         elif opt == "T":
             name = "%s %s %s" % (self.title, self.initial, self.surname)
             heads = ["Member's Transactions",
@@ -1462,9 +1457,9 @@
             prtdia = (("Y","V"),("Y","N"))
             RepPrt(self.opts["mf"], conum=self.opts["conum"],
                 conam=self.opts["conam"], name=self.__class__.__name__,
-                    ttype="D",
-                tables=data, heads=heads, cols=cols, trtp=["mlt_type",
-                mltrtp], gtots=gtots, prtdia=prtdia, fromad=self.fromad)
+                ttype="D", tables=data, heads=heads, cols=cols,
+                trtp=["mlt_type", mltrtp], gtots=gtots, prtdia=prtdia,
+                fromad=self.fromad)
         elif opt == "S":
             tit = ("Print Options",)
             fld = []
@@ -1581,8 +1576,7 @@
                         l[tdc.index("tpd_y1")] = l[tdc.index("tpd_y2")] - h2
             form.doDrawDetail(l)
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.tnamef, ext="pdf")
+            self.__class__.__name__, self.tnamef, ext="pdf")
         form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], pdfnam=pdfnam, splash=False,
             repprt=self.pf.repprt)
@@ -1637,8 +1631,7 @@
                     l = form.newdic[key]
                     form.doDrawDetail(l)
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.tnameb, ext="pdf")
+                    self.__class__.__name__, self.tnameb, ext="pdf")
                 form.output(pdfnam, "F")
                 showWarning(self.opts["mf"].body, "Replace Card",
                     "In Order to Print the Back of the Card, Please "\

=== modified file 'mem/ml2010.py' (properties changed: -x to +x)
--- old/mem/ml2010.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml2010.py	2020-04-26 10:28:50 +0000
@@ -131,8 +131,10 @@
             fld[3][2] = 20
             fld.extend([
                 (("C",1,0,5),"ISD",13.2,"Discount",
-                    "Discount Amount","","N",self.doDisAmt,None,None,None),
-                (("C",1,0,6),"INA",(20,30),"Details","Transaction Details",
+                    "Discount Amount","","N",self.doDisAmt,None,None,None,None,
+                    "Discount Amount to be Added to the Transaction Amount."),
+                (("C",1,0,6),"OSD",13.2,"Total-Amount"),
+                (("C",1,0,7),"INA",(20,30),"Details","Transaction Details",
                     "","N",self.doTrnDet,None,None,None)])
         elif self.glint == "Y":
             fld[3][2] = 24
@@ -245,6 +247,8 @@
         else:
             self.disamt = w
         self.df.loadEntry(frt, pag, p, data=self.disamt)
+        totamt = float(ASD(self.trnamt) + ASD(self.disamt))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def doTrnDet(self, frt, pag, r, c, p, i, w):
         self.trndet = w

=== modified file 'mem/ml2020.py' (properties changed: -x to +x)
--- old/mem/ml2020.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml2020.py	2020-06-21 10:24:47 +0000
@@ -114,7 +114,9 @@
             (("C",2,0,2),"ISD",13.2,"Receipt","Receipt Amount",
                 "","N",self.doAllAmt,None,None,("efld",)),
             (("C",2,0,3),"ISD",13.2,"Discount","Discount Amount",
-                "","N",self.doDisAmt,None,None,("efld",)))
+                "","N",self.doDisAmt,None,None,("efld",),None,
+                "Discount Amount to be Added to the Receipt Amount."),
+            (("C",2,0,4),"OSD",13.2,"Total-Amount"))
         but = (
             ("Age _Normal",None,self.doAgeNormal,0,None,None,
                 "Only Show Unallocated Transactions",1),
@@ -137,13 +139,13 @@
 
     def doRefno(self, frt, pag, r, c, p, i, w):
         if not w:
-            a = self.sql.getRec("memtrn", cols=["mlt_refno"],
+            trns = self.sql.getRec("memtrn", cols=["mlt_refno"],
                 where=[("mlt_cono", "=", self.opts["conum"]), ("mlt_refno",
                 "like", "R________")], order="mlt_refno desc")
             auto = False
-            for r in a:
+            for trn in trns:
                 try:
-                    w = "R%08i" % (int(r[0][1:]) + 1)
+                    w = "R%08i" % (int(trn[0][1:]) + 1)
                     auto = True
                     break
                 except:
@@ -256,6 +258,8 @@
         if ok != "yes":
             return "Invalid Discount Amount (Sign Error)"
         self.disamt = w
+        totamt = float(ASD(self.allamt) + ASD(self.disamt))
+        self.df.loadEntry(frt, pag, p+1, data=totamt)
 
     def checkSign(self):
         return askQuestion(self.opts["mf"].body, "Check Sign",

=== modified file 'mem/ml3010.py' (properties changed: -x to +x)
--- old/mem/ml3010.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3010.py	2020-05-27 12:29:33 +0000
@@ -38,7 +38,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlbat", "memtrn"],
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlbat", "memtrn", "memctc"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -167,8 +167,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'mem/ml3020.py' (properties changed: -x to +x)
--- old/mem/ml3020.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3020.py	2020-06-21 10:13:33 +0000
@@ -227,8 +227,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Member's Ledger Audit Trail for Period "\
             "%s to %s" % (self.sperd, self.eperd))
@@ -264,8 +263,7 @@
             self.head = ("%03u %-30s %91s %10s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, self.__class__.__name__))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.bqty = 0
         self.bdrs = 0
@@ -457,7 +455,7 @@
     def grandTotal(self):
         tot = [0, 0, 0, 0, 0]
         if self.repprt[2] == "export":
-            for x in xrange(0, len(mltrtp)):
+            for x, t in enumerate(mltrtp):
                 tot[0] = float(ASD(tot[0]) + ASD(self.gdr[x]))
                 tot[1] = float(ASD(tot[1]) + ASD(self.gcr[x]))
                 tot[2] = float(ASD(tot[2]) + ASD(self.gvt[x]))
@@ -477,10 +475,10 @@
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-27s %s %s %s %s %s" % \
-                (mltrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-34s %s %s %s %s %s" % \
-                (mltrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))
             tot[2] = float(ASD(tot[2]) + ASD(cr.work))

=== modified file 'mem/ml3030.py' (properties changed: -x to +x)
--- old/mem/ml3030.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3030.py	2020-05-27 12:29:50 +0000
@@ -37,7 +37,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["memmst", "memtrn"],
+        self.sql = Sql(self.opts["mf"].dbm, ["memmst", "memtrn", "memctc"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -256,8 +256,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Members Age Analysis up to %s" %
             self.opts["period"])
@@ -299,8 +298,7 @@
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999

=== modified file 'mem/ml3040.py' (properties changed: -x to +x)
--- old/mem/ml3040.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3040.py	2020-06-21 10:12:29 +0000
@@ -79,8 +79,8 @@
             mm -= 12
         self.nne = mthendDate((yy*10000) + (mm*100) + 1)
         self.trtypes = []
-        for q in xrange(0, len(mltrtp)):
-            self.trtypes.append(mltrtp[q][0])
+        for t in mltrtp:
+            self.trtypes.append(t[0])
         return True
 
     def mainProcess(self):
@@ -421,10 +421,7 @@
             nxt = False
         else:
             dte = False
-            if self.ynd or freq == "M":
-                nxt = True
-            else:
-                nxt = False
+            nxt = bool(self.ynd or freq == "M")
             if not last:
                 if dateDiff(start, self.nme, "days") > self.ldays:
                     dte = True
@@ -736,8 +733,7 @@
         else:
             key = "%s_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            key, ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.dated),

=== modified file 'mem/ml3050.py' (properties changed: -x to +x)
=== modified file 'mem/ml3060.py' (properties changed: -x to +x)
--- old/mem/ml3060.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3060.py	2020-05-27 12:30:05 +0000
@@ -176,11 +176,11 @@
                     self.sql.insRec("chglog", data=["memcat", "D",
                         "%03i%06i%1s%02i" % (self.opts["conum"], rec[0],
                         "B", data[0]), "", self.dte, "", str(data[1]),
-                        str(data[2]), 0])
+                        str(data[2]), "", 0])
                     self.sql.insRec("chglog", data=["memcat", "N",
                         "%03i%06i%1s%02i" % (self.opts["conum"], rec[0],
                         "B", data[7]), "", self.dte, "", str(self.start.work),
-                        str(0), 0])
+                        str(0), "", 0])
             sp.closeSplash()
         self.processRecords()
         self.closeProcess()
@@ -224,8 +224,7 @@
     def exportReport(self, chg):
         p = ProgressBar(self.opts["mf"].body, mxs=len(chg), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Members Category Changes between %s and %s" %
             (self.start.disp, self.end.disp))
@@ -288,8 +287,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.repprt,

=== modified file 'mem/ml3070.py' (properties changed: -x to +x)
--- old/mem/ml3070.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3070.py	2020-06-21 10:14:15 +0000
@@ -39,8 +39,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlnot", "ctlvrf", "memctc",
-            "memctp", "memmst", "memcat", "memadd", "memkon", "memtrn"],
-            prog=self.__class__.__name__)
+            "memctk", "memcto", "memctp", "memmst", "memcat", "memadd",
+            "memkon", "memtrn"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -333,10 +333,10 @@
                         colsh.append(("name%s_%s" % (n1, n2), d2[1],
                             d2[2], d2[0], "y"))
             RepPrt(self.opts["mf"], name=self.__class__.__name__, heads=head,
-                tables=data,
-                cols=colsh, opts=self.getDes(), conum=self.opts["conum"],
-                conam=self.opts["conam"], ttype="D", repprt=self.df.repprt,
-                repeml=self.df.repeml, fromad=self.fromad, pbar="P")
+                tables=data, cols=colsh, opts=self.getDes(), ttype="D",
+                conum=self.opts["conum"], conam=self.opts["conam"],
+                repprt=self.df.repprt, repeml=self.df.repeml,
+                fromad=self.fromad, pbar="P")
 
     def doChooseFields(self):
         r1s = (("Yes", "Y"), ("No", "N"))
@@ -813,10 +813,7 @@
             nxt = False
         else:
             dte = False
-            if self.ynd or freq == "M":
-                nxt = True
-            else:
-                nxt = False
+            nxt = bool(self.ynd or freq == "M")
             if not last:
                 if dateDiff(start, self.tme, "days") > self.ldays:
                     dte = True

=== modified file 'mem/ml3080.py' (properties changed: -x to +x)
--- old/mem/ml3080.py	2020-04-20 12:42:42 +0000
+++ new/mem/ml3080.py	2020-04-24 11:13:12 +0000
@@ -37,8 +37,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["memmst", "memsta", "memtrn"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["memmst", "memsta", "memtrn",
+            "memcat", "memctc", "memctp"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         mc = GetCtl(self.opts["mf"])

=== modified file 'mem/ml3090.py' (properties changed: -x to +x)
--- old/mem/ml3090.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3090.py	2020-04-24 11:13:42 +0000
@@ -38,7 +38,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "memctk", "memmst",
-            "memadd", "memkon"], prog=self.__class__.__name__)
+            "memadd", "memkon", "memctc", "memctk"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])

=== modified file 'mem/ml3100.py' (properties changed: -x to +x)
=== modified file 'mem/ml3110.py' (properties changed: -x to +x)
--- old/mem/ml3110.py	2020-04-21 08:42:36 +0000
+++ new/mem/ml3110.py	2020-05-27 12:30:13 +0000
@@ -188,8 +188,7 @@
             p.closeProgress()
             if self.fpdf.page and not p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)

=== modified file 'mem/ml3120.py' (properties changed: -x to +x)
=== modified file 'mem/ml6010.py' (properties changed: -x to +x)
=== modified file 'mem/mlc110.py' (properties changed: -x to +x)
--- old/mem/mlc110.py	2020-04-21 08:42:36 +0000
+++ new/mem/mlc110.py	2020-07-13 10:20:14 +0000
@@ -24,7 +24,7 @@
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
 
-import os, time
+import time
 from TartanClasses import GetCtl, Sql, TartanDialog
 
 class mlc110(object):
@@ -55,9 +55,8 @@
             self.opts["conum"])], limit=1)
         if not self.acc:
             self.new = True
-            phd = os.path.join(self.opts["mf"].rcdic["prgdir"], "img")
-            self.acc = [self.opts["conum"], "N", 15, 0, phd, "",
-                    "member_cards", "", "statement_member", "", ""]
+            self.acc = [self.opts["conum"], "N", 15, 0, "", "",
+                "member_cards", "", "statement_member", "", ""]
         else:
             self.new = False
         if self.genleg:
@@ -143,7 +142,7 @@
             (("T",0,seq + 6,0),"INA",20,"Statement Template","",
                 self.acc[8],"N",self.doSTpl,tps,None,("notblank",)),
             (("T",0,seq + 7,0),"ITX",50,"Email Address","",
-                self.acc[9],"N",None,None,None,None)])
+                self.acc[9],"N",None,None,None,("email",))])
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -226,14 +225,17 @@
         if self.new:
             self.sql.insRec("memctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.memctl_col
+            data.append(self.acc[col.index("mcm_xflag")])
             self.sql.updRec("memctl", data=data, where=[("mcm_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["memctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.memctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'mem/mlc210.py' (properties changed: -x to +x)
--- old/mem/mlc210.py	2020-04-21 08:42:36 +0000
+++ new/mem/mlc210.py	2020-04-24 11:17:46 +0000
@@ -35,8 +35,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "memctc", "memctp"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "genmst", "memctc",
+            "memcat", "memtrn", "memctp"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -272,7 +272,7 @@
                 ("mcp_type", "=", self.ctyp), ("mcp_date", "=", self.date)],
                 limit=1)
         if self.oldprc:
-            for n, d in enumerate(self.oldprc[4:]):
+            for n, d in enumerate(self.oldprc[4:-1]):
                 self.df.loadEntry(frt, pag, p+1+n, data=d)
         else:
             for n in xrange(14):
@@ -320,7 +320,7 @@
             ("mcc_type", "=", self.ctyp), ("mcc_code", "=", self.code)])
         self.sql.insRec("chglog", data=["memctc", "D", "%03i%1s%02i" % \
             (self.opts["conum"], self.ctyp, self.code), "", dte,
-            self.opts["capnm"], "", "", 0])
+            self.opts["capnm"], "", "", "", 0])
         prc = self.sql.getRec("memctp", cols=["mcp_date"],
             where=[("mcp_cono", "=", self.opts["conum"]), ("mcp_type", "=",
             self.ctyp), ("mcp_code", "=", self.code)])
@@ -330,7 +330,7 @@
                 "=", self.code), ("mcp_date", "=", date)])
             self.sql.insRec("chglog", data=["memctp", "D", "%03i%1s%02i%8s" % \
                 (self.opts["conum"], self.ctyp, self.code, date), "", dte,
-                self.opts["capnm"], "", "", 0])
+                self.opts["capnm"], "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -345,6 +345,8 @@
         if not self.oldcat:
             self.sql.insRec("memctc", data=data)
         elif data != self.oldcat[:len(data)]:
+            col = self.sql.memctc_col
+            data.append(self.oldcat[col.index("mcc_xflag")])
             self.sql.updRec("memctc", data=data, where=[("mcc_cono", "=",
                 self.opts["conum"]), ("mcc_type", "=", self.ctyp),
                 ("mcc_code", "=", self.code)])
@@ -352,8 +354,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["memctc", "U",
                         "%03i%1s%02i" % (self.opts["conum"], self.ctyp,
-                        self.code), self.sql.memctc_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.code), col[num], dte, self.opts["capnm"],
+                        str(dat), str(data[num]), "", 0])
         if self.freq != "N":
             data = [self.opts["conum"], self.ctyp, self.code]
             if self.glint == "Y":
@@ -365,6 +367,8 @@
             if not self.oldprc:
                 self.sql.insRec("memctp", data=data)
             elif data != self.oldprc[:len(data)]:
+                col = self.sql.memctp_col
+                data.append(self.oldcat[col.index("mcp_xflag")])
                 self.sql.updRec("memctp", data=data, where=[("mcp_cono", "=",
                     self.opts["conum"]), ("mcp_type", "=", self.ctyp),
                     ("mcp_code", "=", self.code), ("mcp_date", "=",
@@ -373,9 +377,9 @@
                     if dat != data[num]:
                         self.sql.insRec("chglog", data=["memctp", "U",
                             "%03i%1s%02i%8s" % (self.opts["conum"], self.ctyp,
-                            self.code, str(self.date)),
-                            self.sql.memctp_col[num], dte, self.opts["capnm"],
-                            str(dat), str(data[num]), 0])
+                            self.code, str(self.date)), col[num], dte,
+                            self.opts["capnm"], str(dat), str(data[num]),
+                            "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'mem/mlc310.py' (properties changed: -x to +x)
--- old/mem/mlc310.py	2020-04-21 08:42:36 +0000
+++ new/mem/mlc310.py	2020-04-23 10:09:09 +0000
@@ -97,6 +97,8 @@
             if self.new == "Y":
                 self.sql.insRec("ctlmes", data=data)
             elif data != self.oldm[:len(data)]:
+                col = self.sql.ctlmes_col
+                data.append(self.oldm[col.index("mss_xflag")])
                 self.sql.updRec("ctlmes", data=data, where=[("mss_system",
                     "=", self.system), ("mss_message", "=", self.message)])
             self.opts["mf"].dbm.commitDbase()

=== modified file 'mem/mlc410.py' (properties changed: -x to +x)
--- old/mem/mlc410.py	2020-04-21 08:42:36 +0000
+++ new/mem/mlc410.py	2020-04-24 11:18:11 +0000
@@ -34,7 +34,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "memctk"],
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "memctk", "memkon"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -116,8 +116,10 @@
         if self.new:
             self.sql.insRec("memctk", data=data)
         elif data != self.old[:len(data)]:
-            self.sql.updRec("memctk", data=data, where=[("mck_code", "=",
-                self.code)])
+            col = self.sql.memctk_col
+            data.append(self.old[col.index("mck_xflag")])
+            self.sql.updRec("memctk", data=data, where=[("mck_code",
+                "=", self.code)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'mem/mlm010.py' (properties changed: -x to +x)
--- old/mem/mlm010.py	2020-04-21 08:42:36 +0000
+++ new/mem/mlm010.py	2020-06-21 10:14:50 +0000
@@ -212,13 +212,13 @@
                     self.sql.insRec("chglog", data=["memcat", "D",
                         "%03i%06i%1s%02i" % (self.opts["conum"], self.memno,
                         "B", data[0]), "", dte, self.opts["capnm"],
-                        str(data[1]), str(data[2]), 0])
+                        str(data[1]), str(data[2]), "", 0])
                     self.sql.insRec("memcat", data=[self.opts["conum"],
                         self.memno, "B", data[7], "", self.nxtdt, 0, 0])
                     self.sql.insRec("chglog", data=["memcat", "N",
                         "%03i%06i%1s%02i" % (self.opts["conum"], self.memno,
                         "B", data[7]), "", dte, self.opts["capnm"],
-                        str(self.nxtdt), str(0), 0])
+                        str(self.nxtdt), str(0), "", 0])
             p.closeProgress()
             ok = askQuestion(self.opts["mf"].body, "Category Changes",
                 "Would You Like to Display Category Changes?", default="yes")
@@ -312,10 +312,7 @@
             nxt = False
         else:
             dte = False
-            if self.ynd or freq == "M":
-                nxt = True
-            else:
-                nxt = False
+            nxt = bool(self.ynd or freq == "M")
             if not last:
                 if dateDiff(start, self.tme, "days") > self.ldays:
                     dte = True
@@ -414,7 +411,8 @@
             glt[0][self.sql.gentrn_col.index("glt_tramt")] = tmp
             tmp = glt[0][self.sql.gentrn_col.index("glt_taxamt")]
             tmp = float(ASD(tmp) + ASD(tax))
-            self.sql.updRec("gentrn", cols=["glt_tramt"], data=[tmp], where=whr)
+            glt[0][self.sql.gentrn_col.index("glt_taxamt")] = tmp
+            self.sql.updRec("gentrn", data=glt[0], where=whr)
         else:
             data = [self.opts["conum"], glac, curdt, trdt, 1, ref, self.batch,
                 val, tax, "Month End Raising Charges", self.taxdf, "", 0,

=== renamed file 'mst/ms0000.py' => 'ms0000.py' (properties changed: -x to +x)
--- old/mst/ms0000.py	2020-04-21 08:42:36 +0000
+++ new/ms0000.py	2020-12-12 11:18:21 +0000
@@ -24,14 +24,13 @@
 """
 
 import getpass, gc, glob, io, os, platform, sys, time
-from TartanClasses import AboutTartan, DBCreate, Dbase, ExportDbase, FileDialog
-from TartanClasses import GUI, GetCtl, MainFrame, MergeDbase, MkWindow
-from TartanClasses import PwdConfirm, ScrollText, SelectChoice, Sql
-from TartanClasses import TarBckRes, TartanConfig, TartanDialog, TartanMenu
-from TartanClasses import TartanUser
-from tartanFunctions import askQuestion, askChoice, b64Convert, chkMod, copyList
-from tartanFunctions import dateDiff, ftpDownload, getPeriods, getPrgPath
-from tartanFunctions import internetConnect, loadRcFile, parsePrg, projectDate
+from TartanClasses import Dbase, ViewPDF, FileDialog, FITZ, GUI, GetCtl
+from TartanClasses import MainFrame, MkWindow, PwdConfirm, ScrollText
+from TartanClasses import SelectChoice, Sql, TartanConfig, TartanDialog
+from TartanClasses import TartanMenu, TartanUser
+from tartanFunctions import askQuestion, askChoice, b64Convert, chkMod
+from tartanFunctions import copyList, dateDiff, ftpDownload, getPeriods
+from tartanFunctions import getPrgPath, loadRcFile, projectDate
 from tartanFunctions import runModule, showError, showException
 from tartanWork import allsys, tabdic, tarmen
 try:
@@ -46,7 +45,7 @@
     temp = tuple(os.environ["TARVER"].split("."))
     VERSION = (int(temp[0]), int(temp[1].rstrip()))
 else:
-    VERSION = (5, 11)
+    VERSION = (5, 12)
     os.environ["TARVER"] = "%s.%s" % VERSION
 
 class ms0000(object):
@@ -67,6 +66,7 @@
             ("query", None),
             ("rcfdir", None),
             ("rcfile", None),
+            ("script", False),
             ("tcode", 0),
             ("user", {}),
             ("version", False),
@@ -131,8 +131,14 @@
                 self.rcfdir = v
             elif o in ("-r", "--rcfile"):
                 self.rcfile = v
+            elif o in ("-s", "--script"):
+                self.script = v
             elif o in ("-t", "--tcode"):
-                self.tcode = int(v)
+                try:
+                    self.tcode = int(v)
+                except:
+                    print("Invalid value for -t")
+                    self.doExit(dbm=False)
             elif o in ("-u", "--user"):
                 user = v.split(":")
                 self.user["name"] = user[0]
@@ -146,6 +152,9 @@
                 self.xdisplay = False
             elif o in ("-z", "--zerobar"):
                 self.zerobar = True
+        if self.script:
+            exec("import %s" % self.script)
+            self.doExit(dbm=False)
         if self.output:
             # Redirect stdout
             for pid in xrange(1000):
@@ -156,7 +165,7 @@
                 self.stdout = os.path.join(getPrgPath(), name)
                 try:
                     if not os.path.exists(self.stdout):
-                        sys.stdout = open(self.stdout, "w")
+                        sys.stdout = io.open(self.stdout, "w")
                         os.chmod(self.stdout, 0o777)
                         break
                 except:
@@ -185,6 +194,7 @@
             -q, --query=            Execute a sql query
             -R, --rcfdir=           Directory of Available Tartan RC Files
             -r, --rcfile=           Path of Tartan RC File to use
+            -s, --script=           Python script in the program directory
             -t, --tcode=            Transaction code
             -u, --user=             User name and password e.g. name:password
             -v, --version           Display Version Details
@@ -193,50 +203,60 @@
 """)
             self.doExit(dbm=False)
         if not self.version and not self.xdisplay:
-            nodisp = ("tarBck", "tarUpd", "ml6030")
+            nodisp = ("tarBck", "tarUpd")
             if not self.query and self.program not in nodisp:
                 print("xdisplay False but module not in %s" % str(nodisp))
                 self.doExit(dbm=False)
             elif not self.user:
                 print("xdisplay False but No User Name")
                 self.doExit(dbm=False)
-        if not self.version and self.xdisplay and not GUI:
-            print("Tkinter/ttk not Available or Installed")
-            self.doExit(dbm=False)
-        if self.version:
+        # Check for required modules are installed
+        mods = [
+            ("fpdf", "fpdf", "__version__"),
+            ("PIL", "pillow", "__version__"),
+            ("fitz", "pymupdf", "version")]
+        if sys.platform == "win32":
+            mods.append(("win32api", "pywin32", None))
+        if not self.version:
+            errs = False
+            if self.xdisplay and not GUI:
+                errs = True
+                print("Tkinter/ttk not Available or Installed")
+            for mod in mods:
+                if not chkMod(mod[0]):
+                    errs = True
+                    print("%-16s: Not Installed" % mod[1])
+            if errs:
+                self.doExit(dbm=False)
+        else:
+            # Print/Display installed versions
             nm = platform.uname()
             print("%-16s: %s" % ("Tartan", self.cv[1]))
             print("%-16s: %s, %s, %s" % ("O/System", nm[0], nm[2], nm[4]))
             print("%-16s: %s" % ("python", sys.version.split()[0]))
-            try:
-                from TartanClasses import tk
-                print("%-16s: %s" % ("tcl/tk",
-                    tk.Tcl().eval("info patchlevel")))
-            except:
-                print("%-16s: %s" % ("Tcl/Tk", "Not Installed"))
-            mods = (
-                ("fpdf", "fpdf", "__version__"),
-                ("PIL", "pillow", "__version__"),
-                ("ghostscript", "ghostscript", "__version__"),
+            from TartanClasses import tk
+            print("%-16s: %s" % ("tcl/tk",
+                tk.Tcl().eval("info patchlevel")))
+            mods.extend([
+                ("Crypto", "pycryptodome", "__version__"),
+                ("escpos", "python-escpos", ("version", "version")),
                 ("markdown", "markdown", "__version__"),
                 ("ofxtools", "ofxtools", "__version__"),
+                ("progress", "progress", "__version__"),
                 ("psycopg2", "psycopg2", "__version__"),
                 ("pyaes", "pyaes", "VERSION"),
-                ("pychart", "python-chart", None),
-                ("Crypto", "pycryptodome", "__version__"),
                 ("pyexcel_ods", "pyexcel-ods", None),
                 ("pygal", "pygal", "__version__"),
+                ("requests", "requests", "__version__"),
+                ("send2trash", "send2trash", None),
                 ("smb", "pysmb", None),
                 ("sqlite3", "pysqlite", "version"),
                 ("sqlite3", "sqlite3", "sqlite_version"),
-                ("escpos", "python-escpos", ("version", "version")),
-                ("requests", "requests", "__version__"),
-                ("send2trash", "send2trash", None),
+                ("svglib", "svglib", ("svglib", "__version__")),
                 ("tkcolorpicker", "tkcolorpicker", None),
                 ("tkinterhtml", "tkinterhtml", None),
-                ("tqdm", "tqdm", None),
                 ("xlrd", "xlrd", "__VERSION__"),
-                ("xlwt", "xlwt", "__VERSION__"))
+                ("xlwt", "xlwt", "__VERSION__")])
             for mod in mods:
                 ver = chkMod(mod[0])
                 if not ver:
@@ -252,6 +272,8 @@
                             ver = getattr(ver, mod[2])
                         if type(ver) == list:
                             ver = "%s.%s.%s" % tuple(ver)
+                        elif type(ver) == tuple:
+                            ver = ver[0]
                         ver = ver.split()[0]
                         print("%-16s: %s" % (mod[1], ver))
                     except:
@@ -263,13 +285,7 @@
             igm = ["__init__"]
             if self.exclude:
                 igm.extend(self.exclude)
-            if sys.platform == "win32" and \
-                    os.path.basename(sys.path[0]) == "library.zip":
-                igd = []
-                for mod in sys.modules:
-                    igm.append(mod)
-            else:
-                igd = [sys.prefix, sys.exec_prefix]
+            igd = [sys.prefix, sys.exec_prefix]
             os.environ["TARTANDB"] = "1"
             self.tracer = trace.Trace(ignoredirs=igd, ignoremods=igm,
                 trace=1, count=0)
@@ -279,8 +295,7 @@
                 showError(None, "Directory Error",
                     "Invalid -R Directory: %s" % self.rcfdir)
                 self.doExit(dbm=False)
-            icon = os.path.join(getPrgPath(), "img", "tartan.png")
-            scrn = MkWindow(tk=True, icon=icon).newwin
+            scrn = MkWindow(tk=True, icon="tartan").newwin
             dialog = FileDialog(**{"parent": scrn, "initd": self.rcfdir})
             self.rcfile = dialog.askopenfilename()
             scrn.destroy()
@@ -293,7 +308,9 @@
             unichr(0xa9)
         while not self.rcdic:
             self.rcdic = loadRcFile(self.rcfile, default=True)
-            if self.rcdic == "error":
+            if not type(self.rcdic) == dict:
+                showError(None, "Error", "Invalid Preferences File (%s)\n\n%s"
+                    % (self.rcfile, self.rcdic))
                 self.doExit(dbm=False)
             elif not os.path.isfile(self.rcdic["name"]):
                 self.mf = MainFrame(title=main, rcdic=self.rcdic)
@@ -307,32 +324,36 @@
                     self.doExit(dbm=False)
                 self.rcfile = self.mf.rcfile = cfg.rcfile
                 self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
-        titl = "%s - (%s - %s@%s)" % (main, self.rcdic["dbase"],
-            self.rcdic["dbname"], self.rcdic["dbhost"])
         if not self.mf:
             # Create MainFrame if not already existing
-            self.mf = MainFrame(title=titl, rcdic=self.rcdic,
-                xdisplay=self.xdisplay)
+            self.mf = MainFrame(rcdic=self.rcdic, xdisplay=self.xdisplay)
             if self.mf.rcdic == "error":
                 self.doExit(dbm=False)
-        else:
+        if self.xdisplay:
+            titl = "%s - (%s - %s@%s)" % (main, self.rcdic["dbase"],
+                self.rcdic["dbname"], self.rcdic["dbhost"])
             self.mf.window.title(titl)
-        if self.xdisplay:
             self.mf.head.configure(text="Tartan Systems")
         # Try connecting to the database and create if missing
         self.db = Dbase(rcdic=self.rcdic, screen=self.mf.body)
         if self.db.err:
             self.doExit(dbm=False)
         self.mf.dbm = self.db
-        err = self.db.checkDbase()
-        if err not in (True, False):
+        chk = self.db.checkDbase()
+        if chk not in (True, False):
+            showError(self.mf.window, "Database", chk)
             self.doExit()
-        elif err is False:
+        elif chk is False:
+            if self.rcdic["dbase"] == "PgSQL":
+                mes = "%s@%s" % (self.rcdic["dbname"], self.rcdic["dbhost"])
+            else:
+                mes = os.path.join(self.rcdic["dbdir"], self.rcdic["dbname"])
             ok = askQuestion(self.mf.window, "Database",
-                "Create the Database Now?")
+                "Create the Database?\n\n%s" % mes)
             if ok == "no":
                 self.doExit()
             else:
+                from TartanClasses import DBCreate
                 opts = [
                     ("-c", "i"),
                     ("-l", self.mf.body),
@@ -353,8 +374,6 @@
             if err:
                 # If error, exit
                 self.doExit()
-            # List of financial modules
-            self.fmod = ["ms1020", "ms1040", "ms3010", "msy010", "msy020"]
             # Close dbase
             self.db.closeDbase()
         if self.user:
@@ -362,11 +381,8 @@
             self.userReadCheck(user=self.user["name"], pwd=self.user["pwd"],
                 pwdchk=True)
             if not self.user:
-                if self.xdisplay:
-                    scrn = self.mf.window
-                else:
-                    scrn = "text"
-                showError(scrn, "Error", "Invalid User or User Password")
+                showError(self.mf.window, "Error",
+                    "Invalid User or User Password")
         else:
             # Login user
             self.userLogin()
@@ -401,9 +417,10 @@
                     if len(mod) == 5:
                         found = True
                         break
-                    elif len(mod) == 6 and mod[5] == self.tcode:
-                        found = True
-                        break
+                    if len(mod) > 5:
+                        if mod[5] is None or mod[5] == self.tcode:
+                            found = True
+                            break
             if found:
                 if self.xdisplay and self.program != "ps2010":
                     self.mf.window.deiconify()
@@ -425,14 +442,10 @@
         else:
             # Do not display the tartan image
             self.image = False
-        if self.image:
-            image = os.path.join(self.rcdic["prgdir"], "img", "tartan.png")
-        else:
-            image = None
         # Create the tartan menu
         self.tarmen = TartanMenu(mf=self.mf, usr=self.user["name"],
             men=self.usrmen, mod=self.usrmod, lvl=self.user["lvl"],
-            cmd=self.execCommand, img=image)
+            cmd=self.execCommand, img=self.image)
         if not self.doVersionCheck():
             # Check for notes
             self.checkNotes()
@@ -560,6 +573,8 @@
             self.user["lvl"] = usr[sql.ctlpwu_col.index("usr_lvl")]
             if pwdchk and self.user["pwd"] and self.userCheckPwd(pwd):
                 self.user = {}
+            nos = []
+            nop = []
             if self.user:
                 self.acoy = []
                 self.dcoy = []
@@ -582,7 +597,6 @@
                 for co in dcoy:
                     if int(co):
                         self.dcoy.append(int(co))
-                nos = []
                 # All systems not in the company and phone modules - nos
                 for sss in self.sss:
                     if sss not in ("ms", "td"):
@@ -613,7 +627,7 @@
                     "=", self.user["name"]), ("mpw_prg", "<>", ""),
                     ("mpw_pwd", "<>", "")])
                 if self.vop:
-                    for sss, mod, coy, pwd in self.vop:
+                    for sss, mod, coy, ppp in self.vop:
                         if sss in nos:
                             # System in nos, remove system from nos
                             nos.remove(sss)
@@ -621,7 +635,7 @@
                                 # Add all modules in sss to nop
                                 if prg[2][:2] == sss:
                                     nop.append([prg[2][:2], prg[2][2:]])
-                    for sss, mod, coy, pwd in self.vop:
+                    for sss, mod, coy, ppp in self.vop:
                         # Remove all enabled modules from nop
                         if [sss, mod] in nop:
                             nop.remove([sss, mod])
@@ -646,11 +660,13 @@
                         add = False
                 if add:
                     self.usrmen.append(men)
+            # List of financial modules
+            fmod = ["ms1020", "ms1040", "ms3010", "msy010", "msy020"]
             mods = copyList(self.mod)
             for mod in mods:
                 add = True
                 if len(self.fcoy) == 1 and not self.fcoy[1]:
-                    if mod[0][0] == "P" and mod[2] in self.fmod:
+                    if mod[0][0] == "P" and mod[2] in fmod:
                         continue
                     if mod[2] == "ms1010":
                         mod[4] = "Club Record Maintenance"
@@ -745,20 +761,21 @@
                 self.mf.head.configure(text="%s (%s)" % (tit, prg))
                 self.mf.updateStatus("")
             try:
-                if prg == "doManual":
-                    getattr(self, prg)(tit)
+                if prg[:8] == "doManual":
+                    sss = prg.split()[1]
+                    self.doManual(sss, tit)
                 else:
                     getattr(self, prg)()
             except SystemExit:
                 os._exit(0)
-            except:
+            except Exception as err:
                 if self.xdisplay:
                     for wgt in self.mf.window.winfo_children():
                         if wgt not in (
                                 self.mf.head, self.mf.body, self.mf.status):
                             wgt.destroy()
                     showException(self.mf.body, self.rcdic["wrkdir"],
-                        "Function %s Error" % prg, dbm=self.db)
+                        "Function %s Error %s" % (prg, err), dbm=self.db)
                 else:
                     showException(None, self.rcdic["wrkdir"],
                         "Function %s Error" % prg, dbm=self.db)
@@ -791,14 +808,10 @@
                         if not self.conum:
                             error = True
                         if not error:
-                            if prg in (
-                                    "gl3030", "gl3040", "gl3050", "gl3080",
-                                    "gl4010", "gl4020", "gl6030", "gl6040",
-                                    "gl6070"):
-                                # Check if period is up to date
-                                check = True
-                            else:
-                                check = False
+                            # Check if period is up to date
+                            check = bool(prg in ("gl3030", "gl3040",
+                                "gl3050", "gl3080", "gl4010", "gl4020",
+                                "gl6030", "gl6040", "gl6070"))
                             per = getPeriods(self.mf, self.conum, self.finper,
                                 check=check)
                             if per == (None, None, None):
@@ -842,8 +855,6 @@
                     self.tracer.runfunc(self.doRunModule, prg, **popt)
                 else:
                     self.doRunModule(prg, **popt)
-        if self.xdisplay:
-            self.mf.head.configure(text="Tartan Systems")
         if dbopend:
             try:
                 # Rollback any uncommitted transactions
@@ -866,6 +877,8 @@
             if not self.doVersionCheck():
                 self.checkNotes()
             self.tarmen.drawMenu()
+        elif self.xdisplay:
+            self.mf.head.configure(text="Tartan Systems")
 
     def pwdCheck(self):
         tit = ("Password Validation",)
@@ -1025,20 +1038,19 @@
             except:
                 pass
         try:
-            if "rtn" in popt:
-                rtn = popt["rtn"]
-            else:
-                rtn = 0
+            rtn = popt.get("rtn", 0)
             sql = Sql(self.db, ["ffield", "ctllog"], prog="ms0000")
             if not sql.error:
-                chk = sql.getRec("ffield",
-                    where=[("ff_tabl", "=", "ctllog")])
+                chk = sql.getRec("ffield", where=[("ff_tabl", "=", "ctllog")])
             if not sql.error and len(chk) == 7:
                 if not self.user:
                     name = "admin"
                 else:
                     name = self.user["name"]
-                logd = [getpass.getuser(), name, prg[0], rtn]
+                try:
+                    logd = [getpass.getuser(), name, prg[0], rtn]
+                except:
+                    logd = [name, name, prg[0], rtn]
                 if "conum" in popt:
                     logd.append(popt["conum"])
                 else:
@@ -1051,18 +1063,19 @@
                     "%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3]))
                 sql.insRec("ctllog", data=logd)
                 self.db.commitDbase()
-            if not runModule(prg[0], **popt):
-                raise Exception
-        except:
+            err = runModule(prg[0], **popt)
+            if err:
+                raise Exception(err)
+        except Exception as err:
             if self.xdisplay:
                 for wgt in self.mf.window.winfo_children():
                     if wgt not in (self.mf.head, self.mf.body, self.mf.status):
                         wgt.destroy()
                 showException(self.mf.body, self.rcdic["wrkdir"],
-                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+                    "%s\n\nMod: %s\nArg: %s" % (err, prg, popt), dbm=self.db)
             else:
                 showException(None, self.rcdic["wrkdir"],
-                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+                    "%s\nMod: %s\nArg: %s" % (err, prg, popt), dbm=self.db)
 
     def checkNotes(self):
         if not self.db.dbopen:
@@ -1286,7 +1299,7 @@
                         mod[2] = "%s%s" % (mod[2][:5], mod[5])
                     sm.append((mod[3], mod[2][2:], mod[4]))
             prg[s] = sm
-        TartanUser(self.mf, sss, prg)
+        TartanUser(self.mf, self.user["name"], sss, prg)
 
     def sysUpd(self):
         tit = ("System Upgrade",)
@@ -1375,7 +1388,8 @@
                 return
             return ("Upgrade Error", "No Upgrade Available")
         except:
-            return ("Connection Error", """Please Ensure that You Are Connected to the Internet.
+            return ("Connection Error",
+                """Please Ensure that You Are Connected to the Internet.
 
 
 If Not, Please Connect and then Try Again!""")
@@ -1421,7 +1435,7 @@
                 os.spawnv(os.P_NOWAIT, fle, (fle,))
             else:
                 os.spawnv(os.P_NOWAIT, "/bin/tar",
-                    ("tar", "-xzf", fle, "-C", self.mf.rcdic["prgdir"]))
+                    ("tar", "-xzf", fle, "-C", getPrgPath()))
             os._exit(0)
         except:
             showError(self.mf.window, "Get Error",
@@ -1504,10 +1518,7 @@
             if dbopend:
                 self.db.closeDbase()
             return
-        if ov != self.cv[0]:
-            err = True
-        else:
-            err = False
+        err = bool(ov != self.cv[0])
         chg = False
         if self.altered:
             for tb in tabdic:
@@ -1550,12 +1561,22 @@
                 self.doExit()
 
     def tarExp(self):
+        from TartanClasses import ExportDbase
         ExportDbase(**{"mf": self.mf})
 
     def tarMrg(self):
+        if self.mf.window:
+            ok = askQuestion(self.mf.window, "Backup",
+                "Have You Backed Up the Database?", default="no")
+        else:
+            ok = raw_input("Have You Backed Up the Database? (yes/no) ")
+        if ok != "yes":
+            return
+        from TartanClasses import MergeDbase
         MergeDbase(**{"mf": self.mf})
 
     def tarBck(self):
+        from TartanClasses import TarBckRes
         self.db.openDbase()
         cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarBck",
             passwd=self.bpwd)
@@ -1572,7 +1593,7 @@
             except:
                 csys = None
             if self.zerobar:
-                TarBckRes(self.mf, mode="B", csys=csys, bar=False)
+                TarBckRes(self.mf, mode="B", csys=csys, pbar=False)
             else:
                 TarBckRes(self.mf, mode="B", csys=csys)
         else:
@@ -1583,16 +1604,22 @@
             showError(scrn, "Error", "Invalid Backup Password")
 
     def tarRes(self):
+        from TartanClasses import TarBckRes
         cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarRes",
             passwd=self.bpwd)
         if cf.flag == "ok":
             TarBckRes(self.mf, mode="R", ver=self.cv[1])
 
     def tarCfg(self):
-        cfg = TartanConfig(self.mf, rcdic=self.rcdic, level=self.lvl)
+        cfg = TartanConfig(self.mf, rcdic=self.rcdic, level=self.lvl,
+            dbskp=True)
         if cfg.rcfile:
             self.rcfile = cfg.rcfile
         self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
+        if not type(self.rcdic) == dict:
+            showError(None, "Error", "Invalid Preferences File (%s)\n\n%s"
+                % (self.rcfile, self.rcdic))
+            self.doExit(dbm=False)
         geo = self.rcdic["geo"].split("x")
         self.mf.geo = [int(geo[0]), int(geo[1])]
         self.mf.resizeChildren()
@@ -1603,68 +1630,62 @@
         self.doExit()
 
     def doAbout(self, event=None):
+        from TartanClasses import AboutTartan
         AboutTartan(self.mf, self.cv[1])
 
-    def doManual(self, tit):
-        sss = tit.split("(")[1].split(")")[0]
-        if sss in allsys or sss in ("SYS", "CTL", "UTY"):
-            self.doBrowser(sss)
-        else:
-            self.doBrowser("Manual")
-
-    def doQuick(self):
-        self.doBrowser("QuickStart")
-
-    def doBrowser(self, doc):
-        pdf = os.path.join(self.rcdic["prgdir"], "doc", "%s.pdf" % doc)
-        if os.path.exists(pdf):
-            exe, cmd = parsePrg(self.rcdic["vwr"])
-            cmd.append(pdf)
-            os.spawnv(os.P_NOWAIT, exe, tuple(cmd))
-            return
-        rst = os.path.join(self.rcdic["prgdir"], "doc", "%s.rst" % doc)
-        if os.path.exists(rst):
-            import webbrowser
-            from docutils.core import publish_file
-            htm = os.path.join(self.rcdic["wrkdir"], "%s.html" % doc)
-            if os.path.exists(htm):
-                os.remove(htm)
-            fle = open(rst, "r")
-            if len(doc) == 3:
-                dat = ""
-                for n, f in enumerate(fle.readlines()):
-                    dat += f
-                    if n == 1 and f.count("----"):
-                        dat += """
+    def doManual(self, sss, tit):
+        try:
+            if sss == "REF":
+                doc = ["SYS", "CTL", "GEN", "ASS", "BKM", "CRS", "DRS",
+                       "LON", "MEM", "RTL", "RCA", "STR", "SLS", "POS",
+                       "WAG", "SLN", "BKS", "BWL", "CSH", "SCP", "UTY",
+                       "HLP"]
+                self.doDisplay(doc)
+            else:
+                self.doDisplay([sss])
+        except Exception as err:
+            print(err)
+
+    def doDisplay(self, doc):
+        from TartanClasses import MakeManual
+        man = ""
+        for ddd in doc:
+            if ddd != doc[0]:
+                man += "\nPageBreak\n"
+            rst = os.path.join(getPrgPath(), "doc", "%s.rst" % ddd)
+            if os.path.exists(rst):
+                fle = open(rst, "r")
+                if len(doc) == 1 and ddd != "SYS":
+                    dat = ""
+                    for n, f in enumerate(fle.readlines()):
+                        dat += f
+                        if n == 1 and f.count("----"):
+                            dat += """
 .. contents:: **Table of Contents**
 
-.. raw:: pdf
-
-   PageBreak
-
 """
+                    man += dat
+                else:
+                    man += fle.read()
                 fle.close()
-            else:
-                dat = fle.read()
-            fle = io.StringIO(unicode(dat))
-            publish_file(fle, source_path = fle,
-                destination_path = htm, writer_name ="html",
-                settings_overrides={"embed_stylesheet": False})
-            webbrowser.open(htm)
-            return
-        if internetConnect():
-            try:
-                import webbrowser
-                web = "http://tartan.co.za/cgi-bin/simple_web.py/%s" % doc
-                webbrowser.open(web)
-            except:
-                showError(self.mf.window, "Error", "Browser Not Found.")
-        else:
-            showError(self.mf.window, "Error", "No Internet Connection.")
+        fle = io.StringIO(unicode(man))
+        if FITZ:
+            vwr = self.mf.rcdic["vwr"]
+            self.mf.rcdic["vwr"] = ""
+        man = MakeManual(fle, vwr=self.mf.rcdic["vwr"])
+        pdf = os.path.join(self.rcdic["wrkdir"], "Manual.pdf")
+        if os.path.exists(pdf):
+            os.remove(pdf)
+        man.fpdf.output(pdf, "F")
+        if os.path.exists(pdf):
+            ViewPDF(self.mf, pdf)
+        if FITZ:
+            self.mf.rcdic["vwr"] = vwr
 
     def doHousekeeping(self):
         fles = []
-        for tp in ("csv","gif","html","jpg","odt","pdf","png","ps","svg","xls"):
+        for tp in ("csv", "gif", "html", "jpg", "odt", "pdf", "png", \
+                                        "ps", "svg", "xls", "xml"):
             fles.extend(glob.glob(os.path.join(self.rcdic["wrkdir"],
                 "*.%s" % tp)))
         if fles:
@@ -1912,12 +1933,12 @@
         os.environ["UBUNTU_MENUPROXY"] = "0"
     # Load options
     try:
-        opts, args = getopt.getopt(
-            sys.argv[1:], "ab:c:de:f:hiklnop:q:R:r:t:u:vxz", [
+        opts, args = getopt.getopt(sys.argv[1:],
+            "ab:c:de:f:hiklnop:q:R:r:s:t:u:vxz", [
                 "altered", "bpwd=", "conum=", "debug", "exclude=", "finper=",
                 "help", "image", "loader", "nocheck", "output", "program=",
-                "query=", "rcfdir=", "rcfile=", "tcode=", "user=", "version",
-                "xdisplay", "zerobar"])
+                "query=", "rcfdir=", "rcfile=", "script=", "tcode=", "user=",
+                "version", "xdisplay", "zerobar"])
     except:
         opts, args = [("-h", "")], []
     ms0000(opts, args)

=== added file 'mst/__init__.py'
=== modified file 'mst/ms1010.py' (properties changed: -x to +x)
--- old/mst/ms1010.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms1010.py	2020-04-24 13:05:57 +0000
@@ -27,7 +27,7 @@
 import os, time
 from TartanClasses import TartanDialog, ShowImage, Sql, TabPrt
 from tartanFunctions import askQuestion, callModule, mthendDate, showError
-from tartanWork import allsys
+from tartanWork import allsys, tabdic
 
 class ms1010(object):
     def __init__(self, **opts):
@@ -184,34 +184,29 @@
                 "Company 1 Cannot be Deleted")
             return
         err = False
-        for tab in (
-                ("assmst", "asm_cono"),
-                ("bkmmst", "bkm_cono"),
-                ("crsmst", "crm_cono"),
-                ("drsmst", "drm_cono"),
-                ("genmst", "glm_cono"),
-                ("memmst", "mlm_cono"),
-                ("rtlmst", "rtm_cono"),
-                ("strmf1", "st1_cono"),
-                ("wagmst", "wgm_cono")):
-            sql = Sql(self.opts["mf"].dbm, tab[0], prog=self.__class__.__name__)
-            err = sql.getRec(tables=tab[0], where=[(tab[1], "=",
-                self.opts["conum"])])
-            if err:
-                break
+        skp = {
+            "ctlmst": "ctm_cono",
+            "ctlynd": "cye_cono",
+            "ctlvmf": "vtm_cono",
+            "ctlvrf": "vtr_cono"}
+        for tab in tabdic:
+            if tab in skp:
+                continue
+            chk = tabdic[tab]["fld"][0][1]
+            if chk.count("_cono"):
+                sql = Sql(self.opts["mf"].dbm, tab,
+                        prog=self.__class__.__name__)
+                err = sql.getRec(tables=tab, where=[(chk, "=",
+                    self.opts["conum"])])
+                if err:
+                    break
         if err:
             showError(self.opts["mf"].body, "Deletion Error",
-                "%s Records Exist for This Company, Cannot Delete" % tab[0])
-        else:
-            self.sql.delRec("ctlmst", where=[("ctm_cono", "=",
-                self.opts["conum"])])
-            self.sql.delRec("ctlvmf", where=[("vtm_cono", "=",
-                self.opts["conum"])])
-            self.sql.delRec("ctlvrf", where=[("vtr_cono", "=",
-                self.opts["conum"])])
-            self.sql.delRec("ctlynd", where=[("cye_cono", "=",
-                self.opts["conum"])])
-            self.opts["mf"].dbm.commitDbase()
+                "%s Records Exist for This Company, Cannot Delete" % tab)
+            return
+        for tab in skp:
+            self.sql.delRec(tab, where=[(skp[tab], "=", self.opts["conum"])])
+        self.opts["mf"].dbm.commitDbase(ask=True)
 
     def doCoyNam(self, frt, pag, r, c, p, i, w):
         self.opts["conam"] = w
@@ -307,15 +302,17 @@
             if self.new:
                 self.sql.insRec("ctlmst", data=data)
             elif data != self.old[:len(data)]:
+                col = self.sql.ctlmst_col
+                data.append(self.old[col.index("ctm_xflag")])
                 self.sql.updRec("ctlmst", data=data, where=[("ctm_cono",
                     "=", self.opts["conum"])])
                 dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
                 for num, dat in enumerate(self.old):
                     if dat != data[num]:
                         self.sql.insRec("chglog", data=["ctlmst", "U",
-                            "%03i" % self.opts["conum"],
-                            self.sql.ctlmst_col[num], dte, self.opts["capnm"],
-                            str(dat), str(data[num]), 0])
+                            "%03i" % self.opts["conum"], col[num], dte,
+                            self.opts["capnm"], str(dat), str(data[num]),
+                            "", 0])
             if fin:
                 # Financial Systems
                 ynd = self.sql.getRec("ctlynd", cols=["count(*)"],

=== removed file 'mst/ms1010_oth.py'
--- old/mst/ms1010_oth.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms1010_oth.py	1970-01-01 00:00:00 +0000
@@ -1,217 +0,0 @@
-"""
-SYNOPSIS
-    Bowl's Clubs, Cash Analysis and and Sectional Competitions Master Record
-    Maintenance.
-
-    This file is part of Tartan Systems (TARTAN).
-
-AUTHOR
-    Written by Paul Malherbe, <paul@tartan.co.za>
-
-COPYING
-    Copyright (C) 2004-2020 Paul Malherbe.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program. If not, see <https://www.gnu.org/licenses/>.
-"""
-
-import time
-from TartanClasses import Sql, TartanDialog
-from tartanFunctions import askQuestion, callModule
-try:
-    import tarmod
-    TARMOD = True
-except:
-    TARMOD = False
-
-class ms1010:
-    def __init__(self, **opts):
-        self.opts = opts
-        self.opts["conum"] = 1
-        if self.setVariables():
-            self.mainProcess()
-            self.opts["mf"].startLoop()
-
-    def setVariables(self):
-        self.opts["mf"].head.configure(text="Master Record Maintenance")
-        self.sys = None
-        for mod in (
-                ("bc1010", "BC"),
-                ("bs1010", "BS"),
-                ("cs2010", "CS"),
-                ("sc1010", "SC")):
-            if TARMOD and mod[0] in tarmod.modlst:
-                self.sys = mod[1]
-                break
-        if not self.sys:
-            return
-        tabs = ["ftable", "ctlmst", "chglog"]
-        if self.sys == "CS":
-            tabs.extend(["ctlvmf", "ctlvrf"])
-        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=__name__)
-        if self.sql.error:
-            return
-        self.old = self.sql.getRec("ctlmst", where=[("ctm_cono", "=",
-            self.opts["conum"])], limit=1)
-        if not self.old:
-            self.new = True
-        else:
-            self.new = False
-        return True
-
-    def mainProcess(self):
-        self.tit = ("Club Record Maintenance",)
-        fld = [
-            (("T",0,0,0),"INA",30,"Name","",
-                "","N",self.doNam,None,None,("notblank",)),
-            (("T",0,1,0),"INA",30,"Postal Address Line-1","Address Line-1",
-                "","N",None,None,None,None),
-            (("T",0,2,0),"INA",30,"               Line-2","Address Line-2",
-                "","N",None,None,None,None),
-            (("T",0,3,0),"INA",30,"               Line-3","Address Line-3",
-                "","N",None,None,None,None),
-            (("T",0,4,0),"INA",4,"Postal Code","",
-                "","N",None,None,None,None),
-            (("T",0,5,0),"INA",30,"Street Address Line-1",
-                "Street Address Line-1","","N",None,None,None,None),
-            (("T",0,6,0),"INA",30,"               Line-2","Address Line-2",
-                "","N",None,None,None,None),
-            (("T",0,7,0),"INA",30,"               Line-3","Address Line-3",
-                "","N",None,None,None,None),
-            (("T",0,8,0),"INA",4,"Street Code","",
-                "","N",None,None,None,None),
-            (("T",0,9,0),"INA",30,"Contact Name","",
-                "","N",None,None,None,None),
-            (("T",0,10,0),"INA",15,"Telephone","Telephone No",
-                "","N",None,None,None,None),
-            (("T",0,11,0),"INA",15,"Facsimile","Facsimile No",
-                "","N",None,None,None,None),
-            (("T",0,12,0),"INA",15,"Mobile","Mobile Number",
-                "","N",None,None,None,None),
-            (("T",0,13,0),"ITX",50,"E-Mail Address","",
-                "","N",None,None,None,("email",))]
-        if self.sys == "CS":
-            fld.extend([
-                (("T",0,14,0),"INA",20,"V.A.T. Number","",
-                    "","N",self.doVatNum,None,None,None),
-                (("T",0,15,0),"IUA",1,"V.A.T. Default","",
-                    "","N",self.doVatCod,None,None,("notblank",))])
-        but = (
-            ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
-            ("Quit",None,self.doExit,1,None,None))
-        tnd = ((self.doEnd, "y"),)
-        txt = (self.doExit,)
-        self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
-            butt=but, tend=tnd, txit=txt, focus=False, clicks=self.doClick)
-        if not self.new:
-            for x in xrange(1, 15):
-                self.df.loadEntry("T", 0, x-1, data=self.old[x])
-            if self.sys == "CS":
-                self.df.loadEntry("T", 0, 14, data=self.old[16])
-                self.df.loadEntry("T", 0, 15, data=self.old[17])
-        self.df.focusField("T", 0, 1, clr=False)
-
-    def doClick(self, *opts):
-        if self.df.pag == 0:
-            return
-        self.df.focusField("T", opts[0][0], opts[0][1] + 1)
-
-    def doNam(self, frt, pag, r, c, p, i, w):
-        self.name = w
-        self.opts["conam"] = self.name
-        self.opts["capnm"] = "admin"
-
-    def doVatNum(self, frt, pag, r, c, p, i, w):
-        self.vatnum = w
-        if not self.vatnum:
-            self.vat = "N"
-            acc = self.doReadVat(self.vat)
-            if not acc:
-                self.sql.insRec("ctlvmf", data=[self.opts["conum"], self.vat,
-                    "No VAT", "N"])
-                self.sql.insRec("ctlvrf", data=[self.opts["conum"], self.vat,
-                    0, 0])
-            self.df.loadEntry(frt, pag, p+1, data=self.vat)
-            return "sk1"
-
-    def doVatCod(self, frt, pag, r, c, p, i, w):
-        self.vat = w
-        acc = self.doReadVat(self.vat)
-        if not acc:
-            if self.vat == "N":
-                self.sql.insRec("ctlvmf", data=[self.opts["conum"], self.vat,
-                    "No VAT", "N"])
-                self.sql.insRec("ctlvrf", data=[self.opts["conum"], self.vat,
-                    0, 0])
-            else:
-                ok = askQuestion(self.opts["mf"].body, "Invalid VAT Code",
-                    "This Code Does Not Exist, Do You Want to Create It?")
-                if ok == "no":
-                    return "Invalid Code"
-                state = self.df.disableButtonsTags()
-                self.df.setWidget(self.df.mstFrame, state="hide")
-                callModule(self.opts["mf"], None, "ms1040",
-                    coy=(self.opts["conum"], self.opts["conam"]),
-                    user=self.opts["capnm"], args=self.vat)
-                self.df.setWidget(self.df.mstFrame, state="show")
-                self.df.enableButtonsTags(state=state)
-                acc = self.doReadVat(self.vat)
-                if not acc:
-                    self.df.loadEntry(frt, pag, p, data="")
-                    return "Invalid Code"
-
-    def doReadVat(self, w):
-        acc = self.sql.getRec("ctlvmf", cols=["vtm_desc"],
-            where=[("vtm_cono", "=", self.opts["conum"]),
-            ("vtm_code", "=", w)], limit=1)
-        return acc
-
-    def doEnd(self):
-        data = [self.opts["conum"]]
-        for x in xrange(14):
-            data.append(self.df.t_work[0][0][x])
-        if self.sys == "CS":
-            data.extend(["", self.df.t_work[0][0][14],
-                self.df.t_work[0][0][15], "","","","","GLCS",""])
-        else:
-            data.extend(["","","N","","","","",self.sys,""])
-        if self.new:
-            self.sql.insRec("ctlmst", data=data)
-        elif data != self.old:
-            self.sql.updRec("ctlmst", data=data, where=[("ctm_cono",
-                "=", self.opts["conum"])])
-            dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-            for num, dat in enumerate(self.old):
-                if dat != data[num]:
-                    self.sql.insRec("chglog", data=["ctlmst", "U",
-                        "%03i" % self.opts["conum"], self.sql.ctlmst_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
-        self.opts["mf"].dbm.commitDbase()
-        self.closeProcess()
-
-    def closeProcess(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
-    def doAccept(self):
-        frt, pag, col, mes = self.df.doCheckFields(("T", 0, None))
-        if mes:
-            self.df.focusField(frt, pag, (col+1), err=mes)
-        else:
-            self.df.doEndFrame("T", 0, cnf="N")
-
-    def doExit(self):
-        self.df.closeProcess()
-        self.opts["mf"].closeLoop()
-
-# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'mst/ms1020.py' (properties changed: -x to +x)
--- old/mst/ms1020.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms1020.py	2020-04-29 14:03:26 +0000
@@ -25,7 +25,7 @@
 """
 
 from TartanClasses import GetCtl, Sql, TartanDialog
-from tartanFunctions import showError
+from tartanFunctions import chkGenAcc, showError
 
 class ms1020(object):
     def __init__(self, **opts):
@@ -101,25 +101,31 @@
                 "","N",self.doName,None,self.doDelete,("notblank",))]
         if self.glint == "Y":
             if self.coys == 1:
-                self.fld.append((("T",0,2,0),"OUI",3,"Debit  Company"))
+                self.fld.append((("T",0,2,0),"OUI",7,"Debit  Company"))
             else:
-                self.fld.append((("T",0,2,0),"IUI",3,"Debit  Company","",
-                    self.opts["conum"],"N",self.doCoy,coy,None,("notzero",)))
+                self.fld.append((("T",0,2,0),"IUI",7,"Debit  Company","",
+                    self.opts["conum"],"N",self.doCoy,coy,None,None))
+            self.fld.append((("T",0,2,0),"ONA",30,""))
             self.fld.extend([
                 (("T",0,3,0),"IUI",7,"       Salary A/C","",
                     "","N",self.doSal,glm,None,("notzero",)),
+                (("T",0,3,0),"ONA",30,""),
                 (("T",0,4,0),"IUI",7,"       Commission A/C","",
-                    "","N",self.doCom,glm,None,("efld",))])
+                    "","N",self.doCom,glm,None,("efld",)),
+                (("T",0,4,0),"ONA",30,"")])
             if self.coys == 1:
-                self.fld.append((("T",0,5,0),"OUI",3,"Credit Company"))
+                self.fld.append((("T",0,5,0),"OUI",7,"Credit Company"))
             else:
-                self.fld.append((("T",0,5,0),"IUI",3,"Credit Company","",
-                    self.opts["conum"],"N",self.doCoy,coy,None,("notzero",)))
+                self.fld.append((("T",0,5,0),"IUI",7,"Credit Company","",
+                    self.opts["conum"],"N",self.doCoy,coy,None,None))
+            self.fld.append((("T",0,5,0),"ONA",30,""))
             self.fld.extend([
                 (("T",0,6,0),"IUI",7,"       Salary A/C","",
-                    "","N",self.doSal,glm,None,("efld",)),
+                    "","N",self.doSal,glm,None,("notzero",)),
+                (("T",0,6,0),"ONA",30,""),
                 (("T",0,7,0),"IUI",7,"       Commission A/C","",
-                    "","N",self.doCom,glm,None,("efld",))])
+                    "","N",self.doCom,glm,None,("efld",)),
+                (("T",0,7,0),"ONA",30,"")])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
             ("Cancel",None,self.doCancel,0,("T",0,2),("T",0,0)),
@@ -135,75 +141,84 @@
             self.opts["conum"]), ("dep_code", "=", self.code)], limit=1)
         if not self.old:
             self.new = "Y"
-            self.name = ""
-            self.co1 = 0
-            self.sl1 = 0
-            self.cm1 = 0
-            self.co2 = 0
-            self.sl2 = 0
-            self.cm2 = 0
         else:
             self.new = "N"
-            self.name = self.old[self.sql.ctldep_col.index("dep_name")]
-            self.co1 = self.old[self.sql.ctldep_col.index("dep_dr_coy")]
-            self.sl1 = self.old[self.sql.ctldep_col.index("dep_dr_sal")]
-            self.cm1 = self.old[self.sql.ctldep_col.index("dep_dr_com")]
-            self.co2 = self.old[self.sql.ctldep_col.index("dep_cr_coy")]
-            self.sl2 = self.old[self.sql.ctldep_col.index("dep_cr_sal")]
-            self.cm2 = self.old[self.sql.ctldep_col.index("dep_cr_com")]
-            for x in xrange(1, (self.df.topq[pag])):
-                self.df.loadEntry(frt, pag, p+x, data=self.old[x+1])
+        self.doLoadRec(self.old)
+
+    def doLoadRec(self, rec):
+        if not rec:
+            self.df.clearFrame("T", 0)
+            self.df.loadEntry("T", 0, 0, data=self.code)
+            return
+        for num, dat in enumerate(rec[2:-1]):
+            if num == 0:
+                seq = 1
+                self.df.loadEntry("T", 0, seq, data=dat)
+                if self.glint == "N":
+                    return
+                seq += 1
+            elif num in (1, 4):
+                coy = dat
+                nam = self.sql.getRec("ctlmst", cols=["ctm_name"],
+                    where=[("ctm_cono", "=", coy)], limit=1)
+                self.df.loadEntry("T", 0, seq, data=coy)
+                self.df.loadEntry("T", 0, seq+1, data=nam[0])
+                seq += 2
+            elif num in (2, 3, 5, 6):
+                if dat:
+                    dsc = self.sql.getRec("genmst", cols=["glm_desc"],
+                        where=[("glm_cono", "=", coy), ("glm_acno",
+                        "=", dat)], limit=1)
+                else:
+                    dsc = [""]
+                self.df.loadEntry("T", 0, seq, data=dat)
+                self.df.loadEntry("T", 0, seq + 1, data=dsc[0])
+                seq += 2
 
     def doName(self, frt, pag, r, c, p, i, w):
         self.name = w
         if self.glint == "Y" and self.coys == 1:
             self.co1 = self.opts["conum"]
-            self.df.loadEntry(frt, pag, p+1, data=self.co1)
-            return "sk1"
+            self.co2 = self.opts["conum"]
+            self.df.loadEntry(frt, pag, p+1, data=self.opts["conum"])
+            self.df.loadEntry(frt, pag, p+2, data=self.opts["conam"])
+            return "sk2"
 
     def doCoy(self, frt, pag, r, c, p, i, w):
         coy = self.sql.getRec("ctlmst", cols=["ctm_name "],
             where=[("ctm_cono", "=", w)], limit=1)
         if not coy:
             return "Invalid Company Number"
-        if c == 3:
+        if p == 2:
             self.co1 = w
         else:
             self.co2 = w
+        self.df.loadEntry(frt, pag, p+1, coy[0])
 
     def doSal(self, frt, pag, r, c, p, i, w):
-        if w:
-            if c == 4:
-                co = self.co1
-            else:
-                co = self.co2
-            acc = self.sql.getRec("genmst", cols=["glm_desc"],
-                where=[("glm_cono", "=", co), ("glm_acno", "=", w)], limit=1)
-            if not acc:
-                return "Invalid Account Number"
-        if c == 4:
-            self.sl1 = w
+        if p == 4:
+            co = self.co1
         else:
-            self.sl2 = w
+            co = self.co2
+        chk = chkGenAcc(self.opts["mf"], co, w)
+        if type(chk) is str:
+            return chk
+        self.df.loadEntry(frt, pag, p+1, data=chk[0])
 
     def doCom(self, frt, pag, r, c, p, i, w):
         if w:
-            if c == 5:
+            if p == 6:
                 co = self.co1
             else:
                 co = self.co2
-            acc = self.sql.getRec("genmst", cols=["glm_desc"],
-                where=[("glm_cono", "=", co), ("glm_acno", "=", w)], limit=1)
-            if not acc:
-                return "Invalid Account Number"
-        if c == 5:
-            self.cm1 = w
-            if self.coys == 1:
-                self.co2 = self.opts["conum"]
-                self.df.loadEntry(frt, pag, p+1, data=self.co2)
-                return "sk1"
-        else:
-            self.cm2 = w
+            chk = chkGenAcc(self.opts["mf"], co, w)
+            if type(chk) is str:
+                return chk
+            self.df.loadEntry(frt, pag, p+1, data=chk[0])
+        if p == 6 and self.coys == 1:
+            self.df.loadEntry(frt, pag, p+2, data=self.opts["conum"])
+            self.df.loadEntry(frt, pag, p+3, data=self.opts["conam"])
+            return "sk2"
 
     def doDelete(self):
         if self.glint == "Y":
@@ -217,13 +232,18 @@
         self.df.focusField("T", 0, 1)
 
     def doEnd(self):
-        dat = [self.opts["conum"], self.code, self.name, self.co1,
-            self.sl1, self.cm1, self.co2, self.sl2, self.cm2]
+        data = [self.opts["conum"]]
+        for num, dat in enumerate(self.df.t_work[0][0]):
+            if num in (3, 5, 7, 9, 11, 13):
+                continue
+            data.append(dat)
         if self.new == "Y":
-            self.sql.insRec("ctldep", data=dat)
-        elif dat != self.old[:len(dat)]:
-            self.sql.updRec("ctldep", data=dat, where=[("dep_cono", "=",
-            self.opts["conum"]), ("dep_code", "=", self.code)])
+            self.sql.insRec("ctldep", data=data)
+        elif data != self.old[:len(data)]:
+            col = self.sql.ctldep_col
+            data.append(self.old[col.index("dep_xflag")])
+            self.sql.updRec("ctldep", data=data, where=[("dep_cono",
+                "=", self.opts["conum"]), ("dep_code", "=", self.code)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'mst/ms1030.py' (properties changed: -x to +x)
=== modified file 'mst/ms1040.py' (properties changed: -x to +x)
--- old/mst/ms1040.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms1040.py	2020-05-27 12:02:27 +0000
@@ -133,8 +133,7 @@
         state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-            heads=[hds],
-            ttype="D", cols=col, prtdia=(("Y","V"), ("Y","N")))
+            heads=[hds], ttype="D", cols=col, prtdia=(("Y","V"), ("Y","N")))
         self.df.setWidget(self.df.mstFrame, state="show")
         self.df.enableButtonsTags(state=state)
         self.df.focusField("T", 0, 1)
@@ -154,6 +153,22 @@
             self.doLoadRates()
             return "ff2"
 
+    def doDelete(self):
+        if self.df.frt == "T":
+            if self.doCheckTrn():
+                showError(self.opts["mf"].body, "Exists",
+                    "Transactions Exist for this Code, Not Deleted")
+                return
+            self.sql.delRec("ctlvmf", where=[("vtm_cono", "=",
+                self.opts["conum"]), ("vtm_code", "=", self.code)])
+            dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+            self.sql.insRec("chglog", data=["ctlvmf", "D", "%03i%-1s" % \
+                (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
+                "", "", "", 0])
+            self.sql.delRec("ctlvrf", where=[("vtr_cono", "=",
+                self.opts["conum"]), ("vtr_code", "=", self.code)])
+            self.opts["mf"].dbm.commitDbase()
+
     def doDesc(self, frt, pag, r, c, p, i, w):
         self.desc = w
 
@@ -177,6 +192,8 @@
         elif self.cat in ("N", "X", "Z"):
             self.df.focusField("T", 0, 1)
         elif datm != self.oldm[:len(datm)]:
+            col = self.sql.ctlvmf_col
+            datm.append(self.oldm[col.index("vtm_xflag")])
             self.sql.updRec("ctlvmf", data=datm, where=[("vtm_cono", "=",
                 self.opts["conum"]), ("vtm_code", "=", self.code)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -184,8 +201,8 @@
                 if dat != datm[num]:
                     self.sql.insRec("chglog", data=["ctlvmf",
                     "U", "%03i%-1s" % (self.opts["conum"], self.code),
-                    self.sql.ctlvmf_col[num], dte, self.opts["capnm"],
-                    str(dat), str(datm[num]), 0])
+                    col[num], dte, self.opts["capnm"], str(dat),
+                    str(datm[num]), "", 0])
             self.doButtons()
         self.opts["mf"].dbm.commitDbase()
 
@@ -345,22 +362,6 @@
                 return "Invalid Rate"
         self.rate = w
 
-    def doDelete(self):
-        if self.df.frt == "T":
-            if self.doCheckTrn():
-                showError(self.opts["mf"].body, "Exists",
-                    "Transactions Exist for this Code, Not Deleted")
-                return
-            self.sql.delRec("ctlvmf", where=[("vtm_cono", "=",
-                self.opts["conum"]), ("vtm_code", "=", self.code)])
-            dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-            self.sql.insRec("chglog", data=["ctlvmf", "D", "%03i%-1s" % \
-                (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
-                "", "", 0])
-            self.sql.delRec("ctlvrf", where=[("vtr_cono", "=",
-                self.opts["conum"]), ("vtr_code", "=", self.code)])
-            self.opts["mf"].dbm.commitDbase()
-
     def doCheckTrn(self, date=None):
         where = [
             ("vtt_cono", "=", self.opts["conum"]),
@@ -375,16 +376,18 @@
         if self.newr:
             self.sql.insRec("ctlvrf", data=datr)
         elif datr != self.oldr[:len(datr)]:
+            col = self.sql.ctlvrf_col
+            datr.append(self.oldr[col.index("vtr_xflag")])
             self.sql.updRec("ctlvrf", data=datr, where=[("vtr_cono", "=",
                 self.opts["conum"]), ("vtr_code", "=", self.code),
                 ("vtr_date", "=", self.start)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.oldr):
                 if dat != datr[num]:
-                    self.sql.insRec("chglog", data=["ctlvrf",
-                    "U", "%03i%-1s" % (self.opts["conum"], self.code),
-                    self.sql.ctlvmf_col[num], dte, self.opts["capnm"],
-                    str(dat), str(datr[num]), 0])
+                    self.sql.insRec("chglog", data=["ctlvrf", "U",
+                        "%03i%-1s" % (self.opts["conum"], self.code),
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(datr[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.edit = False
         self.doExit()

=== modified file 'mst/ms3010.py' (properties changed: -x to +x)
--- old/mst/ms3010.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms3010.py	2020-06-21 10:25:31 +0000
@@ -173,9 +173,9 @@
         chk = self.sql.getRec("ctlynd", cols=["cye_start", "cye_end"],
             where=[("cye_cono", "=", self.opts["conum"])])
         self.start = 0
-        for c in chk:
-            if self.eper >= int(c[0] / 100) and int(self.eper <= c[1] / 100):
-                self.start = c[0]
+        for ck in chk:
+            if self.eper >= int(ck[0] / 100) and int(self.eper <= ck[1] / 100):
+                self.start = ck[0]
         if not self.start:
             return "Invalid Ending Period"
 
@@ -257,8 +257,7 @@
         p1 = ProgressBar(self.opts["mf"].body, mxs=len(recs),
             typ="VAT Categories")
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("VAT Statement for Period %s to %s" % \
             (self.sperd, self.eperd))
@@ -267,9 +266,9 @@
         self.expdatas = []
         self.pcat = None
         self.pcode = None
-        for n1, dat in enumerate(recs):
+        for n1, dat1 in enumerate(recs):
             p1.displayProgress(n1)
-            vals = self.getValues1(dat)
+            vals = self.getValues1(dat1)
             if not vals:
                 continue
             code, self.pdesc, cat, vtf = vals
@@ -291,10 +290,10 @@
                 self.pcode = code
             p2 = ProgressBar(self.opts["mf"].body, mxs=len(vtf), inn=p1,
                 typ="Category Transactions")
-            for n2, dat in enumerate(vtf):
+            for n2, dat2 in enumerate(vtf):
                 p2.displayProgress(n2)
                 vtyp, curdt,styp, ttyp, acno, refno, refdt, desc, exc, \
-                    vtr, tax, inc = self.getValues2(dat)
+                    vtr, tax, inc = self.getValues2(dat2)
                 line = ["BODY", [self.pcode, vtyp.work, curdt.work, styp.work,
                     ttyp.work, acno.work, refno.work, refdt.work, desc.work,
                     vtr.work]]
@@ -345,9 +344,9 @@
         self.pglin = 999
         self.pcat = None
         self.pcode = None
-        for n1, dat in enumerate(recs):
+        for n1, dat1 in enumerate(recs):
             p1.displayProgress(n1)
-            vals = self.getValues1(dat)
+            vals = self.getValues1(dat1)
             if not vals:
                 continue
             code, self.pdesc, cat, vtf = vals
@@ -376,10 +375,10 @@
                     self.doPrintHeading("C")
             p2 = ProgressBar(self.opts["mf"].body, mxs=len(vtf), inn=p1,
                 typ="Category Transactions")
-            for n2, dat in enumerate(vtf):
+            for n2, dat2 in enumerate(vtf):
                 p2.displayProgress(n2)
                 vtyp, curdt,styp, ttyp, acno, refno, refdt, desc, exc, \
-                    vtr, tax, inc = self.getValues2(dat)
+                    vtr, tax, inc = self.getValues2(dat2)
                 if self.pglin > self.fpdf.lpp:
                     self.doPrintHeading("A")
                 if vtyp.work == "I":
@@ -429,8 +428,7 @@
                 self.doPrintHeading("S")
                 self.doPrintSummary()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'mst/ms3020.py' (properties changed: -x to +x)
--- old/mst/ms3020.py	2020-03-01 12:48:20 +0000
+++ new/mst/ms3020.py	2020-05-27 12:02:44 +0000
@@ -88,8 +88,7 @@
         odr = "pwd_cono, pwd_sys, pwd_code"
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=cols, where=whr, order=odr, repprt=self.df.repprt)
+            heads=heads, cols=cols, where=whr, order=odr, repprt=self.df.repprt)
         self.df.enableButtonsTags(state=state)
 
     def doExit(self):

=== modified file 'mst/ms3030.py' (properties changed: -x to +x)
--- old/mst/ms3030.py	2020-03-01 12:48:20 +0000
+++ new/mst/ms3030.py	2020-05-27 12:03:04 +0000
@@ -89,8 +89,7 @@
         else:
             odr = "eml_dtt desc"
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=["emllog"],
-            heads=[hds],
-            cols=col, where=whr, order=odr, repprt=self.df.repprt,
+            heads=[hds], cols=col, where=whr, order=odr, repprt=self.df.repprt,
             repeml=self.df.repeml)
         self.opts["mf"].closeLoop()
 

=== modified file 'mst/ms3040.py' (properties changed: -x to +x)
--- old/mst/ms3040.py	2020-04-21 08:42:36 +0000
+++ new/mst/ms3040.py	2020-06-12 14:50:11 +0000
@@ -52,6 +52,7 @@
             "cols": (("chg_usr", "", 0, "User Login name", "User-Login-Name"),),
             "group": "chg_usr",
             "order": "chg_usr"}
+        r1s = (("Yes", "Y"), ("No", "N"))
         fld = (
             (("T",0,0,0),"Id1",10,"Date From","",
                 0,"N",self.doDate,None,None,("efld",)),
@@ -60,9 +61,11 @@
             (("T",0,2,0),"INA",6,"Table Name","",
                 "","N",self.doTable,tab,None,("efld",)),
             (("T",0,2,0),"ONA",30,""),
-            (("T",0,3,0),"INA",20,"User Login","",
+            (("T",0,3,0),("IRB",r1s),0,"Order By Table","",
+                "Y","N",self.doOrder,None,None,None),
+            (("T",0,4,0),"INA",20,"User Login","",
                 "","N",self.doUser,usr,None,("efld",)),
-            (("T",0,3,0),"ONA",30,""))
+            (("T",0,4,0),"ONA",30,""))
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False,
@@ -94,17 +97,30 @@
             self.tname = acc[0]
             self.df.loadEntry(frt, pag, p+1, data=self.tname)
 
+    def doOrder(self, frt, pag, r, c, p, i, w):
+        self.byusr = w
+
     def doEnd(self):
         self.df.closeProcess()
         frm = CCD(self.frm, "d1", 10)
         too = CCD(self.too, "D1", 10)
         hds = "Changes Log Report from %s to %s" % (frm.disp, too.disp)
-        col = ["chg_tab", "chg_act", "chg_key", "chg_col", "chg_dte",
-                "chg_usr", "chg_old", "chg_new"]
+        col = [
+            ("chg_tab", "NA", 6.0, "TabNam"),
+            ("chg_act", "UA", 1.0, "A"),
+            ("chg_key", "NA", 30.0, "Record-Key"),
+            ("chg_col", "NA", 20.0, "Column-Name"),
+            ("chg_old", "TX", 50.0, "Old-Details"),
+            ("chg_new", "TX", 50.0, "New-Details"),
+            ("chg_dte", "TS", 19.0, "Date-&-Time-Changed"),
+            ("chg_usr", "NA", 20.0, "User-Login")]
         whr = [
-            ("chg_dte", ">=", (frm.work * 1000000)),
-            ("chg_dte", "<=", ((too.work * 1000000) + 999999))]
-        odr = "chg_dte"
+            ("chg_dte", ">=", str(frm.work * 1000000)),
+            ("chg_dte", "<=", str((too.work * 1000000) + 999999))]
+        if self.byusr == "Y":
+            odr = "chg_tab, chg_dte"
+        else:
+            odr = "chg_dte"
         if self.table:
             whr.append(("chg_tab", "=", self.table))
         if self.user:

=== modified file 'mst/msc110.py' (properties changed: -x to +x)
--- old/mst/msc110.py	2020-04-21 08:42:36 +0000
+++ new/mst/msc110.py	2020-10-15 11:32:14 +0000
@@ -82,7 +82,7 @@
             (("T",0,9,0),"ITX",20,"SMTP Username","",
                 self.acc[9],"N",self.doUsr,None,None,None),
             (("T",0,10,0),"IHA",20,"SMTP Password","",
-                self.acc[10],"N",self.doPwd,None,None,None),
+                self.acc[10],"N",None,None,None,None),
             (("T",0,11,0),("IRB",r1s),0,"SMS Service","",
                 self.acc[11],"N",self.doSms,None,None,None),
             (("T",0,12,0),"ITX",20,"SMS Username","",
@@ -118,8 +118,8 @@
 
     def doSmtp(self, frt, pag, r, c, p, i, w):
         if not w:
-            self.df.loadEntry(frt, pag, p+1, data="")
-            self.df.loadEntry(frt, pag, p+2, data="")
+            self.df.loadEntry(frt, pag, p+1, data="0")
+            self.df.loadEntry(frt, pag, p+2, data="0")
             self.df.loadEntry(frt, pag, p+3, data="")
             self.df.loadEntry(frt, pag, p+4, data="")
             self.df.loadEntry(frt, pag, p+5, data="")
@@ -140,10 +140,6 @@
         if not w:
             return "Invalid SMTP Name"
 
-    def doPwd(self, frt, pag, r, c, p, i, w):
-        if not w:
-            return "Invalid SMTP Password"
-
     def doSms(self, frt, pag, r, c, p, i, w):
         if w == "Y" and not chkMod("requests"):
             showError(self.opts["mf"].body, "Error", "Missing requests Module")
@@ -170,9 +166,6 @@
         if w == "N":
             self.df.loadEntry(frt, pag, p+1, data=0)
             return "sk1"
-        chk = self.sql.getRec("genmst")
-        if chk:
-            return "General Ledger Accounts Already Exist"
 
     def doEnd(self):
         svr = self.df.t_work[0][0][5]
@@ -182,11 +175,10 @@
             aut = self.df.t_work[0][0][7]
             nam = self.df.t_work[0][0][9]
             pwd = self.df.t_work[0][0][10]
-            if not sendMail([svr, prt, sec, aut, nam, pwd], "", "", "",
-                    check=True, err=self.opts["mf"].body,
-                    wrkdir=self.opts["mf"].rcdic["wrkdir"]):
-                showError(self.opts["mf"].body, "Error",
-                    "Mail Server Invalid or Unavailable")
+            chk = sendMail([svr, prt, sec, aut, nam, pwd], "", "", "",
+                check=True, err=self.opts["mf"].body,
+                wrkdir=self.opts["mf"].rcdic["wrkdir"])
+            if not chk:
                 self.df.focusField("T", 0, 6)
                 return
         tme = time.localtime()
@@ -200,7 +192,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["ctlsys", "U",
                         "%03i" % 0, self.sql.ctlsys_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         # Reset all password dates to current date (Temporary Fix)
         dte = (tme[0] * 10000) + (tme[1] * 100) + tme[2]
         self.sql.updRec("ctlpwu", cols=["usr_last"], data=[dte])

=== modified file 'mst/msy010.py' (properties changed: -x to +x)
--- old/mst/msy010.py	2020-04-21 08:42:36 +0000
+++ new/mst/msy010.py	2020-07-11 11:04:58 +0000
@@ -27,7 +27,7 @@
 import time
 from TartanClasses import ASD, CCD, GetCtl, ProgressBar, PwdConfirm, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import getPeriods, copyList, getTrn, mthendDate
+from tartanFunctions import getPeriods, copyList, doAutoAge, mthendDate
 from tartanFunctions import showError
 from tartanWork import tabdic
 
@@ -60,16 +60,16 @@
         ctlmst = self.gc.getCtl("ctlmst", self.opts["conum"])
         if not ctlmst:
             return
-        tab = ["ctlsys", "ctlynd", "ftable"]
+        tabs = ["ctlsys", "ctlynd", "ftable"]
         self.mod = []
         for x in xrange(0, len(ctlmst["ctm_modules"].rstrip()), 2):
             self.mod.append(ctlmst["ctm_modules"][x:x+2])
         if "AR" in self.mod:
-            tab.append("assctl")
+            tabs.append("assctl")
         if "CR" in self.mod:
-            tab.append("crsage")
+            tabs.append("crsage")
         if "DR" in self.mod:
-            tab.append("drsage")
+            tabs.append("drsage")
         if "GL" in self.mod:
             ctlctl = self.gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -77,19 +77,19 @@
             if self.gc.chkRec(self.opts["conum"], ctlctl, ["ret_inc"]):
                 return
             self.ri_acc = ctlctl["ret_inc"]
-            tab.extend(["genbal", "genmst", "gentrn"])
+            tabs.extend(["genbal", "genmst", "gentrn"])
         if "LN" in self.mod:
-            tab.append("lonctl")
+            tabs.append("lonctl")
         if "ML" in self.mod:
-            tab.append("memage")
-            tab.append("memctl")
+            tabs.append("memage")
+            tabs.append("memctl")
         if "RC" in self.mod:
-            tab.append("rcactl")
+            tabs.append("rcactl")
         if "RT" in self.mod:
-            tab.append("rtlctl")
+            tabs.append("rtlctl")
         if "WG" in self.mod:
-            tab.append("wagctl")
-        self.sql = Sql(self.opts["mf"].dbm, tab, prog=self.__class__.__name__)
+            tabs.append("wagctl")
+        self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
         if self.sql.error:
             return
         t = time.localtime()
@@ -225,13 +225,6 @@
                 newe = mthendDate(newe)
                 self.sql.insRec("ctlynd", data=[self.opts["conum"], (per + 1),
                     news, newe, 0, "N"])
-                if "stkmst" in tabdic:
-                    # Clear RNE Stock Take System
-                    tabs = ["stkmst", "stkpag", "stklin"]
-                    sql = Sql(self.opts["mf"].dbm, tabs,
-                            prog=self.__class__.__name__)
-                    for tab in tabs:
-                        sql.delRec(tab)
         else:
             s, e, f = getPeriods(self.opts["mf"], self.opts["conum"], per)
             if s is None or e is None:
@@ -294,14 +287,11 @@
             ["bkmtrn", "bkt_curdt", ["bkt_tramt"], "bkmmst"],
             ["chglog"],
             ["crspay", "cpt_date", []],
-            ["crsrbm", "rbm_curdt", []],
-            ["crsrdm", "rdm_curdt", []],
             ["crstrn", "crt_curdt", ["crt_tramt"], "crsmst"],
             ["ctlbat", "btm_curdt", []],
             ["ctllog"],
             ["ctlnot"],
             ["ctlvtf", "vtt_curdt", []],
-            ["drsrcm", "dcm_last", []],
             ["drstrn", "drt_curdt", ["drt_tramt"], "drsmst"],
             ["emllog"],
             ["genbal", "glo_trdt", []],
@@ -309,7 +299,6 @@
             ["gendtt", "gdt_curdt", []],
             ["genrct", "grt_date", []],
             ["gentrn", "glt_curdt", ["glt_tramt"], "genmst"],
-            ["ibtmst", "ibm_date", []],
             ["lontrn", "lnt_curdt", ["lnt_tramt"], "lonmf2"],
             ["memtrn", "mlt_curdt", ["mlt_tramt"], "memmst"],
             ["memtrs", "mst_trdt", []],
@@ -330,7 +319,7 @@
         last = ynds[len(ynds) - (self.years + 1)]
         sdate = last[self.sql.ctlynd_col.index("cye_start")]
         edate = last[self.sql.ctlynd_col.index("cye_end")]
-        elong = (edate * 1000000) + 999999
+        etime = (edate * 10000) + 9999
         emldt = "%04i-%02i-99 99:99" % (int(edate / 10000),
             (int(edate / 100) % 100))
         ecurdt = int(edate / 100)
@@ -348,12 +337,7 @@
         ourtab = []
         for tab in tables:
             ourtab.append(tab[0])
-        tabs = []
-        for tab in TABLES:
-            if tab[0] in ourtab:
-                tabs.append(tab[0])
-            if len(tab) > 3:
-                tabs.append(tab[3])
+        tabs = list(tabdic.keys())
         if "args" not in self.opts:
             pb = ProgressBar(self.opts["mf"].body, typ=("G",
                 "Dropping Periods Older Than %s Years" % self.years))
@@ -366,10 +350,10 @@
             if tab[0] == "chglog":
                 key = "%03i%s" % (self.opts["conum"], "%")
                 sql.delRec(tab[0], where=[("chg_key", "like", key),
-                    ("chg_dte", "<=", elong)])
+                    ("chg_dte", "<=", etime)])
                 continue
             if tab[0] == "ctllog":
-                sql.delRec(tab[0], where=[("clg_start", "<=", elong)])
+                sql.delRec(tab[0], where=[("clg_start", "<=", etime)])
                 continue
             if tab[0] == "ctlnot":
                 sql.delRec(tab[0], where=[("not_cono", "=",
@@ -435,16 +419,6 @@
                 elif tab[0] == "genrct":
                     whrt.append((tab[1], "<=", sdate))
                     sql.delRec(tab[0], where=whrt)
-                elif tab[0] == "ibtmst":
-                    whrt.append((tab[1], "<=", edate))
-                    recs = sql.getRec(tables=tab[0], where=whrt)
-                    for num, rec in enumerate(recs):
-                        if "args" not in self.opts and not num % 10:
-                            pb.displayProgress()
-                        sql.delRec(tab[0], where=[("ibm_cono", "=", rec[0]),
-                            ("ibm_docno", "=", rec[1])])
-                        sql.delRec("ibttrn", where=[("ibt_cono", "=", rec[0]),
-                            ("ibt_docno", "=", rec[1])])
                 elif tab[0] == "memtrs":
                     whrt.append((tab[1], "<=", sdate))
                     sql.delRec(tab[0], where=whrt)
@@ -595,54 +569,7 @@
                             self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
                         # Re-Age Transactions
-                        self.sql.delRec("crsage", where=[("cra_cono", "=",
-                            rec[0]), ("cra_acno", "=", rec[1])])
-                        crc, cr = getTrn(self.opts["mf"].dbm, "crs",
-                            whr=[("crt_cono", "=", rec[0]), ("crt_acno", "=",
-                                rec[1]), ("crt_tramt", "<", 0)], zer="N")
-                        if cr:
-                            drc, dr = getTrn(self.opts["mf"].dbm, "crs",
-                                whr=[("crt_cono", "=", rec[0]), ("crt_acno",
-                                "=", rec[1]), ("crt_tramt", ">", 0)],
-                                neg=False, zer="N")
-                            if dr:
-                                for cno, ctr in enumerate(cr):
-                                    ccdt = ctr[crc.index("crt_curdt")]
-                                    cbal = ctr[crc.index("balance")]
-                                    camt = cbal
-                                    for dno, dtr in enumerate(dr):
-                                        dbal = dtr[drc.index("balance")]
-                                        if not dbal:
-                                            continue
-                                        damt = float(ASD(dbal) + ASD(camt))
-                                        if damt < 0:
-                                            camt = damt
-                                            damt = 0.00
-                                        else:
-                                            camt = 0.00
-                                        diff = float(ASD(dbal) - ASD(damt))
-                                        dr[dno][drc.index("balance")] = damt
-                                        if diff:
-                                            self.sql.insRec("crsage",
-                                                data=[rec[0], rec[1],
-                                                dtr[drc.index("crt_type")],
-                                                dtr[drc.index("crt_ref1")],
-                                                ccdt,
-                                                ctr[drc.index("crt_type")],
-                                                ctr[drc.index("crt_ref1")],
-                                                diff, 0])
-                                        if not camt:
-                                            break
-                                    diff = float(ASD(cbal) - ASD(camt))
-                                    if diff:
-                                        self.sql.insRec("crsage",
-                                            data=[rec[0], rec[1],
-                                            ctr[drc.index("crt_type")],
-                                            ctr[drc.index("crt_ref1")],
-                                            ccdt,
-                                            ctr[drc.index("crt_type")],
-                                            ctr[drc.index("crt_ref1")],
-                                            diff, 0])
+                        doAutoAge(self.opts["mf"].dbm, "crs", rec[0], rec[1])
                     elif tab[0] == "drstrn" and bals[0]:
                         data = rec[:3]
                         data.extend([3, "Bal-Fwd", "Bal-Fwd", edate, "",
@@ -650,57 +577,8 @@
                             self.opts["capnm"], self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
                         # Re-Age Transactions
-                        self.sql.delRec("drsage", where=[("dra_cono",
-                            "=", rec[0]), ("dra_chain", "=", rec[1]),
-                            ("dra_acno", "=", rec[2])])
-                        crc, cr = getTrn(self.opts["mf"].dbm, "drs",
-                            whr=[("drt_cono", "=", rec[0]), ("drt_chain",
-                            "=", rec[1]), ("drt_acno", "=", rec[2]),
-                            ("drt_tramt", "<", 0)], zer="N")
-                        if cr:
-                            drc, dr = getTrn(self.opts["mf"].dbm, "drs",
-                                whr=[("drt_cono", "=", rec[0]), ("drt_chain",
-                                "=", rec[1]), ("drt_acno", "=", rec[2]),
-                                ("drt_tramt", ">", 0)], neg=False, zer="N")
-                            if dr:
-                                for cno, ctr in enumerate(cr):
-                                    ccdt = ctr[crc.index("drt_curdt")]
-                                    cbal = CCD(ctr[crc.index("balance")],
-                                        "SD", 13.2).work
-                                    camt = cbal
-                                    for dno, dtr in enumerate(dr):
-                                        dbal = dtr[drc.index("balance")]
-                                        if not dbal:
-                                            continue
-                                        damt = float(ASD(dbal) + ASD(camt))
-                                        if damt < 0:
-                                            camt = damt
-                                            damt = 0.00
-                                        else:
-                                            camt = 0.00
-                                        diff = float(ASD(dbal) - ASD(damt))
-                                        dr[dno][drc.index("balance")] = damt
-                                        if diff:
-                                            self.sql.insRec("drsage",
-                                                data=[rec[0], rec[1], rec[2],
-                                                dtr[drc.index("drt_type")],
-                                                dtr[drc.index("drt_ref1")],
-                                                ccdt,
-                                                ctr[drc.index("drt_type")],
-                                                ctr[drc.index("drt_ref1")],
-                                                diff, 0])
-                                        if not camt:
-                                            break
-                                    diff = float(ASD(cbal) - ASD(camt))
-                                    if diff:
-                                        self.sql.insRec("drsage", data=[rec[0],
-                                            rec[1], rec[2],
-                                            ctr[drc.index("drt_type")],
-                                            ctr[drc.index("drt_ref1")],
-                                            ccdt,
-                                            ctr[drc.index("drt_type")],
-                                            ctr[drc.index("drt_ref1")],
-                                            diff, 0])
+                        doAutoAge(self.opts["mf"].dbm, "drs", rec[0], rec[1],
+                            rec[2])
                     elif tab[0] == "gentrn" and bals[0]:
                         continue
                     elif tab[0] == "memtrn" and bals[0]:
@@ -710,53 +588,7 @@
                             self.opts["capnm"], self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
                         # Re-Age Transactions
-                        self.sql.delRec("memage", where=[("mta_cono",
-                            "=", rec[0]), ("mta_acno", "=", rec[1])])
-                        crc, cr = getTrn(self.opts["mf"].dbm, "mem",
-                            whr=[("mlt_cono", "=", rec[0]), ("mlt_memno",
-                            "=", rec[1]), ("mlt_tramt", "<", 0)], zer="N")
-                        if cr:
-                            drc, dr = getTrn(self.opts["mf"].dbm, "mem",
-                                whr=[("mlt_cono", "=", rec[0]), ("mlt_memno",
-                                "=", rec[1]), ("mlt_tramt", ">", 0)],
-                                neg=False, zer="N")
-                            if dr:
-                                for cno, ctr in enumerate(cr):
-                                    ccdt = ctr[crc.index("mlt_curdt")]
-                                    cbal = CCD(ctr[crc.index("balance")],
-                                        "SD", 13.2).work
-                                    camt = cbal
-                                    for dno, dtr in enumerate(dr):
-                                        dbal = dtr[drc.index("balance")]
-                                        if not dbal:
-                                            continue
-                                        damt = float(ASD(dbal) + ASD(camt))
-                                        if damt < 0:
-                                            camt = damt
-                                            damt = 0.00
-                                        else:
-                                            camt = 0.00
-                                        diff = float(ASD(dbal) - ASD(damt))
-                                        dr[dno][drc.index("balance")] = damt
-                                        if diff:
-                                            self.sql.insRec("memage",
-                                                data=[rec[0], rec[1],
-                                                dtr[drc.index("mlt_type")],
-                                                dtr[drc.index("mlt_refno")],
-                                                ccdt,
-                                                ctr[drc.index("mlt_type")],
-                                                ctr[drc.index("mlt_refno")],
-                                                diff, 0])
-                                        if not camt:
-                                            break
-                                    diff = float(ASD(cbal) - ASD(camt))
-                                    if diff:
-                                        self.sql.insRec("memage", data=[rec[0],
-                                            rec[1], ctr[drc.index("mlt_type")],
-                                            ctr[drc.index("mlt_refno")], ccdt,
-                                            ctr[drc.index("mlt_type")],
-                                            ctr[drc.index("mlt_refno")],
-                                            diff, 0])
+                        doAutoAge(self.opts["mf"].dbm, "mem", rec[0], rec[1])
                     elif tab[0] == "rcaowt" and bals[0]:
                         data = rec[:2]
                         data.extend([4, "Bal-Fwd", "Bal-Fwd", edate, bals[0],

=== modified file 'mst/msy020.py' (properties changed: -x to +x)
=== added file 'pos/__init__.py'
=== modified file 'pos/ps2010.py' (properties changed: -x to +x)
--- old/pos/ps2010.py	2020-04-21 08:42:36 +0000
+++ new/pos/ps2010.py	2020-07-17 10:25:27 +0000
@@ -31,13 +31,13 @@
 except:
     ESCPOS = False
 from TartanClasses import tk, tkfont, ttk
-from TartanClasses import AgeAll, ASD, Balances, CCD, DrawForm, GetCtl
-from TartanClasses import MyButton, MyButtonBox, MyFrame, MyLabel, PwdConfirm
+from TartanClasses import AgeAll, ASD, CCD, DrawForm, GetCtl, MyButton
+from TartanClasses import MyButtonBox, MyFrame, MyLabel, PwdConfirm
 from TartanClasses import SelectChoice, SimpleDialog, SplashScreen, Sql
 from TartanClasses import TartanDialog
 from tartanFunctions import askQuestion, callModule, doPrinter, copyList
-from tartanFunctions import getMarkup, getModName, getVatRate, showError
-from tartanFunctions import showInfo
+from tartanFunctions import getCost, getImage, getModName, getSell, getVatRate
+from tartanFunctions import showError, showInfo
 
 class SmallGrid(object):
     """
@@ -374,19 +374,23 @@
         # Load Groups
         sp = SplashScreen(self.opts["mf"].window,
             "Loading Groups, Please Wait ....")
-        self.grps = self.sql.getRec(
-            tables=["strgrp", "strmf1", "strprc"],
-            cols=["gpm_group", "gpm_desc"],
-            where=[
-                ("gpm_cono", "=", self.opts["conum"]),
-                ("gpm_desc", "<>", ""),
+        tab = ["strgrp", "strmf1"]
+        col = ["gpm_group", "gpm_desc"]
+        whr = [
+            ("gpm_cono", "=", self.opts["conum"]),
+            ("gpm_desc", "<>", ""),
+            ("st1_cono=gpm_cono",),
+            ("st1_group=gpm_group",),
+            ("st1_type", "<>", "X")]
+        if self.automu == "N":
+            tab.append("strprc")
+            whr.extend([
                 ("stp_cono=gpm_cono",),
-                ("stp_group=gpm_group",),
-                ("st1_cono=gpm_cono",),
-                ("st1_group=gpm_group",),
-                ("st1_type", "<>", "X")],
-            group="gpm_group, gpm_desc",
-            order="gpm_group")
+                ("stp_group=gpm_group",)])
+        grp = "gpm_group, gpm_desc"
+        odr = "gpm_group"
+        self.grps = self.sql.getRec(tables=tab, cols=col, where=whr,
+            group=grp, order=odr)
         # Load Items
         self.glist = []
         self.itms = {}
@@ -476,8 +480,11 @@
         self.opts["mf"].window.maxsize(ww, wh)
         self.opts["mf"].window.update_idletasks()
         # Rounded Frame Image
-        prgdir = self.opts["mf"].rcdic["prgdir"]
-        imgpth = os.path.join(prgdir, "img", "white.png")
+        imgpth = os.path.join(self.opts["mf"].rcdic["wrkdir"], "white.png")
+        if not os.path.exists(imgpth):
+            getImage("white", fle=imgpth)
+        if not os.path.exists(imgpth):
+            self.img = None
         self.img = tk.PhotoImage("frameborder", file=imgpth)
         # Themes and Styles
         self.style = ttk.Style()
@@ -1044,8 +1051,8 @@
         self.vrte = getVatRate(self.sql, self.opts["conum"], self.vatcod,
             self.trdt)
         self.totqty = float(ASD(self.totqty) + ASD(qty.work))
-        self.gtp = strmf1[self.sql.strmf1_col.index("st1_type")]
-        if self.gtp == "R":
+        self.gtype = strmf1[self.sql.strmf1_col.index("st1_type")]
+        if self.gtype == "R":
             # Recipe
             recs = self.sql.getRec("strrcp", where=[("srr_cono",
                 "=", self.opts["conum"]), ("srr_group", "=", self.grp),
@@ -1056,8 +1063,8 @@
             incl = 0
             for rec in recs:
                 st1 = self.sql.getRec("strmf1", cols=["st1_type"],
-                    where=[("st1_cono", "=", rec[0]), ("st1_group", "=",
-                    rec[4]), ("st1_code", "=", rec[5])], limit=1)
+                    where=[("st1_cono", "=", rec[0]), ("st1_group",
+                    "=", rec[4]), ("st1_code", "=", rec[5])], limit=1)
                 if st1[0] == "X":
                     self.window.bell()
                     return
@@ -1069,8 +1076,7 @@
                 incl.work * self.vrte / float(ASD(self.vrte) + ASD(100)), 2)
             excl = CCD(float(ASD(incl.work) - ASD(vat)), "SD", 11.2)
         else:
-            prc, excl, incl = self.doCalSell(
-                self.grp, self.code, qty.work)
+            prc, excl, incl = self.doCalSell(self.grp, self.code, qty.work)
         if not prc.work:
             cf = PwdConfirm(self.opts["mf"], screen=self.opts["mf"].window,
                 conum=self.opts["conum"], system="INV", code="NoCharge")
@@ -1087,43 +1093,15 @@
             self.grid._scroll("Down")
         self.items.configure(text="%s" % self.totqty)
         self.values.configure(text="%s" % self.totval.disp)
-        self.body.append([self.row, self.grp, self.code, self.gtp, desc,
+        self.body.append([self.row, self.grp, self.code, self.gtype, desc,
             qty.work, prc.work, excl.work, incl.work, 0, self.vatcod])
         self.row += 1
         self.window.bell()
 
-    def doCalSell(self, grp, cod, qty, sprc=None):
-        # Calculate selling price
-        if sprc is None:
-            cst = 0
-            sprc = 0
-            prc = self.sql.getRec("strprc", cols=["stp_price"],
-                where=[("stp_cono", "=", self.opts["conum"]),
-                ("stp_group", "=", grp), ("stp_code", "=", cod),
-                ("stp_loc", "=", self.loc), ("stp_level", "=", self.plev)],
-                limit=1)
-            if prc and prc[0]:
-                sprc = prc[0]
-            else:
-                bal = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                    self.curdt, (grp, cod, self.loc, ("P",
-                    self.opts["period"][0])))
-                bals = bal.doStrBals()
-                if self.automu == "Y":
-                    if bals[7]:
-                        # Last Cost
-                        cst = bals[7]
-                    else:
-                        # Average Cost
-                        cst = bals[6]
-                    mkp = getMarkup(self.sql, self.opts["conum"], grp, cod,
-                        self.loc, self.plev)
-                    if mkp:
-                        sprc = round((cst * (100 + mkp) / 100.0), 2)
-                if not sprc and bals[8]:
-                    # Last Selling Price
-                    sprc = bals[8]
-            sprc = round(sprc * (float(ASD(100.0) + ASD(self.vrte))) / 100.0, 2)
+    def doCalSell(self, grp, cod, qty):
+        sprc = getSell(self.sql, self.opts["conum"], grp, cod, self.loc,
+            self.plev)
+        sprc = round(sprc * (float(ASD(100.0) + ASD(self.vrte))) / 100.0, 2)
         sprc = CCD(sprc, "UD", 10.2)
         incl = CCD(qty * sprc.work, "SD", 11.2)
         vat = round(incl.work * self.vrte / float(ASD(self.vrte) + ASD(100)), 2)
@@ -1223,7 +1201,7 @@
                 self.doButton(keyF, char, (self.doEntry, char), False,
                     "P", (row, col + 1))
         self.doButton(keyF, "Clear", self.doClear, rc=(4, 1))
-        x = self.doButton(keyF, "Enter", self.doCalc, rc=(4, 2, 2))
+        self.doButton(keyF, "Enter", self.doCalc, rc=(4, 2, 2))
         self.payf.pack(fill="both", expand="yes")
         self.window.update_idletasks()
         self.payf.wait_window()
@@ -1469,10 +1447,10 @@
                 "=", self.opts["conum"]), ("drm_chain", "=", self.chain),
                 ("drm_acno", "=", self.acno)], limit=1)
             if not drm:
-                self.sql.insRec(tables="drsmst", data=[self.opts["conum"],
-                    self.chain, self.acno, self.name, "", "", "", "", "",
-                    "", "", "", "", "", "", "", 0, 0, "", "", "", "", "",
-                    0, 0, 0, 0, 0, 0, "", 0, 0, ""])
+                self.sql.insRec("drsmst", data=[self.opts["conum"], self.chain,
+                    self.acno, self.name, "", "", "", "", "", "", "", "", "",
+                    "", "", "", 0, 0, "", "", "", "", "", 0, 0, 0, 0, 0, 0, "",
+                    0, 0, ""])
         # Create POS Master Record
         data = [self.opts["conum"], self.host, self.ref1, self.trdt,
             self.chain, self.acno]
@@ -1500,20 +1478,22 @@
                 grp, cod, self.loc, des, tqty, prc, texc, tinc, rte, vcd,
                 self.vrte, self.opts["capnm"], self.trdt, 0]
             self.sql.insRec("postrn", data=data)
-            # Get Cost Price and Create posrcp records
+            # Get Cost Price
             if gtp == "R":
-                # Recipe
+                # Recipe - Create posrcp records
                 cst = 0
                 recs = self.sql.getRec("strrcp", where=[("srr_cono",
                     "=", self.opts["conum"]), ("srr_group", "=", grp),
                     ("srr_code", "=", cod), ("srr_loc", "=", self.loc)])
                 for rec in recs:
-                    rcst = self.doCalCost(rec[4], rec[5], (qty * rec[6]))
-                    cst = float(ASD(cst) + ASD(rcst))
+                    icst = getCost(self.sql, self.opts["conum"], rec[4],
+                        rec[5], loc=self.loc, qty=1, ind="I")
                     data = [self.opts["conum"], self.host, self.ref1, row,
-                        rec[4], rec[5], rec[6], rcst, 0]
+                        rec[4], rec[5], rec[6], icst, 0]
                     self.sql.insRec("posrcp", data=data)
-                    rqty = qty * rec[6]
+                    rqty = round(qty * rec[6], 2)
+                    rcst = round(rqty * icst, 2)
+                    cst = float(ASD(cst) + ASD(rcst))
                     if self.refund:
                         rtyp = 5
                     else:
@@ -1527,19 +1507,16 @@
                     self.sql.insRec("strtrn", data=data)
                 if self.refund:
                     rtyp = 6
-                    rqty = float(ASD(0) - ASD(qty))
-                    rcst = float(ASD(0) - ASD(cst))
                 else:
                     rtyp = 5
-                    rqty = qty
-                    rcst = cst
                 data = [self.opts["conum"], grp, cod, self.loc, self.trdt,
-                    rtyp, self.ref1, self.batch, ref2, rqty, rcst, 0,
+                    rtyp, self.ref1, self.batch, ref2, qty, cst, 0,
                     self.curdt, self.name, 0, self.acno, self.repno, "INV",
                     0, "", self.opts["capnm"], self.trdt, 0]
                 self.sql.insRec("strtrn", data=data)
             else:
-                cst = self.doCalCost(grp, cod, qty)
+                icost, cst = getCost(self.sql, self.opts["conum"],
+                    grp, cod, loc=self.loc, qty=qty, tot=True)
             # Create/Update Stores Transaction Record
             if self.refund:
                 tqty = qty
@@ -1740,32 +1717,6 @@
                 self.sql.insRec("gentrn", data=data)
         self.opts["mf"].dbm.commitDbase()
 
-    def doCalCost(self, grp, cod, qty):
-        # Calculate cost price
-        ind = self.sql.getRec("strmf1", cols=["st1_value_ind"],
-            where=[("st1_cono", "=", self.opts["conum"]), ("st1_group", "=",
-            grp), ("st1_code", "=", cod)], limit=1)
-        bal = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
-            (grp, cod, self.loc, ("P", self.opts["period"][0])))
-        bals = bal.doStrBals()
-        if ind[0] == "N":
-            icost = 0.00
-            tcost = 0.00
-        elif ind[0] == "S":
-            icost = bals[7]
-            tcost = round((icost * qty), 2)
-        else:
-            if qty == bals[5][0]:
-                tcost = bals[5][1]
-                icost = round((tcost / qty), 2)
-            else:
-                icost = bals[6]
-                tcost = round((icost * qty), 2)
-            if not icost:
-                icost = bals[7]
-                tcost = round((icost * qty), 2)
-        return tcost
-
     def doLeft(self):
         if not self.page:
             return
@@ -1881,10 +1832,11 @@
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
             self.__class__.__name__, pfx, ext="pdf")
         self.form.output(pdfnam, "F")
-        self.form.changeSize(pdfnam)
+        if self.dtp == "S":
+            self.form.changeSize(pdfnam)
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
-            repprt=("Y", "P", self.prn))
-        if self.pcd and self.prtr:
+            repprt=("N", "P", self.prn))
+        if self.dtp == "S" and self.pcd and self.prtr:
             # Cut Paper
             self.prtr._raw(self.pcd)
 

=== modified file 'pos/ps2020.py' (properties changed: -x to +x)
--- old/pos/ps2020.py	2020-04-21 08:42:36 +0000
+++ new/pos/ps2020.py	2020-08-04 06:47:30 +0000
@@ -25,8 +25,8 @@
 """
 
 import socket, time
-from TartanClasses import ASD, CCD, MyFpdf, Sql, TartanDialog
-from tartanFunctions import askQuestion, getModName, doPrinter, showError
+from TartanClasses import ASD, CCD, MyFpdf, Sql, TartanDialog, ViewPDF
+from tartanFunctions import askQuestion, getModName, showError
 
 class ps2020(object):
     def __init__(self, **opts):
@@ -82,11 +82,11 @@
             "stype": "R",
             "tables": ("poscnt",),
             "cols": (
-                ("psc_date", "", 0, "Date"),),
+                ("psc_date", "", 0, "Date"),
+                ("psc_float", "", 0, "Float")),
             "where": [
                 ("psc_cono", "=", self.opts["conum"]),
-                ("psc_rec", "=", 0)],
-            "group": "psc_date"}
+                ("psc_rec", "=", 0)]}
         fld = (
             (("T",0,0,0),"OTX",15,"Terminal Name"),
             (("T",0,1,0),"ID1",10,"Date","",
@@ -108,8 +108,7 @@
         cxt = (self.doExit,)
         but = None
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
-            tend=tnd, txit=txt, cend=cnd, cxit=cxt, butt=but, focus=False,
-            view=("N","V"), mail=("Y","N"))
+            tend=tnd, txit=txt, cend=cnd, cxit=cxt, butt=but, focus=False)
         for x in xrange(14):
             self.df.colLabel[0][x].configure(text=self.denoms[x][0])
         self.df.loadEntry("T", 0, 0, data=self.host)
@@ -173,7 +172,7 @@
             self.df.focusField("C", 0, 1)
         elif self.df.col == 28:
             ask = askQuestion(self.opts["mf"].body, "Accept",
-                "Accept All Entries")
+                "Accept All Entries\n\nYes to Save and View\n\nNo to Re-Enter")
             if ask == "yes":
                 data = [self.opts["conum"]]
                 data.append(self.df.t_work[0][0][0])
@@ -245,12 +244,9 @@
         self.fpdf.drawText("%-32s %13s %s" % ("Total Takings", "", net.disp))
         self.fpdf.drawText("%46s %-12s" % ("", self.fpdf.suc*12))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
-            pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
-            repeml=self.df.repeml)
+        ViewPDF(self.opts["mf"], pdfnam)
         self.closeProcess()
 
     def doExit(self):

=== modified file 'pos/ps2030.py' (properties changed: -x to +x)
--- old/pos/ps2030.py	2020-04-21 08:42:36 +0000
+++ new/pos/ps2030.py	2020-05-27 12:30:32 +0000
@@ -232,8 +232,7 @@
         self.fpdf.drawText("%20s %-13s %13s %13s" % ("", self.fpdf.suc*12,
             self.fpdf.suc*12, self.fpdf.suc*12))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
             pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'pos/psc110.py' (properties changed: -x to +x)
--- old/pos/psc110.py	2020-04-21 08:42:36 +0000
+++ new/pos/psc110.py	2020-07-07 13:34:00 +0000
@@ -26,7 +26,7 @@
 
 import os, socket, sys, time
 from TartanClasses import CCD, GetCtl, Sql, TartanDialog
-from tartanFunctions import showPrinters
+from tartanFunctions import getPrinters
 
 class psc110(object):
     def __init__(self, **opts):
@@ -36,8 +36,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["posdev", "tplmst", "chglog"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["posdev", "tplmst", "chglog",
+            "strloc"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -99,10 +99,14 @@
                 ("srl_desc", "", 0, "Description", "Y")),
             "where": [("srl_cono", "=", self.opts["conum"])],
             "order": "srl_loc"}
+        prts = getPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])
+        data = prts[:]
+        if "Default" in data:
+            data.remove("Default")
         prt = {
             "stype": "C",
             "titl": "Valid Printers",
-            "data": showPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])}
+            "data": data}
         tpl = {
             "stype": "R",
             "tables": ("tplmst",),
@@ -130,7 +134,7 @@
             (("T",0,4,0),("IRB",r3s),0,"Document Type","",
                 "S","N",self.doDocTyp,None,None,None),
             (("T",0,5,0),"ITX",30,"Printer Name","",
-                "Default","N",self.doPrtNam,prt,None,None),
+                "Default","N",self.doPrtNam,prt,None,("in",prts)),
             (("T",0,6,0),"IUI",1,"Paper Width (8/6)","",
                 8,"N",self.doPrtWid,None,None,("in", (8, 6))),
             (("T",0,7,0),"INa",3,"Cut Paper Code","",
@@ -187,7 +191,7 @@
                 return "sk2"
         else:
             self.new = False
-            for num, dat in enumerate(self.acc[2:]):
+            for num, dat in enumerate(self.acc[2:-1]):
                 self.df.loadEntry(frt, pag, p+num+1, data=dat)
 
     def doLocCod(self, frt, pag, r, c, p, i, w):
@@ -245,14 +249,20 @@
             data.append(self.df.t_work[0][0][x])
         self.sql.delRec("posdev", where=[("psd_cono", "=", data[0]),
             ("psd_host", "=", data[1])])
+        if self.new:
+            data.append("")
+        else:
+            col = self.sql.posdev_col
+            data.append(self.acc[col.index("psd_xflag")])
         self.sql.insRec("posdev", data=data)
         if not self.new and data != self.acc:
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["posdev", "U",
-                        "%03i" % self.opts["conum"], self.sql.posdev_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== added file 'rca/__init__.py'
=== modified file 'rca/rc1010.py' (properties changed: -x to +x)
--- old/rca/rc1010.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc1010.py	2020-04-23 14:00:12 +0000
@@ -156,7 +156,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["rcaowm", "D", "%03i%-7s" % \
             (self.opts["conum"], self.acno), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -167,6 +167,8 @@
         if self.new == "y":
             self.sql.insRec("rcaowm", data=datm)
         elif datm != self.oldm[:len(datm)]:
+            col = self.sql.rcaowm_col
+            datm.append(self.oldm[col.index("rom_xflag")])
             self.sql.updRec("rcaowm", data=datm, where=[("rom_cono", "=",
                 self.opts["conum"]), ("rom_acno", "=", self.acno)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -174,8 +176,8 @@
                 if dat != datm[num]:
                     self.sql.insRec("chglog", data=["rcaowm", "U",
                         "%03i%-7s" % (self.opts["conum"], self.acno),
-                        self.sql.rcaowm_col[num], dte, self.opts["capnm"],
-                        str(dat), str(datm[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(datm[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'rca/rc1020.py' (properties changed: -x to +x)
--- old/rca/rc1020.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc1020.py	2020-04-24 11:24:10 +0000
@@ -35,8 +35,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "rcaprm"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "rcaprm", "rcaowm",
+            "rcatnm"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         return True
@@ -117,7 +117,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["rcaprm", "D", "%03i%-7s" % \
             (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -130,6 +130,8 @@
         if self.new == "y":
             self.sql.insRec("rcaprm", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.rcaprm_col
+            data.append(self.old[col.index("rcp_xflag")])
             self.sql.updRec("rcaprm", data=data, where=[("rcp_cono", "=",
                 self.opts["conum"]), ("rcp_code", "=", self.code)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -137,8 +139,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["rcaprm",
                         "U", "%03i%-7s" % (self.opts["conum"], self.code),
-                        self.sql.rcaprm_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'rca/rc1030.py' (properties changed: -x to +x)
--- old/rca/rc1030.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc1030.py	2020-04-24 11:24:45 +0000
@@ -35,8 +35,9 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "rcaprm", "rcatnm",
-            "rcacon", "rcatnt", "chglog"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "rcaprm", "rcaowm",
+            "rcatnm", "rcacon", "rcatnt", "chglog"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         return True
@@ -207,7 +208,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["rcatnm", "D", "%03i%-7s" % \
             (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -225,6 +226,8 @@
         else:
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             if datm != self.oldm[:len(datm)]:
+                col = self.sql.rcatnm_col
+                datm.append(self.oldm[col.index("rtn_xflag")])
                 self.sql.updRec("rcatnm", data=datm, where=[("rtn_cono", "=",
                     self.opts["conum"]), ("rtn_owner", "=", self.owner),
                     ("rtn_code", "=", self.code), ("rtn_acno", "=",
@@ -233,9 +236,11 @@
                     if dat != datm[num]:
                         self.sql.insRec("chglog", data=["rcatnm", "U",
                             "%03i%-7s%-7s" % (self.opts["conum"], self.owner,
-                            self.code), self.sql.rcatnm_col[num], dte,
-                            self.opts["capnm"], str(dat), str(datm[num]), 0])
+                            self.code), col[num], dte, self.opts["capnm"],
+                            str(dat), str(datm[num]), "", 0])
             if datc != self.oldc[-1:][0][:len(datc)]:
+                col = self.sql.rcacon_col
+                datc.append(self.oldc[col.index("rtn_xflag")])
                 self.sql.updRec("rcacon", data=datc, where=[("rcc_cono", "=",
                     self.opts["conum"]), ("rcc_owner", "=", self.owner),
                     ("rcc_code", "=", self.code), ("rcc_acno", "=", self.acno),
@@ -245,8 +250,8 @@
                         self.sql.insRec("chglog", data=["rcacon", "U",
                             "%03i%-7s%-7s%-7s%03i" % (self.opts["conum"],
                             self.owner, self.code, self.acno, self.cnum),
-                            self.sql.rcacon_col[num], dte, self.opts["capnm"],
-                            str(dat), str(datc[num]), 0])
+                            col[num], dte, self.opts["capnm"], str(dat),
+                            str(datc[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'rca/rc2010.py' (properties changed: -x to +x)
--- old/rca/rc2010.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc2010.py	2020-06-21 11:10:13 +0000
@@ -55,13 +55,13 @@
         lme = rcactl["cte_lme"]
         yr = int(lme / 10000)
         mt = int(lme / 100) % 100
-        self.lme = (yr * 10000) + (mt * 100) + 1
         if mt == 12:
             yr += 1
             mt = 1
         else:
             mt += 1
         self.nme = mthendDate((yr * 10000) + (mt * 100) + 1)
+        self.lme = (yr * 10000) + (mt * 100) + 1
         self.chk = projectDate(self.nme, 1)
         if self.glint == "Y":
             self.glbnk = rcactl["cte_glbnk"]
@@ -293,7 +293,10 @@
 
     def doOwnDat(self, frt, pag, r, c, p, i, w):
         if w <= self.lme or w > self.chk:
-            return "Invalid Date (<= %s or > %s)" % (self.lme, self.chk)
+            ov = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
+                system="RCA", code="DateOver")
+            if ov.flag == "no":
+                return "Invalid Date (<= %s or > %s)" % (self.lme, self.chk)
         self.trndat = w
         data = []
         for x in xrange(2, len(rctrtp)+1):
@@ -348,7 +351,10 @@
 
     def doTntDat(self, frt, pag, r, c, p, i, w):
         if w <= self.lme or w > self.chk:
-            return "Invalid Date (<= %s or > %s)" % (self.lme, self.chk)
+            ov = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
+                system="RCA", code="DateOver")
+            if ov.flag == "no":
+                return "Invalid Date (<= %s or > %s)" % (self.lme, self.chk)
         self.trndat = w
         data = []
         for x in xrange(1, len(rctrtp)+1):
@@ -598,7 +604,6 @@
             # Payment
             gltyp = 2
             bnk = float(ASD(0) - ASD(amt))
-            pass
         if self.df.pag == 1:
             # Owners Transaction
             accod = self.owner

=== modified file 'rca/rc3010.py' (properties changed: -x to +x)
--- old/rca/rc3010.py	2020-03-01 12:48:20 +0000
+++ new/rca/rc3010.py	2020-06-21 11:11:36 +0000
@@ -367,16 +367,16 @@
         self.totind = "Y"
         self.pageHeading()
         tot = [0,0,0,0]
-        for x in xrange(0, len(rttrtp)):
+        for x, t in enumerate(rttrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             am = CCD(self.gam[x], "SD", 13.2)
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-39s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, am.disp, vt.disp))
+                (t[1], qt.disp, am.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-26s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, am.disp, vt.disp))
+                (t[1], qt.disp, am.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(am.work))
             tot[3] = float(ASD(tot[3]) + ASD(vt.work))

=== modified file 'rca/rc3020.py' (properties changed: -x to +x)
--- old/rca/rc3020.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3020.py	2020-06-21 11:12:19 +0000
@@ -370,16 +370,16 @@
         self.totind = "Y"
         self.pageHeading()
         tot = [0,0,0,0]
-        for x in xrange(0, len(rttrtp)):
+        for x, t in enumerate(rttrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             am = CCD(self.gam[x], "SD", 13.2)
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-39s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, am.disp, vt.disp))
+                (t[1], qt.disp, am.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-26s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, am.disp, vt.disp))
+                (t[1], qt.disp, am.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(am.work))
             tot[3] = float(ASD(tot[3]) + ASD(vt.work))

=== modified file 'rca/rc3030.py' (properties changed: -x to +x)
--- old/rca/rc3030.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3030.py	2020-06-21 11:14:00 +0000
@@ -102,12 +102,12 @@
         self.tots = 0
         self.pgnum = 0
         self.pglin = 999
-        for x in xrange(0, len(recs)):
-            p.displayProgress(x)
+        for num, rec in enumerate(recs):
+            p.displayProgress(num)
             if p.quit:
                 break
-            acc = CCD(recs[x][0], "NA", 7)
-            name = CCD(recs[x][1], "NA", 30)
+            acc = CCD(rec[0], "NA", 7)
+            name = CCD(rec[1], "NA", 30)
             bals = self.sql.getRec("rcaowt", cols=["sum(rot_tramt)"],
                 where=[("rot_cono", "=", self.opts["conum"]), ("rot_acno", "=",
                 acc.work), ("rot_curdt", "<=", self.cutoff)], limit=1)
@@ -129,8 +129,7 @@
         if self.fpdf.page:
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'rca/rc3040.py' (properties changed: -x to +x)
--- old/rca/rc3040.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3040.py	2020-06-15 15:24:11 +0000
@@ -24,11 +24,11 @@
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
 
-import copy, time
+import time
 from TartanClasses import ASD, CCD, GetCtl, MyFpdf, ProgressBar, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import doPrinter, getModName, copyList, showError
-from tartanWork import mthnam
+from tartanFunctions import copyList, doPrinter, getModName, mthendDate
+from tartanFunctions import projectDate, showError
 
 class rc3040(object):
     def __init__(self, **opts):
@@ -38,7 +38,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["rcatnm","rcatnt","rcacon"],
+        self.sql = Sql(self.opts["mf"].dbm, ["rcatnm", "rcatnt", "rcacon"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -165,21 +165,8 @@
                     mths = 6 * prds.work
                 else:
                     mths = 12 * prds.work
-                yy = int(strt.work / 10000)
-                mm = (int(strt.work % 10000) / 100) + mths - 1
-                while mm < 1:
-                    yy -= 1
-                    mm += 12
-                while mm > 12:
-                    yy += 1
-                    mm -= 12
-                chkmth = copy.deepcopy(mthnam)
-                if mm == 2:
-                    if not yy % 4:
-                        chkmth[2][2] = 29
-                    else:
-                        chkmth[2][2] = 28
-                exdt = CCD(((yy*10000)+(mm*100)+chkmth[mm][2]), "D1", 10)
+                exdt = projectDate(strt.work, mths - 1, typ="months")
+                exdt = CCD(mthendDate(exdt), "D1", 10)
                 if self.styp == "E" and int(exdt.work / 100) > curdt:
                     continue
             else:
@@ -269,8 +256,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -283,7 +269,7 @@
         self.pgnum += 1
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
-        self.fpdf.drawText("%-34s %-10s %105s %5s" % ("Rental Tenants Master "\
+        self.fpdf.drawText("%-34s %-10s %119s %5s" % ("Rental Tenants Master "\
             "Report as at", self.datd, "Page", self.pgnum))
         self.fpdf.drawText()
         opts = "%-14s %-1s" % ("(Options: Type", self.styp)

=== modified file 'rca/rc3050.py' (properties changed: -x to +x)
--- old/rca/rc3050.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3050.py	2020-05-27 12:30:49 +0000
@@ -60,7 +60,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmes", "ctlmst", "rcaowm",
-            "rcaowt", "tplmst"], prog=self.__class__.__name__)
+            "rcaowt", "rcatnt", "tplmst"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -271,8 +271,7 @@
         else:
             key = "%s_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            key, ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.dated),

=== modified file 'rca/rc3060.py' (properties changed: -x to +x)
--- old/rca/rc3060.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3060.py	2020-05-27 12:30:55 +0000
@@ -327,8 +327,7 @@
         else:
             key = "%s_all_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            key, ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.dated),

=== modified file 'rca/rc3070.py' (properties changed: -x to +x)
=== modified file 'rca/rc3080.py' (properties changed: -x to +x)
=== modified file 'rca/rc3090.py' (properties changed: -x to +x)
--- old/rca/rc3090.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc3090.py	2020-05-27 12:03:35 +0000
@@ -123,9 +123,8 @@
                 ["ff", "SD", 13.2, "Balance",  "y"],
                 ["gg", "SD", 13.2, "Admin",  "y"]]
             RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-                heads=head,
-                cols=cols, gtots=["dd", "ee", "ff", "gg"], ttype="D",
-                repprt=self.df.repprt, repeml=self.df.repeml,
+                heads=head, cols=cols, gtots=["dd", "ee", "ff", "gg"],
+                ttype="D", repprt=self.df.repprt, repeml=self.df.repeml,
                 fromad=self.fromad)
 
     def doExit(self):

=== modified file 'rca/rc4010.py' (properties changed: -x to +x)
--- old/rca/rc4010.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc4010.py	2020-10-02 10:23:00 +0000
@@ -110,7 +110,7 @@
         self.acno = w
         self.name = acc[self.sql.rcaowm_col.index("rom_name")]
         self.df.loadEntry(frt, pag, p+1, data=self.name)
-        for num, fld in enumerate(acc[3:]):
+        for num, fld in enumerate(acc[3:-1]):
             self.df.loadEntry("T", 1, num, data=fld)
         self.loadBalances()
         self.opts["mf"].updateStatus("")
@@ -168,7 +168,7 @@
         odr = "rot_trdt, rot_type"
         state = self.df.disableButtonsTags()
         SRec(self.opts["mf"], screen=self.df.nb.Page3, title=tit, tables=tab,
-            cols=col, where=whr, order=odr, rows=12)
+            cols=col, where=whr, order=odr)
         self.df.enableButtonsTags(state=state)
         self.df.selPage("Owner")
 
@@ -209,8 +209,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'rca/rc4020.py' (properties changed: -x to +x)
--- old/rca/rc4020.py	2020-04-21 08:42:36 +0000
+++ new/rca/rc4020.py	2020-10-02 10:23:05 +0000
@@ -145,7 +145,7 @@
             return "Invalid Premises"
         self.code = w
         self.owner = acc[self.sql.rcaprm_col.index("rcp_owner")]
-        for num, fld in enumerate(acc):
+        for num, fld in enumerate(acc[:-1]):
             if num > 2:
                 self.df.loadEntry("T", 1, (num-3), data=fld)
 
@@ -166,11 +166,11 @@
         if not con:
             return "Invalid Contract"
         self.df.loadEntry(frt, pag, p+1, data=self.name)
-        for num, fld in enumerate(acc[5:]):
+        for num, fld in enumerate(acc[5:-1]):
             self.df.loadEntry("T", 2, num, data=fld)
         self.cnum = con[-1:][0][4]
         self.df.topf[4][0][5] = self.cnum
-        for num, fld in enumerate(con[-1:][0][5:]):
+        for num, fld in enumerate(con[-1:][0][5:-1]):
             self.df.loadEntry("T", 2, num+4, data=fld)
         self.loadBalances()
         self.opts["mf"].updateStatus("")
@@ -248,7 +248,7 @@
         odr = "rtu_trdt, rtu_type"
         state = self.df.disableButtonsTags()
         SRec(self.opts["mf"], screen=self.df.nb.Page3, title=tit, tables=tab,
-            cols=col, where=whr, order=odr, rows=12)
+            cols=col, where=whr, order=odr)
         self.df.enableButtonsTags(state=state)
         self.doTrans1()
 
@@ -316,8 +316,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'rca/rcc110.py' (properties changed: -x to +x)
--- old/rca/rcc110.py	2020-04-21 08:42:36 +0000
+++ new/rca/rcc110.py	2020-04-29 16:01:09 +0000
@@ -148,7 +148,7 @@
             (("T",0,seq + 2,0),"INA",20,"Tenant Template","",
                 self.acc[5],"N",self.doTplNam,tpm,None,None),
             (("T",0,seq + 3,0),"ITX",50,"Email Address","",
-                self.acc[6],"N",None,None,None,None)])
+                self.acc[6],"N",None,None,None,("email",))])
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -236,14 +236,17 @@
         if self.new:
             self.sql.insRec("rcactl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.rcactl_col
+            data.append(self.acc[col.index("cte_xflag")])
             self.sql.updRec("rcactl", data=data, where=[("cte_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["rcactl", "U",
-                        "%03i" % self.opts["conum"], self.sql.rcactl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'rca/rcc210.py' (properties changed: -x to +x)
--- old/rca/rcc210.py	2020-04-21 08:42:36 +0000
+++ new/rca/rcc210.py	2020-04-23 10:11:08 +0000
@@ -97,6 +97,8 @@
             if self.new == "Y":
                 self.sql.insRec("ctlmes", data=data)
             elif data != self.old[:len(data)]:
+                col = self.sql.ctlmes_col
+                data.append(self.old[col.index("mss_xflag")])
                 self.sql.updRec("ctlmes", data=data, where=[("mss_system",
                     "=", self.system), ("mss_message", "=", self.message)])
             self.opts["mf"].dbm.commitDbase()

=== modified file 'rca/rcc220.py' (properties changed: -x to +x)
--- old/rca/rcc220.py	2020-04-21 08:42:36 +0000
+++ new/rca/rcc220.py	2020-05-27 12:32:25 +0000
@@ -53,8 +53,7 @@
         return True
 
     def mainProcess(self):
-        self.tit = ("Rentals Messages Master Listing (%s)" %
-            self.__class__.__name__,)
+        self.tit = ("Rentals Messages Listing (%s)" % self.__class__.__name__)
         fld = []
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
@@ -114,8 +113,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__, 0,
-                ext="pdf")
+                self.__class__.__name__, 0, ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], pdfnam=pdfnam, header=self.tit,
                 repprt=self.df.repprt, fromad=self.fromad,

=== modified file 'rca/rcc310.py' (properties changed: -x to +x)
--- old/rca/rcc310.py	2020-04-21 08:42:36 +0000
+++ new/rca/rcc310.py	2020-04-23 10:43:55 +0000
@@ -154,7 +154,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["rcaint", "D", "%03i%8s" % \
             (self.opts["conum"], self.date), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -165,6 +165,8 @@
         if self.new:
             self.sql.insRec("rcaint", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.rcaint_col
+            data.append(self.acc[col.index("rci_xflag")])
             self.sql.updRec("rcaint", data=data, where=[("rci_cono",
                 "=", self.opts["conum"]), ("rci_date", "=", self.date)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -172,8 +174,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["rcaint", "U",
                         "%03i%8s" % (self.opts["conum"], self.date),
-                        self.sql.rcaint_col[num], dte, self.opts["capnm"],
-                        str(dat), str(data[num]), 0])
+                        col[num], dte, self.opts["capnm"], str(dat),
+                        str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'rca/rcm010.py' (properties changed: -x to +x)
--- old/rca/rcm010.py	2020-04-21 08:42:36 +0000
+++ new/rca/rcm010.py	2020-06-16 09:27:04 +0000
@@ -24,11 +24,10 @@
     along with this program. If not, see <https://www.gnu.org/licenses/>.
 """
 
-import copy, time
+import time
 from TartanClasses import ASD, CCD, GetCtl, Sql, TartanDialog
 from tartanFunctions import askQuestion, getVatRate, mthendDate, projectDate
 from tartanFunctions import showError
-from tartanWork import mthnam
 
 class rcm010(object):
     def __init__(self, **opts):
@@ -39,8 +38,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlvrf", "ctlvtf", "gentrn",
-            "rcactl", "rcaowm", "rcaowt", "rcatnm", "rcacon", "rcatnt"],
-            prog=self.__class__.__name__)
+            "rcactl", "rcaprm", "rcaowm", "rcaowt", "rcatnm", "rcacon",
+            "rcatnt"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -138,7 +137,7 @@
                         (self.con[1], self.con[2]))
                     continue
                 self.freq = self.con[5]
-                strt = CCD(self.con[6], "D1", 10)
+                self.strt = CCD(self.con[6], "D1", 10)
                 self.pers = self.con[7]
                 self.amnt = self.con[8]
                 self.depo = self.con[9]
@@ -147,41 +146,27 @@
                 self.eamt = self.con[12]
                 self.etyp = self.con[13]
                 if self.freq == "M":
-                    mths = 1 * self.pers
+                    self.mths = 1 * self.pers
                 elif self.freq == "3":
-                    mths = 3 * self.pers
+                    self.mths = 3 * self.pers
                 elif self.freq == "6":
-                    mths = 6 * self.pers
+                    self.mths = 6 * self.pers
                 else:
-                    mths = 12 * self.pers
-                yy = int(strt.work / 10000)
-                mm = int((strt.work % 10000) / 100) + mths - 1
-                while mm < 1:
-                    yy -= 1
-                    mm += 12
-                while mm > 12:
-                    yy += 1
-                    mm -= 12
-                chkmth = copy.deepcopy(mthnam)
-                if mm == 2:
-                    if not yy % 4:
-                        chkmth[2][2] = 29
-                    else:
-                        chkmth[2][2] = 28
-                self.exdt = CCD((yy*10000) + (mm*100) + chkmth[mm][2], "D1", 10)
-                if int(self.exdt.work / 100) <= self.curdt:
+                    self.mths = 12 * self.pers
+                exdt = projectDate(self.strt.work, self.mths - 1, typ="months")
+                exdt = CCD(mthendDate(exdt), "D1", 10)
+                if int(exdt.work / 100) <= self.curdt:
                     self.sql.updRec("rcacon", cols=["rcc_status"], data=["X"],
                         where=[("rcc_cono", "=", self.con[0]), ("rcc_owner",
                         "=", self.con[1]), ("rcc_code", "=", self.con[2]),
                         ("rcc_acno", "=", self.con[3]), ("rcc_cnum", "=",
                         self.con[4])])
-
                     ok = askQuestion(self.opts["mf"].body, "Expired Contract",
                         "This contract has Expired, would you like to "\
                         "Renew it?\n\nOwner: %s\nPremises: %s\nAccount: %s\n"\
                         "Name: %s\nStart: %s\nEnd:   %s" % (self.con[1],
-                        self.con[2], self.con[3], self.con[14], strt.disp,
-                        self.exdt.disp))
+                        self.con[2], self.con[3], self.con[14], self.strt.disp,
+                        exdt.disp))
                     if ok == "no":
                         continue
                     self.doExpiredContract()
@@ -201,7 +186,12 @@
             ("Quarterly","3"),
             ("Bi-Annually", "6"),
             ("Annually","A"))
-        rndt = projectDate(self.exdt.work, 1)
+        chdt = self.strt.work
+        while True:
+            chdt = projectDate(chdt, self.mths, typ="months")
+            exdt = mthendDate(projectDate(chdt, self.mths - 1, typ="months"))
+            if int(exdt / 100) > self.curdt:
+                break
         self.fld = (
             (("T",0,0,0),"OUA",7,"Owner Code"),
             (("T",0,1,0),"OUA",7,"Premises Code"),
@@ -210,7 +200,7 @@
             (("T",0,4,0),("IRB",r1s),0,"Payment Frequency","",
                 self.freq,"N",None,None,None,None),
             (("T",0,5,0),"ID1",10,"Start Date","",
-                rndt,"N",None,None,None,("efld",)),
+                chdt,"N",None,None,None,("efld",)),
             (("T",0,6,0),"IUI",3,"Number of Periods","",
                 self.pers,"N",None,None,None,("notzero",)),
             (("T",0,7,0),"IUD",12.2,"Rental Amount","",
@@ -226,10 +216,10 @@
             (("T",0,12,0),"IUI",1,"Type","",
                 "","N",None,None,None,("efld",)))
         tnd = ((self.doExpireEnd,"y"), )
-        txt = (self.doLoadFocus, )
+        txt = (None, )
         self.na = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=self.fld, tend=tnd, txit=txt, focus=False)
-        self.doLoadFocus()
+        self.doLoadFocus(chdt)
         self.na.mstFrame.wait_window()
 
     def doExpireEnd(self):
@@ -368,9 +358,12 @@
                     "", 0, self.opts["capnm"], self.sysdtw, 0]
                 self.sql.insRec("gentrn", data=data)
 
-    def doLoadFocus(self):
+    def doLoadFocus(self, chdt=None):
         for num, fld in enumerate(self.con[1:14]):
-            self.na.loadEntry("T", 0, num, data=fld)
+            if chdt and num == 5:
+                self.na.loadEntry("T", 0, num, data=chdt)
+            else:
+                self.na.loadEntry("T", 0, num, data=fld)
         self.na.focusField("T", 0, 4)
 
     def closeProcess(self):

=== added file 'rtl/__init__.py'
=== modified file 'rtl/rt1010.py' (properties changed: -x to +x)
--- old/rtl/rt1010.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt1010.py	2020-04-23 10:44:01 +0000
@@ -198,9 +198,9 @@
         self.sql.delRec("rtlcon", where=[("rtc_cono", "=", self.opts["conum"]),
             ("rtc_code", "=", self.code), ("rtc_acno", "=", self.acno)])
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        self.sql.insRec("chglog", data=["rtlmst", "D", "%03i%-7s" % \
-            (self.opts["conum"], self.code), "", dte, self.opts["capnm"], "",
-            "", 0])
+        self.sql.insRec("chglog", data=["rtlmst", "D", "%03i%-7s" %
+            (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
+            "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -218,6 +218,8 @@
         else:
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             if datm != self.oldm[:len(datm)]:
+                col = self.sql.rtlmst_col
+                datm.append(self.oldm[col.index("rtm_xflag")])
                 self.sql.updRec("rtlmst", data=datm, where=[("rtm_cono", "=",
                     self.opts["conum"]), ("rtm_code", "=", self.code),
                     ("rtm_acno", "=", self.acno)])
@@ -225,9 +227,11 @@
                     if dat != datm[num]:
                         self.sql.insRec("chglog", data=["rtlmst", "U",
                             "%03i%-7s" % (self.opts["conum"], self.code),
-                            self.sql.rtlmst_col[num], dte, self.opts["capnm"],
-                            str(dat), str(datm[num]), 0])
+                            col[num], dte, self.opts["capnm"], str(dat),
+                            str(datm[num]), "", 0])
             if datc != self.oldc[-1:][0][:len(datc)]:
+                col = self.sql.rtlcon_col
+                datc.append(self.oldc[col.index("rtc_xflag")])
                 self.sql.updRec("rtlcon", data=datc, where=[("rtc_cono", "=",
                     self.opts["conum"]), ("rtc_code", "=", self.code),
                     ("rtc_acno", "=", self.acno), ("rtc_cnum", "=",
@@ -236,8 +240,9 @@
                     if dat != datc[num]:
                         self.sql.insRec("chglog", data=["rtlcon", "U",
                         "%03i%-7s%-7s%03i" % (self.opts["conum"], self.code,
-                        self.acno, self.cnum), self.sql.rtlcon_col[num], dte,
-                        self.opts["capnm"], str(dat), str(datc[num]), 0])
+                        self.acno, self.cnum), col[num], dte,
+                        self.opts["capnm"], str(dat), str(datc[num]),
+                        "", 0])
         if "args" in self.opts:
             self.doExit()
         else:

=== modified file 'rtl/rt2010.py' (properties changed: -x to +x)
=== modified file 'rtl/rt3010.py' (properties changed: -x to +x)
--- old/rtl/rt3010.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt3010.py	2020-05-27 12:32:37 +0000
@@ -172,8 +172,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'rtl/rt3020.py' (properties changed: -x to +x)
--- old/rtl/rt3020.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt3020.py	2020-06-21 11:16:36 +0000
@@ -196,8 +196,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Rental's Ledger Audit Trail for Period "\
             "%s to %s" % (self.sperd, self.eperd))
@@ -233,8 +232,7 @@
             self.head = ("%03u %-30s %91s %10s" % (self.opts["conum"],
                 self.opts["conam"], self.sysdttm, self.__class__.__name__))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.bqty = 0
         self.bdrs = 0
@@ -439,7 +437,7 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(rttrtp)):
+        for x, t in enumerate(rttrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             dr = CCD(self.gdr[x], "SD", 13.2)
             cr = CCD(self.gcr[x], "SD", 13.2)
@@ -448,10 +446,10 @@
             vt = CCD(self.gvt[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-27s %s %s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             else:
                 self.fpdf.drawText("%-34s %s %s %s %s %s" % \
-                (rttrtp[x][1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
+                (t[1], qt.disp, dr.disp, cr.disp, df.disp, vt.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(dr.work))
             tot[2] = float(ASD(tot[2]) + ASD(cr.work))

=== modified file 'rtl/rt3030.py' (properties changed: -x to +x)
--- old/rtl/rt3030.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt3030.py	2020-05-27 12:32:52 +0000
@@ -38,7 +38,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["rtlmst", "rtlcon"],
+        self.sql = Sql(self.opts["mf"].dbm, ["rtlmst", "rtltrn", "rtlcon"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -171,7 +171,7 @@
                 else:
                     mths = 12 * prds.work
                 yy = int(strt.work / 10000)
-                mm = (int(strt.work % 10000) / 100) + mths - 1
+                mm = int((strt.work % 10000) / 100) + mths - 1
                 while mm < 1:
                     yy -= 1
                     mm += 12
@@ -243,8 +243,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'rtl/rt3040.py' (properties changed: -x to +x)
--- old/rtl/rt3040.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt3040.py	2020-06-21 11:15:47 +0000
@@ -52,8 +52,8 @@
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.trtypes = []
-        for q in xrange(0, len(rttrtp)):
-            self.trtypes.append(rttrtp[q][0])
+        for t in rttrtp:
+            self.trtypes.append(t[0])
         return True
 
     def mainProcess(self):
@@ -379,8 +379,7 @@
         else:
             key = "%s_all_all" % self.opts["conum"]
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, key,
-            ext="pdf")
+            self.__class__.__name__, key, ext="pdf")
         self.form.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Statement at %s" % (self.opts["conam"], self.dated),

=== modified file 'rtl/rt3050.py' (properties changed: -x to +x)
=== modified file 'rtl/rt4010.py' (properties changed: -x to +x)
--- old/rtl/rt4010.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rt4010.py	2020-10-02 10:23:11 +0000
@@ -161,7 +161,7 @@
             self.df.loadEntry("T", 2, num, data=fld)
         self.cnum = con[-1:][0][3]
         self.df.topf[4][0][5] = self.cnum
-        for num, fld in enumerate(con[-1:][0][4:]):
+        for num, fld in enumerate(con[-1:][0][4:-1]):
             self.df.loadEntry("T", 2, num+8, data=fld)
         self.loadBalances()
         self.opts["mf"].updateStatus("")
@@ -227,7 +227,7 @@
         odr = "rtt_trdt, rtt_type"
         state = self.df.disableButtonsTags()
         SRec(self.opts["mf"], screen=self.df.nb.Page2, title=tit, tables=tab,
-            cols=col, where=whr, order=odr, rows=12)
+            cols=col, where=whr, order=odr)
         self.df.enableButtonsTags(state=state)
         self.doTrans1()
 
@@ -268,8 +268,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'rtl/rt6010.py' (properties changed: -x to +x)
=== modified file 'rtl/rtc110.py' (properties changed: -x to +x)
--- old/rtl/rtc110.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rtc110.py	2020-04-29 15:38:01 +0000
@@ -69,7 +69,7 @@
             (("T",0,2,0),"INA",20,"Statement Template","",
                 self.acc[3],"N",self.doTplNam,tpm,None,None),
             (("T",0,3,0),"ITX",50,"Email Address","",
-                self.acc[4],"N",None,None,None,None))
+                self.acc[4],"N",None,None,None,("email",)))
         but = (("Quit",None,self.doExit,1,None,None),)
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
@@ -92,14 +92,17 @@
         if self.new:
             self.sql.insRec("rtlctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.rtlctl_col
+            data.append(self.acc[col.index("ctr_xflag")])
             self.sql.updRec("rtlctl", data=data, where=[("ctr_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["rtlctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.rtlctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'rtl/rtc210.py' (properties changed: -x to +x)
--- old/rtl/rtc210.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rtc210.py	2020-04-28 08:11:03 +0000
@@ -36,8 +36,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "rtlprm"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["chglog", "genmst", "rtlprm",
+            "rtlmst"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -77,11 +77,13 @@
             (("T",0,5,0),"INA",4,"Postal Code","PCod",
                 "","N",None,None,None,("notblank",))]
         if self.glint == "Y":
-            self.fld.append((("T",0,6,0),"IUI",7,"Rental Account",
-                "Rental Account","","N",self.doRental,glm,None,("notzero",)))
+            self.fld.append((("T",0,6,0),"IUI",7,"Rental Account","",
+                "","N",self.doRental,glm,None,("notzero",),None,
+                "Rental Control Account in the General Ledger."))
             self.fld.append((("T",0,6,0),"ONA",30,""))
-            self.fld.append((("T",0,7,0),"IUI",7,"Income Account",
-                "Income Account","","N",self.doIncome,glm,None,("notzero",)))
+            self.fld.append((("T",0,7,0),"IUI",7,"Income Account","",
+                "","N",self.doIncome,glm,None,("notzero",), None,
+                "Rental Income Account in the General Ledger."))
             self.fld.append((("T",0,7,0),"ONA",30,""))
         but = (
             ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
@@ -143,9 +145,9 @@
         self.sql.delRec("rtlprm", where=[("rtp_cono", "=", self.opts["conum"]),
             ("rtp_code", "=", self.code)])
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
-        self.sql.insRec("chglog", data=["rtlprm", "D", "%03i%-7s" % \
-            (self.opts["conum"], self.code), "", dte, self.opts["capnm"], "",
-            "", 0])
+        self.sql.insRec("chglog", data=["rtlprm", "D", "%03i%-7s" %
+            (self.opts["conum"], self.code), "", dte, self.opts["capnm"],
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -160,6 +162,8 @@
         if self.new == "y":
             self.sql.insRec("rtlprm", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.rtlprm_col
+            data.append(self.old[col.index("rtp_xflag")])
             self.sql.updRec("rtlprm", data=data, where=[("rtp_cono", "=",
                 self.opts["conum"]), ("rtp_code", "=", self.code)])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
@@ -167,8 +171,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["rtlprm",
                     "U", "%03i%-7s" % (self.opts["conum"], self.code),
-                    self.sql.rtlprm_col[num], dte, self.opts["capnm"],
-                    str(dat), str(data[num]), 0])
+                    col[num], dte, self.opts["capnm"], str(dat),
+                    str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'rtl/rtm010.py' (properties changed: -x to +x)
--- old/rtl/rtm010.py	2020-04-21 08:42:36 +0000
+++ new/rtl/rtm010.py	2020-04-28 08:32:11 +0000
@@ -37,7 +37,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlbat", "ctlvrf", "ctlvtf",
-            "gentrn", "rtlctl", "rtlmst", "rtlcon", "rtltrn"],
+            "gentrn", "rtlctl", "rtlprm", "rtlmst", "rtlcon", "rtltrn"],
                 prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -140,7 +140,7 @@
                 else:
                     mths = 12 * self.pers
                 yy = int(strt / 10000)
-                mm = (int(strt % 10000) / 100) + mths - 1
+                mm = int((strt % 10000) / 100) + mths - 1
                 while mm > 12:
                     yy += 1
                     mm -= 12

=== added file 'scp/__init__.py'
=== modified file 'scp/sc1010.py' (properties changed: -x to +x)
--- old/scp/sc1010.py	2020-04-21 08:42:36 +0000
+++ new/scp/sc1010.py	2020-04-23 10:11:34 +0000
@@ -250,6 +250,8 @@
         if self.newskp:
             self.sql.insRec("scpmem", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.scpmem_col
+            data.append(self.old[col.index("scm_xflag")])
             self.sql.updRec("scpmem", data=data, where=[("scm_cono",
                 "=", self.opts["conum"]), ("scm_scod", "=", self.skip)])
         if self.newclb:

=== modified file 'scp/sc2010.py' (properties changed: -x to +x)
--- old/scp/sc2010.py	2020-04-21 08:42:36 +0000
+++ new/scp/sc2010.py	2020-05-27 12:04:13 +0000
@@ -37,10 +37,12 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["scpcmp", "scpmem", "scpclb",
-            "scpent", "scpgme"], prog=self.__class__.__name__)
+            "scpsec", "scprnd", "scpent", "scpgme"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         self.img = None
+        self.newent = False
         return True
 
     def mainProcess(self):
@@ -106,12 +108,10 @@
                 "","N",self.doCmpLogo,log,None,("fle","blank")),
             (("C",0,0,0),"I@scm_scod",0,"Skip  ","",
                 "","Y",self.doSkpCod,sk1,None,("efld",)),
-            (("C",0,0,1),"ONA",30,"Name","",
-                "","N",None,None,None,("notblank",)),
+            (("C",0,0,1),"ONA",30,"Name"),
             (("C",0,0,2),"I@scm_scod",0,"Lead  ","",
                 "","n",self.doSkpCod,sk1,None,("efld",)),
-            (("C",0,0,3),"ONA",30,"Name","",
-                "","N",None,None,None,("notblank",)))
+            (("C",0,0,3),"ONA",30,"Name"))
         but = (("Entered Players",sk2,None,0,("C",0,1),("T",0,1)),)
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
@@ -169,13 +169,6 @@
             self.df.loadEntry(frt, pag, p+3, data=str(self.tsiz))
             self.df.loadEntry(frt, pag, p+4, data=self.fmat)
             self.df.loadEntry(frt, pag, p+5, data=self.logo)
-            ent = self.sql.getRec("scpent", cols=["sce_scod",
-                "sce_pcod"], where=[("sce_cono", "=", self.opts["conum"]),
-                ("sce_ccod", "=", self.ccod)])
-            for e in ent:
-                self.skips.append(e[0])
-                if e[1]:
-                    self.parts.append(e[1])
 
     def doCmpNam(self, frt, pag, r, c, p, i, w):
         self.cmpnam = w
@@ -231,7 +224,7 @@
             return "Invalid Player Code"
         if self.tsex in ("M", "F") and chk[2] != self.tsex:
             return "Invalid Gender"
-        self.df.loadEntry(frt, pag, p+1, data=self.getName(chk))
+        self.df.loadEntry(frt, pag, p+1, data=self.getName(chk=chk))
         if i == 0:
             ent = self.sql.getRec("scpent", cols=["sce_pcod"],
                 where=[("sce_cono", "=", self.opts["conum"]), ("sce_ccod", "=",
@@ -244,14 +237,18 @@
                         self.opts["conum"]), ("scm_scod", "=", ent[0])],
                         limit=1)
                     self.df.loadEntry(frt, pag, p+2, data=ent[0])
-                    self.df.loadEntry(frt, pag, p+3, data=self.getName(ptr))
+                    self.df.loadEntry(frt, pag, p+3, data=self.getName(chk=ptr))
             else:
                 self.newent = True
             if self.tsiz != 2:
                 self.pcod = 0
                 return "sk3"
 
-    def getName(self, chk):
+    def getName(self, scod=None, chk=None):
+        if scod:
+            chk = self.sql.getRec("scpmem", cols=["scm_surname",
+                "scm_names", "scm_gender"], where=[("scm_cono", "=",
+                self.opts["conum"]), ("scm_scod", "=", scod)], limit=1)
         name = "%s," % chk[0]
         init = chk[1].split()
         for i in init:
@@ -265,6 +262,7 @@
         self.sql.delRec("scpgme", where=[("scg_cono", "=", self.opts["conum"]),
             ("scg_ccod", "=", self.ccod), ("scg_scod", "=", self.scod)])
         self.loadButton()
+        self.doLoadEntries()
 
     def doEnd(self):
         if self.df.frt == "T":
@@ -273,20 +271,47 @@
             if self.newcmp:
                 self.sql.insRec("scpcmp", data=data)
             elif data != self.old[:len(data)]:
-                self.sql.updRec("scpcmp", data=data, where=[("scp_cono", "=",
-                    self.opts["conum"]), ("scp_ccod", "=", self.ccod)])
+                col = self.sql.scpcmp_col
+                data.append(self.old[col.index("scp_xflag")])
+                self.sql.updRec("scpcmp", data=data, where=[("scp_cono",
+                    "=", self.opts["conum"]), ("scp_ccod", "=", self.ccod)])
             self.loadButton()
-            self.df.focusField("C", 0, 1)
+            if self.newcmp:
+                self.df.focusField("C", 0, 1)
+            else:
+                self.doLoadEntries()
         else:
             if self.newent:
                 self.sql.insRec("scpent", data=[self.opts["conum"], self.ccod,
                     self.scod, self.pcod])
+                self.df.advanceLine(0)
             else:
                 self.sql.updRec("scpent", cols=["sce_scod", "sce_pcod"],
                     data=[self.scod, self.pcod], where=[("sce_cono", "=",
                     self.opts["conum"]), ("sce_ccod", "=", self.ccod),
                     ("sce_scod", "=", self.scod)])
+                self.doLoadEntries()
             self.loadButton()
+
+    def doLoadEntries(self):
+        self.skips = []
+        ents = self.sql.getRec("scpent", cols=["sce_scod", "sce_pcod"],
+            where=[("sce_cono", "=", self.opts["conum"]), ("sce_ccod",
+            "=", self.ccod)])
+        self.df.clearFrame("C", 0)
+        self.df.focusField("C", 0, 1)
+        for num, ent in enumerate(ents):
+            self.skips.append(ent[0])
+            self.df.loadEntry("C", 0, self.df.pos,
+                    data=ent[0])
+            self.df.loadEntry("C", 0, self.df.pos+1,
+                    data=self.getName(ent[0]))
+            if ent[1]:
+                self.parts.append(ent[1])
+                self.df.loadEntry("C", 0, self.df.pos+2,
+                        data=ent[1])
+                self.df.loadEntry("C", 0, self.df.pos+3,
+                        data=self.getName(ent[1]))
             self.df.advanceLine(0)
 
     def loadButton(self):
@@ -304,8 +329,8 @@
         whr = [("sce_ccod", "=", self.ccod), ("scm_scod=sce_scod",)]
         odr = "scm_surname"
         RepPrt(self.opts["mf"], name=self.__class__.__name__, heads=hdr,
-            tables=tab, cols=col,
-            where=whr, order=odr, prtdia=(("Y","V"),("Y","N")))
+            tables=tab, cols=col, where=whr, order=odr, prtdia=(("Y","V"),
+            ("Y","N")))
         self.df.setWidget(self.df.mstFrame, state="show")
 
     def doExit(self):

=== modified file 'scp/sc2020.py' (properties changed: -x to +x)
--- old/scp/sc2020.py	2020-04-21 08:42:36 +0000
+++ new/scp/sc2020.py	2020-06-21 12:39:34 +0000
@@ -19,6 +19,14 @@
 
     Number of games             = (N x (N - 1)) / 2
 
+    Status Flags:   0 = No Draw done
+                    1 = Main Draw done without Results
+                    2 = Main Draw done with Results
+                    3 = Main Draw Completed
+                    4 = Playoff Draw without Results
+                    5 = Playoff Draw with Results
+                    6 = Match Complete
+
     This file is part of Tartan Systems (TARTAN).
 
 AUTHOR
@@ -49,21 +57,18 @@
 class sc2020(object):
     def __init__(self, **opts):
         self.opts = opts
-        if "test" not in opts:
-            self.opts["test"] = None
         if self.setVariables():
             self.mainProcess()
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        t = time.localtime()
-        self.today = ((t[0] * 10000) + (t[1] * 100) + t[2])
         self.sql = Sql(self.opts["mf"].dbm, ["scpclb", "scpcmp", "scpent",
             "scpgme", "scpmem", "scprnd", "scpsec"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
         t = time.localtime()
+        self.today = ((t[0] * 10000) + (t[1] * 100) + t[2])
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
         self.sysdw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.codes = ["A","B","C","D","E","F","G","H","I","J","K","L"]
@@ -82,9 +87,9 @@
         r1s = (("Main","M"), ("Play-Offs","P"))
         r2s = (("Yes","Y"), ("No", "N"))
         r3s = (("Single","S"), ("Multiple", "M"))
-        fld = (
-            (("T",0,0,0),"I@scp_ccod",0,"","",
-                "","N",self.doCmpCod,cpt,None,None),
+        fld = [
+            [("T",0,0,0),"I@scp_ccod",0,"","",
+                "","N",self.doCmpCod,cpt,None,None],
             (("T",0,0,0),"ONA",30,""),
             (("T",0,1,0),("IRB",r1s),0,"Type","",
                 "M","N",self.doCmpTyp,None,None,None),
@@ -98,7 +103,9 @@
             (("T",0,6,0),("IRB",r3s),0,"Possible Qualifiers","",
                 "S","N",self.doQuaSec,None,None,None),
             (("T",0,7,0),("IRB",r2s),0,"Closed-Up","",
-                "Y","N",self.doClosed,None,None,None))
+                "Y","N",self.doClosed,None,None,None)]
+        if "test"in self.opts:
+            fld[0][5] = self.opts["test"]
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False,
@@ -122,11 +129,15 @@
         self.state = scpcmp[self.sql.scpcmp_col.index("scp_state")]
         self.prnds = scpcmp[self.sql.scpcmp_col.index("scp_prnds")]
         self.df.loadEntry(frt, pag, p+1, data=self.cdes)
-        if self.clup == "Y" and self.state:
+        if self.state > 2:
             self.df.loadEntry(frt, pag, p+2, data="P")
 
     def doCmpTyp(self, frt, pag, r, c, p, i, w):
         self.ctyp = w
+        if self.clup == "Y" and self.ctyp == "M" and self.state > 1:
+            showError(self.opts["mf"].body, "Error",
+                "This Closed-Up Competition is Already Underway")
+            return "rf"
         if self.ctyp == "P":
             if self.numsec < 3:
                 return "No Playoff Grid Available (Less than 3 Sections)"
@@ -134,36 +145,10 @@
                 showError(self.opts["mf"].window, "Invalid Type",
                     "Main not Completed or All results Not yet Entered")
                 return "Main Not Completed"
-        elif self.ctyp == "M" and self.opts["test"]:
-            # Populate test data
-            self.state = 0
-            self.sql.updRec("scpcmp", cols=["scp_state"], data=[self.state],
-                where=[("scp_cono", "=", self.opts["conum"]), ("scp_ccod", "=",
-                self.ccod)])
-            self.sql.delRec("scpent", where=[("sce_cono", "=",
-                self.opts["conum"]), ("sce_ccod", "=", self.ccod)])
-            self.sql.delRec("scpgme", where=[("scg_cono", "=",
-                self.opts["conum"]), ("scg_ccod", "=", self.ccod)])
-            self.sql.delRec("scprnd", where=[("scr_cono", "=",
-                self.opts["conum"]), ("scr_ccod", "=", self.ccod)])
-            self.sql.delRec("scpsec", where=[("scs_cono", "=",
-                self.opts["conum"]), ("scs_ccod", "=", self.ccod)])
-            ent = self.sql.getRec("scpmem", cols=["scm_scod",
-                "scm_surname", "scm_names", "scm_club"], where=[("scm_cono",
-                "=", self.opts["conum"]), ("scm_scod", ">", 500)],
-                order="scm_scod")
-            random.shuffle(ent)
-            if len(ent) < self.opts["test"]:
-                ext = self.sql.getRec("scpmem", cols=["scm_scod",
-                    "scm_surname", "scm_names", "scm_club"],
-                    where=[("scm_cono", "=", self.opts["conum"]), ("scm_scod",
-                    "<", 500)], order="scm_scod")
-                random.shuffle(ext)
-                ent.extend(ext[:self.opts["test"]-len(ent)])
-            for x in xrange(self.opts["test"]):
-                self.sql.insRec("scpent", data=[self.opts["conum"], self.ccod,
-                    ent[x][0], 0])
-            self.opts["mf"].dbm.commitDbase()
+        self.gwhr = [
+            ("scg_cono", "=", self.opts["conum"]),
+            ("scg_ccod", "=", self.ccod),
+            ("scg_ctyp", "=", self.ctyp)]
         if self.state == 3 and self.quasec == "M" and self.numsec > 2:
             # Playoff records for 1st round of ctyp="P" and no "P" records
             chk = self.sql.getRec("scpgme", cols=["count(*)"],
@@ -173,27 +158,17 @@
             if not chk:
                 tot = 0
                 data = [self.opts["conum"], self.ccod, "P", 1, "", 1, "M", 0,
-                    0, 0, 0, 0, 0, 0, 0, 0]
-                for sec in xrange(1, self.numsec + 1):
-                    pnts = self.sql.getRec("scpgme", cols=["scg_scod",
-                        "sum(scg_pnts) as p"], where=[("scg_cono", "=",
-                        self.opts["conum"]), ("scg_ccod", "=", self.ccod),
-                        ("scg_ctyp", "=", "M"), ("scg_snum", "=", sec)],
-                        group="scg_scod", order="p desc")
-                    win = pnts[0][1:]
-                    for pnt in pnts:
-                        if pnt[1:] == win:
-                            tot += 1
-                            data[7] = pnt[0]
-                            self.sql.insRec("scpgme", data=data)
+                    0, "", 0, 0, 0, 0, 0, 0]
+                self.doGetNewWin()
+                for sec in self.newwin:
+                    tot += 1
+                    data[7] = self.newwin[sec]
+                    self.sql.insRec("scpgme", data=data)
                 self.seeds = []
-                self.gwhr = [
-                    ("scg_cono", "=", self.opts["conum"]),
-                    ("scg_ccod", "=", self.ccod),
-                    ("scg_ctyp", "=", "P")]
-                self.where = copyList(self.gwhr)
+                self.where = copyList(self.gwhr[:2])
+                self.append(("scg_ctyp", "=", "P"))
                 self.where.append(("scg_snum", "=", 1))
-                self.createKnockout("P", 1, "", tot)
+                self.createKnockout("P", 1, "", self.numsec)
                 self.state = 5
                 self.sql.updRec("scpcmp", cols=["scp_state"],
                     data=[self.state], where=[("scp_cono", "=",
@@ -201,38 +176,27 @@
                 self.opts["mf"].dbm.commitDbase()
         self.getTotalSkips()
         self.df.loadEntry(frt, pag, p+1, data=self.totskp)
-        self.scores = False
         self.redraw = False
         self.reprint = False
-        self.gwhr = [
-            ("scg_cono", "=", self.opts["conum"]),
-            ("scg_ccod", "=", self.ccod),
-            ("scg_ctyp", "=", self.ctyp)]
-        chk = self.sql.getRec("scpgme", cols=["count(*)",
-            "sum(scg_ocod)", "sum(scg_sfor)"], where=self.gwhr, limit=1)
-        if chk[0]:
-            if chk[2]:
-                self.scores = True
+        if self.state:
             but = [("Exit", "E")]
             dflt = "Exit"
-            if self.clup == "Y" and self.ctyp == "M":
-                if not chk[1]:
-                    but.append(("Reprint", "P"))
-                    dflt = "Reprint"
-                else:
-                    showError(self.opts["mf"].body, "Error",
-                        "This Closed-Up Competition is Already Underway")
-                    return "rf"
-            elif chk[1]:
-                but.append(("Reprint", "P"))
+            if self.state:
+                but.append(("Reprint", "R"))
                 dflt = "Reprint"
-            if not self.scores:
+            if self.ctyp == "M" and self.state == 1:
                 but.append(("Redraw", "D"))
-            ok = askChoice(self.opts["mf"].body, "Already Drawn",
-                "This Draw Has Already Been Done.", butt=but, default=dflt)
+            if self.state == 1:
+                txt = "This Draw Has Already Been Done."
+            elif self.state == 6:
+                txt = "This Competition has been Completed."
+            else:
+                txt = "This Competition is Underway."
+            ok = askChoice(self.opts["mf"].body, "Drawn", txt,
+                butt=but, default=dflt)
             if ok == "E":
                 return "rf"
-            elif ok == "P":
+            elif ok == "R":
                 self.reprint = True
             else:
                 self.redraw = True
@@ -244,6 +208,32 @@
             self.df.loadEntry(frt, pag, p+6, data=self.clup)
             return "sk6"
 
+    def doGetNewWin(self, sect=None):
+        # Get Leaders
+        self.newwin = {}
+        if sect is None:
+            secs = []
+            for x in range(self.numsec):
+                secs.append(x + 1)
+        else:
+            secs = [sect]
+        for sec in secs:
+            col = [
+                "scg_scod",
+                "sum(scg_pnts) as a",
+                "sum(scg_sfor - scg_sagt) as b",
+                "round(sum(scg_sfor) / sum(scg_sagt), 2) as c"]
+            whr = [
+                ("scg_cono", "=", self.opts["conum"]),
+                ("scg_ccod", "=", self.ccod),
+                ("scg_ctyp", "=", "M"),
+                ("scg_snum", "=", sec)]
+            grp = "scg_scod"
+            odr = "a desc, b desc, c desc"
+            rec = self.sql.getRec("scpgme", cols=col, where=whr, group=grp,
+                order=odr, limit=1)
+            self.newwin[sec] = rec[0]
+
     def doNumEnt(self, frt, pag, r, c, p, i, w):
         if w:
             self.entsec = w
@@ -322,75 +312,6 @@
             self.doEnder()
         self.opts["mf"].closeLoop()
 
-    def doEnder(self):
-        if not self.reprint and self.ctyp == "M" and self.clup == "N":
-            recs = self.sql.getRec("scpgme", cols=["scg_snum",
-                "scg_subs", "count(*)"], where=self.gwhr,
-                group="scg_snum, scg_subs", order="scg_snum, scg_subs")
-            for sec, sub, tot in recs:
-                self.where = copyList(self.gwhr)
-                self.where.extend([("scg_snum","=",sec), ("scg_subs","=",sub)])
-                if self.fmat == "K":
-                    self.createKnockout(self.ctyp, sec, sub, tot)
-                else:
-                    self.createRoundRobin(sec, sub)
-            if self.fmat == "R":
-                self.allocateRinks()
-            self.state = 1
-            self.sql.updRec("scpcmp", cols=["scp_state"], data=[self.state],
-                where=[("scp_cono", "=", self.opts["conum"]), ("scp_ccod", "=",
-                self.ccod)])
-        if self.fmat == "K" or self.ctyp == "P":
-            head = (self.rnds * 26) + 25
-            self.fpdf = MyFpdf(name=self.__class__.__name__, head=head,
-                font="Helvetica", foot=True)
-            self.fpdf.def_orientation = "P"
-            self.fpdf.font[2] = 5
-        else:
-            self.fpdf = MyFpdf(name=self.__class__.__name__, head=65,
-                font="Helvetica", foot=True)
-        recs = self.sql.getRec("scpgme", cols=["scg_snum", "scg_subs"],
-            where=self.gwhr, group="scg_snum, scg_subs",
-            order="scg_snum, scg_subs")
-        for sec, sub in recs:
-            self.where = copyList(self.gwhr)
-            self.where.extend([
-                ("scg_snum", "=", sec),
-                ("scg_subs", "=", sub)])
-            if self.fmat == "K" or self.ctyp == "P":
-                self.printKnockout(sec, sub)
-            else:
-                self.printRoundRobin(sec, sub)
-        if self.ctyp == "M" and self.numsec > 2 and (self.quasec == "S" or \
-                self.state > 2):
-            # Print sectional playoff sheet
-            self.clup = "N"
-            if self.state > 2:
-                self.ctyp = "P"
-                self.rnds = self.prnds
-                self.gwhr = [
-                    ("scg_cono", "=", self.opts["conum"]),
-                    ("scg_ccod", "=", self.ccod),
-                    ("scg_ctyp", "=", self.ctyp)]
-                self.where = copyList(self.gwhr)
-                self.where.extend([
-                    ("scg_snum", "=", 1),
-                    ("scg_subs", "=", "")])
-                self.printKnockout(1, "")
-            else:
-                self.playoff = True
-                self.printPlayOffs()
-        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__, self.opts["conum"], ext="pdf")
-        self.fpdf.output(pdfnam, "F")
-        doPrinter(mf=self.opts["mf"], conum=1, pdfnam=pdfnam,
-            repprt=self.df.repprt)
-        if not self.reprint:
-            if self.opts["test"]:
-                self.opts["mf"].dbm.commitDbase()
-            else:
-                self.opts["mf"].dbm.commitDbase(ask=True)
-
     def getTotalSkips(self):
         if self.ctyp == "M":
             self.totskp = self.sql.getRec("scpent", cols=["count(*)"],
@@ -407,10 +328,7 @@
         if self.ctyp == "P":
             self.rnds = self.prnds
         elif self.fmat == "K":
-            if self.clup == "Y":
-                self.rnds = 4
-            else:
-                self.rnds = self.getRounds(self.entsec)
+            self.rnds = self.getRounds(self.entsec)
         else:
             self.rnds = self.entsec - 1
         if self.numsec == 1:
@@ -445,7 +363,7 @@
         self.doMatchDetails()
         if not self.quit:
             if self.subsec == "Y":
-                for x in xrange(0, self.numsec, 2):
+                for x in range(0, self.numsec, 2):
                     self.rsecnum = int(x / 2) + 1
                     if self.rsecnum == 1:
                         self.rnum = self.xtra
@@ -455,7 +373,7 @@
                     if self.quit:
                         break
             else:
-                for x in xrange(self.numsec):
+                for x in range(self.numsec):
                     self.rsecnum = x + 1
                     if self.rsecnum == 1:
                         self.rnum = self.xtra
@@ -478,7 +396,7 @@
             add = False
             byes = 0
         bent = int(self.totskp / self.numsec)
-        for x in xrange(self.numsec):
+        for x in range(self.numsec):
             sections[x + 1] = []
             sectot[x + 1] = 0
             if byes:
@@ -558,10 +476,8 @@
                 snum = sec
                 ssec = ""
             data = [self.opts["conum"], self.ccod, "M", snum, ssec, 1, "M", 0,
-                0, 0, 0, 0, 0, 0, 0, 0]
-            totsec = 0
+                0, "", 0, 0, 0, 0, 0, 0]
             for plr in sections[sec]:
-                totsec += 1
                 data[7] = plr
                 self.sql.insRec("scpgme", data=data)
 
@@ -661,7 +577,7 @@
         if not chk:
             return "Not a Valid Entered Member"
         seeds = []
-        for x in xrange(self.seednum):
+        for x in range(self.seednum):
             if ((x * 2) + 1) == p:
                 continue
             if self.sp.t_work[0][0][(x * 2) + 1]:
@@ -677,7 +593,7 @@
         self.quit = False
         self.sp.closeProcess()
         self.seeds = []
-        for x in xrange(self.seednum):
+        for x in range(self.seednum):
             self.seeds.append(self.sp.t_work[0][0][(x * 2) + 1])
 
     def doSeedsQuit(self):
@@ -685,9 +601,6 @@
         self.sp.closeProcess()
 
     def doMatchDetails(self):
-        if self.opts["test"]:
-            self.doMatchEnd()
-            return
         tit = ("Match Details",)
         fld = (
             (("C",0,0,0),"ID1",10,"Date","",
@@ -699,7 +612,7 @@
         self.md = TartanDialog(self.opts["mf"], title=tit, tops=True,
             eflds=fld, butt=but, cend=((self.doMatchEnd,"n"),),
             cxit=(self.doMatchExit,))
-        for x in xrange(self.xtra):
+        for x in range(self.xtra):
             self.md.colLabel[0][x].configure(text=self.getRndTxt(x + 1)[0])
         self.md.mstFrame.wait_window()
         self.df.setWidget(self.df.mstFrame, state="show")
@@ -715,12 +628,6 @@
         self.rtime = w
 
     def doMatchEnd(self):
-        if self.opts["test"]:
-            for num in xrange(self.xtra):
-                self.sql.insRec("scprnd", data=[self.opts["conum"], self.ccod,
-                    num+1, self.sysdw, 1415])
-            self.quit = False
-            return
         if self.md.col < self.xtra * 2:
             self.md.advanceLine(0)
         else:
@@ -739,9 +646,6 @@
         self.md.closeProcess()
 
     def doSectionDetails(self):
-        if self.opts["test"]:
-            self.doSecEnd()
-            return
         tit = ("Section %s Details" % self.rsecnum,)
         clb = {
             "stype": "R",
@@ -758,7 +662,7 @@
         self.sd = TartanDialog(self.opts["mf"], title=tit, tops=True,
             eflds=fld, butt=but, cend=((self.doSecEnd,"n"),),
             cxit=(self.doSecExit,))
-        for x in xrange(self.rnum):
+        for x in range(self.rnum):
             self.sd.colLabel[0][x].configure(text=self.getRndTxt(x + 1)[0])
         self.sd.mstFrame.wait_window()
         self.df.setWidget(self.df.mstFrame, state="show")
@@ -772,13 +676,6 @@
         self.sd.loadEntry(frt, pag, p+1, data=chk[1])
 
     def doSecEnd(self):
-        if self.opts["test"]:
-            for num in xrange(self.xtra):
-                chk = self.sql.getRec("scpclb", where=[("scc_club",
-                    "=", num+1)], limit=1)
-                self.sql.insRec("scpsec", data=[self.opts["conum"], self.ccod,
-                    self.rsecnum, num+1, chk[0], chk[1]])
-            return
         if self.sd.col < self.rnum * 2:
             self.sd.advanceLine(0)
         else:
@@ -808,6 +705,80 @@
         self.quit = True
         self.sd.closeProcess()
 
+    def doEnder(self):
+        if not self.reprint and self.ctyp == "M":
+            if self.clup == "N":
+                recs = self.sql.getRec("scpgme", cols=["scg_snum",
+                    "scg_subs", "count(*)"], where=self.gwhr,
+                    group="scg_snum, scg_subs", order="scg_snum, scg_subs")
+                for sec, sub, tot in recs:
+                    self.where = copyList(self.gwhr)
+                    self.where.extend([("scg_snum","=",sec),
+                        ("scg_subs","=",sub)])
+                    if self.fmat == "K":
+                        self.createKnockout(self.ctyp, sec, sub, tot)
+                    else:
+                        self.createRoundRobin(sec, sub)
+                if self.fmat == "R":
+                    self.allocateRinks()
+            self.state = 1
+            self.sql.updRec("scpcmp", cols=["scp_state"], data=[self.state],
+                where=[("scp_cono", "=", self.opts["conum"]), ("scp_ccod",
+                "=", self.ccod)])
+        if self.fmat == "K" or self.ctyp == "P":
+            if self.ctyp == "M" and self.clup == "Y":
+                head = (4 * 26) + 25
+            else:
+                head = (self.rnds * 26) + 25
+            self.fpdf = MyFpdf(name=self.__class__.__name__, head=head,
+                font="Helvetica", foot=True)
+            self.fpdf.def_orientation = "P"
+            self.fpdf.font[2] = 5
+        else:
+            self.fpdf = MyFpdf(name=self.__class__.__name__, head=65,
+                font="Helvetica", foot=True)
+        recs = self.sql.getRec("scpgme", cols=["scg_snum", "scg_subs"],
+            where=self.gwhr, group="scg_snum, scg_subs",
+            order="scg_snum, scg_subs")
+        for sec, sub in recs:
+            self.where = copyList(self.gwhr)
+            self.where.extend([
+                ("scg_snum", "=", sec),
+                ("scg_subs", "=", sub)])
+            if self.fmat == "K" or self.ctyp == "P":
+                self.printKnockout(sec, sub)
+            else:
+                self.printRoundRobin(sec, sub)
+        if self.ctyp == "M" and self.numsec > 2 and \
+                (self.quasec == "S" or self.state > 2):
+            # Print sectional playoff sheet
+            self.clup = "N"
+            if self.state > 2:
+                self.ctyp = "P"
+                self.rnds = self.prnds
+                self.gwhr = [
+                    ("scg_cono", "=", self.opts["conum"]),
+                    ("scg_ccod", "=", self.ccod),
+                    ("scg_ctyp", "=", self.ctyp)]
+                self.where = copyList(self.gwhr)
+                self.where.extend([
+                    ("scg_snum", "=", 1),
+                    ("scg_subs", "=", "")])
+                self.printKnockout(1, "")
+            else:
+                self.playoff = True
+                self.printPlayOffs()
+        pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
+        self.fpdf.output(pdfnam, "F")
+        doPrinter(mf=self.opts["mf"], conum=1, pdfnam=pdfnam,
+            repprt=self.df.repprt)
+        if not self.reprint:
+            if "test" in self.opts:
+                self.opts["mf"].dbm.commitDbase()
+            else:
+                self.opts["mf"].dbm.commitDbase(ask=True)
+
     def createKnockout(self, ctyp, sec, sub, tot):
         pwrs = 2
         if ctyp == "P":
@@ -828,9 +799,9 @@
         prs = int((frg + byes) / 4)
         grps = [0, 0]
         # Create shadow players for byes in groups
-        data = [self.opts["conum"], self.ccod, ctyp, sec, sub, 1, "M", 0, 0, 0,
-            0, 0, 0, 0, 0, 0]
-        for bye in xrange(byes):
+        data = [self.opts["conum"], self.ccod, ctyp, sec, sub, 1, "M",
+            0, 0, "", 0, 0, 0, 0, 0, 0]
+        for bye in range(byes):
             self.byenum += 1
             data[7] = self.byenum
             if bye % 2:
@@ -862,7 +833,7 @@
             grp = chk[0][0]
         else:
             grp = 2
-        for num in xrange(0, len(sseed), 2):
+        for num in range(0, len(sseed), 2):
             grps[grp-1] += 1
             sgrps[grp-1].append(sseed[num])
             whr = copyList(self.where)
@@ -901,7 +872,7 @@
             self.sql.updRec("scpgme", cols=["scg_group"], data=[grp],
                 where=whr)
         # Allocate opponents
-        for grp in xrange(1, 3):
+        for grp in range(1, 3):
             # Allocate seeded players to byes
             for seed in sgrps[grp-1]:
                 self.doAllocateBye(sec, sub, seed, grp)
@@ -927,12 +898,13 @@
                 temp.append(c[0])
             random.shuffle(temp)
             for p1 in sseed:
+                # Pair seeded player with unseeded player
                 if p1 not in temp:
                     continue
-                for x in xrange(len(temp)):
-                    if temp[x] in sseed:
-                        continue
-                    p2 = temp[x]
+                for rec in temp:
+                    if rec not in sseed:
+                        p2 = rec
+                        break
                 temp.remove(p1)
                 temp.remove(p2)
                 whr = copyList(self.where)
@@ -971,11 +943,11 @@
                 if len(skips) % prs:
                     p2[0] += 1
                 for sd, seed in enumerate(self.seeds):
-                    for num in xrange(len(skips)):
-                        if skips[num][0] == seed:
+                    for skp in skips:
+                        if skp[0] == seed:
                             pos = p1.pop(0)
                             whr = copyList(self.where)
-                            whr.append(("scg_scod", "=", skips[num][0]))
+                            whr.append(("scg_scod", "=", skp[0]))
                             self.sql.updRec("scpgme", cols=["scg_seed",
                                 "scg_pair"], data=[sd+1, pos], where=whr)
                             p2[pos - 1] -= 1
@@ -994,23 +966,23 @@
                 if len(skips) % prs:
                     p2[0] += 1
                 for sd, seed in enumerate(self.seeds):
-                    for num in xrange(len(skips)):
-                        if skips[num][0] == seed:
+                    for skp in skips:
+                        if skp[0] == seed:
                             pos = p1.pop(0)
                             whr = copyList(self.where)
-                            whr.append(("scg_scod", "=", skips[num][0]))
+                            whr.append(("scg_scod", "=", skp[0]))
                             self.sql.updRec("scpgme", cols=["scg_seed",
                                 "scg_pair"], data=[sd+1, pos], where=whr)
                             p2[pos - 1] -= 1
                             break
                 # Allocate rest into pair groups
-                for num in xrange(len(skips)):
-                    if skips[num][0] in sseed:
+                for skp in skips:
+                    if skp[0] in sseed:
                         continue
                     for n, p in enumerate(p2):
                         if p:
                             whr = copyList(self.where)
-                            whr.append(("scg_scod", "=", skips[num][0]))
+                            whr.append(("scg_scod", "=", skp[0]))
                             self.sql.updRec("scpgme", cols=["scg_seed",
                                 "scg_pair"], data=[0, n+1], where=whr)
                             p2[n] -= 1
@@ -1044,11 +1016,11 @@
         if self.clup == "Y" and self.ctyp == "M":
             self.second = [17, 18, 19, 20, 21, 22, 23, 24]
             self.third = [25, 26, 27, 28]
-        for grp in xrange(1, 3):
+        for grp in range(1, 3):
             if self.clup == "Y" and self.ctyp == "M":
                 skips = []
                 p = 1
-                for _ in xrange(2):
+                for _ in range(2):
                     skips.append([(cod * 2) + 1, (cod * 2) + 2, 0, p])
                     cod += 1
                     skips.append([(cod * 2) + 1, (cod * 2) + 2, 0, p])
@@ -1137,11 +1109,15 @@
             self.fpdf.drawText("")
             lasty = self.fpdf.get_y()
         inc = 4
-        for aa in xrange(self.rnds - 3):
+        if self.ctyp == "M" and self.clup == "Y":
+            prnd = 4
+        else:
+            prnd = self.rnds
+        for aa in range(prnd - 3):
             # Print Rounds > 3 but Not the Last 2 Rounds
             bb = []
             cnt = 1
-            for rnd in xrange(0, len(rnds), 2):
+            for rnd in range(0, len(rnds), 2):
                 x = rnds[rnd][0]
                 y = rnds[rnd][1]
                 if self.clup == "Y" and self.ctyp == "M":
@@ -1259,7 +1235,7 @@
             align="C")
         self.fpdf.setFont(size=8.5)
         pair = 0
-        for x in xrange(16):
+        for x in range(16):
             self.fpdf.drawText(x+1, w=4*cw, h=5, ln=0, border="TLRB",
                 align="C")
             self.fpdf.drawText("", w=4*cw, h=5, ln=0, border="TLRB", align="C")
@@ -1331,23 +1307,22 @@
         for rec in recs:
             skps.append(rec[0])
         random.shuffle(skps)
-        data = [self.opts["conum"], self.ccod, "M", sec, sub, 1, "M", 0, 0, 0,
-            0, 0, 0, 0, 0, 0]
+        data = [self.opts["conum"], self.ccod, "M", sec, sub, 1, "M",
+            0, 0, "", 0, 0, 0, 0, 0, 0]
         if byes == 1:
-            rnds = rnds
-            for _ in xrange(byes):
+            for _ in range(byes):
                 self.byenum += 1
                 data[7] = self.byenum
                 skps.append(self.byenum)
                 self.sql.insRec("scpgme", data=data)
         # Allocate Opponents
         count = entsec
-        grps = [0+i for i in xrange(entsec)]
+        grps = [0+i for i in range(entsec)]
         half = int(count / 2)
         schedule = []
-        for _ in xrange(rnds):
+        for _ in range(rnds):
             pairings = []
-            for i in xrange(half):
+            for i in range(half):
                 pairings.append([grps[i], grps[count-i-1]])
             grps.insert(1, grps.pop())
             schedule.append(pairings)
@@ -1523,7 +1498,7 @@
         self.rnks = []
         for grn in grns:
             if grn in ("A", "B", "C", "D"):
-                for rnk in xrange(1, 7):
+                for rnk in range(1, 7):
                     self.rnks.append("%s%s" % (grn, rnk))
             else:
                 for rnk in grn[1:]:
@@ -1583,10 +1558,11 @@
             txt = self.getRndTxt(r[0])[0]
             self.fpdf.drawText(txt, w=10, border="TLRB", ln=0, align="C")
             date = CCD(r[1], "D1", 10).disp
-            time = CCD(r[2], "TM",  5).disp
-            dt = "%s %s" % (date, time)
+            dtim = CCD(r[2], "TM",  5).disp
+            dt = "%s %s" % (date, dtim)
             self.fpdf.drawText(dt, w=32, border="TLRB", ln=0, align="C")
-            self.fpdf.drawText(r[3], w=38, border="TLRB")
+            txt = r[3].replace("Bowling Club", "BC")
+            self.fpdf.drawText(txt, w=38, border="TLRB")
             y1 = self.fpdf.get_y()
         self.fpdf.set_xy(x, y1)
         self.fpdf.drawText()
@@ -1625,16 +1601,16 @@
     def getSubSecWin(self, sec, sub):
         if self.state < 3:
             return ""
-        winn = self.sql.getRec("scpgme", cols=["scg_scod",
+        wins = self.sql.getRec("scpgme", cols=["scg_scod",
             "sum(scg_pnts) as pnts", "sum(scg_sfor) as sfor",
             "sum(scg_sagt) as sagt", "sum(scg_sfor) - sum(scg_sagt) as agg"],
             where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod", "=",
-            self.ccod), ("scg_ctyp", "=", "M"), ("scg_snum", "=",
-            sec), ("scg_subs", "=", sub)], group="scg_scod",
+            self.ccod), ("scg_ctyp", "=", "M"), ("scg_snum", "=", sec),
+            ("scg_subs", "=", sub)], group="scg_scod",
             order="pnts desc, agg desc, sagt asc", limit=1)
         nams = self.sql.getRec("scpmem", cols=["scm_surname",
             "scm_names"], where=[("scm_cono", "=", self.opts["conum"]),
-            ("scm_scod", "=", winn[0])], limit=1)
+            ("scm_scod", "=", wins[0])], limit=1)
         return self.getName(nams[0], nams[1])
 
     def printHeading(self, sec=0, sub="", date=False):
@@ -1663,34 +1639,49 @@
         cwth, chgt = self.setBracketFont()
         self.fpdf.setFont(style="B", size=8)
         text = []
-        for x in xrange(self.rnds):
+        skip = []
+        if not self.playoff and self.ctyp == "M" and self.clup == "Y":
+            if self.rnds < 4:
+                skip.append(1)
+            if self.rnds < 3:
+                skip.append(2)
+            if self.rnds < 2:
+                skip.append(3)
+            prnd = 4
+        else:
+            prnd = self.rnds
+        nrnd = 1
+        for x in range(prnd):
             if self.playoff:
                 rnum = self.save + x
                 num = rnum + 1
                 txt = self.getRndTxt(num)[1]
             elif self.ctyp == "P":
-                if x == (self.rnds - 1):
+                if x == (prnd - 1):
                     txt = "Final"
-                elif x == (self.rnds - 2):
+                elif x == (prnd - 2):
                     txt = "Semi-Final"
-                elif x == (self.rnds - 3):
+                elif x == (prnd - 3):
                     txt = "Quarter-Final"
-                elif x == (self.rnds - 4):
-                    if self.rnds == 4:
+                elif x == (prnd - 4):
+                    if prnd == 4:
                         txt = "1st Round"
-                    elif self.rnds == 5:
+                    elif prnd == 5:
                         txt = "2nd Round"
-                    elif self.rnds == 6:
+                    elif prnd == 6:
                         txt = "3rd Round"
-                elif x == (self.rnds - 5):
-                    if self.rnds == 5:
+                elif x == (prnd - 5):
+                    if prnd == 5:
                         txt = "1st Round"
-                    elif self.rnds == 6:
+                    elif prnd == 6:
                         txt = "2nd Round"
-                elif x == (self.rnds - 6):
+                elif x == (prnd - 6):
                     txt = "1st Round"
+            elif (x + 1) in skip:
+                txt = ""
             else:
-                txt = "Round %s" % (x + 1)
+                txt = "Round %s" % nrnd
+                nrnd += 1
             text.append(txt)
         if self.playoff:
             start = self.save + 1
@@ -1699,47 +1690,41 @@
             rnds = self.sql.getRec("scprnd", cols=["count(*)"],
                 where=[("scr_cono", "=", self.opts["conum"]), ("scr_ccod", "=",
                 self.ccod)], limit=1)
-            start = rnds[0] - self.rnds + 1
+            start = rnds[0] - prnd + 1
             end = rnds[0] + 1
         else:
             start = 1
-            end = self.rnds + 1
-        for x in xrange(start, end):
-            rec = self.sql.getRec("scpsec", cols=["scs_name"],
-                where=[("scs_cono", "=", self.opts["conum"]), ("scs_ccod", "=",
-                self.ccod), ("scs_snum", "=", sec), ("scs_rnum", "=", x)],
-                limit=1)
-            venue = rec[0]
-            if self.playoff:
-                idx = x - self.save - 1
-            elif self.ctyp == "P":
-                idx = x - start
-            else:
-                idx = x - 1
-            text[idx] = "%s\n%s" % (text[idx], venue)
-        for x in xrange(start, end):
-            rec = self.sql.getRec("scprnd", cols=["scr_date"],
-                where=[("scr_cono", "=", self.opts["conum"]), ("scr_ccod", "=",
-                self.ccod), ("scr_rnum", "=", x)], limit=1)
-            date = CCD(rec[0], "D1", 10).disp
-            if self.playoff:
-                idx = x - self.save - 1
-            elif self.ctyp == "P":
-                idx = x - start
-            else:
-                idx = x - 1
-            text[idx] = "%s\n%s" % (text[idx], date)
-        for x in xrange(1, self.rnds + 1):
-            rec = self.sql.getRec("scprnd", cols=["scr_time"],
-                where=[("scr_cono", "=", self.opts["conum"]), ("scr_ccod", "=",
-                self.ccod), ("scr_rnum", "=", x)], limit=1)
-            time = CCD(rec[0], "TM", 5).disp
-            text[x - 1] = "%s\n%s" % (text[x - 1], time)
+            end = prnd + 1
+        nrec = start
+        for x in range(start, end):
+            if x in skip:
+                venue = "Not Applicable"
+                date = ""
+                dtim = ""
+            else:
+                rec = self.sql.getRec("scpsec", cols=["scs_name"],
+                    where=[("scs_cono", "=", self.opts["conum"]),
+                    ("scs_ccod", "=", self.ccod), ("scs_snum",
+                    "=", sec), ("scs_rnum", "=", nrec)], limit=1)
+                venue = rec[0].replace("Bowling Club", "BC")
+                rec = self.sql.getRec("scprnd", cols=["scr_date", "scr_time"],
+                    where=[("scr_cono", "=", self.opts["conum"]), ("scr_ccod",
+                    "=", self.ccod), ("scr_rnum", "=", nrec)], limit=1)
+                date = CCD(rec[0], "D1", 10).disp
+                dtim = CCD(rec[1], "TM", 5).disp
+                nrec += 1
+            if self.playoff:
+                idx = x - self.save - 1
+            elif self.ctyp == "P":
+                idx = x - start
+            else:
+                idx = x - 1
+            text[idx] = "%s\n%s\n%s %s" % (text[idx], venue, date, dtim)
         if self.numsec == 1 or self.playoff or self.ctyp == "P":
-            if self.rnds <= 5:
-                text.append("\n\nCompetition\nWinner")
+            if prnd <= 5:
+                text.append("\nCompetition\nWinner")
         else:
-            text.append("\n\nSection\nWinner")
+            text.append("\nSection\nWinner")
         x = self.fpdf.get_x()
         y = self.fpdf.get_y()
         for txt in text:
@@ -1824,14 +1809,14 @@
         x = ox
         y = oy + 4.5
         w = [5, 5, 5, 7, 7, 6, 5]
-        for z in xrange(1, rnds + 2):
+        for z in range(1, rnds + 2):
             row = [x, y, []]
             if z == (rnds + 1):
                 row[2].append((w[0]+w[1]+w[2], h, 0.8, "Totals", True))
-                for l in xrange(3, 7):
+                for l in range(3, 7):
                     row[2].append((w[l], h, 0, ""))
             else:
-                for l in xrange(7):
+                for l in range(7):
                     row[2].append((w[l], h, 0, ""))
             rr["rows"].append(row)
             y += h
@@ -1863,10 +1848,10 @@
         ox = cw * ox
         oy = ld * oy
         sk = 0
-        for row in xrange(qt):
+        for row in range(qt):
             x = ox
             y = oy
-            for col in xrange(2):
+            for col in range(2):
                 tot = [0, 0, 0, 0.0]
                 skp = nskp[sk]
                 self.fpdf.set_font_size(20)
@@ -1876,7 +1861,7 @@
                 self.fpdf.drawText(skp[1], x=x+(cw*10), y=y, w=30, h=(ld*h))
                 self.fpdf.drawText(skp[2], x=x+(cw*10), w=30, h=(ld*h))
                 self.fpdf.drawText(h=(ld*h))
-                for rnd in xrange(1, rnds + 1):
+                for rnd in range(1, rnds + 1):
                     self.fpdf.drawText(rnd, x=x, w=(cw*5), h=(ld*h),
                         ln=0, align="C")
                     cd = po[skp[3][rnd][1]]
@@ -1889,7 +1874,7 @@
                         ln=0, align="C")
                     if skp[0] > 900000 or skp[3][rnd][0] > 900000:
                         txt = ["Bye", "Bye", "", ""]
-                    elif self.scores:
+                    elif self.state > 1:
                         f = skp[3][rnd][3]
                         a = skp[3][rnd][4]
                         n = (f - a)
@@ -1910,7 +1895,7 @@
                         ln=0, align="C")
                     self.fpdf.drawText(txt[3], w=(cw*5), h=(ld*h),
                         align="R")
-                if self.scores:
+                if self.state > 1:
                     self.fpdf.drawText(tot[0], x=tx, w=(cw*7), h=(ld*h),
                         ln=0, align="C")
                     self.fpdf.drawText(tot[1], w=(cw*7), h=(ld*h),
@@ -1935,7 +1920,7 @@
                 order="scg_snum, scg_subs")
             if self.subsec == "Y":
                 nsec = []
-                for x in xrange(0, len(secs), 2):
+                for x in range(0, len(secs), 2):
                     nsec.append(secs[x][0])
                 random.shuffle(nsec)
                 secs = []
@@ -1954,9 +1939,9 @@
             pair = 0
             self.two = False
             nsec = [secs[:int(len(secs) / 2)], secs[int(len(secs) / 2):]]
-            data = [self.opts["conum"], self.ccod, "P", 1, "", 1, "S", 0, 0, 0,
-                0, 0, 0, 0, 0, 0]
-        for grp in xrange(1, 3):
+            data = [self.opts["conum"], self.ccod, "P", 1, "", 1, "S", 0,
+                0, 0, 0, 0, 0, 0, 0, 0]
+        for grp in range(1, 3):
             skips = []
             if self.reprint:
                 # Reprint
@@ -1966,16 +1951,16 @@
                     ("scg_group", "=", grp)], order="scg_pair")
                 for skp in skps:
                     if self.subsec == "Y":
-                        if skp[0] > 1000:
-                            s1 = "%sB" % (skp[0] - 1000)
+                        if skp[0] > 800000:
+                            s1 = "%sB" % (skp[0] - 800000)
                         else:
-                            s1 = "%sA" % skp[0]
+                            s1 = "%sA" % (skp[0] - 700000)
                         if skp[1] > 900000:
                             s2 = "Bye"
-                        elif skp[1] > 1000:
-                            s2 = "%sB" % (skp[1] - 1000)
+                        elif skp[1] > 800000:
+                            s2 = "%sB" % (skp[1] - 800000)
                         else:
-                            s2 = "%sA" % skp[1]
+                            s2 = "%sA" % (skp[1] - 700000)
                         skips.append([s1, s2, 0, 1])
                     elif skp[1] > 900000:
                         skips.append(["%s" % skp[0], "Bye", 0, 1])
@@ -1995,9 +1980,9 @@
                     if bye or not nsec[grp - 1]:
                         skips.append(["%s%s" % tuple(skp),"Bye", 0, 1])
                         if skp[1] == "B":
-                            data[7] = skp[0] + 1000
+                            data[7] = skp[0] + 800000
                         else:
-                            data[7] = skp[0]
+                            data[7] = skp[0] + 700000
                         byen += 1
                         data[8] = byen
                         bye -= 1
@@ -2006,13 +1991,13 @@
                         skips.append(["%s%s" % tuple(skp),
                             "%s%s" % tuple(opp), 0,1])
                         if skp[1] == "B":
-                            data[7] = skp[0] + 1000
+                            data[7] = skp[0] + 800000
                         else:
-                            data[7] = skp[0]
+                            data[7] = skp[0] + 700000
                         if opp[1] == "B":
-                            data[8] = opp[0] + 1000
+                            data[8] = opp[0] + 800000
                         else:
-                            data[8] = opp[0]
+                            data[8] = opp[0] + 700000
                     data[13] = grp
                     pair += 1
                     data[15] = pair
@@ -2028,12 +2013,16 @@
             return "Bye", "TLRB"
         if self.playoff and self.ctyp == "M" and self.state < 3:
             if self.subsec == "Y":
-                if skip > 1000:
-                    return "%sB" % (skip - 1000), "LRB"
+                if skip > 800000:
+                    return "%sB" % (skip - 800000), "LRB"
                 else:
-                    return "%sA" % skip, "LRB"
+                    return "%sA" % (skip - 700000), "LRB"
             else:
                 return str(skip), "LRB"
+        if skip > 800000:
+            skip = skip - 800000
+        elif skip > 700000:
+            skip = skip - 700000
         col = ["scm_surname", "scm_names"]
         whr = [
             ("scm_cono", "=", self.opts["conum"]),
@@ -2043,7 +2032,7 @@
             name = "%s, %s" % (skp[0], skp[1][0])
         else:
             name = "Unknown"
-        if rnd and self.scores:
+        if rnd and self.state > 1:
             col = ["scg_scod", "scg_ocod", "scg_sfor", "scg_sagt"]
             whr = [
                 ("scg_cono", "=", self.opts["conum"]),
@@ -2081,7 +2070,7 @@
                 ("scc_club=scm_club",)], limit=1)
         else:
             clb = ["Bye"]
-        return clb[0]
+        return clb[0].replace("Bowling Club", "BC")
 
     def getRndTxt(self, rnd):
         if self.subsec == "Y" and rnd == self.rnds + 1:

=== modified file 'scp/sc2030.py' (properties changed: -x to +x)
--- old/scp/sc2030.py	2020-04-21 08:42:36 +0000
+++ new/scp/sc2030.py	2020-06-21 11:18:00 +0000
@@ -2,6 +2,14 @@
 SYNOPSIS
     Sectional Competition Capture Match Results.
 
+    Status Flags:   0 = No Draw done
+                    1 = Main Draw done without Results
+                    2 = Main Draw done with Results
+                    3 = Main Draw Completed
+                    4 = Playoff Draw without Results
+                    5 = Playoff Draw with Results
+                    6 = Match Complete
+
     This file is part of Tartan Systems (TARTAN).
 
 AUTHOR
@@ -67,33 +75,26 @@
             "head": ("Sec", "Club"),
             "typs": (("Ua", 3), ("NA", 30)),
             "data": []}
-        skp = {
+        self.skp = {
             "stype": "R",
             "tables": ("scpmem", "scpgme"),
             "cols": (
-                ("scm_scod", "", 0, "S-Code"),
-                ("scm_surname", "", 0, "Surname", "Y"),
-                ("scm_names", "", 0, "Names")),
-            "where": [
-                ("scm_cono", "=", self.opts["conum"]),
-                ("scg_cono=scm_cono",),
-                ("scg_scod=scm_scod",),
-                ("scg_ocod<900000",)],
-            "whera": [
-                ("T", "scg_ccod", 0, 0),
-                ("T", "scg_ctyp", 2, 0),
-                ("T", "scg_rnum", 3, 0),
-                ("T", "scg_snum", 0, 1),
-                ("T", "scg_subs", 1, 1)],
-            "group": "scm_scod, scm_surname, scm_names",
-            "order": "scm_surname, scm_names"}
+                ("a", "UI", 6, "S-Code"),
+                ("b", "NA", 30, "Name", "Y"),
+                ("c", "UI", 6, "O-Code"),
+                ("d", "NA", 30, "Name"),
+                ("e", "UI", 3, "For"),
+                ("f", "UI", 3, "Agt")),
+            "where": [],
+            "wtype": "D"}
         tag = (("Results", None, ("T",0,0), ("T",0,1)),)
         r1s = (("Main","M"), ("Play-Offs","P"))
         fld = (
             (("T",0,0,0),"I@scp_ccod",0,"","",
                 "","Y",self.doCmpCod,com,None,("notzero",)),
             (("T",0,0,0),"O@scp_name",0,""),
-            (("T",0,1,0),("ORB",r1s),0,"Type"),
+            (("T",0,1,0),("IRB",r1s),0,"Type","",
+                "","N",self.doCmpTyp,None,None,None),
             (("T",0,2,0),"I@scg_rnum",0,"Round","",
                 "","N",self.doRndNum,None,None,("notzero",)),
             (("T",1,0,0),"IUI",2,"Section Number", "",
@@ -101,12 +102,12 @@
             (("T",1,0,0),"IUA",1,"Sub-Section", "",
                 "","N",self.doSubNum,None,None,("in",("A","B"))),
             (("C",1,0,0),"I@scg_scod",0,"","",
-                0,"N",self.doSkpCod,skp,None,("notzero",)),
+                0,"N",self.doSkpCod,self.skp,None,("notzero",)),
             (("C",1,0,0),"ONA",30,"Skp-Name"),
             (("C",1,0,0),"I@scg_sfor",0,"","",
                 "","N",self.doShots,None,None,("efld",)),
             (("C",1,0,0),"I@scg_ocod",0,"","",
-                0,"N",self.doSkpCod,skp,None,("notzero",)),
+                0,"N",self.doSkpCod,self.skp,None,("notzero",)),
             (("C",1,0,0),"ONA",30,"Opp-Name"),
             (("C",1,0,0),"I@scg_sagt",0,"","",
                 "","N",self.doShots,None,None,("efld",)))
@@ -152,19 +153,28 @@
             self.lrnd = self.mrnds
             if not self.doimport:
                 self.df.loadEntry(frt, pag, p+2, data=self.ctyp)
-                return "sk1"
+                return "sk2"
         elif self.state == 6:
             return "All Results Already Captured"
         else:
             self.ctyp = "P"
-            if not self.sql.getRec("scpgme", where=[("scg_cono", "=",
-                    self.opts["conum"]), ("scg_ccod", "=", self.ccod),
-                    ("scg_ctyp", "=", self.ctyp)]):
-                return "Play-Offs Draw Not Yet Done"
             self.lrnd = self.prnds
             if not self.doimport:
                 self.df.loadEntry(frt, pag, p+2, data=self.ctyp)
-                return "sk1"
+
+    def doCmpTyp(self, frt, pag, r, c, p, i, w):
+        self.ctyp = w
+        chk = self.sql.getRec("scpgme", cols=["count(*)", "sum(scg_sfor)",
+            "sum(scg_sagt)"], where=[("scg_cono", "=", self.opts["conum"]),
+            ("scg_ccod", "=", self.ccod), ("scg_ctyp", "=", "P")], limit=1)
+        if self.ctyp == "M":
+            if chk[0] and (chk[1] or chk[2]):
+                return "Play-Offs Already Started"
+            self.lrnd = self.mrnds
+        elif not chk[0]:
+            return "Play-Offs Draw Not Yet Done"
+        else:
+            self.lrnd = self.prnds
 
     def doRndNum(self, frt, pag, r, c, p, i, w):
         if self.ctyp == "M" and self.clup == "Y" and w > 1:
@@ -182,8 +192,8 @@
                 where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod", "=",
                 self.ccod), ("scg_ctyp", "=", self.ctyp), ("scg_rnum", "=",
                 w - 1)])
-            for c in chk:
-                if c[0] < 900000 and c[1] < 900000 and not c[2] and not c[3]:
+            for s in chk:
+                if s[0] < 900000 and s[1] < 900000 and not s[2] and not s[3]:
                     return "Invalid Round, Previous Round Missing"
             chk = self.sql.getRec("scpgme", where=[("scg_cono", "=",
                 self.opts["conum"]), ("scg_ccod", "=", self.ccod), ("scg_ctyp",
@@ -231,26 +241,29 @@
             if err:
                 print(err)
                 return
+            self.doGetOldWin()
             impdlg = False
         else:
             impfle = None
             impdlg = True
             self.df.setWidget(self.df.mstFrame, state="hide")
         cols = [
-            ["scg_snum",0,"UI",2],
-            ["scg_subs",1,"UA",1],
-            ["scg_scod",2,"UI",6],
-            ["scg_ocod",3,"UI",6],
-            ["scg_sfor",4,"UI",2],
-            ["scg_sagt",5,"UI",2]]
+            ["scg_snum", 0, "UI", 2],
+            ["scg_subs", 1, "UA", 1],
+            ["scg_scod", 2, "UI", 6],
+            ["scg_ocod", 3, "UI", 6],
+            ["scg_sfor", 4, "UI", 2],
+            ["scg_sagt", 5, "UI", 2]]
         fi = FileImport(self.opts["mf"], impcol=cols, impfle=impfle,
             impdlg=impdlg)
         if fi.impdat:
-            sp = ProgressBar(self.opts["mf"].body, typ="Importing Results",
-                mxs=len(fi.impdat))
+            if not self.opts["test"]:
+                sp = ProgressBar(self.opts["mf"].body, typ="Importing Results",
+                    mxs=len(fi.impdat))
             err = None
             for num, line in enumerate(fi.impdat):
-                sp.displayProgress(num)
+                if not self.opts["test"]:
+                    sp.displayProgress(num)
                 if not line[0]:
                     continue
                 whr = [
@@ -271,7 +284,9 @@
                 if not chk:
                     err = "Invalid Skip %s, Opponent %s" % (line[2], line[3])
                     break
-                if not line[4] and not line[5]:
+                if line[2] > 900000 or line[3] > 900000:
+                    pass
+                elif not line[4] and not line[5]:
                     err = "Zero Results"
                     break
                 self.snum = line[0]
@@ -281,7 +296,8 @@
                 self.sfor = line[4]
                 self.sagt = line[5]
                 self.doColEnd()
-            sp.closeProgress()
+            if not self.opts["test"]:
+                sp.closeProgress()
             if err:
                 err = "Line %s: %s" % ((num + 1), err)
                 showError(self.opts["mf"].body, "Import Error", """%s
@@ -324,10 +340,12 @@
         if self.ssub == "N" or self.ctyp == "P":
             self.subs = ""
             self.df.loadEntry(frt, pag, p+1, data=self.subs)
+            self.doLoadSkips()
             return "sk1"
 
     def doSubNum(self, frt, pag, r, c, p, i, w):
         self.subs = w
+        self.doLoadSkips()
 
     def doTopEnd(self):
         if self.df.pag == 0:
@@ -336,17 +354,58 @@
                 self.df.loadEntry("T", 1, 0, data=self.snum)
                 self.subs = ""
                 self.df.loadEntry("T", 1, 1, data=self.subs)
+                self.doLoadSkips()
                 self.df.focusField("C", 1, 1)
             else:
+                self.doGetOldWin()
                 self.df.focusField("T", 1, 1)
         else:
             self.df.focusField("C", 1, 1)
 
+    def doLoadSkips(self):
+        col = ["scg_scod", "scg_ocod", "scg_sfor", "scg_sagt"]
+        whr = [
+            ("scg_cono", "=", self.opts["conum"]),
+            ("scg_ccod", "=", self.ccod),
+            ("scg_ctyp", "=", self.ctyp),
+            ("scg_rnum", "=", self.rnum),
+            ("scg_snum", "=", self.snum),
+            ("scg_subs", "=", self.subs),
+            ("scg_ocod", "<", 900000)]
+        data = []
+        recs = self.sql.getRec("scpgme", cols=col, where=whr)
+        for rec in recs:
+            data.append((rec[0], self.getName(rec[0]), rec[1],
+                self.getName(rec[1]), rec[2], rec[3]))
+        self.skp["where"] = data
+
     def doTopExit(self):
         if not self.opts["test"] and self.df.pag == 0:
             self.df.closeProcess()
             self.opts["mf"].closeLoop()
         else:
+            # Check all entries for round
+            chk = self.sql.getRec("scpgme", cols=["count(*)"],
+                where=[("scg_cono", "=", self.opts["conum"]),
+                ("scg_ccod", "=", self.ccod), ("scg_ctyp",
+                "=", self.ctyp), ("scg_rnum", "=", self.rnum),
+                ("scg_scod", "<", 900000), ("scg_ocod", "<", 900000),
+                ("scg_sfor", "=", 0), ("scg_sagt", "=", 0)], limit=1)[0]
+            if chk:
+                txt = "Not All the Results for Round %s Captured" % self.rnum
+                if self.opts["test"]:
+                    self.opts["mf"].dbm.rollbackDbase()
+                    return
+                txt = "%s\n\nDo You want to Exit and Lose All Results for "\
+                    "this Round?" % txt
+                ok = askQuestion(self.opts["mf"].body, "Missing Results", txt,
+                    default="no")
+                if ok == "yes":
+                    self.opts["mf"].dbm.rollbackDbase()
+                    self.df.focusField("T", 0, 4)
+                else:
+                    self.df.focusField("T", 1, 1)
+                return
             if self.rnum == self.lrnd:
                 chk = self.sql.getRec("scpgme", cols=["count(*)"],
                     where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod",
@@ -469,6 +528,7 @@
                 self.rnum), ("scg_scod", "=", self.ocod)])
         self.scod = 0
         if not self.doimport:
+            self.doLoadSkips()
             self.df.advanceLine(1)
 
     def doShow(self):
@@ -500,13 +560,14 @@
     def doColExit(self):
         chk = self.sql.getRec("scpgme", cols=["count(*)"],
             where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod", "=",
-            self.ccod), ("scg_ctyp", "=", "M"), ("scg_snum", "=", self.snum),
-            ("scg_subs", "=", self.subs), ("scg_rnum", "=", self.rnum),
-            ("scg_scod", "<", 900000), ("scg_ocod", "<", 900000), ("(",
-            "scg_sfor", "=", 0, "and", "scg_sagt", "=", 0, ")")], limit=1)
-        if chk[0] and (self.clup == "N" or \
-                (self.clup == "Y" and self.rnum > 1)):
-            # All results not yet entered
+            self.ccod), ("scg_ctyp", "=", self.ctyp), ("scg_rnum", "=",
+            self.rnum), ("scg_snum", "=", self.snum), ("scg_subs", "=",
+            self.subs), ("scg_scod", "<", 900000), ("scg_ocod", "<", 900000),
+            ("(", "scg_sfor", "=", 0, "and", "scg_sagt", "=", 0, ")")],
+            limit=1)
+        if chk[0] and (self.clup == "N" or self.ctyp == "P" or \
+                            (self.clup == "Y" and self.rnum > 1)):
+            # All results for section not yet entered
             if self.doimport:
                 showError(self.opts["mf"].body, "Missing Results",
                     "Some Results are Missing, Please Check Import "\
@@ -515,7 +576,8 @@
                 self.ierr = True
                 return
             ok = askQuestion(self.opts["mf"].body, "Missing Results",
-                "Do you wish to Exit and Lose These Results for This Section?")
+                "Some Result are Missing. Do You want to Exit and Lose "\
+                "the Results for this Section?")
             if ok == "no":
                 self.df.focusField(self.df.frt, self.df.pag, self.df.col)
                 return
@@ -575,53 +637,66 @@
                     del nums[skp]
                     continue
             for scod in nums:
-                scod = nums[scod][self.sql.scpgme_col.index("scg_scod")]
-                ocod = nums[scod][self.sql.scpgme_col.index("scg_ocod")]
-                sfor = nums[scod][self.sql.scpgme_col.index("scg_sfor")]
-                sagt = nums[scod][self.sql.scpgme_col.index("scg_sagt")]
+                rec = nums[scod]
+                scod = rec[self.sql.scpgme_col.index("scg_scod")]
+                ocod = rec[self.sql.scpgme_col.index("scg_ocod")]
+                sfor = rec[self.sql.scpgme_col.index("scg_sfor")]
+                sagt = rec[self.sql.scpgme_col.index("scg_sagt")]
+                where = [
+                    ("scg_cono", "=", self.opts["conum"]),
+                    ("scg_ccod", "=", self.ccod),
+                    ("scg_ctyp", "=", self.ctyp),
+                    ("scg_snum", "=", self.snum),
+                    ("scg_subs", "=", self.subs),
+                    ("scg_rnum", "=", nrnd),
+                    ("scg_scod", "=", scod)]
                 if scod in byes:
                     self.byenum += 1
                     # Create bye
                     self.sql.updRec("scpgme", cols=["scg_ocod"],
-                        data=[self.byenum], where=[("scg_cono", "=",
-                        self.opts["conum"]), ("scg_ccod", "=", self.ccod),
-                        ("scg_ctyp", "=", self.ctyp), ("scg_snum", "=",
-                        self.snum), ("scg_subs", "=", self.subs),
-                        ("scg_rnum", "=", self.rnum), ("scg_scod", "=", scod)])
-                # Create next round record
-                nums[scod][self.sql.scpgme_col.index("scg_rnum")] = nrnd
-                nums[scod][self.sql.scpgme_col.index("scg_ocod")] = 0
-                nums[scod][self.sql.scpgme_col.index("scg_sfor")] = 0
-                nums[scod][self.sql.scpgme_col.index("scg_sagt")] = 0
-                nums[scod][self.sql.scpgme_col.index("scg_seed")] = 0
-                nums[scod][self.sql.scpgme_col.index("scg_pair")] = 0
-                if scod not in byes:
+                        data=[self.byenum], where=where)
+                if nrnd < self.lrnd:
+                    # Create next round record
+                    rec[self.sql.scpgme_col.index("scg_rnum")] = nrnd
+                    rec[self.sql.scpgme_col.index("scg_ocod")] = 0
+                    rec[self.sql.scpgme_col.index("scg_sfor")] = 0
+                    rec[self.sql.scpgme_col.index("scg_sagt")] = 0
+                    rec[self.sql.scpgme_col.index("scg_seed")] = 0
+                    rec[self.sql.scpgme_col.index("scg_pair")] = 0
+                    if scod not in byes and sfor < sagt and ocod:
+                        scod = ocod
+                        rec[self.sql.scpgme_col.index("scg_scod")] = scod
+                    chk = self.sql.getRec("scpgme", where=where, limit=1)
+                    if not chk:
+                        self.sql.insRec("scpgme", data=rec)
+                    else:
+                        self.sql.updRec("scpgme", data=rec, where=where)
+                else:
+                    # Update playoff records
+                    cod = self.snum + 700000
                     if sfor > sagt:
-                        nums[scod][self.sql.scpgme_col.index("scg_scod")] = scod
+                        win = scod
                     else:
-                        nums[scod][self.sql.scpgme_col.index("scg_scod")] = ocod
-                if not self.sql.getRec("scpgme", data=nums[scod]):
-                    self.sql.insRec("scpgme", data=nums[scod])
-        # Check if all results for round are captured
-        chek = self.sql.getRec("scpgme", cols=["count(*)"],
-            where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod", "=",
-            self.ccod), ("scg_ctyp", "=", self.ctyp), ("scg_rnum", "=",
-            self.rnum), ("scg_scod", "<", 900000), ("scg_ocod", "<",
-            900000),("scg_sfor", "=", 0), ("scg_sagt", "=", 0)])[0]
-        if not chek:
-            return
+                        win = ocod
+                    whr = where[:6]
+                    whr[2] = ("scg_ctyp", "=", "P")
+                    whr[3] = ("scg_snum", "=", 1)
+                    whr[5] = ("scg_rnum", "=", 1)
+                    whr.append(("scg_scod", "=", cod))
+                    self.sql.updRec("scpgme", cols=["scg_scod"], data=[win],
+                        where=whr)
+                    whr[6] = ("scg_ocod", "=", cod)
+                    self.sql.updRec("scpgme", cols=["scg_ocod"], data=[win],
+                        where=whr)
         if (self.fmat == "K" and self.clup == "N") or self.ctyp == "P":
             recs = self.sql.getRec("scpgme", where=[("scg_cono", "=",
                 self.opts["conum"]), ("scg_ccod", "=", self.ccod), ("scg_ctyp",
                 "=", self.ctyp), ("scg_snum", "=", self.snum), ("scg_rnum",
                 "=", self.rnum)], order="scg_group, scg_pair")
-            lsec = 0
             group = 0
             for num in xrange(0, len(recs), 2):
                 one = recs[num]
                 snum = one[self.sql.scpgme_col.index("scg_snum")]
-                if not lsec:
-                    lsec = snum
                 subs = one[self.sql.scpgme_col.index("scg_subs")]
                 if group != one[self.sql.scpgme_col.index("scg_group")]:
                     group = one[self.sql.scpgme_col.index("scg_group")]
@@ -636,7 +711,7 @@
                     win1 = cod1
                 else:
                     win1 = opp1
-                if len(recs) > 1:
+                if len(recs[num:]) > 1:
                     two = recs[num + 1]
                     cod2 = two[self.sql.scpgme_col.index("scg_scod")]
                     opp2 = two[self.sql.scpgme_col.index("scg_ocod")]
@@ -674,10 +749,13 @@
                 if self.rnum == self.lrnd and \
                         self.ctyp == "M" and self.nsec > 2:
                     # Create playoff records with winners codes
-                    if subs == "B":
-                        key = snum + 1000
+                    if not self.oldwin:
+                        if subs == "B":
+                            key = snum + 800000
+                        else:
+                            key = snum + 700000
                     else:
-                        key = snum
+                        key = self.oldwin[snum]
                     self.sql.updRec("scpgme", cols=["scg_scod"],
                         data=[win1], where=[("scg_cono", "=",
                         self.opts["conum"]), ("scg_ccod", "=", self.ccod),
@@ -710,36 +788,38 @@
                 else:
                     win = rec[1]
             else:
-                col = [
-                    "scg_scod",
-                    "sum(scg_pnts) as pnts",
-                    "sum(scg_sfor) as sfor",
-                    "sum(scg_sfor - scg_sagt) as sdif",
-                    "sum(scg_sfor / scg_sagt) as savg"]
-                grp = "scg_scod"
-                odr = "pnts desc, sfor desc, sdif desc, savg desc"
-                win = self.sql.getRec("scpgme", cols=col,
-                    where=whr, group=grp, order=odr)
-                win = win[0][0]
-            if self.subs == "B":
-                key = self.snum + 1000
+                self.doGetNewWin(sect=self.snum, sub=self.subs)
+                win = self.newwin[self.snum]
+            if not self.oldwin:
+                if self.subs == "B":
+                    key = self.snum + 800000
+                else:
+                    key = self.snum + 700000
             else:
-                key = self.snum
-            self.sql.updRec("scpgme", cols=["scg_scod"],
-                data=[win], where=[("scg_cono", "=",
-                self.opts["conum"]), ("scg_ccod", "=", self.ccod),
-                ("scg_ctyp", "=", "P"), ("scg_rnum", "=", 1),
-                ("scg_ktyp", "=", "S"), ("scg_scod", "=", key)])
-            self.sql.updRec("scpgme", cols=["scg_ocod"],
-                data=[win], where=[("scg_cono", "=",
-                self.opts["conum"]), ("scg_ccod", "=", self.ccod),
-                ("scg_ctyp", "=", "P"), ("scg_rnum", "=", 1),
-                ("scg_ktyp", "=", "S"), ("scg_ocod", "=", key)])
+                key = self.oldwin[self.snum]
+            self.sql.updRec("scpgme", cols=["scg_scod"], data=[win],
+                where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod",
+                "=", self.ccod), ("scg_ctyp", "=", "P"), ("scg_rnum", "=", 1),
+                ("scg_scod", "=", key)])
+            self.sql.updRec("scpgme", cols=["scg_ocod"], data=[win],
+                where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod",
+                "=", self.ccod), ("scg_ctyp", "=", "P"), ("scg_rnum", "=", 1),
+                ("scg_ocod", "=", key)])
             if self.snum == self.nsec and self.subs == lsub:
                 self.sql.updRec("scpgme", cols=["scg_ktyp"], data=["M"],
                     where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod",
                     "=", self.ccod), ("scg_ctyp", "=", "P")])
-        if self.rnum == self.lrnd:
+        # Check if all results for the round are captured
+        chek = self.sql.getRec("scpgme", cols=["count(*)"],
+            where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod", "=",
+            self.ccod), ("scg_ctyp", "=", self.ctyp), ("scg_rnum", "=",
+            self.rnum), ("scg_scod", "<", 900000), ("scg_ocod", "<", 900000),
+            ("scg_sfor", "=", 0), ("scg_sagt", "=", 0)], limit=1)
+        if chek[0]:
+            return
+        if self.clup == "Y" and self.ctyp == "M" and nrnd == self.lrnd:
+            state = 3
+        elif self.rnum == self.lrnd:
             if self.ctyp == "M":
                 state = 3
             else:
@@ -749,44 +829,50 @@
         else:
             state = 5
         self.sql.updRec("scpcmp", cols=["scp_state"], data=[state],
-            where=[("scp_cono", "=", self.opts["conum"]), ("scp_ccod", "=",
-            self.ccod)])
-
-    def getSubs(self, sec):
-        if self.ssub == "Y":
-            snum = int((sec + 1) / 2)
-            if sec % 2:
-                subs = "A"
-            else:
-                subs = "B"
-        else:
-            snum = sec
-            subs = ""
-        return snum, subs
-
-if __name__ == "__main__":
-    import getopt, sys
-    from TartanClasses import Dbase, MainFrame
-    from tartanFunctions import loadRcFile
-    try:
-        opts, args = getopt.getopt(sys.argv[1:],"r:")
-    except:
-        print("")
-        print("Usage: -r rcfile")
-        print("")
-        sys.exit()
-    rcdic = loadRcFile(opts[0][1])
-    dbm = Dbase(rcdic)
-    if not dbm.err:
-        mf = MainFrame(rcdic=rcdic)
-        mf.dbm = dbm
-        mf.dbm.openDbase()
-        if len(sys.argv) > 3:
-            test = (int(sys.argv[3]), int(sys.argv[4]), sys.argv[5])
-        else:
-            test = None
-        sc2030(**{"mf": mf, "conum": 1, "conam": "Bowls Association",
-            "test": test})
-        mf.dbm.closeDbase()
+            where=[("scp_cono", "=", self.opts["conum"]), ("scp_ccod",
+            "=", self.ccod)])
+
+    def doGetOldWin(self):
+        self.oldwin = {}
+        if self.ctyp == "M" and self.rnum == self.lrnd:
+            recs = self.sql.getRec("scpgme", cols=["scg_scod", "scg_ocod"],
+                where=[("scg_cono", "=", self.opts["conum"]), ("scg_ccod",
+                "=", self.ccod), ("scg_ctyp", "=", "P"), ("scg_snum", "=", 1)])
+            for rec in recs:
+                for cod in rec:
+                    if cod < 900000:
+                        sec = self.sql.getRec("scpgme", cols=["scg_snum"],
+                            where=[("scg_cono", "=", self.opts["conum"]),
+                            ("scg_ccod", "=", self.ccod), ("scg_ctyp", "=",
+                            "M"), ("scg_scod", "=", cod)], limit=1)
+                        if sec:
+                            self.oldwin[sec[0]] = cod
+
+    def doGetNewWin(self, sect=None, sub=""):
+        # Get Leaders
+        self.newwin = {}
+        if sect is None:
+            secs = []
+            for x in range(self.nsec):
+                secs.append(x + 1)
+        else:
+            secs = [sect]
+        for sec in secs:
+            col = [
+                "scg_scod",
+                "sum(scg_pnts) as a",
+                "sum(scg_sfor - scg_sagt) as b",
+                "round(sum(scg_sfor) / sum(scg_sagt), 2) as c"]
+            whr = [
+                ("scg_cono", "=", self.opts["conum"]),
+                ("scg_ccod", "=", self.ccod),
+                ("scg_ctyp", "=", "M"),
+                ("scg_snum", "=", sec),
+                ("scg_subs", "=", sub)]
+            grp = "scg_scod"
+            odr = "a desc, b desc, c desc"
+            rec = self.sql.getRec("scpgme", cols=col, where=whr, group=grp,
+                order=odr, limit=1)
+            self.newwin[sec] = rec[0]
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'scp/sc3010.py' (properties changed: -x to +x)
--- old/scp/sc3010.py	2020-04-21 08:42:36 +0000
+++ new/scp/sc3010.py	2020-07-13 10:47:11 +0000
@@ -26,7 +26,7 @@
 
 import os, time
 from TartanClasses import MyFpdf, Sql, TartanDialog
-from tartanFunctions import getModName, doPrinter
+from tartanFunctions import getImage, getModName, doPrinter
 
 class sc3010(object):
     def __init__(self, **opts):
@@ -40,8 +40,11 @@
             prog=self.__class__.__name__)
         t = time.localtime()
         self.sysdt = time.strftime("%d %B %Y %H:%M:%S", t)
-        self.image = os.path.join(self.opts["mf"].rcdic["prgdir"], "img",
-            "bowls.png")
+        self.image = os.path.join(self.opts["mf"].rcdic["wrkdir"], "bowls.png")
+        if not os.path.exists(self.image):
+            getImage("bowls", fle=self.image)
+        if not os.path.exists(self.image):
+            self.image = None
 
     def mainProcess(self):
         com = {
@@ -83,22 +86,20 @@
         recs = self.sql.getRec(tables=["scpent", "scpmem", "scpclb"], cols=col,
             where=whr, order="scm_surname")
         if recs:
-            self.fpdf = MyFpdf(auto=True, foot=True)
+            self.fpdf = MyFpdf(auto=True, name="sc3010", head=90, foot=True)
             self.fpdf.header = self.doHead
             self.fpdf.add_page()
-            self.fpdf.set_font("Courier","",12)
-            cwth = self.fpdf.get_string_width("X")
+            cwth = self.fpdf.cwth
             for num, rec in enumerate(recs):
                 self.fpdf.drawText(txt="%6s" % rec[0], w=cwth*7, h=5, ln=0)
                 nm = rec[1].strip() + ", %s" % rec[2].split()[0]
                 self.fpdf.drawText(txt=nm, w=cwth*31, h=5, ln=0)
                 self.fpdf.drawText(txt=rec[3], w=cwth*2, h=5, ln=0)
-                self.fpdf.drawText(txt=rec[4], w=cwth*16, h=5, ln=0)
+                self.fpdf.drawText(txt=rec[4], w=cwth*31, h=5, ln=0)
                 ph = rec[5].replace(" ", "").strip()
                 self.fpdf.drawText(txt=ph, w=cwth*16, h=5, ln=1)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], pdfnam=pdfnam,
                 repprt=self.df.repprt,
@@ -112,8 +113,8 @@
         self.fpdf.cell(20)
         self.fpdf.cell(0,10,"Players Entered in the %s" % self.cnam,1,0,"C")
         self.fpdf.ln(20)
-        self.fpdf.set_font("Courier","B",12)
-        self.fpdf.cell(0, 5, "%-6s %-30s %-1s %-15s %-15s" % \
+        self.fpdf.setFont(style="B")
+        self.fpdf.cell(0, 5, "%-6s %-30s %-1s %-30s %-15s" % \
             ("Reg-No", "Name", "G", "Club", "Contact"), "B")
         self.fpdf.ln(5)
 

=== modified file 'scp/scc110.py' (properties changed: -x to +x)
--- old/scp/scc110.py	2020-04-21 08:42:36 +0000
+++ new/scp/scc110.py	2020-04-23 14:19:29 +0000
@@ -126,10 +126,12 @@
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doEnd(self):
-        data = self.df.t_work[0][0]
+        data = self.df.t_work[0][0][:]
         if self.newclb:
             self.sql.insRec("scpclb", data=data)
         elif data != self.old[:len(data)]:
+            col = self.sql.scpclb_col
+            data.append(self.old[col.index("scc_xflag")])
             self.sql.updRec("scpclb", data=data, where=[("scc_club",
                 "=", self.club)])
         self.opts["mf"].dbm.commitDbase()

=== removed file 'std/sitecustomize.py'
--- old/std/sitecustomize.py	2014-03-28 07:32:49 +0000
+++ new/std/sitecustomize.py	1970-01-01 00:00:00 +0000
@@ -1,2 +0,0 @@
-import sys
-sys.setdefaultencoding("latin-1")

=== added file 'sls/__init__.py'
=== modified file 'sls/si2010.py' (properties changed: -x to +x)
--- old/sls/si2010.py	2020-04-21 08:42:36 +0000
+++ new/sls/si2010.py	2020-07-07 11:35:50 +0000
@@ -27,14 +27,14 @@
 import time
 from TartanClasses import AgeAll, ASD, Balances, CCD, GetCtl, PrintInvoice
 from TartanClasses import PwdConfirm, Sql, TartanDialog
-from tartanFunctions import callModule, copyList, getMarkup, getVatRate
+from tartanFunctions import callModule, copyList, getCost, getSell, getVatRate
 
 class si2010(object):
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
             self.exit = False
-            self.getPrinters()
+            self.selectPrinter()
             if not self.exit:
                 self.mainProcess()
                 self.opts["mf"].startLoop()
@@ -63,8 +63,7 @@
             return
         self.stgl = strctl["cts_glint"]
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
-        self.automu = strctl["cts_automu"]
+        self.plevs = strctl["cts_plevs"]
         if self.drgl == "Y" or self.stgl == "Y":
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -101,7 +100,7 @@
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         return True
 
-    def getPrinters(self):
+    def selectPrinter(self):
         tit = ("Date and Printer Selection",)
         tpm = {
             "stype": "R",
@@ -220,13 +219,13 @@
             ("Quote","Q"))
         r2s = (("Account","A"),("Cash","C"))
         fld = [
-            (("T",0,0,0),("IRB",r1s),0,"Type","Transaction Type",
-                "I","Y",self.doTyp,None,None,None),
-            (("T",0,1,0),("IRB",r2s),0,"Mode ","Mode of Payment",
-                "A","Y",self.doMod,None,None,None),
-            (("T",0,2,0),"IUI",3,"Chain","Chain Store",
-                "","N",self.doChn,chn,None,None),
-            (("T",0,2,0),"ONA",30,""),
+            [["T",0,0,0],("IRB",r1s),0,"Type","Transaction Type",
+                "I","Y",self.doTyp,None,None,None],
+            [["T",0,1,0],("IRB",r2s),0,"Mode ","Mode of Payment",
+                "A","Y",self.doMod,None,None,None],
+            [["T",0,2,0],"IUI",3,"Chain","Chain Store",
+                "","N",self.doChn,chn,None,None],
+            [["T",0,2,0],"ONA",30,""],
             [["T",0,3,0],"INA",7,"Acc-Num","Account Number",
                 "","N",self.doAcc,drm,None,None],
             [["T",0,3,0],"ONA",30,""],
@@ -245,15 +244,15 @@
             fld[5][0][2] = 3
         else:
             drm["whera"] = [["T", "drm_chain", 2]]
-        if self.levels == 1:
+        if self.plevs == 1:
             self.opts["level"] = 1
         else:
             r3s = [("One","1"),("Two","2")]
-            if self.levels > 2:
+            if self.plevs > 2:
                 r3s.append(("Three","3"))
-            if self.levels > 3:
+            if self.plevs > 3:
                 r3s.append(("Four","4"))
-            if self.levels > 4:
+            if self.plevs > 4:
                 r3s.append(("Five","5"))
             if self.chns == "Y":
                 fld.append([("T",0,5,0),("IRB",r3s),0,"Level",
@@ -363,7 +362,7 @@
                 self.df.loadEntry("T", 0, num+1, data=self.name)
                 self.df.loadEntry("T", 0, num+2, data=self.repno)
                 self.df.loadEntry("T", 0, num+3, data=self.repnm)
-                if self.levels == 1:
+                if self.plevs == 1:
                     return "nd"
                 self.df.loadEntry("T", 0, num+4, data=str(self.opts["level"]))
                 return "nd"
@@ -599,7 +598,7 @@
         self.repno = w
         self.repnm = nam[0]
         self.df.loadEntry(frt, pag, p+1, data=self.repnm)
-        if self.levels == 1:
+        if self.plevs == 1:
             pass
         else:
             lev = str(self.drsmst[self.sql.drsmst_col.index("drm_plev")])
@@ -780,11 +779,14 @@
                 pass
             else:
                 # Check for quantity on hand
-                bal = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                    self.curdt, (self.grp, self.code, self.loc, ("P",
-                    self.opts["period"][0])))
-                bals = bal.doStrBals()
-                qty = CCD(bals[5][0], "SD", 11.2).work
+                bal = self.sql.getRec("strtrn", cols=["sum(stt_qty)"],
+                    where=[("stt_cono", "=", self.opts["conum"]),
+                    ("stt_group", "=", self.grp), ("stt_code", "=", self.code),
+                    ("stt_loc", "=", self.loc)], limit=1)
+                if bal:
+                    qty = CCD(bal[0], "SD", 11.2).work
+                else:
+                    qty = CCD(0, "SD", 11.2).work
                 if self.vind != "N" and self.typs != "C" and self.qty > qty:
                     state = self.df.disableButtonsTags()
                     cf = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
@@ -818,18 +820,19 @@
             self.recipe = []
             needpwd = False
             for item in recipe:
-                st1 = self.sql.getRec("strmf1", cols=["st1_type"],
-                    where=[("st1_cono", "=", item[0]), ("st1_group", "=",
-                    item[4]), ("st1_code", "=", item[5])], limit=1)
+                st1 = self.sql.getRec("strmf1", cols=["st1_type",
+                    "st1_value_ind"], where=[("st1_cono", "=", item[0]),
+                    ("st1_group", "=", item[4]), ("st1_code", "=", item[5])],
+                    limit=1)
                 if st1[0] == "X":
                     return "Redundant"
                 quant = item[6] * self.qty
-                vals = self.doCalCost(item[4], item[5], self.loc, 1)
-                if vals[0] != "N" and quant > vals[3]:
+                icost, bal = getCost(self.sql, self.opts["conum"], item[4],
+                    item[5], loc=self.loc, qty=1, ind="I", bal=True)
+                if st1[1] == "A" and quant > bal[0]:
                     needpwd = True
-                data = [self.opts["conum"], self.typs, self.docno, self.lineno,
-                    item[4], item[5], item[6], vals[1], 0]
-                self.recipe.append(data)
+                self.recipe.append([self.opts["conum"], self.typs, self.docno,
+                    self.lineno, item[4], item[5], item[6], icost, 0])
             if needpwd:
                 state = self.df.disableButtonsTags()
                 cf = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
@@ -862,8 +865,9 @@
                 "=", self.docno), ("si3_seq", "=", self.lineno)])
             for item in recipe:
                 quant = item[6] * self.qty
-                vals = self.doCalCost(item[4], item[5], self.loc, quant)
-                self.tcost = float(ASD(self.tcost) + ASD(vals[2]))
+                icost, tcost = getCost(self.sql, self.opts["conum"], item[4],
+                    item[5], loc=self.loc, qty=quant, ind="I", tot=True)
+                self.tcost = float(ASD(self.tcost) + ASD(tcost))
             self.icost = round(self.tcost / self.qty, 2)
         elif atype == "S":
             self.doCalSell()
@@ -875,8 +879,9 @@
             desc = self.sql.getRec("strmf1", cols=["st1_desc"],
                 where=[("st1_cono", "=", self.opts["conum"]), ("st1_group",
                 "=", item[4]), ("st1_code", "=", item[5])], limit=1)
-            cost = self.doCalCost(item[4], item[5], self.loc, item[6])
-            data.append([num, item[4], item[5], desc[0], item[6], cost[2]])
+            icost, tcost = getCost(self.sql, self.opts["conum"], item[4],
+                item[5], loc=self.loc, qty=item[6], ind="I", tot=True)
+            data.append([num, item[4], item[5], desc[0], item[6], tcost])
         titl = "Recipe Items"
         head = ("Seq","Grp","Product-Code", "Description", "  Quantity",
             "      Cost")
@@ -985,10 +990,10 @@
         if self.rectyp == "chg":
             self.recipe[int(self.recchg[0])][6] = self.recqty
         else:
-            vals = self.doCalCost(self.recgrp, self.reccod, self.loc, 1)
+            icost = getCost(self.sql, self.opts["conum"], self.recgrp,
+                self.reccod, loc=self.loc, qty=1, ind="I")
             self.recipe.append([self.opts["conum"], self.typs, self.docno,
-                self.lineno, self.recgrp, self.reccod, self.recqty,
-                vals[1], 0])
+                self.lineno, self.recgrp, self.reccod, self.recqty, icost, 0])
         self.doRecExit()
 
     def doRecExit(self):
@@ -1006,8 +1011,8 @@
             self.doRecipe(atype="U", lineno=self.newline)
             icost = self.icost
         else:
-            ind, icost, tcost, cbal = self.doCalCost(self.grp, self.code,
-                self.loc, self.qty)
+            icost = getCost(self.sql, self.opts["conum"], self.grp, self.code,
+                loc=self.loc, qty=self.qty, ind="I")
         if w < icost:
             state = self.df.disableButtonsTags()
             cf = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
@@ -1240,8 +1245,8 @@
             self.doRecipe(atype="U", lineno=self.change[0])
             icost = self.icost
         else:
-            ind, icost, tcost, cbal = self.doCalCost(self.change[1],
-                self.change[2], self.change[4], self.qty)
+            icost = getCost(self.sql, self.opts["conum"], self.change[1],
+                self.change[2], loc=self.change[4], qty=self.qty, ind="I")
         if w < icost:
             state = self.df.disableButtonsTags()
             cf = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
@@ -1448,13 +1453,13 @@
             mf1 = self.sql.getRec("strmf1", where=[("st1_cono", "=",
                 self.opts["conum"]), ("st1_group", "=", grp), ("st1_code", "=",
                 cod)], limit=1)
-            typ = mf1[self.sql.strmf1_col.index("st1_type")]
             ind = mf1[self.sql.strmf1_col.index("st1_value_ind")]
-            if typ != "R" and ind != "N":
-                bal = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                    self.curdt, (grp, cod, loc, ("P", self.opts["period"][0])))
-                bals = bal.doStrBals()
-                if qty > bals[5][0]:
+            if ind == "A":
+                bal = self.sql.getRec("strtrn", cols=["sum(stt_qty)"],
+                    where=[("stt_cono", "=", self.opts["conum"]),
+                    ("stt_group", "=", grp), ("stt_code", "=", cod),
+                    ("stt_loc", "=", loc)], limit=1)
+                if qty > bal[0]:
                     needpwd = True
         if needpwd:
             state = self.df.disableButtonsTags()
@@ -1668,8 +1673,8 @@
                 icost = self.icost
                 tcost = self.tcost
             else:
-                ind, icost, tcost, cbal = self.doCalCost(self.grp, self.code,
-                    self.loc, self.qty)
+                icost, tcost = getCost(self.sql, self.opts["conum"], self.grp,
+                    self.code, loc=self.loc, qty=self.qty, ind="I", tot=True)
             if self.typs == "I":
                 rtn = 7
                 qty = float(ASD(0) - ASD(self.qty))
@@ -1876,75 +1881,13 @@
         self.docno = CCD(docno, "UI", 9).work
         self.othno = CCD(docno, "Na", 9).work
 
-    def doCalCost(self, grp, code, loc, qty):
-        # Calculate cost price
-        ind = self.sql.getRec("strmf1", cols=["st1_value_ind"],
-            where=[("st1_cono", "=", self.opts["conum"]), ("st1_group", "=",
-            grp), ("st1_code", "=", code)], limit=1)
-        bal = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
-            (grp, code, loc, ("P", self.opts["period"][0])))
-        bals = bal.doStrBals()
-        if ind[0] == "N":
-            icost = 0.00
-            tcost = 0.00
-        elif ind[0] == "S":
-            icost = bals[7]
-            tcost = round((icost * qty), 2)
-        else:
-            if qty == bals[5][0]:
-                tcost = bals[5][1]
-                icost = round((tcost / qty), 2)
-            else:
-                icost = bals[6]
-                tcost = round((icost * qty), 2)
-            if not icost:
-                icost = bals[7]
-                tcost = round((icost * qty), 2)
-        return (ind[0], icost, tcost, bals[5][0])
-
     def doCalSell(self):
-        prc = self.sql.getRec("strprc", cols=["stp_price"],
-            where=[("stp_cono", "=", self.opts["conum"]), ("stp_group", "=",
-            self.grp), ("stp_code", "=", self.code), ("stp_loc", "=",
-            self.loc), ("stp_level", "=", self.opts["level"])], limit=1)
-        if prc and prc[0]:
-            self.rrp = prc[0]
-            return
         if self.gtype == "R":
-            items = self.sql.getRec("slsiv3", cols=["si3_rgroup",
-                "si3_rcode", "si3_rqty"], where=[("si3_cono", "=",
-                self.opts["conum"]), ("si3_rtn", "=", self.typs), ("si3_docno",
-                "=", self.docno), ("si3_seq", "=", self.lineno)])
+            gtyp = [self.typs, self.docno, self.lineno]
         else:
-            items = [[self.grp, self.code, 1]]
-        cst = 0
-        self.rrp = 0
-        for grp, cod, qty in items:
-            bal = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                self.curdt, (grp, cod, self.loc, ("P", self.opts["period"][0])))
-            bals = bal.doStrBals()
-            if bals[7]:
-                # Last Cost
-                cst = float(ASD(cst) + ASD(qty * bals[7]))
-            else:
-                # Average Cost
-                cst = float(ASD(cst) + ASD(qty * bals[6]))
-            if self.gtype == "R":
-                prc = self.sql.getRec("strprc", cols=["stp_price"],
-                    where=[("stp_cono", "=", self.opts["conum"]), ("stp_group",
-                    "=", grp), ("stp_code", "=", cod), ("stp_loc", "=",
-                    self.loc), ("stp_level", "=", self.opts["level"])],
-                    limit=1)
-            else:
-                prc = None
-            if prc and prc[0]:
-                prc = round((qty * prc[0]), 2)
-                self.rrp = float(ASD(self.rrp) + ASD(prc))
-        if not self.rrp and self.automu == "Y":
-            mkp = getMarkup(self.sql, self.opts["conum"], self.grp, self.code,
-                self.loc, self.opts["level"])
-            if mkp:
-                self.rrp = round((cst * (100 + mkp) / 100.0), 2)
+            gtyp = False
+        self.rrp = getSell(self.sql, self.opts["conum"], self.grp,
+            self.code, self.loc, self.opts["level"], recp=gtyp)
 
     def doCancel(self):
         self.opts["mf"].dbm.rollbackDbase()

=== modified file 'sls/si3010.py' (properties changed: -x to +x)
--- old/sls/si3010.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3010.py	2020-05-27 12:33:12 +0000
@@ -37,8 +37,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["drsmst", "slsiv1", "slsiv2"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlrep", "drsmst", "slsiv1",
+            "slsiv2"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -154,8 +154,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = ["%03u %-30s %s" % (self.opts["conum"],
             self.opts["conam"], self.sysdttm)]
         self.expheads.append("Outstanding Sales Orders Report as at %s" % \
@@ -219,8 +218,7 @@
         p.closeProgress()
         if not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'sls/si3020.py' (properties changed: -x to +x)
--- old/sls/si3020.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3020.py	2020-05-27 12:33:20 +0000
@@ -159,8 +159,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Sales Report By Product up to %s" % self.cutper)
         self.expcolsh = self.colsh
@@ -222,8 +221,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'sls/si3030.py' (properties changed: -x to +x)
--- old/sls/si3030.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3030.py	2020-06-21 11:35:11 +0000
@@ -153,14 +153,14 @@
         lstgrp = ""
         self.pgnum = 0
         self.pglin = 999
-        for x in xrange(0, len(recs)):
-            p.displayProgress(x)
+        for num, rec in enumerate(recs):
+            p.displayProgress(num)
             if p.quit:
                 break
-            self.grp = CCD(recs[x][0], "UA", 3)
-            code = CCD(recs[x][1], "NA", 20)
-            desc = CCD(recs[x][2], "NA", 30)
-            uoi = CCD(recs[x][3], "NA", 10)
+            self.grp = CCD(rec[0], "UA", 3)
+            code = CCD(rec[1], "NA", 20)
+            desc = CCD(rec[2], "NA", 30)
+            uoi = CCD(rec[3], "NA", 10)
             bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
                 self.per, keys=(self.grp.work, code.work, self.loc,
                 ("P", self.opts["period"][0])))
@@ -207,8 +207,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'sls/si3040.py' (properties changed: -x to +x)
--- old/sls/si3040.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3040.py	2020-05-27 12:33:35 +0000
@@ -217,8 +217,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Stores Sales History for the 12 Month Period "\
             "to %s" % self.coffd)
@@ -272,8 +271,7 @@
         if "args" in self.opts and "noprint" in self.opts["args"]:
             return
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header=self.tit, repprt=self.df.repprt, fromad=self.fromad,

=== modified file 'sls/si3050.py' (properties changed: -x to +x)
--- old/sls/si3050.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3050.py	2020-05-27 12:33:40 +0000
@@ -269,8 +269,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'sls/si3060.py' (properties changed: -x to +x)
--- old/sls/si3060.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3060.py	2020-06-12 08:50:23 +0000
@@ -180,8 +180,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -197,9 +196,9 @@
             ("Sales By Salesman Report as at",
             self.sysdtd, "Page", self.pgnum))
         self.fpdf.drawText()
-        self.fpdf.drawText("%-24s%-7s%-3s%-11s%-7s%-1s" % \
-            ("(Options: Start Period-", self.df.t_disp[0][0][0], "",
-                "End Period-", self.df.t_disp[0][0][1], ")"))
+        self.fpdf.drawText("%-23s%-7s%-3s%-11s%-7s%-1s" % \
+            ("(Options: Start Period ", self.df.t_disp[0][0][0], "",
+                "End Period ", self.df.t_disp[0][0][1], ")"))
         self.fpdf.drawText()
         rep = self.sql.getRec("ctlrep", cols=["rep_name"],
             where=[("rep_cono", "=", self.opts["conum"]), ("rep_code", "=",

=== modified file 'sls/si3070.py' (properties changed: -x to +x)
--- old/sls/si3070.py	2020-04-21 08:42:36 +0000
+++ new/sls/si3070.py	2020-06-21 11:33:59 +0000
@@ -138,12 +138,12 @@
         self.ctots = [0] * 13
         self.pgnum = 0
         self.pglin = 999
-        for x in xrange(0, len(recs)):
-            p.displayProgress(x)
+        for x1, r1 in enumerate(recs):
+            p.displayProgress(x1)
             if p.quit:
                 break
-            rep = CCD(recs[x][0], "Na", 3)
-            name = CCD(recs[x][1], "NA", 30)
+            rep = CCD(r1[0], "Na", 3)
+            name = CCD(r1[1], "NA", 30)
             bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
                 self.end, (rep.work,))
             this, hist = bals.doStrHist(self.start)
@@ -153,15 +153,15 @@
             salesd = ""
             proftd = ""
             prperd = ""
-            prt = "no"
+            prt = False
             mchart = ["T", name.work]
-            for x in xrange(11,-1,-1):
-                c = float(ASD(0) - ASD(hist[2][x][1]))
+            for x2 in xrange(11,-1,-1):
+                c = float(ASD(0) - ASD(hist[2][x2][1]))
                 c = CCD(round(c, 0), "SL", 11)
-                s = float(ASD(0) - ASD(hist[2][x][2]))
+                s = float(ASD(0) - ASD(hist[2][x2][2]))
                 s = CCD(round(s, 0), "SL", 11)
                 if c.work or s.work:
-                    prt = "yes"
+                    prt = True
                 prf = float(ASD(s.work) - ASD(c.work))
                 prf = CCD(round(prf, 0), "SL", 11)
                 if s.work == 0:
@@ -169,23 +169,23 @@
                 else:
                     pcn = round((prf.work * 100.0 / s.work), 2)
                 pcn = CCD(pcn, "SD", 11.2)
-                self.ctots[x] = self.ctots[x] + c.work
-                self.stots[x] = self.stots[x] + s.work
+                self.ctots[x2] = self.ctots[x2] + c.work
+                self.stots[x2] = self.stots[x2] + s.work
                 costsd = costsd + c.disp
                 salesd = salesd + s.disp
                 proftd = proftd + prf.disp
                 prperd = prperd + pcn.disp
                 mchart.append(s.work)
-            if prt == "no":
+            if not prt:
                 continue
             self.mchart.append(mchart)
             if self.pglin > (self.fpdf.lpp - 5):
                 self.pageHeading()
-            self.fpdf.drawText("%s %s %s %s" % (rep.disp, name.disp,
+            self.fpdf.drawText("%s %s %-6s %s" % (rep.disp, name.disp,
                 "Sales", salesd))
-            self.fpdf.drawText("%-34s %s %s" % ("", "Costs ", costsd))
-            self.fpdf.drawText("%-34s %s %s" % ("", "Profit", proftd))
-            self.fpdf.drawText("%-34s %s %s" % ("", "Prf-% ", prperd))
+            self.fpdf.drawText("%-34s %-6s %s" % ("", "Costs ", costsd))
+            self.fpdf.drawText("%-34s %-6s %s" % ("", "Profit", proftd))
+            self.fpdf.drawText("%-34s %-6s %s" % ("", "Prf-% ", prperd))
             self.fpdf.underLine(txt=self.head)
             self.pglin += 5
         p.closeProgress()
@@ -193,8 +193,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'sls/si3080.py' (properties changed: -x to +x)
=== modified file 'sls/si3090.py' (properties changed: -x to +x)
--- old/sls/si3090.py	2020-03-01 12:48:20 +0000
+++ new/sls/si3090.py	2020-08-11 08:03:21 +0000
@@ -34,7 +34,7 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["slsiv1"],
+        self.sql = Sql(self.opts["mf"].dbm, ["slsiv1", "drsmst"],
             prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -72,20 +72,40 @@
             self.edte = w
 
     def doEnd(self):
+        data = []
         self.df.closeProcess()
         hed = ["Cancelled Sales %s" % self.dtyp]
-        col = ["si1_rtn", "si1_docno", "si1_date", "si1_acno", "drm_name"]
+        tab = ["slsiv1", "drsmst"]
+        col = ["si1_rtn", "si1_docno", "si1_date", "si1_acno",
+            "drm_name", "si1_invno"]
         whr = [
             ("si1_cono", "=", self.opts["conum"]),
             ("si1_date", "between", self.sdte, self.edte),
-            ("si1_invno", "=", "cancel")]
+            ("drm_cono=si1_cono",), ("drm_chain=si1_chain",),
+            ("drm_acno=si1_acno",)]
         if self.type == "B":
             whr.append(("si1_rtn", "in", ("C", "I")))
         else:
             whr.append(("si1_rtn", "=", self.type))
-        RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=["slsiv1",
-            "drsmst"],
-            heads=hed, cols=col, where=whr, order="si1_rtn, si1_docno")
+        odr = "si1_rtn, si1_docno"
+        recs = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
+        last = {"I": None, "C": None}
+        for num, rec in enumerate(recs):
+            if last[rec[0]] is None:
+                last[rec[0]] = [rec[0], rec[1] - 1] + rec[2:]
+            while rec[1] != last[rec[0]][1] + 1:
+                last[rec[0]][1] += 1 
+                data.append(last[rec[0]][:5])
+            if rec[5] == "cancel":
+                data.append(rec[:5])
+            last[rec[0]] = rec[:]
+        cols = []
+        dics = self.sql.slsiv1_dic.copy()
+        dics.update(self.sql.drsmst_dic)
+        for c in col[:5]:
+            cols.append((c, dics[c][2], dics[c][3], dics[c][5]))
+        RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
+            ttype="D", heads=hed, cols=cols)
         self.opts["mf"].closeLoop()
 
     def doExit(self):

=== modified file 'sls/si6010.py' (properties changed: -x to +x)
=== modified file 'sls/si6020.py' (properties changed: -x to +x)
=== modified file 'sls/sic110.py' (properties changed: -x to +x)
--- old/sls/sic110.py	2020-04-21 08:42:36 +0000
+++ new/sls/sic110.py	2020-04-29 16:01:21 +0000
@@ -63,13 +63,15 @@
         r1s = (("Yes","Y"),("No","N"))
         self.fld = (
             (("T",0,0,0),("IRB",r1s),0,"Delivery Notes","",
-                self.acc[1],"N",self.doDelNo,None,None,None),
+                self.acc[1],"N",self.doDelNo,None,None,None,None,
+                "Generate Delivery Notes as well as the Sales Document"),
             (("T",0,1,0),("IRB",r1s),0,"Print Values","",
-                self.acc[2],"N",None,None,None,None),
+                self.acc[2],"N",None,None,None,None,None,
+                "Whether to Print Values on the Delivery Note."),
             (("T",0,2,0),"INA",20,"Invoice Template","",
                 self.acc[3],"N",self.doTplNam,tpl,None,None),
             (("T",0,3,0),"ITX",50,"Email Address","",
-                self.acc[4],"N",None,None,None,None))
+                self.acc[4],"N",None,None,None,("email",)))
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -99,14 +101,17 @@
         if self.new:
             self.sql.insRec("slsctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.slsctl_col
+            data.append(self.acc[col.index("ctv_xflag")])
             self.sql.updRec("slsctl", data=data, where=[("ctv_cono", "=",
                 self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["slsctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.slsctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== removed directory 'std'
=== added file 'str/__init__.py'
=== modified file 'str/st1010.py' (properties changed: -x to +x)
--- old/str/st1010.py	2020-04-21 08:42:36 +0000
+++ new/str/st1010.py	2020-06-04 16:33:27 +0000
@@ -39,10 +39,11 @@
                 self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "drschn", "drsmst",
-            "genmst", "slsiv1", "slsiv2", "strgrp", "strloc", "strmf1",
-            "strmf2", "strgmu", "strcmu", "strprc", "strrcp", "struoi",
-            "strvar", "chglog"], prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlvmf", "ctlrep", "drschn",
+            "drsmst", "genmst", "slsiv1", "slsiv2", "strgrp", "strloc",
+            "strmf1", "strmf2", "strgmu", "strcmu", "strprc", "strrcp",
+            "struoi", "strtrn", "strpot", "strvar", "slsiv3", "chglog"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -52,6 +53,7 @@
         self.glint = strctl["cts_glint"]
         self.locs = strctl["cts_locs"]
         self.plevs = strctl["cts_plevs"]
+        self.automu = strctl["cts_automu"]
         self.drsctl = gc.getCtl("drsctl", self.opts["conum"], error=False)
         if not self.drsctl:
             self.chains = "N"
@@ -151,28 +153,26 @@
                 "N","N",self.doType,None,None,None),
             (("T",1,1,0),"INA",30,"Description","",
                 "","N",None,None,self.doDelete,("notblank",)),
-            (("T",1,2,0),"INA",10,"Units Of Issue","",
+            (("T",1,2,0),"INA",10,"Unit of Issue","",
                 "","N",self.doUoi,unm,None,("notblank",)),
             (("T",1,2,0),"ONA",30,""),
-            (("T",1,3,0),"IUI",7,"Units Per Pack","",
-                "","N",self.doUnits,None,None,("efld",)),
-            (("T",1,4,0),("IRB",r2s),0,"Value Indicator","",
+            (("T",1,3,0),("IRB",r2s),0,"Value Indicator","",
                 "A","N",self.doValInd,None,None,None),
-            (("T",1,5,0),"IUA",1,"VAT Code","",
+            (("T",1,4,0),"IUA",1,"VAT Code","",
                 "","N",self.doVat,vtm,None,("notblank",)),
+            (("T",1,4,0),"ONA",30,""),
+            (("T",1,5,0),"IUI",3,"Exclusive Chainstore","",
+                "","N",self.doChnExcl,drc,None,("efld",)),
             (("T",1,5,0),"ONA",30,""),
-            (("T",1,6,0),"IUI",3,"Exclusive Chainstore","",
-                "","N",self.doChnExcl,drc,None,("efld",)),
+            (("T",1,6,0),"INA",7,"Exclusive Account","",
+                "","N",self.doAccExcl,drm,None,("efld",)),
             (("T",1,6,0),"ONA",30,""),
-            (("T",1,7,0),"INA",7,"Exclusive Account","",
-                "","N",self.doAccExcl,drm,None,("efld",)),
+            (("T",1,7,0),"IUI",7,"Sales Code","",
+                "","N",self.doSales,glm,None,("efld",)),
             (("T",1,7,0),"ONA",30,""),
-            (("T",1,8,0),"IUI",7,"Sales Code","",
-                "","N",self.doSales,glm,None,("efld",)),
+            (("T",1,8,0),"IUI",7,"COS Code","",
+                "","N",self.doCos,glm,None,("efld",)),
             (("T",1,8,0),"ONA",30,""),
-            (("T",1,9,0),"IUI",7,"COS Code","",
-                "","N",self.doCos,glm,None,("efld",)),
-            (("T",1,9,0),"ONA",30,""),
             (("T",2,0,0),"IUA",8,"Bin Number","",
                 "","N",None,None,self.doDelete,("efld",)),
             (("T",2,1,0),("IRB",r3s),0,"Re-Order Indicator","",
@@ -180,12 +180,13 @@
             (("T",2,2,0),"IUI",7,"Re-Order Level","",
                 "","N",None,None,None,("efld",)),
             (("T",2,3,0),"IUI",7,"Re-Order Quantity","",
-                "","N",None,None,None,("efld",)),
-            (("T",2,4,0),"IUD",6.2,"Percentabge Markup Lv1","",
                 "","N",None,None,None,("efld",))]
-        for x in range(1, self.plevs):
-            self.fld.append((("T",2,4,0),"IUD",6.2,"Lv%s" % (x + 1),"",
+        if self.automu in ("A", "L"):
+            self.fld.append((("T",2,4,0),"IUD",6.2,"Percentabge Markup Lv1","",
                 "","N",None,None,None,("efld",)))
+            for x in range(1, self.plevs):
+                self.fld.append((("T",2,4,0),"IUD",6.2,"Lv%s" % (x + 1),"",
+                    "","N",None,None,None,("efld",)))
         self.fld.extend([
             (("C",3,0,0),"INA",3,"Grp","Product Group",
                 "r","N",self.doRecGrp,gpm,None,None),
@@ -225,6 +226,7 @@
 
     def doCode(self, frt, pag, r, c, p, i, w):
         self.code = w
+        self.mups = [0, 0, 0, 0, 0]
         self.old1 = self.sql.getRec("strmf1", where=[("st1_cono", "=",
             self.opts["conum"]), ("st1_group", "=", self.group), ("st1_code",
             "=", w)], limit=1)
@@ -237,7 +239,7 @@
             self.newcode = False
             d = 3
             for x in range(0, self.df.topq[1]):
-                if x in (3, 7, 9, 11, 13, 15):
+                if x in (3, 6, 8, 10, 12, 14):
                     continue
                 if x == 0:
                     self.gtype = self.old1[d]
@@ -246,19 +248,19 @@
                     get = self.getUoi(self.old1[d])
                     if get:
                         self.df.loadEntry("T", 1, x+1, data=get[0])
-                if x == 6:
+                if x == 5:
                     get = self.getVat(self.old1[d])
                     if get:
                         self.df.loadEntry("T", 1, x+1, data=get[0])
-                if x == 8:
+                if x == 7:
                     get = self.getChnExcl(self.old1[d])
                     if get:
                         self.df.loadEntry("T", 1, x+1, data=get[0])
-                if x == 10:
+                if x == 9:
                     get = self.getAccExcl(self.old1[d])
                     if get:
                         self.df.loadEntry("T", 1, x+1, data=get[0])
-                if self.glint == "Y" and x in (12, 14):
+                if self.glint == "Y" and x in (11, 13):
                     get = self.getGenDes(self.old1[d])
                     if get:
                         self.df.loadEntry("T", 1, x+1, data=get[0])
@@ -306,10 +308,12 @@
             for x in range(0, 4):
                 d = d + 1
                 self.df.loadEntry("T", 2, x, data=self.old2[d])
-            for y in range(self.plevs):
-                mup = getMarkup(self.sql, self.opts["conum"], self.group,
-                    self.code, self.loc, y + 1)
-                self.df.loadEntry("T", 2, 4 + y, data=mup)
+            if self.automu in ("A", "L"):
+                for y in range(self.plevs):
+                    mup = getMarkup(self.sql, self.opts["conum"], self.group,
+                        self.code, self.loc, y + 1)
+                    self.df.loadEntry("T", 2, 4 + y, data=mup)
+                    self.mups[y] = mup
 
     def doType(self, frt, pag, r, c, p, i, w):
         self.gtype = w
@@ -324,14 +328,8 @@
             return "Invalid UOI Record"
         self.df.loadEntry(frt, pag, p+1, data=acc[0])
 
-    def doUnits(self, frt, pag, r, c, p, i, w):
-        if self.gtype == "R":
-            self.df.loadEntry(frt, pag, p+1, data="N")
-            self.df.topf[1][6][5] = self.grpacc[0]
-            return "sk1"
-
     def doValInd(self, frt, pag, r, c, p, i, w):
-        self.df.topf[1][6][5] = self.grpacc[0]
+        self.df.topf[1][5][5] = self.grpacc[0]
 
     def doVat(self, frt, pag, r, c, p, i, w):
         acc = self.getVat(w)
@@ -617,7 +615,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["strmf2", "D", "%03i%-3s%-20s%-1s" % \
             (self.opts["conum"], self.group, self.code, self.loc), "", dte,
-        self.opts["capnm"], "", "", 0])
+        self.opts["capnm"], "", "", "", 0])
         st2 = self.sql.getRec("strmf2", cols=["count(*)"],
             where=[("st2_cono", "=", self.opts["conum"]), ("st2_group", "=",
             self.group), ("st2_code", "=", self.code)], limit=1)
@@ -627,8 +625,11 @@
                 ("st1_code", "=", self.code)])
             self.sql.insRec("chglog", data=["strmf1", "D", "%03i%-3s%-20s" % \
                 (self.opts["conum"], self.group, self.code), "", dte,
-                self.opts["capnm"], "", "", 0])
+                self.opts["capnm"], "", "", "", 0])
         # Other Files
+        self.sql.delRec("strcst", where=[("stc_cono", "=", self.opts["conum"]),
+            ("stc_group", "=", self.group), ("stc_code", "=", self.code),
+            ("stc_loc", "=", self.loc)])
         self.sql.delRec("strprc", where=[("stp_cono", "=", self.opts["conum"]),
             ("stp_group", "=", self.group), ("stp_code", "=", self.code),
             ("stp_loc", "=", self.loc)])
@@ -689,12 +690,14 @@
         for x in range(0, 2):
             data.append(self.df.t_work[0][0][x])
         for x in range(0, len(self.df.t_work[1][0])):
-            if x in (3,7,9,11,13,15):
+            if x in (3, 6, 8, 10, 12, 14):
                 continue
             data.append(self.df.t_work[1][0][x])
         if self.newcode:
             self.sql.insRec("strmf1", data=data)
         elif data != self.old1[:len(data)]:
+            col = self.sql.strmf1_col
+            data.append(self.old1[col.index("st1_xflag")])
             self.sql.updRec("strmf1", data=data, where=[("st1_cono", "=",
                 self.opts["conum"]), ("st1_group", "=", self.group),
                 ("st1_code", "=", self.code)])
@@ -703,14 +706,16 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["strmf1", "U",
                         "%03i%-3s%-20s" % (self.opts["conum"], self.group,
-                        self.code), self.sql.strmf1_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.code), col[num], dte, self.opts["capnm"],
+                        str(dat), str(data[num]), "", 0])
         data = [self.opts["conum"], self.group, self.code, self.loc]
         for x in range(0, 4):
             data.append(self.df.t_work[2][0][x])
         if self.newloc == "Y":
             self.sql.insRec("strmf2", data=data)
         elif data != self.old2[:len(data)]:
+            col = self.sql.strmf2_col
+            data.append(self.old2[col.index("st2_xflag")])
             self.sql.updRec("strmf2", data=data, where=[("st2_cono", "=",
                 self.opts["conum"]), ("st2_group", "=", self.group),
                 ("st2_code", "=", self.code), ("st2_loc", "=", self.loc)])
@@ -719,14 +724,16 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["strmf2", "U",
                         "%03i%-3s%-20s%-1s" % (self.opts["conum"], self.group,
-                        self.code, self.loc), self.sql.strmf1_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.code, self.loc), col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.sql.delRec("strcmu", where=[("smc_cono", "=", self.opts["conum"]),
             ("smc_group", "=", self.group), ("smc_code", "=", self.code),
             ("smc_loc", "=", self.loc)])
         for num, mup in enumerate(self.df.t_work[2][0][4:]):
-            self.sql.insRec("strcmu", data=[self.opts["conum"], self.group,
-                self.code, self.loc, num + 1, mup])
+            if mup and mup != self.mups[num]:
+                self.sql.insRec("strcmu", data=[self.opts["conum"],
+                    self.group, self.code, self.loc, num + 1, mup])
         self.opts["mf"].dbm.commitDbase()
         self.df.selPage("Basic-_A")
         self.df.focusField("T", 0, 1)

=== added file 'str/st1020.py'
--- old/str/st1020.py	1970-01-01 00:00:00 +0000
+++ new/str/st1020.py	2020-06-04 08:36:39 +0000
@@ -1,6 +1,6 @@
 """
 SYNOPSIS
-    Stores Ledger - Capturing Selling Prices
+    Stores Ledger - Standard Cost Prices
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -36,7 +36,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["strgrp", "strmf1", "strmf2",
-            "strloc", "strprc"], prog=self.__class__.__name__)
+            "strloc", "strcst"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -44,7 +44,6 @@
         if not strctl:
             return
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
         return True
 
     def drawDialog(self):
@@ -77,22 +76,21 @@
             "whera": (
                 ("C", "st2_group", 0),
                 ("C", "st2_code", 1))}
-        self.fld = [
+        self.fld = (
             (("C",0,0,0),"IUA",3,"Grp","Product Group",
                 "","Y",self.doGrp,grp,None,None),
             (("C",0,0,1),"INA",20,"Code","Product Code",
                 "","N",self.doCode,st1,None,None),
             (("C",0,0,2),"ONA",30,"Description"),
             (("C",0,0,3),"IUA",1,"L","Location",
-                "","N",self.doLoc,loc,None,None)]
-        for x in range(self.levels):
-            lev = x + 1
-            txt = "Level-%s" % lev
-            self.fld.append((("C",0,0,x+4),"IUD",10.2,txt,txt,
-                "","N",self.doLevel,None,None,("notzero",)))
+                "","N",self.doLoc,loc,None,None),
+            (("C",0,0,4),"IUD",10.2,"Cost-Price","Standard Cost Price",
+                "","N",self.doCst,None,None,("notzero",)))
         but = (
             ("Import File",None,self.doImport,0,("C",0,1),("C",0,2),
-                "Import Selling Prices from a CSV or XLS File."),
+                "Import Cost Prices from a CSV or XLS File "\
+                "having the following columns: Group, Code, "\
+                "Location, Cost-Price"),
             ("Exit", None, self.doExit, 1, ("C", 0, 1), ("C", 0, 2)))
         row = (20,)
         self.df = TartanDialog(self.opts["mf"], rows=row,
@@ -104,6 +102,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         impcol = []
         pos = 0
+        err = None
         for num, fld in enumerate(self.fld):
             if num == 2:
                 continue
@@ -114,7 +113,6 @@
             impcol.append([fld[4], pos, fld[1][1:], size])
             pos += 1
         fi = FileImport(self.opts["mf"], impcol=impcol)
-        err = None
         for num, line in enumerate(fi.impdat):
             if len(line) != pos:
                 err = "Line %s: Invalid Number of Fields (S/B %s is %s)" % \
@@ -133,6 +131,9 @@
             if not chk:
                 err = "Line %s: Invalid Code %s" % ((num + 1), self.cod)
                 break
+            if chk[self.sql.strmf1_col.index("st1_value_ind")] != "S":
+                err = "Line %s: Invalid Value-Ind %s" % ((num + 1), self.cod)
+                break
             self.loc = line[2]
             chk = self.sql.getRec("strmf2", where=[("st2_cono", "=",
                 self.opts["conum"]), ("st2_group", "=", self.grp),
@@ -141,12 +142,10 @@
             if not chk:
                 err = "Line %s: Invalid Location %s" % ((num + 1), self.loc)
                 break
-            self.levs = []
-            for x in range(self.levels):
-                self.levs.append(line[x + 3])
-            if len(self.levs) != self.levels:
-                err = "Line %s: Invalid Number of Levels (S/B %s is %s)" % \
-                    ((num + 1), self.levels, len(self.levs))
+            self.cst = line[3]
+            if not self.cst:
+                err = "Line %s: Invalid Cost %s" % ((num + 1), self.cst)
+                break
             self.doEnd(det=True)
         if err:
             showError(self.opts["mf"].body, "Import Error", err)
@@ -164,18 +163,20 @@
         self.grp = w
 
     def doCode(self, frt, pag, r, c, p, i, w):
-        chk = self.sql.getRec("strmf1", cols=["st1_desc"],
+        chk = self.sql.getRec("strmf1", cols=["st1_desc", "st1_value_ind"],
             where=[("st1_cono", "=", self.opts["conum"]), ("st1_group",
             "=", self.grp), ("st1_code", "=", w)], limit=1)
         if not chk:
             return "Invalid Code"
+        if chk[1] != "S":
+            return "Invalid Value-Ind"
         self.cod = w
         self.df.loadEntry(frt, pag, p+1, data=chk[0])
         if self.locs == "N":
             self.loc = "1"
             self.df.loadEntry(frt, pag, p+2, data=self.loc)
-            self.doLoadLevs(p + 3)
-            return "sk2"
+            self.doLoadCost(p+3)
+            return "sk1"
 
     def doLoc(self, frt, pag, r, c, p, i, w):
         chk = self.sql.getRec("strmf2", where=[("st2_cono", "=",
@@ -185,31 +186,32 @@
         if not chk:
             return "Invalid Location"
         self.loc = w
-        self.doLoadLevs(p + 1)
-
-    def doLoadLevs(self, p):
-        self.levs = []
-        for x in range(self.levels):
-            prc = self.sql.getRec("strprc", cols=["stp_price"],
-                where=[("stp_cono", "=", self.opts["conum"]), ("stp_group",
-                "=", self.grp), ("stp_code", "=", self.cod), ("stp_loc",
-                "=", self.loc), ("stp_level", "=", x + 1)], limit=1)
-            if not prc:
-                prc = [0]
-            self.df.loadEntry("C", 0, p, data=prc[0])
-            self.levs.append(prc[0])
-            p += 1
-
-    def doLevel(self, frt, pag, r, c, p, i, w):
-        self.levs[i - 4] = w
+        self.doLoadCost(p+1)
+
+    def doLoadCost(self, pos):
+        chk = self.sql.getRec("strcst", cols=["stc_cost"],
+            where=[("stc_cono", "=", self.opts["conum"]),
+            ("stc_group", "=", self.grp), ("stc_code", "=",
+            self.cod), ("stc_loc", "=", self.loc)], limit=1)
+        if chk:
+            self.df.loadEntry("C", 0, pos, data=chk[0])
+
+    def doDelete(self):
+        self.sql.delRec("strcst", where=[("stc_cono", "=", self.opts["conum"]),
+            ("stc_group", "=", self.grp), ("stc_code", "=", self.cod),
+            ("stc_loc", "=", self.loc)])
+        self.opts["mf"].dbm.commitDbase()
+        self.df.clearLine(0, focus=True)
+
+    def doCst(self, frt, pag, r, c, p, i, w):
+        self.cst = w
 
     def doEnd(self, det=False):
-        self.sql.delRec("strprc", where=[("stp_cono", "=",
-            self.opts["conum"]), ("stp_group", "=", self.grp),
-            ("stp_code", "=", self.cod), ("stp_loc", "=", self.loc)])
-        for num, lev in enumerate(self.levs):
-            self.sql.insRec("strprc", data=[self.opts["conum"], self.grp,
-                self.cod, self.loc, num + 1, lev])
+        self.sql.delRec("strcst", where=[("stc_cono", "=",
+            self.opts["conum"]), ("stc_group", "=", self.grp),
+            ("stc_code", "=", self.cod), ("stc_loc", "=", self.loc)])
+        self.sql.insRec("strcst", data=[self.opts["conum"], self.grp,
+            self.cod, self.loc, self.cst])
         self.opts["mf"].dbm.commitDbase()
         self.df.advanceLine(0)
         self.df.loadEntry("C", 0, self.df.pos, data=self.grp)

=== renamed file 'str/st1020.py' => 'str/st1030.py' (properties changed: -x to +x)
--- old/str/st1020.py	2020-04-21 08:42:36 +0000
+++ new/str/st1030.py	2020-06-04 08:28:21 +0000
@@ -27,7 +27,7 @@
 from TartanClasses import FileImport, GetCtl, Sql, TartanDialog
 from tartanFunctions import showError
 
-class st1020(object):
+class st1030(object):
     def __init__(self, **opts):
         self.opts = opts
         if self.setVariables():
@@ -44,7 +44,7 @@
         if not strctl:
             return
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
+        self.plevs = strctl["cts_plevs"]
         return True
 
     def drawDialog(self):
@@ -85,14 +85,20 @@
             (("C",0,0,2),"ONA",30,"Description"),
             (("C",0,0,3),"IUA",1,"L","Location",
                 "","N",self.doLoc,loc,None,None)]
-        for x in range(self.levels):
+        for x in range(self.plevs):
             lev = x + 1
             txt = "Level-%s" % lev
+            if lev == 1:
+                ddd = self.doDelete
+            else:
+                ddd = None
             self.fld.append((("C",0,0,x+4),"IUD",10.2,txt,txt,
-                "","N",self.doLevel,None,None,("notzero",)))
+                "","N",self.doLevel,None,ddd,("notzero",)))
         but = (
             ("Import File",None,self.doImport,0,("C",0,1),("C",0,2),
-                "Import Selling Prices from a CSV or XLS File."),
+                "Import Selling Prices from a CSV or XLS File "\
+                "having the following columns: Group, Code, "\
+                "Location, Prices by Level"),
             ("Exit", None, self.doExit, 1, ("C", 0, 1), ("C", 0, 2)))
         row = (20,)
         self.df = TartanDialog(self.opts["mf"], rows=row,
@@ -142,11 +148,11 @@
                 err = "Line %s: Invalid Location %s" % ((num + 1), self.loc)
                 break
             self.levs = []
-            for x in range(self.levels):
+            for x in range(self.plevs):
                 self.levs.append(line[x + 3])
-            if len(self.levs) != self.levels:
+            if len(self.levs) != self.plevs:
                 err = "Line %s: Invalid Number of Levels (S/B %s is %s)" % \
-                    ((num + 1), self.levels, len(self.levs))
+                    ((num + 1), self.plevs, len(self.levs))
             self.doEnd(det=True)
         if err:
             showError(self.opts["mf"].body, "Import Error", err)
@@ -187,9 +193,16 @@
         self.loc = w
         self.doLoadLevs(p + 1)
 
+    def doDelete(self):
+        self.sql.delRec("strprc", where=[("stp_cono", "=", self.opts["conum"]),
+            ("stp_group", "=", self.grp), ("stp_code", "=", self.cod),
+            ("stp_loc", "=", self.loc)])
+        self.opts["mf"].dbm.commitDbase()
+        self.df.clearLine(0, focus=True)
+
     def doLoadLevs(self, p):
         self.levs = []
-        for x in range(self.levels):
+        for x in range(self.plevs):
             prc = self.sql.getRec("strprc", cols=["stp_price"],
                 where=[("stp_cono", "=", self.opts["conum"]), ("stp_group",
                 "=", self.grp), ("stp_code", "=", self.cod), ("stp_loc",

=== modified file 'str/st2010.py' (properties changed: -x to +x)
--- old/str/st2010.py	2020-04-21 08:42:36 +0000
+++ new/str/st2010.py	2020-07-07 11:36:14 +0000
@@ -25,9 +25,9 @@
 """
 
 import time
-from TartanClasses import ASD, Balances, CCD, GetCtl, PrintOrder, PwdConfirm
-from TartanClasses import Sql, TartanDialog
-from tartanFunctions import askQuestion, callModule, getMarkup, getVatRate
+from TartanClasses import ASD, CCD, GetCtl, PrintOrder, PwdConfirm, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import askQuestion, callModule, getCost, getVatRate
 from tartanFunctions import showError
 
 class st2010(object):
@@ -35,16 +35,16 @@
         self.opts = opts
         if self.setVariables():
             self.exit = False
-            self.getPrinters()
+            self.selectPrinter()
             if not self.exit:
                 self.mainProcess()
                 self.opts["mf"].startLoop()
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "ctlmes", "ctlvrf",
-            "crsmst", "gentrn", "strgrp", "strloc", "strmf1", "strmf2",
-            "strpom", "strpot", "strtrn", "strgmu", "strcmu", "strprc",
-            "tplmst"], prog=self.__class__.__name__)
+            "ctlrep", "crsmst", "gentrn", "strgrp", "strloc", "strmf1",
+            "strmf2", "strpom", "strpot", "strtrn", "strgmu", "strcmu",
+            "strprc", "tplmst"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -63,8 +63,7 @@
             return
         self.stgl = strctl["cts_glint"]
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
-        self.automu = strctl["cts_automu"]
+        self.plevs = strctl["cts_plevs"]
         self.dtpl = strctl["cts_tplnam"]
         if self.stgl == "Y":
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
@@ -79,7 +78,7 @@
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         return True
 
-    def getPrinters(self):
+    def selectPrinter(self):
         tit = ("Printer Selection",)
         tpm = {
             "stype": "R",
@@ -91,14 +90,11 @@
                 ("tpm_type", "=", "O"),
                 ("tpm_system", "=", "STR")],
             "order": "tpm_tname"}
-        r1s = (("Yes","Y"),("No","N"))
         fld = (
             (("T",0,0,0),"INA",20,"Template Name","",
                 self.dtpl,"N",self.doTplNam,tpm,None,None),
             (("T",0,1,0),"ID1",10,"Order Date","",
-                self.sysdtw,"N",self.doOrdDate,None,None,("efld",)),
-            (("T",0,2,0),("IRB",r1s),0,"Auto Markup","Automatic Markup",
-                self.automu,"N",self.doAutoMkUp,None,None,None))
+                self.sysdtw,"N",self.doOrdDate,None,None,("efld",)))
         self.pr = TartanDialog(self.opts["mf"], tops=True, title=tit,
             eflds=fld, tend=((self.doPrtEnd,"y"),), txit=(self.doPrtExit,),
             view=("N","P"), mail=("N","Y","Y"))
@@ -119,8 +115,8 @@
         self.curdt = int(self.trdt / 100)
         self.batch = "S%s" % self.curdt
 
-    def doAutoMkUp(self, frt, pag, r, c, p, i, w):
-        self.mkup = w
+    #def doAutoMkUp(self, frt, pag, r, c, p, i, w):
+    #    self.mkup = w
 
     def doPrtEnd(self):
         self.doPrtClose()
@@ -220,14 +216,13 @@
                 "","N",self.doDes,None,None,None),
             (("C",0,0,3),"ISD",11.2,"Quantity","",
                 1,"N",self.doQty,None,None,("notzero",)),
-            (("C",0,0,4),"OSD",10.2,"Units"),
-            (("C",0,0,5),"IUA",1,"V","V.A.T. Code",
+            (("C",0,0,4),"IUA",1,"V","V.A.T. Code",
                 "I","N",self.doVat,None,None,("notblank",)),
-            (("C",0,0,6),"IUD",10.2,"Price","Exclusive Price",
+            (("C",0,0,5),"IUD",10.2,"Price","Exclusive Price",
                 "","N",self.doPri,None,None,None),
-            (("C",0,0,7),"IUD",6.2,"Dis-%","Trade Discount",
+            (("C",0,0,6),"IUD",6.2,"Dis-%","Trade Discount",
                 "","N",self.doDis,None,None,None),
-            (("C",0,0,8),"OSD",10.2,"Value"))
+            (("C",0,0,7),"OSD",10.2,"Value"))
         self.row = (15,)
         self.but = (
             ("Cancel",None,self.doCancel,1,("C",0,1),("T",0,1)),
@@ -497,7 +492,6 @@
         self.code = w
         desc = strmf1[self.sql.strmf1_col.index("st1_desc")]
         self.uoi = strmf1[self.sql.strmf1_col.index("st1_uoi")]
-        self.unt = strmf1[self.sql.strmf1_col.index("st1_units")]
         self.df.loadEntry(frt, pag, p+1, data=desc)
 
     def doDes(self, frt, pag, r, c, p, i, w):
@@ -505,11 +499,6 @@
 
     def doQty(self, frt, pag, r, c, p, i, w):
         self.qty = w
-        if self.unt:
-            units = self.qty * self.unt
-        else:
-            units = self.qty
-        self.df.loadEntry(frt, pag, p+1, data=units)
 
     def doVat(self, frt, pag, r, c, p, i, w):
         self.vatrte = getVatRate(self.sql, self.opts["conum"], w, self.trdt)
@@ -517,14 +506,9 @@
             return "Invalid V.A.T Code"
         self.vatcod = w
         # Last Cost Price
-        bal = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
-            (self.grp, self.code, self.loc, ("P", self.opts["period"][0])))
-        bals = bal.doStrBals()
-        if self.unt:
-            pri = bals[7] * self.unt
-        else:
-            pri = bals[7]
-        self.df.loadEntry(frt, pag, p+1, data=pri)
+        lcost = getCost(self.sql, self.opts["conum"], self.grp, self.code,
+            loc=self.loc, qty=1, ind="L")
+        self.df.loadEntry(frt, pag, p+1, data=lcost)
 
     def doPri(self, frt, pag, r, c, p, i, w):
         self.price = w
@@ -548,9 +532,8 @@
     def doColEnd(self):
         # Create Purchase Order Transaction (Body)
         data = [self.opts["conum"], self.ordno, self.grp, self.code,
-            self.uoi, self.unt, self.desc, self.qty, self.price,
-            self.disrat, self.vatcod, self.vatrte, self.opts["capnm"],
-            self.sysdtw, 0]
+            self.uoi, self.desc, self.qty, self.price, self.disrat,
+            self.vatcod, self.vatrte, self.opts["capnm"], self.sysdtw, 0]
         self.sql.insRec("strpot", data=data)
         if self.acttyp == "A":
             self.amend = True
@@ -917,30 +900,11 @@
                 data=[self.delno, self.deldt], where=[("pom_cono", "=",
                 self.opts["conum"]), ("pom_ordno", "=", self.ordno)])
             # Write strtrn record
-            unt = line[self.sql.strpot_col.index("pot_units")]
-            if unt:
-                qty = self.qty * unt
-            else:
-                qty = self.qty
             data = [self.opts["conum"], self.grp, self.code, self.loc,
-                self.deldt, 1, self.othno, self.batch, self.delno, qty,
+                self.deldt, 1, self.othno, self.batch, self.delno, self.qty,
                 self.excamt, 0, curdt, self.name, 0, self.acno, "", "STR",
                 self.disrat, "", self.opts["capnm"], self.sysdtw, 0]
             self.sql.insRec("strtrn", data=data)
-            if self.mkup == "Y":
-                # Create or Update Price Records
-                for x in range(self.levels):
-                    lev = x + 1
-                    mkp = getMarkup(self.sql, self.opts["conum"], self.grp,
-                        self.code, self.loc, lev)
-                    if mkp:
-                        sell = round((self.ucost * (100 + mkp) / 100.0), 2)
-                        self.sql.delRec("strprc", where=[("stp_cono", "=",
-                            self.opts["conum"]), ("stp_group", "=", self.grp),
-                            ("stp_code", "=", self.code), ("stp_loc", "=",
-                            self.loc), ("stp_level", "=", lev)])
-                        self.sql.insRec("strprc", data=[self.opts["conum"],
-                            self.grp, self.code, self.loc, lev, sell])
             # If Integrated Create GL Transaction (SOH and Recon Accounts)
             if self.stgl == "Y" and self.excamt:
                 # Stock on Hand Control
@@ -959,7 +923,6 @@
         self.grp = line[self.sql.strpot_col.index("pot_group")]
         self.code = line[self.sql.strpot_col.index("pot_code")]
         self.uoi = line[self.sql.strpot_col.index("pot_uoi")]
-        self.unt = line[self.sql.strpot_col.index("pot_units")]
         self.desc = line[self.sql.strpot_col.index("pot_desc")]
         self.qty = line[self.sql.strpot_col.index("pot_qty")]
         self.price = line[self.sql.strpot_col.index("pot_price")]
@@ -974,11 +937,6 @@
         self.excamt = round((self.qty * exc * dis / 100.0), 2)
         self.incamt = round((self.qty * inc * dis / 100.0), 2)
         self.vatamt = float(ASD(self.incamt) - ASD(self.excamt))
-        if self.mkup == "Y":
-            udis = round((self.price * self.disrat / 100.0), 2)
-            self.ucost = float(ASD(self.price) - ASD(udis))
-            if self.unt:
-                self.ucost = round(self.ucost / self.unt, 2)
 
     def doCancel(self):
         self.opts["mf"].dbm.rollbackDbase()

=== modified file 'str/st2020.py' (properties changed: -x to +x)
--- old/str/st2020.py	2020-04-21 08:42:36 +0000
+++ new/str/st2020.py	2020-06-06 08:57:34 +0000
@@ -25,9 +25,9 @@
 """
 
 import time
-from TartanClasses import ASD, Balances, FileImport, GetCtl, RepPrt, Sql
-from TartanClasses import TartanDialog
-from tartanFunctions import askQuestion, callModule, getMarkup, showError
+from TartanClasses import ASD, FileImport, GetCtl, RepPrt, Sql, TartanDialog
+from tartanFunctions import askQuestion, callModule, getCost, getSell
+from tartanFunctions import showError
 
 class st2020(object):
     def __init__(self, **opts):
@@ -58,7 +58,7 @@
             return
         self.glint = strctl["cts_glint"]
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
+        self.plevs = strctl["cts_plevs"]
         self.automu = strctl["cts_automu"]
         self.fromad = strctl["cts_emadd"]
         if self.glint == "Y":
@@ -135,8 +135,6 @@
                 self.sysdtw,"N",self.doDte,None,None,("efld",)),
             (("T",0,0,0),"INa",7,"Order Number","",
                 "","N",self.doOrd,None,None,("efld",)),
-            (("T",0,0,0),"IUA",1,"Auto Markup","Automatic Markup",
-                self.automu,"N",self.doMkUp,None,None,("in",("Y","N"))),
             (("C",0,0,0),"IUA",3,"Grp","Product Group",
                 "r","Y",self.doGroup,gpm,None,("notblank",)),
             (("C",0,0,1),"INA",(15,20),"Product Code","",
@@ -145,15 +143,16 @@
             (("C",0,0,3),"ONA",5,"U.O.I"),
             [("C",0,0,4),"IUA",1,"L","Location",
                 "r","N",self.doLoc,stl,None,("notblank",)],
-            (("C",0,0,5),"ISD",9.2,"Units","",
+            (("C",0,0,5),"ISD",9.2,"Quantity","",
                 "","N",self.doQty,None,None,("notzero",)),
             (("C",0,0,6),"IUD",9.2,"Unit-Cost","Unit Cost Price",
                 "","N",self.doUcost,None,None,("notzero",)),
             (("C",0,0,7),"IUD",5.2,"Dis-%","Discount Percentage",
                 "","N",self.doDisPer,None,None,("efld",)),
-            (("C",0,0,8),"OSD",9.2,"Value"),
-            (("C",0,0,9),"IUD",9.2,"Unit-Sell","Unit Selling Price",
-                "","N",self.doUsell,None,None,("efld",))]
+            (("C",0,0,8),"OSD",9.2,"Value")]
+        if self.automu == "N":
+            fld.append((("C",0,0,9),"IUD",9.2,"Unit-Sell","Unit Selling Price",
+                "","N",self.doUsell,None,None,("efld",)))
         tnd = ((self.endPage0,"n"),)
         txt = (self.exitPage0,)
         cnd = ((self.endPage1,"y"),)
@@ -182,9 +181,6 @@
     def doOrd(self, frt, pag, r, c, p, i, w):
         self.odr = w
 
-    def doMkUp(self, frt, pag, r, c, p, i, w):
-        self.mkup = w
-
     def doImport(self):
         state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
@@ -277,21 +273,19 @@
 
     def doCode(self, frt, pag, r, c, p, i, w):
         self.code = w
-        acc = self.sql.getRec("strmf1", cols=["st1_type", "st1_desc",
-            "st1_uoi", "st1_units", "st1_value_ind"], where=[("st1_cono", "=",
-            self.opts["conum"]), ("st1_group", "=", self.group), ("st1_code",
-            "=", w)], limit=1)
+        acc = self.sql.getRec("strmf1", cols=["st1_type", "st1_desc", "st1_uoi",
+            "st1_value_ind"], where=[("st1_cono", "=", self.opts["conum"]),
+            ("st1_group", "=", self.group), ("st1_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Code"
         if acc[0] == "R":
             return "Invalid Code (Recipe Item)"
         if acc[0] == "X":
             return "Invalid Code (Redundant"
-        if acc[4] == "N":
+        if acc[3] == "N":
             return "Invalid Code (Value Indicator)"
         self.desc = acc[1]
         self.uoi = acc[2]
-        self.unt = acc[3]
         self.df.loadEntry("C", pag, p+1, data=self.desc)
         self.df.loadEntry("C", pag, p+2, data=self.uoi)
         if self.locs == "N":
@@ -318,14 +312,9 @@
     def doQty(self, frt, pag, r, c, p, i, w):
         self.qty = w
         # Last Cost Price
-        bal = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
-            (self.group, self.code, self.loc, ("P", self.opts["period"][0])))
-        bals = bal.doStrBals()
-        if self.unt:
-            pri = bals[7] * self.unt
-        else:
-            pri = bals[7]
-        self.df.loadEntry(frt, pag, p+1, data=pri)
+        lcost = getCost(self.sql, self.opts["conum"], self.group, self.code,
+            loc=self.loc, qty=1, ind="L")
+        self.df.loadEntry(frt, pag, p+1, data=lcost)
 
     def doUcost(self, frt, pag, r, c, p, i, w):
         self.ucost = w
@@ -338,22 +327,13 @@
         self.ucost = float(ASD(self.ucost) - ASD(udis))
         self.tcost = float(ASD(self.tcost) - ASD(tdis))
         self.df.loadEntry(frt, pag, p+1, data=self.tcost)
-        mkper = getMarkup(self.sql, self.opts["conum"], self.group, self.code,
-            self.loc, 1)
-        prc = self.sql.getRec("strprc", where=[("stp_cono", "=",
-            self.opts["conum"]), ("stp_group", "=", self.group), ("stp_code",
-            "=", self.code), ("stp_loc", "=", self.loc), ("stp_level", "=",
-            1)], limit=1)
-        if self.mkup == "Y" and mkper:
-            self.usell = round((self.ucost * (100 + mkper) / 100.0), 2)
-        elif prc:
-            self.usell = prc[self.sql.strprc_col.index("stp_price")]
-        else:
-            self.usell = 0.00
-        self.df.loadEntry(frt, pag, p+2, data=self.usell)
+        if self.automu == "N":
+            self.usell = getSell(self.sql, self.opts["conum"],
+                self.group, self.code, self.loc, 1, ind="P")
+            self.df.loadEntry(frt, pag, p+2, data=self.usell)
 
     def doUsell(self, frt, pag, r, c, p, i, w):
-        self.usell = w
+        self.nsell = w
 
     def endPage0(self):
         self.df.focusField("C", 0, 1)
@@ -390,24 +370,14 @@
             self.tcost, 0, self.curdt, self.desc, 0, "", "", "STR",
             self.trdis, "N", self.opts["capnm"], self.sysdtw, 0]
         self.sql.insRec("strtrn", data=data)
-        for x in range(self.levels):
-            lev = x + 1
-            if lev == 1:
-                prc = self.usell
-            elif self.mkup == "Y":
-                mk = getMarkup(self.sql, self.opts["conum"], self.group,
-                    self.code, self.loc, lev)
-                if mk:
-                    prc = round((self.ucost * (100 + mk) / 100.0), 2)
-            else:
-                prc = 0
-            if prc:
-                self.sql.delRec("strprc", where=[("stp_cono", "=",
-                    self.opts["conum"]), ("stp_group", "=", self.group),
-                    ("stp_code", "=", self.code), ("stp_loc", "=", self.loc),
-                    ("stp_level", "=", lev)])
-                self.sql.insRec("strprc", data=[self.opts["conum"], self.group,
-                    self.code, self.loc, lev, prc])
+        if self.automu == "N" and self.nsell != self.usell:
+            # Price Record
+            self.sql.delRec("strprc", where=[("stp_cono", "=",
+                self.opts["conum"]), ("stp_group", "=", self.group),
+                ("stp_code", "=", self.code), ("stp_loc", "=", self.loc),
+                ("stp_level", "=", 1)])
+            self.sql.insRec("strprc", data=[self.opts["conum"],
+                self.group, self.code, self.loc, 1, self.nsell])
         if self.glint == "N":
             return
         # General Ledger Control Transaction (Stock On Hand)

=== modified file 'str/st2030.py' (properties changed: -x to +x)
--- old/str/st2030.py	2020-04-21 08:42:36 +0000
+++ new/str/st2030.py	2020-06-06 08:57:56 +0000
@@ -25,9 +25,8 @@
 """
 
 import time
-from TartanClasses import ASD, Balances, GetCtl, PwdConfirm, RepPrt, Sql
-from TartanClasses import TartanDialog
-from tartanFunctions import chkGenAcc, showError
+from TartanClasses import ASD, GetCtl, PwdConfirm, RepPrt, Sql, TartanDialog
+from tartanFunctions import chkGenAcc, getCost, showError
 
 class st2030(object):
     def __init__(self, **opts):
@@ -345,15 +344,15 @@
         if self.gtype == "R":
             for item in self.recipe:
                 quant = item[6] * self.quant
-                vals = self.doCalCost(item[4], item[5], quant)
-                if not vals:
+                tcost = self.doCalCost(item[4], item[5], quant)
+                if tcost is None:
                     return "error"
-                self.tcost = float(ASD(self.tcost) + ASD(vals[2]))
+                self.tcost = float(ASD(self.tcost) + ASD(tcost))
         else:
-            vals = self.doCalCost(self.group, self.code, self.quant)
-            if not vals:
+            tcost = self.doCalCost(self.group, self.code, self.quant)
+            if tcost is None:
                 return "error"
-            self.tcost = vals[2]
+            self.tcost = tcost
         self.ucost = round(self.tcost / self.quant, 2)
 
     def updateTables(self):
@@ -368,9 +367,9 @@
                 else:
                     des = "Unknown Description"
                 qty = item[6] * self.quant
-                vals = self.doCalCost(item[4], item[5], qty, chk=False)
+                tcost = self.doCalCost(item[4], item[5], qty, chk=False)
                 qty = float(ASD(0) - ASD(qty))
-                val = float(ASD(0) - ASD(vals[2]))
+                val = float(ASD(0) - ASD(tcost))
                 data = [self.opts["conum"], item[4], item[5], self.loc,
                     self.dte, 6, self.iss, self.batno, self.glnum, qty, val,
                     0, self.curdt, des, 0, "", "", "STR", 0, "",
@@ -424,31 +423,18 @@
 
     def doCalCost(self, grp, code, qty, chk=True):
         # Calculate cost price
-        acc = self.sql.getRec("strmf1", cols=["st1_desc",
-            "st1_value_ind"], where=[("st1_cono", "=", self.opts["conum"]),
-            ("st1_group", "=", grp), ("st1_code", "=", code)], limit=1)
-        bal = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
-            (grp, code, self.loc, ("P", self.opts["period"][0])))
-        bals = bal.doStrBals()
-        if chk and qty > bals[5][0]:
+        icost, tcost, bal = getCost(self.sql, self.opts["conum"], grp, code,
+            loc=self.loc, qty=qty, tot=True, bal=True)
+        if chk and qty > bal[0]:
+            acc = self.sql.getRec("strmf1", cols=["st1_desc"],
+                where=[("st1_cono", "=", self.opts["conum"]),
+                ("st1_group", "=", grp), ("st1_code", "=", code)],
+                limit=1)
             cf = PwdConfirm(self.opts["mf"], conum=self.opts["conum"],
                 system="STR", code="ExQty", product=(grp, code, acc[0]))
             if cf.flag == "no":
                 return
-        if acc[1] == "N":
-            icost = 0.00
-            tcost = 0.00
-        else:
-            if qty == bals[5][0]:
-                tcost = bals[5][1]
-                icost = round((tcost / qty), 2)
-            else:
-                icost = bals[6]
-                tcost = round((icost * qty), 2)
-            if icost == 0:
-                icost = bals[7]
-                tcost = round((icost * qty), 2)
-        return (acc[1], icost, tcost, bals[5][0])
+        return tcost
 
     def doReprint(self):
         tit = ("Reprint Documents",)
@@ -538,8 +524,7 @@
         self.df.setWidget(self.df.mstFrame, state="hide")
         RepPrt(self.opts["mf"], conum=self.opts["conum"],
             conam=self.opts["conam"], name=self.__class__.__name__, tables=tab,
-                heads=hds,
-            cols=col, gtots=gtt, where=whr, order=odr, repprt=repprt)
+            heads=hds, cols=col, gtots=gtt, where=whr, order=odr, repprt=repprt)
         self.df.setWidget(self.df.mstFrame, state="show")
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'str/st2040.py' (properties changed: -x to +x)
=== modified file 'str/st3010.py' (properties changed: -x to +x)
--- old/str/st3010.py	2020-04-21 08:42:36 +0000
+++ new/str/st3010.py	2020-05-27 12:34:23 +0000
@@ -170,8 +170,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3020.py' (properties changed: -x to +x)
--- old/str/st3020.py	2020-04-20 12:42:42 +0000
+++ new/str/st3020.py	2020-06-21 09:52:06 +0000
@@ -300,8 +300,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -443,13 +442,13 @@
             return
         self.totind = "Y"
         self.pageHeading()
-        for x in xrange(0, len(sttrtp)):
+        for x, t in enumerate(sttrtp):
             cnt = CCD(self.gcnt[x], "SI", 7)
             qty = CCD(self.gqty[x], "SD", 13.2)
             cst = CCD(self.gcst[x], "SD", 13.2)
             sel = CCD(self.gsel[x], "SD", 13.2)
             self.fpdf.drawText("%-30s %s %s %s %s" % \
-                (sttrtp[x][1], cnt.disp, qty.disp, cst.disp, sel.disp))
+                (t[1], cnt.disp, qty.disp, cst.disp, sel.disp))
             tot[0] = tot[0] + cnt.work
             tot[1] = float(ASD(tot[1]) + ASD(qty.work))
             tot[2] = float(ASD(tot[2]) + ASD(cst.work))

=== modified file 'str/st3030.py' (properties changed: -x to +x)
--- old/str/st3030.py	2020-04-21 08:42:36 +0000
+++ new/str/st3030.py	2020-06-12 07:32:00 +0000
@@ -25,10 +25,9 @@
 """
 
 import time
-from TartanClasses import Balances, CCD, GetCtl, MyFpdf, ProgressBar, Sql
-from TartanClasses import TartanDialog
-from tartanFunctions import doWriteExport, getMarkup, getModName, getVatRate
-from tartanFunctions import doPrinter, showError
+from TartanClasses import CCD, GetCtl, MyFpdf, ProgressBar, Sql, TartanDialog
+from tartanFunctions import doWriteExport, getCost, getSell, getModName
+from tartanFunctions import getVatRate, doPrinter, showError
 
 class st3030(object):
     def __init__(self, **opts):
@@ -39,7 +38,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlvrf", "strloc", "strgrp",
-            "strgmu", "strcmu", "strprc", "strmf1", "strmf2"],
+            "strgmu", "strcmu", "strprc", "strmf1", "strmf2", "strtrn"],
                 prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -48,7 +47,7 @@
         if not strctl:
             return
         self.locs = strctl["cts_locs"]
-        self.prcs = strctl["cts_plevs"]
+        self.plevs = strctl["cts_plevs"]
         self.fromad = strctl["cts_emadd"]
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
@@ -58,8 +57,7 @@
         self.stot = [0] * 6
         self.gtot = [0] * 6
         self.pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         return True
 
     def mainProcess(self):
@@ -81,7 +79,6 @@
             "where": [("gpm_cono", "=", self.opts["conum"])]}
         r1s = (("Yes","Y"),("No","N"))
         r2s = (("Selling Price","S"),("Cost Price","C"))
-        r3s = (("Levels","L"),("Mark Up","M"))
         if self.locs == "N":
             self.loc = "1"
             fld = []
@@ -92,21 +89,17 @@
             (("T",0,1,0),"IUA",3,"Product Group","",
                 "","Y",self.doGroup,grp,None,None),
             (("T",0,2,0),("IRB",r1s),0,"Ignore Out of Stock","",
-                "Y","Y",self.doNoStock,None,None,None),
+                "Y","N",self.doNoStock,None,None,None),
             (("T",0,3,0),("IRB",r2s),0,"Report Type","",
-                "S","Y",self.doType,None,None,None),
-            (("T",0,4,0),("IRB",r3s),0,"Price Type","",
-                "L","Y",self.doPriceType,None,None,None),
-            (("T",0,5,0),"IUI",1,"Price Level","",
-                0,"Y",self.doLvl,None,None,("between",0,self.prcs)),
-            (("T",0,6,0),("IRB",r1s),0,"Ignore Un-priced","",
-                "Y","Y",self.doNoPrice,None,None,None),
-            (("T",0,7,0),("IRB",r1s),0,"Use Last S/P","Use Last S/P if "\
-                "Un-priced","Y","Y",self.doLastSP,None,None,None),
-            (("T",0,8,0),("IRB",r1s),0,"V.A.T Inclusive","",
-                "Y","Y",self.doVat,None,None,None),
-            (("T",0,9,0),("IRB",r1s),0,"Show Cost Price","",
-                "N","Y",self.doCost,None,None,None)])
+                "S","N",self.doType,None,None,None),
+            (("T",0,4,0),"IUI",1,"Price Level","",
+                0,"N",self.doLvl,None,None,("between",0,self.plevs)),
+            (("T",0,5,0),("IRB",r1s),0,"Ignore Un-priced","",
+                "Y","N",self.doNoPrice,None,None,None),
+            (("T",0,6,0),("IRB",r1s),0,"V.A.T Inclusive","",
+                "Y","N",self.doVat,None,None,None),
+            (("T",0,7,0),("IRB",r1s),0,"Show Cost Price","",
+                "N","N",self.doCost,None,None,None)])
         tnd = ((self.doEnd,"Y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
@@ -135,21 +128,22 @@
     def doType(self, frt, pag, r, c, p, i, w):
         self.rtype = w
         if self.rtype == "C":
-            return "sk6"
-
-    def doPriceType(self, frt, pag, r, c, p, i, w):
-        self.ptype = w
-        if self.ptype == "M":
+            return "sk4"
+        if self.plevs == 1:
+            self.levs = [1]
+            self.df.loadEntry(frt, pag, p+1, data=1)
             return "sk1"
 
     def doLvl(self, frt, pag, r, c, p, i, w):
-        self.opts["level"] = w
+        if not w:
+            self.levs = []
+            for x in range(1, self.plevs + 1):
+                self.levs.append(x)
+        else:
+            self.levs = [w]
 
     def doNoPrice(self, frt, pag, r, c, p, i, w):
         self.noprice = w
-        if self.noprice == "Y":
-            self.lasts = "N"
-            return "sk1"
 
     def doLastSP(self, frt, pag, r, c, p, i, w):
         self.lasts = w
@@ -165,7 +159,7 @@
         whr = [("st2_cono", "=", self.opts["conum"])]
         if self.group:
             whr.append(("st2_group", "=", self.group))
-        whr.append(("st1_type", "<>", "X"))
+        whr.append(("st1_type", "=", "N"))
         whr.append(("st2_loc", "=", self.loc))
         whr.extend([("st1_cono=st2_cono",), ("st1_group=st2_group",),
             ("st1_code=st2_code",)])
@@ -187,32 +181,31 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         expheads = ["%03u %-30s %s" % (self.opts["conum"], self.opts["conam"],
             self.sysdttm)]
         if self.rtype == "S":
             expheads.append("Selling Price List as at %s" % self.sysdtd)
             mess = "Options:- Ignore Out of Stock: %s  VAT Inclusive: %s  "\
-                "Ignore Un-priced: %s" % (self.nostock,self.vatinc,self.noprice)
-            if self.noprice == "N":
-                mess = "%s  Use Last S/P for Un-priced: %s" % (mess, self.lasts)
+                "Ignore Un-priced: %s" % (self.nostock, self.vatinc,
+                self.noprice)
             expheads.append(mess)
             expcolsh = [["Grp", "Product-Code", "Description", "U.O.I",
-                "V", "Qty-Balance", "Price-1", "Price-2", "Price-3", "Price-4",
-                "Price-5"]]
+                "V", "Quantity"]]
             expforms = [("UA", 3), ("NA", 20), ("NA", 30), ("NA", 10),
-                ("UA", 1), ("SD", 10.2), ("UD", 9.2), ("UD", 9.2),
-                ("UD", 9.2), ("UD", 9.2), ("UD", 9.2)]
+                ("UA", 1), ("SD", 10.2)]
+            for lev in self.levs:
+                expcolsh[0].append("Level-%s" % lev)
+                expforms.append(("UD", 9.2))
             if self.costs == "Y":
-                expcolsh[0].extend(["Avg-Cost", "Lst-Cost"])
+                expcolsh[0].extend(["Avg-Cost", "Last-Cost"])
                 expforms.extend([("SD", 10.2), ("SD", 10.2)])
         else:
             expheads.append("Cost Price List as at %s" % self.sysdtd)
             mess = "Options:- Ignore Out of Stock: %s" % self.nostock
             expheads.append(mess)
             expcolsh = [["Grp", "Product-Code", "Description", "U.O.I",
-                    "Qty-Balance", "Avg-Cost", "Lst-Cost"]]
+                    "Quantity", "Avg-Cost", "Last-Cost"]]
             expforms = [("UA", 3), ("NA", 20), ("NA", 30), ("NA", 10),
                 ("SD", 10.2), ("SD", 10.2), ("SD", 10.2)]
         expdatas = []
@@ -225,31 +218,30 @@
             if not vals:
                 continue
             if self.rtype == "S":
-                vvv = [vals[0].work, vals[1].work, vals[2].work, vals[3].work,
-                    vals[4].work, vals[5].work, vals[8][0].work,
-                    vals[8][1].work, vals[8][2].work, vals[8][3].work,
-                    vals[8][4].work]
+                grp, code, desc, uoi, vat, qty, acst, lcst, prcs = vals
+                vvv = [grp.work, code.work, desc.work, uoi.work, vat.work,
+                    qty.work]
+                for lev in prcs:
+                    vvv.append(lev.work)
                 if self.costs == "Y":
-                    vvv.extend([vals[6].work, vals[7].work])
+                    vvv.extend([acst.work, lcst.work])
                 expdatas.append(["BODY", vvv])
             else:
-                expdatas.append(["BODY", [vals[0].work, vals[1].work,
-                    vals[2].work, vals[3].work, vals[4].work, vals[5].work,
-                    vals[6].work]])
+                grp, code, desc, uoi, qty, acst, lcst = vals
+                expdatas.append(["BODY", [grp.work, code.work, desc.work,
+                    uoi.work, qty.work, acst.work, lcst.work]])
         p.closeProgress()
         doWriteExport(xtype=self.df.repprt[1], name=expnam,
             heads=expheads, colsh=expcolsh, forms=expforms, datas=expdatas,
             rcdic=self.opts["mf"].rcdic)
 
     def printSell(self, recs):
-        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        hdr = 77 + (len(self.levs) * 10)
         if self.costs == "Y":
-            spc = " " * 72
-        else:
-            spc = " " * 51
-        self.head = ("%03u %-30s %s %40s" % (self.opts["conum"],
-            self.opts["conam"], spc, self.sysdttm))
-        self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
+            hdr += 22
+        self.head = ("%03u %-30s" % (self.opts["conum"], self.opts["conam"]))
+        self.fpdf = MyFpdf(name=self.__class__.__name__, head=hdr, foot=True)
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         old_grp = ""
         self.pgnum = 0
         self.pglin = 999
@@ -260,26 +252,19 @@
             vals = self.getValues(dat)
             if not vals:
                 continue
-            grp, code, desc, uoi, vat, qty, acst, lcst, pr = vals
-            for nm, sp in enumerate(pr):
-                if not nm:
-                    continue
-                if not sp.work and sp.disp != "*        ":
-                    pr[nm].disp = "         "
+            grp, code, desc, uoi, vat, qty, acst, lcst, prcs = vals
             if old_grp and old_grp != grp.work:
                 self.pglin = 999
             if self.pglin > self.fpdf.lpp:
                 self.pageHeading()
-            if self.costs != "Y":
-                self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s" %
-                    (code.disp, desc.disp, uoi.disp, vat.disp, qty.disp,
-                    pr[0].disp, pr[1].disp, pr[2].disp, pr[3].disp,
-                    pr[4].disp))
-            else:
-                self.fpdf.drawText("%s %s %s %s %s %s %s %s %s %s %s %s" % \
-                    (code.disp, desc.disp, uoi.disp, vat.disp, qty.disp,
-                    pr[0].disp, pr[1].disp, pr[2].disp, pr[3].disp,
-                    pr[4].disp, acst.disp, lcst.disp))
+            txt = "%s %s %s %s %s" % (code.disp, desc.disp,
+                uoi.disp, vat.disp, qty.disp)
+            for prc in prcs:
+                txt += " %s" % prc.disp
+            if self.costs == "Y":
+                txt += " %s" % acst.disp
+                txt += " %s" % lcst.disp
+            self.fpdf.drawText(txt)
             self.pglin += 1
             old_grp = grp.work
         p.closeProgress()
@@ -291,9 +276,8 @@
 
     def printCost(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%03u %-30s %20s %40s" % (self.opts["conum"],
-            self.opts["conam"], "", self.sysdttm))
-        self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
+        self.head = ("%03u %-30s" % (self.opts["conum"], self.opts["conam"]))
+        self.fpdf = MyFpdf(name=self.__class__.__name__, head=100, foot=True)
         old_grp = ""
         self.pgnum = 0
         self.pglin = 999
@@ -326,73 +310,38 @@
         code = CCD(data[1], "NA", 20)
         desc = CCD(data[2], "UA", 30)
         uoi = CCD(data[3], "NA", 10)
-        # Balances and Cost Prices
-        bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
-            int(self.sysdtw / 100), keys=(grp.work, code.work, self.loc))
-        bal = bals.doStrBals(0)
-        qty = CCD(bal[5][0], "SD", 12.2)
+        # Cost Prices and Balances
+        cst, bal = getCost(self.sql, self.opts["conum"], grp.work, code.work,
+            loc=self.loc, qty=1, ind="AL", bal=True)
+        qty = CCD(bal[0], "SD", 12.2)
         if self.nostock == "Y" and qty.work <= 0:
             return
-        acst = CCD(bal[6], "SD", 10.2)
-        lcst = CCD(bal[7], "SD", 10.2)
+        acst = CCD(cst[0], "SD", 10.2)
+        lcst = CCD(cst[1], "SD", 10.2)
         if self.rtype == "C":
             return (grp, code, desc, uoi, qty, acst, lcst)
         # Selling Prices
-        prs = [0] * 5
         vat = CCD(data[4], "NA", 1)
+        rte = 0
         if self.vatinc == "Y":
-            vatrte = getVatRate(self.sql, self.opts["conum"], vat.work,
-                self.sysdtw)
-            if vatrte is None:
-                vatrte = 0.0
-        else:
-            vatrte = 0.0
-        if self.ptype == "L":
-            whr = [
-                ("stp_cono", "=", self.opts["conum"]),
-                ("stp_group", "=", grp.work),
-                ("stp_code", "=", code.work),
-                ("stp_loc", "=", self.loc)]
-            if self.opts["level"]:
-                whr.append(("stp_level", "=", self.opts["level"]))
-            prc = self.sql.getRec("strprc", cols=["stp_level",
-                "stp_price"], where=whr, order="stp_level")
-            if prc:
-                for lev, pr in (prc):
-                    prs[lev - 1] = round((pr * ((100 + vatrte) / 100.0)),2)
-        else:
-            # Markup Based on Last Cost
-            for x in range(self.prcs):
-                lev = x + 1
-                mup = getMarkup(self.sql, self.opts["conum"], grp.work,
-                    code.work, self.loc, lev)
-                if mup:
-                    if lcst.work:
-                        pr = round((lcst.work * (1 + (mup / 100.0))), 2)
-                    else:
-                        pr = round((acst.work * (1 + (mup / 100.0))), 2)
-                    prs[x] = round((pr * ((100 + vatrte) / 100.0)),2)
-        pr = []
-        for y in xrange(0, 5):
-            pr.append(CCD(prs[y], "UD", 9.2))
-        if not pr[0].work and not pr[1].work and not pr[2].work and \
-                                    not pr[3].work and not pr[4].work:
-            if self.noprice == "Y":
+            vatrte = getVatRate(self.sql, self.opts["conum"],
+                vat.work, self.sysdtw)
+            if vatrte is not None:
+                rte = vatrte
+        prcs = []
+        for lev in self.levs:
+            prc = getSell(self.sql, self.opts["conum"], grp.work, code.work,
+                self.loc, lev)
+            prcs.append(CCD(round((prc*((100 + rte)/100.0)),2), "UD", 9.2))
+        if self.noprice == "Y":
+            cont = False
+            for prc in prcs:
+                if prc.work:
+                    cont = True
+                    break
+            if not cont:
                 return
-            if self.lasts == "Y":
-                lsp = self.sql.getRec("strtrn", cols=["stt_sell"],
-                    where=[("stt_cono", "=", self.opts["conum"]), ("stt_group",
-                    "=", grp.work), ("stt_code", "=", code.work),
-                    ("stt_loc", "=", self.loc), ("stt_type", "in", (7, 8))],
-                    order="stt_trdt desc", limit=1)
-                if not lsp or lsp[0] <= 0:
-                    lsp = CCD(0, "UD", 9.2)
-                else:
-                    lsp = CCD(lsp[0], "UD", 9.2)
-                pr[0] = lsp
-                if lsp.work:
-                    pr[1].disp = "*        "
-        return (grp, code, desc, uoi, vat, qty, acst, lcst, pr)
+        return (grp, code, desc, uoi, vat, qty, acst, lcst, prcs)
 
     def pageHeading(self):
         locd = self.getLoc(self.loc)[0]
@@ -402,23 +351,17 @@
         self.fpdf.drawText(self.head)
         self.fpdf.drawText()
         if self.rtype == "S":
-            if self.costs == "Y":
-                pag = (" " * 102) + "Page"
-            else:
-                pag = (" " * 81) + "Page"
-            self.fpdf.drawText("%-24s %-10s %s %5s" % \
-                ("Selling Price List as at", self.sysdtd, pag, self.pgnum))
+            self.fpdf.drawText("%-24s %-10s" % ("Selling Price List as at",
+                self.sysdtd))
             self.fpdf.drawText()
             mess = "%-31s %1s %-14s %1s %-16s %s" % (
                 "(Options:- Ignore Out of Stock:", self.nostock,
                 "VAT Inclusive:", self.vatinc,
                 "Ignore Un-priced:", self.noprice)
-            if self.noprice == "N":
-                mess = "%s Use Last S/P for Un-priced: %s" % (mess, self.lasts)
             self.fpdf.drawText("%s%s" % (mess, ")"))
         else:
-            self.fpdf.drawText("%-21s %-10s %57s %5s" % \
-                ("Cost Price List as at", self.sysdtd, "Page", self.pgnum))
+            self.fpdf.drawText("%-21s %-10s" % ("Cost Price List as at",
+                self.sysdtd))
             self.fpdf.drawText()
             self.fpdf.drawText("%-31s %1s%1s" % (
                 "(Options:- Ignore Out of Stock:", self.nostock, ")"))
@@ -427,20 +370,19 @@
             ("Group", self.groupd, "Location", self.loc, locd))
         self.fpdf.drawText()
         cost = "Avg-Cost"
-        last = "Lst-Cost"
+        last = "Last-Cost"
         if self.rtype == "S":
-            if self.costs == "N":
-                cost = ""
-                last = ""
-            self.fpdf.drawText("%-20s %-30s %-10s %1s %-14s %-9s %-9s %-9s " \
-                "%-9s %-9s%-10s %-10s" % ("Product-Code", "Description",
-                "U.O.I", "V", "Qty-Balance", "Price-1", "Price-2",
-                "Price-3", "Price-4", "Price-5", cost, last))
+            self.txt = "%-20s %-30s %-10s %1s %11s " % ("Product-Code",
+                "Description", "U.O.I", "V", "Quantity")
+            for lev in self.levs:
+                self.txt += "   Level-%s" % lev
+            if self.costs == "Y":
+                self.txt += " %9s  %9s" % (cost, last)
         else:
-            self.fpdf.drawText("%-20s %-30s %-10s %-12s  %-10s %-10s" % \
-                ("Product-Code", "Description", "U.O.I", "Qty-Balance",
-                cost, last))
-        self.fpdf.underLine(txt=self.head)
+            self.txt = "%-20s %-30s %-10s %11s  %9s  %9s" % ("Product-Code",
+                "Description", "U.O.I", "Quantity", cost, last)
+        self.fpdf.drawText(self.txt)
+        self.fpdf.underLine(txt=self.txt)
         self.fpdf.setFont()
         self.pglin = 10
 

=== modified file 'str/st3040.py' (properties changed: -x to +x)
--- old/str/st3040.py	2020-04-21 08:42:36 +0000
+++ new/str/st3040.py	2020-09-22 10:19:01 +0000
@@ -125,8 +125,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         expheads = ["%03u %-30s %s %6s" % (self.opts["conum"],
             self.opts["conam"], self.sysdttm, self.__class__.__name__)]
         expheads.append("Stores Master Code List as at %s" % self.sysdtd)
@@ -139,8 +138,6 @@
                 p.closeProgress()
                 return
             vals = self.getValues(dat)
-            if not vals:
-                continue
             expdatas.append(["BODY", [vals[0].work, vals[1].work,
                 vals[2].work, vals[3].work, vals[4].work, vals[5].work]])
         p.closeProgress()
@@ -173,8 +170,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3050.py' (properties changed: -x to +x)
--- old/str/st3050.py	2020-04-21 08:42:36 +0000
+++ new/str/st3050.py	2020-05-27 12:34:58 +0000
@@ -191,8 +191,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3060.py' (properties changed: -x to +x)
--- old/str/st3060.py	2020-04-21 08:42:36 +0000
+++ new/str/st3060.py	2020-06-12 07:29:49 +0000
@@ -103,8 +103,8 @@
             self.locd = "ALL"
         else:
             acc = self.sql.getRec("strloc", cols=["srl_desc"],
-                where=[("srl_cono", "=", self.opts["conum"]), ("srl_loc", "=",
-                w)], limit=1)
+                where=[("srl_cono", "=", self.opts["conum"]),
+                ("srl_loc", "=", w)], limit=1)
             if not acc:
                 return "Invalid Location"
             self.locd = acc[0]
@@ -114,8 +114,8 @@
             self.group = ""
         else:
             acc = self.sql.getRec("strgrp", cols=["gpm_desc"],
-                where=[("gpm_cono", "=", self.opts["conum"]), ("gpm_group",
-                "=", w)], limit=1)
+                where=[("gpm_cono", "=", self.opts["conum"]),
+                ("gpm_group", "=", w)], limit=1)
             if not acc:
                 return "Invalid Group"
             self.group = w
@@ -133,8 +133,9 @@
             self.egrp = self.group
         recs = self.sql.getRec("strmf1", cols=["st1_group", "st1_code",
             "st1_desc", "st1_uoi"], where=[("st1_cono", "=",
-            self.opts["conum"]), ("st1_group", ">=", self.sgrp), ("st1_group",
-            "<=", self.egrp)], order="st1_group, st1_code")
+            self.opts["conum"]), ("st1_group", ">=", self.sgrp),
+            ("st1_group", "<=", self.egrp), ("st1_type", "=", "N")],
+            order="st1_group, st1_code")
         if not recs:
             showError(self.opts["mf"].body, "Processing Error",
             "No Records Selected")
@@ -147,8 +148,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = ["%03u %-30s %s" % (self.opts["conum"],
             self.opts["conam"], self.sysdttm), "Stock Movement Report "\
             "as at %s for Period %s to %s" % (self.sysdtd, self.sdatd,
@@ -211,8 +211,7 @@
             self.groupTotal()
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3070.py' (properties changed: -x to +x)
--- old/str/st3070.py	2020-04-21 08:42:36 +0000
+++ new/str/st3070.py	2020-05-27 12:35:12 +0000
@@ -157,8 +157,7 @@
                 self.doList(recs)
             if self.fpdf.page and not self.p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3080.py' (properties changed: -x to +x)
--- old/str/st3080.py	2020-04-21 08:42:36 +0000
+++ new/str/st3080.py	2020-05-27 12:35:20 +0000
@@ -41,8 +41,8 @@
                 self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strgrp", "strmf1"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strgrp", "strmf1",
+            "strtrn"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -187,8 +187,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Stock On Hand Report as at %s" % self.date.disp)
         self.expcolsh = [self.colsh]
@@ -243,8 +242,7 @@
             self.grandTotal()
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3090.py' (properties changed: -x to +x)
--- old/str/st3090.py	2020-04-21 08:42:36 +0000
+++ new/str/st3090.py	2020-06-12 07:40:06 +0000
@@ -81,7 +81,7 @@
             view = None
             mail = None
         else:
-            var = ["", "", "", "", "N"]
+            var = ["", "", "", "", "N", "N"]
             view = ("N","V")
             mail = ("Y","N")
         fld = [
@@ -93,8 +93,10 @@
                 var[2],"N",self.doLoc,loc,None,("efld",)],
             (("T",0,3,0),"IUA",3,"Product Group","",
                 var[3],"N",self.doGroup,grp,None,None),
-            (("T",0,4,0),("IRB",r1s),0,"New Account on New Page","",
-                var[4],"N",self.doPage,None,None,None)]
+            (("T",0,4,0),("IRB",r1s),0,"Include Recipes","",
+                var[4],"N",self.doRecp,None,None,None),
+            (("T",0,5,0),("IRB",r1s),0,"New Account on New Page","",
+                var[5],"N",self.doPage,None,None,None)]
         if self.locs == "N":
             fld[2][1] = "OUA"
         tnd = ((self.doEnd,"Y"), )
@@ -138,6 +140,9 @@
                 return "Invalid Group"
             self.group = w
 
+    def doRecp(self, frt, pag, r, c, p, i, w):
+        self.recp = w
+
     def doPage(self, frt, pag, r, c, p, i, w):
         self.npag = w
 
@@ -149,10 +154,14 @@
         else:
             self.sgrp = self.group
             self.egrp = self.group
+        whr = [
+            ("st1_cono", "=", self.opts["conum"]),
+            ("st1_group", ">=", self.sgrp),
+            ("st1_group", "<=", self.egrp)]
+        if self.recp == "N":
+            whr.append(("st1_type", "=", "N"))
         recs = self.sql.getRec("strmf1", cols=["st1_group", "st1_code",
-            "st1_desc"], where=[("st1_cono", "=", self.opts["conum"]),
-            ("st1_group", ">=", self.sgrp), ("st1_group", "<=", self.egrp)],
-            order="st1_group, st1_code")
+            "st1_desc"], where=whr, order="st1_group, st1_code")
         if not recs:
             showError(self.opts["mf"].body, "Processing Error",
             "No Records Selected")
@@ -178,8 +187,8 @@
             cod = CCD(dat[1], "NA", 20)
             desc = CCD(dat[2], "UA", 30)
             bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                self.edate, keys=(grp.work, cod.work, self.loc, ("P",
-                self.opts["period"][0])))
+                self.edate, keys=(grp.work, cod.work, self.loc,
+                ("P", self.opts["period"][0])))
             m_ob, m_mv, m_cb, y_ob, y_mv, y_cb, ac, lc, ls, stt_rslt = \
                 bals.doStrBals(self.sdate, trans="Y")
             self.qfwd = y_ob[0]
@@ -215,8 +224,7 @@
         if self.fpdf.page and not p.quit:
             if "args" not in self.opts or "noprint" not in self.opts["args"]:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st3100.py' (properties changed: -x to +x)
=== modified file 'str/st3110.py' (properties changed: -x to +x)
--- old/str/st3110.py	2020-04-21 08:42:36 +0000
+++ new/str/st3110.py	2020-06-06 08:58:56 +0000
@@ -25,9 +25,10 @@
 """
 
 import time
-from TartanClasses import ASD, Balances, CCD, GetCtl, TartanLabel, ProgressBar
-from TartanClasses import Sql, TartanDialog
-from tartanFunctions import getModName, doPrinter, getVatRate, showError
+from TartanClasses import ASD, CCD, GetCtl, TartanLabel, ProgressBar, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import getCost, getModName, doPrinter, getSell
+from tartanFunctions import getVatRate, showError
 from tartanWork import labels
 
 class st3110(object):
@@ -39,7 +40,8 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["ctlvrf", "strgrp", "strloc",
-            "strprc", "strmf1", "strmf2"], prog=self.__class__.__name__)
+            "strprc", "strmf1", "strmf2", "strtrn"],
+            prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -87,7 +89,7 @@
             "head": ("Codes",),
             "data": list(labels.keys())}
         r1s = (("Normal", "N"), ("Recipes", "R"))
-        r2s = (("Yes", "A"), ("No", "N"), ("All", "B"))
+        r2s = (("Average", "A"), ("Standard", "S"), ("All", "B"))
         r3s = (("No", "N"), ("Yes", "Y"))
         fld = [
             (("T",0,0,0),"ID1",10,"Reporting Date","",
@@ -192,7 +194,7 @@
         if self.code:
             whr.append(("st1_code", "=", self.code))
         whr.append(("st1_type", "=", self.types))
-        if self.valind in ("A", "N"):
+        if self.valind in ("A", "S"):
             whr.append(("st1_value_ind", "=", self.valind))
         if self.loc:
             whr.append(("st2_loc", "=", self.loc))
@@ -217,8 +219,7 @@
             p.closeProgress()
             if self.fpdf.page and not p.quit:
                 pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                    self.__class__.__name__,
-                    self.opts["conum"], ext="pdf")
+                    self.__class__.__name__, self.opts["conum"], ext="pdf")
                 self.fpdf.output(pdfnam, "F")
                 doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                     pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt)
@@ -226,23 +227,14 @@
 
     def doProcess(self, dat):
         loc, group, code, desc, valind, vatcod = dat
-        # Calculate cost price code ########################################
+        icost, bal = getCost(self.sql, self.opts["conum"], group, code,
+            loc=loc, qty=1, ind="I", bal=True)
+        if self.outs == "N" and not bal[0]:
+            return
         if self.ccode:
-            bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
-                int(self.date / 100), (group, code, loc)).doStrBals()
-            if self.outs == "N" and not bals[5][0]:
-                return
-            if valind == "N":
-                icost = 0
-            else:
-                if bals[5][0] == 1:
-                    icost = bals[5][1]
-                else:
-                    icost = bals[6]
-                if icost <= 0:
-                    icost = bals[7]
+            # Calculate cost price code
             cost = CCD(int(icost * 100), "UI", 9)
-            ncost = " " * (9 - len(str(cost)))
+            ncost = " " * (9 - len(str(cost.work)))
             for x in str(cost.work):
                 ncost = ncost + self.ccode[int(x)]
             lab = "%-30s %13s" % (self.df.t_disp[0][0][0], ncost)
@@ -251,22 +243,15 @@
         ####################################################################
         lab = "%s\n%s %s %s" % (lab, loc, group, code)
         lab = "%s\n%s\n" % (lab, desc)
-        prc = self.sql.getRec("strprc", cols=["stp_price"],
-            where=[("stp_cono", "=", self.opts["conum"]), ("stp_group", "=",
-            group), ("stp_code", "=", code), ("stp_loc", "=", loc),
-            ("stp_level", "=", 1)], limit=1)
-        if not prc or not prc[0]:
-            price1 = CCD(0, "UD", 9.2)
-            price2 = CCD(0, "UD", 9.2)
+        prc = getSell(self.sql, self.opts["conum"], group, code, loc)
+        price1 = CCD(prc, "UD", 9.2)
+        vrte = getVatRate(self.sql, self.opts["conum"], vatcod, self.date)
+        if vrte is None:
+            vrte = CCD(0, "UD", 9.2)
         else:
-            price1 = CCD(prc[0], "UD", 9.2)
-            vrte = getVatRate(self.sql, self.opts["conum"], vatcod, self.date)
-            if vrte is None:
-                vrte = CCD(0, "UD", 9.2)
-            else:
-                vrte = CCD(vrte, "UD", 9.2)
-            price2 = CCD(round((price1.work * float(ASD(100) + \
-                ASD(vrte.work)) / 100.0), 2), "OUD", 9.2)
+            vrte = CCD(vrte, "UD", 9.2)
+        price2 = CCD(round((price1.work * float(ASD(100) + \
+            ASD(vrte.work)) / 100.0), 2), "OUD", 9.2)
         lab = "%s\n%s %s %s" % (lab, vatcod, price1.disp, price2.disp)
         self.fpdf.add_label(lab)
 

=== modified file 'str/st3120.py' (properties changed: -x to +x)
--- old/str/st3120.py	2020-04-21 08:42:36 +0000
+++ new/str/st3120.py	2020-05-27 12:35:35 +0000
@@ -37,8 +37,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strmf1", "strmf2"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strgrp", "strmf1",
+            "strmf2"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])
@@ -145,8 +145,7 @@
     def exportReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         expnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"])
+            self.__class__.__name__, self.opts["conum"])
         self.expheads = [self.head % self.sysdttm]
         self.expheads.append("Stock to Order Report as at %s" % self.sysdtd)
         self.expheads.append("(Options: Report Date %s)" % self.repdtd)
@@ -185,8 +184,7 @@
         self.head2 = self.head2 % (" " * pad, " Page %5s")
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head2)
         self.pgnum = 0
         self.pglin = 999

=== modified file 'str/st4010.py' (properties changed: -x to +x)
--- old/str/st4010.py	2020-04-21 08:42:36 +0000
+++ new/str/st4010.py	2020-11-20 05:37:39 +0000
@@ -52,8 +52,13 @@
         if not strctl:
             return
         self.glint = strctl["cts_glint"]
-        self.locs = strctl["cts_locs"]
-        self.prcs = strctl["cts_plevs"]
+        self.plevs = strctl["cts_plevs"]
+        self.automu = strctl["cts_automu"]
+        if strctl["cts_locs"] == "Y":
+            self.locs = self.sql.getRec("strloc", cols=["count(*)"],
+                where=[("srl_cono", "=", self.opts["conum"])], limit=1)[0]
+        else:
+            self.locs = 1
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i)" % \
@@ -106,7 +111,7 @@
             ("Balances", self.doTagSelect, ("T",0,0), ("T",0,1)),
             ("History", self.doTagSelect, ("T",0,0), ("T",0,1)),
             ("Trans", self.doTrans1, ("T",0,0), ("T",0,1)))
-        fld = (
+        fld = [
             (("T",0,0,0),"IUA",3,"Grp","Product Group",
                 "","N",self.doGroup,gpm,None,("notblank",)),
             (("T",0,0,0),"INA",20,"Code","Product Code",
@@ -116,34 +121,32 @@
                 "","N",self.doLoc,stl,None,("efld",)),
             (("T",0,0,0),"ONA",20,""),
             (("T",1,0,0),("ORB",r1s),0,"Type of Item"),
-            (("T",1,1,0),"ONA",10,"Units Of Issue"),
+            (("T",1,1,0),"ONA",10,"Unit of Issue"),
             (("T",1,1,0),"ONA",20,""),
-            (("T",1,2,0),"OUI",7,"Units Per Pack"),
-            (("T",1,3,0),("ORB",r2s),0,"Value Indicator"),
-            (("T",1,4,0),"OUA",1,"VAT Code"),
-            (("T",1,4,0),"ONA",29,""),
-            (("T",1,5,0),"OUI",3,"Exclusive Chainstore"),
-            (("T",1,5,0),"ONA",27,""),
-            (("T",1,6,0),"ONA",7,"Exclusive Account"),
+            (("T",1,2,0),("ORB",r2s),0,"Value Indicator"),
+            (("T",1,3,0),"OUA",1,"VAT Code"),
+            (("T",1,3,0),"ONA",29,""),
+            (("T",1,4,0),"OUI",3,"Exclusive Chainstore"),
+            (("T",1,4,0),"ONA",27,""),
+            (("T",1,5,0),"ONA",7,"Exclusive Account"),
+            (("T",1,5,0),"ONA",23,""),
+            (("T",1,6,0),"OUI",7,"Sales Code"),
             (("T",1,6,0),"ONA",23,""),
-            (("T",1,7,0),"OUI",7,"Sales Code"),
+            (("T",1,7,0),"OUI",7,"COS Code"),
             (("T",1,7,0),"ONA",23,""),
-            (("T",1,8,0),"OUI",7,"COS Code"),
-            (("T",1,8,0),"ONA",23,""),
-            (("T",1,9,0),"OUA",8,"Bin Number"),
-            (("T",1,10,0),("ORB",r3s),0,"Re-Order Indicator"),
-            (("T",1,11,0),"OUI",7,"Re-Order Level"),
-            (("T",1,12,0),"OUI",7,"Re-Order Quantity"),
-            (("T",1,13,0),"OUD",6.2,"Price Markup    Lv1"),
-            (("T",1,13,0),"OUD",6.2," Lv2"),
-            (("T",1,13,0),"OUD",6.2," Lv3"),
-            (("T",1,13,0),"OUD",6.2," Lv4"),
-            (("T",1,13,0),"OUD",6.2," Lv5"),
+            (("T",1,8,0),"OUA",8,"Bin Number"),
+            (("T",1,9,0),("ORB",r3s),0,"Re-Order Indicator"),
+            (("T",1,10,0),"OUI",7,"Re-Order Level"),
+            (("T",1,11,0),"OUI",7,"Re-Order Quantity"),
+            (("T",1,12,0),"OUD",6.2,"Price Markup    Lv1")]
+        for x in range(self.plevs - 1):
+            fld.append((("T",1,12,0),"OUD",6.2," Lv%s" % (x + 2)))
+        fld.extend([
             (("T",2,0,0),"Od1",10,"Date Last Receipt"),
             (("T",2,1,0),"Od1",10,"Date Last Issue"),
             (("T",2,2,0),"OSD",12.2,"Quantity Balance"),
             (("T",2,3,0),"OSD",12.2,"Value Balance"),
-            (("T",2,4,0),"OSD",12.2,"Average Unit Cost"),
+            [("T",2,4,0),"OSD",12.2,"Average Cost"],
             (("T",2,5,0),"OSD",12.2,"Quantity on P/O"),
             (("T",2,6,0),"OSD",12.2,"Quantity on S/O"),
             (("C",3,0,0),"OSD",13.2,"Qty-Receipts","",
@@ -154,7 +157,7 @@
             (("T",4,0,0),"Id2",7,"Start Period", "Start Period (0=All)",
                 "","N",self.doTrans2a,None,None,("efld",)),
             (("T",4,0,0),"Id2",7,"End Period", "End Period",
-                "","N",self.doTrans2b,None,None,("efld",)))
+                "","N",self.doTrans2b,None,None,("efld",))])
         but = (
             ("Clear",None,self.doClear,1,("T",0,0),("T",0,1)),
             ("Recipe",None,self.doRecipe,None,None,None),
@@ -194,25 +197,26 @@
 
     def doCode(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec("strmf1", where=[("st1_cono", "=",
-            self.opts["conum"]), ("st1_group", "=", self.group), ("st1_code",
-            "=", w), ("st1_type", "<>", "X")], limit=1)
+            self.opts["conum"]), ("st1_group", "=", self.group),
+            ("st1_code", "=", w), ("st1_type", "<>", "X")], limit=1)
         if not acc:
             return "Invalid or Redundant Code"
         self.code = w
         self.desc = acc[self.sql.strmf1_col.index("st1_desc")]
+        valind = acc[self.sql.strmf1_col.index("st1_value_ind")]
         self.df.loadEntry("T", 0, 2, data=self.desc)
         pag = 1
         d = 3
         for x in range(0, 15):
             if x == 2:
                 self.loadUoi(x, acc[d-1])
-            elif x == 6:
+            elif x == 5:
                 self.loadVat(x, acc[d-1])
-            elif x == 8:
+            elif x == 7:
                 self.loadChnExcl(x, acc[d-1])
-            elif x == 10:
+            elif x == 9:
                 self.loadAccExcl(x, acc[d-1])
-            elif x in (12, 14):
+            elif x in (11, 13):
                 self.loadGen(x, acc[d-1])
             else:
                 self.df.loadEntry("T", pag, x, data=acc[d])
@@ -221,7 +225,11 @@
                     d += 2
                 else:
                     d += 1
-        if self.locs == "N":
+        if valind == "S":
+            self.df.topLabel[2][4].configure(text="%-18s" % "Standard Cost")
+        else:
+            self.df.topLabel[2][4].configure(text="%-18s" % "Average Cost")
+        if self.locs == 1:
             self.df.loadEntry("T", 0, 3, data="1")
             no = self.doLoc(frt, pag, r, c+1, p+1, i+1, "1")
             if no:
@@ -236,20 +244,20 @@
             return "Invalid Location Code"
         self.df.loadEntry("T", 0, 4, data=acc[0])
         acc = self.sql.getRec("strmf2", where=[("st2_cono", "=",
-            self.opts["conum"]), ("st2_group", "=", self.group), ("st2_code",
-            "=", self.code), ("st2_loc", "=", w)], limit=1)
+            self.opts["conum"]), ("st2_group", "=", self.group),
+            ("st2_code", "=", self.code), ("st2_loc", "=", w)], limit=1)
         if not acc:
             return "This location does not exist for this product"
         self.loc = w
         d = 4
-        for x in range(15, 19):
+        for x in range(14, 18):
             self.df.loadEntry("T", 1, x, data=acc[d])
             d += 1
-        for y in range(self.prcs):
-            lev = y + 1
-            mup = getMarkup(self.sql, self.opts["conum"], self.group,
-                self.code, self.loc, lev)
-            self.df.loadEntry("T", 1, x + lev, data=mup)
+        if self.automu in ("A", "L"):
+            for lev in range(1, self.plevs + 1):
+                mup = getMarkup(self.sql, self.opts["conum"], self.group,
+                    self.code, self.loc, lev)
+                self.df.loadEntry("T", 1, x + lev, data=mup)
         self.loadBalances()
         if self.itype == "R":
             self.df.setWidget(self.df.B1, "normal")
@@ -324,7 +332,7 @@
             where=[("stt_cono", "=", self.opts["conum"]), ("stt_group", "=",
             self.group), ("stt_code", "=", self.code), ("stt_loc", "=",
             self.loc), ("stt_type", "in", (2, 4, 7, 8))])
-        if not liss[0][0]:
+        if not liss or not liss[0][0]:
             lastiss = 0
         else:
             lastiss = liss[0][0]
@@ -378,8 +386,8 @@
             "Location: %s  Code: %s  Description: %s" %
             (self.loc, self.code, self.desc)]
         RepPrt(self.opts["mf"], conum=self.opts["conum"],
-            conam=self.opts["conam"], name=self.__class__.__name__, heads=hds,
-            cols=self.rcp[0], tables=self.rcp[1], ttype="D",
+            conam=self.opts["conam"], name=self.__class__.__name__,
+            heads=hds, cols=self.rcp[0], tables=self.rcp[1], ttype="D",
             prtdia=(("Y", "V"), ("Y", "N")))
         self.df.setWidget(self.df.mstFrame, state="show")
         if "wait" not in self.opts:
@@ -393,9 +401,10 @@
             ("srr_group", "=", self.group),
             ("srr_code", "=", self.code),
             ("srr_loc", "=", self.loc),
+            ("st1_cono=srr_cono",),
             ("st1_group=srr_rgroup",),
             ("st1_code=srr_rcode",)]
-        odr = "srr_rgroup, srr_code"
+        odr = "srr_rgroup, srr_rcode"
         items = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
         for seq, item in enumerate(items):
             bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
@@ -432,12 +441,14 @@
         crt = (
             ("stt_trdt", "", 0, "   Date"),
             ("stt_batch", "", 0, "Batch"),
-            ("stt_type", ("XX", sttrtp), 3, "Typ"),
+            ("stt_type", "NA", 3, "Typ"),
             ("stt_ref1", "", 0, "Reference","Y"),
             ("stt_ref2", "", 0, "Ref-Num-2"),
             ("stt_qty", "", 0, "  Quantity"),
             ("stt_cost", "", 0, "      Cost"),
             ("stt_sell", "", 0, "   Selling"),
+            ("qbal", "SD", 13.2, "   Qty-Bal"),
+            ("cbal", "SD", 13.2, "  Cost-Bal"),
             ("stt_desc", "", 0, "Details"))
         whr = [
             ("stt_cono", "=", self.opts["conum"]),
@@ -447,13 +458,29 @@
         if self.per_from:
             whr.extend([("stt_curdt", ">=", self.per_from),
                 ("stt_curdt", "<=", self.per_to)])
-        odr = "stt_trdt, stt_seq"
+        odr = "stt_trdt, stt_qty desc"
+        recs = self.sql.getRec("strtrn", cols=["stt_trdt", "stt_batch",
+            "stt_type", "stt_ref1", "stt_ref2", "stt_qty", "stt_cost",
+            "stt_sell", "stt_desc"], where=whr, order=odr)
+        data = []
+        tqty = 0
+        tcst = 0
+        for rec in recs:
+            rec[2] = sttrtp[rec[2] - 1][0]
+            tqty = float(ASD(tqty) + ASD(rec[5]))
+            tcst = float(ASD(tcst) + ASD(rec[6]))
+            rec.insert(8, tqty)
+            rec.insert(9, tcst)
+            data.append(rec)
         state = self.df.disableButtonsTags()
         while True:
             rec = SRec(self.opts["mf"], screen=self.df.nb.Page4, title=tit,
-                tables=tab, cols=crt, where=whr, order=odr, rows=12)
+                tables=tab, cols=crt, where=data, wtype="D")
             if rec.selection:
-                typ = rec.selection[2]
+                for n, t in enumerate(sttrtp):
+                    if t[0] == rec.selection[2]:
+                        typ = n + 1
+                        break
                 doc = rec.selection[3]
                 if self.itype == "R" and typ in (7, 8):
                     bt = (("Transaction", "T"), ("Recipe", "R"))
@@ -549,10 +576,9 @@
             tab = ["strmf1", "strmf2"]
             col = [
                 "st1_group", "st1_code", "st2_loc", "st1_desc", "st1_type",
-                "st1_uoi", "st1_units", "st1_value_ind", "st1_vatcode",
-                "st1_chn_excl", "st1_acc_excl", "st1_sls", "st1_cos",
-                "st2_bin", "st2_reord_ind", "st2_reord_level",
-                "st2_reord_qty"]
+                "st1_uoi", "st1_value_ind", "st1_vatcode", "st1_chn_excl",
+                "st1_acc_excl", "st1_sls", "st1_cos", "st2_bin",
+                "st2_reord_ind", "st2_reord_level", "st2_reord_qty"]
             whr = [
                 ("st1_cono", "=", self.opts["conum"]),
                 ("st1_group", "=", self.group),
@@ -563,8 +589,7 @@
                 ("st2_loc", "=", self.loc)]
             TabPrt(self.opts["mf"], self.opts["conum"], self.opts["conam"],
                 name=self.__class__.__name__, head=head, tabs=tab, cols=col,
-                    where=whr,
-                keys=[self.group, self.code, self.loc])
+                where=whr, keys=[self.group, self.code, self.loc])
         elif opt == "T":
             tab = ["strtrn"]
             hds = ["Stores's Transactions",
@@ -587,9 +612,8 @@
             gtots = ["stt_qty", "stt_cost", "stt_sell"]
             RepPrt(self.opts["mf"], conum=self.opts["conum"],
                 conam=self.opts["conam"], name=self.__class__.__name__,
-                    tables=tab,
-                heads=hds, cols=col, where=whr, order=odr, gtots=gtots,
-                prtdia=(("Y","V"),("Y","N")))
+                tables=tab, heads=hds, cols=col, where=whr, order=odr,
+                gtots=gtots, prtdia=(("Y","V"),("Y","N")))
         else:
             self.rcp = self.getRecipeItems()
             hds = ["Stores's Recipe",
@@ -597,8 +621,7 @@
                 (self.loc, self.code, self.desc)]
             RepPrt(self.opts["mf"], conum=self.opts["conum"],
                 conam=self.opts["conam"], name=self.__class__.__name__,
-                    heads=hds,
-                cols=self.rcp[0], tables=self.rcp[1], ttype="D",
+                heads=hds, cols=self.rcp[0], tables=self.rcp[1], ttype="D",
                 prtdia=(("Y", "V"), ("Y", "N")))
         self.df.setWidget(self.df.mstFrame, state="show")
         self.df.enableButtonsTags(state=state)

=== modified file 'str/st5010.py' (properties changed: -x to +x)
--- old/str/st5010.py	2020-04-21 08:42:36 +0000
+++ new/str/st5010.py	2020-05-27 12:36:25 +0000
@@ -224,8 +224,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'str/st5020.py' (properties changed: -x to +x)
--- old/str/st5020.py	2020-04-21 08:42:36 +0000
+++ new/str/st5020.py	2020-06-07 14:15:36 +0000
@@ -25,8 +25,8 @@
 """
 
 import time
-from TartanClasses import Balances, GetCtl, Sql, TartanDialog
-from tartanFunctions import getMarkup, showError
+from TartanClasses import GetCtl, Sql, TartanDialog
+from tartanFunctions import getCost, showError
 
 class st5020(object):
     def __init__(self, **opts):
@@ -37,7 +37,7 @@
 
     def setVariables(self):
         self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strgrp", "strmf1",
-            "strmf2", "strgmu", "strcmu", "strprc", "strvar"],
+            "strmf2", "strgmu", "strcmu", "strprc", "strtrn", "strvar"],
                 prog=self.__class__.__name__)
         if self.sql.error:
             return
@@ -46,7 +46,6 @@
         if not strctl:
             return
         self.locs = strctl["cts_locs"]
-        self.automu = strctl["cts_automu"]
         t = time.localtime()
         self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
         self.last = 0
@@ -84,23 +83,22 @@
             "index": 1}
         r1s = (("Number","N"),("Bin Number","B"))
         r2s = (("Yes","Y"),("No","N"))
+        r3s = (("No","N"),("Last","L"),("Average","A"))
         fld = (
             (("T",0,0,0),("IRB",r1s),0,"Sort Order","",
                 "N","Y",self.doSort,None,None,None),
             (("T",0,1,0),"IUA",1,"Location","",
-                "","Y",self.doLoc,loc,None,("efld",)),
+                "","N",self.doLoc,loc,None,("efld",)),
             (("T",0,2,0),("IRB",r2s),0,"Auto Sequence","",
-                "N","Y",self.doAuto,None,None,None),
+                "N","N",self.doAuto,None,None,None),
             (("T",0,3,0),"IUA",8,"First Bin Number","",
-                "","Y",self.doFbin,None,None,("efld",)),
+                "","N",self.doFbin,None,None,("efld",)),
             (("T",0,4,0),"IUA",3,"First Group","",
-                "","Y",self.doFgrp,gpm,None,None),
+                "","N",self.doFgrp,gpm,None,None),
             (("T",0,5,0),"INA",20,"First Code","",
-                "","Y",self.doFcode,stm1,None,None),
-            (("T",0,6,0),("IRB",r2s),0,"Selling Prices","",
-                "N","Y",self.doSell,None,None,None),
-            (("T",0,7,0),("IRB",r2s),0,"Automatic Markup","",
-                self.automu,"Y",self.doMkUp,None,None,None))
+                "","N",self.doFcode,stm1,None,None),
+            (("T",0,6,0),("IRB",r3s),0,"Cost Prices","",
+                "N","N",self.doCosts,None,None,None))
         tnd = ((self.endPage1,"y"),)
         txt = (self.exitPage1,)
         self.df1 = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
@@ -160,15 +158,8 @@
                 return "Invalid Code (Redundant Item)"
         self.fcode = w
 
-    def doSell(self, frt, pag, r, c, p, i, w):
-        self.sprices = w
-        if self.sprices == "N":
-            self.mkup = "N"
-            self.df1.loadEntry(frt, pag, p+1, data=self.mkup)
-            return "sk1"
-
-    def doMkUp(self, frt, pag, r, c, p, i, w):
-        self.mkup = w
+    def doCosts(self, frt, pag, r, c, p, i, w):
+        self.costs = w
 
     def endPage1(self):
         self.df1.closeProcess()
@@ -229,19 +220,14 @@
         fld.extend([
             (("C",0,0,2),"ONA",16,"Description"),
             (("C",0,0,3),"ONA",10,"U.O.I"),
-            (("C",0,0,4),"OUA",8,"Bin"),
-            (("C",0,0,5),"IUD",9.2,"Unit-Cost","Unit Cost Price",
-                "","N",self.doUcost,None,None,("efld",))])
-        if self.sprices == "Y" and self.mkup == "N":
-            fld.extend([
-                (("C",0,0,6),"IUD",9.2,"Unit-Sell","Unit Selling Price",
-                    "","N",self.doUsell,None,None,("efld",)),
-                (("C",0,0,7),"ISD",9.2,"Quantity","",
-                    "","N",self.doQty,None,None,("efld",))])
+            (("C",0,0,4),"OUA",8,"Bin")])
+        if self.costs == "N":
+            fld.append((("C",0,0,5),"OUD",9.2,"Unit-Cost"))
         else:
-            fld.append(
-                (("C",0,0,6),"ISD",9.2,"Quantity","",
-                    "","N",self.doQty,None,None,("efld",)))
+            fld.append((("C",0,0,5),"IUD",9.2,"Unit-Cost","",
+                "","N",self.doUcost,None,None,("efld",)))
+        fld.append((("C",0,0,6),"ISD",9.2,"Quantity","",
+                "","N",self.doQty,None,None,("efld",)))
         cnd = ((self.endPage2,"y"),)
         cxt = (self.exitPage2,)
         self.df2 = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
@@ -275,28 +261,12 @@
         self.df2.loadEntry("C", 0, p+2, data=ac1[1])
         self.bin = ac2[self.sql.strmf2_col.index("st2_bin")]
         self.df2.loadEntry("C", 0, p+3, data=self.bin)
-        cst, self.usell, qty = self.doGetValues()
-        self.df2.loadEntry("C", 0, p+4, data=cst)
-        if self.sprices == "Y" and self.mkup == "N":
-            self.df2.loadEntry("C", 0, p+5, data=self.usell)
-            self.df2.loadEntry("C", 0, p+6, data=qty)
-        else:
-            self.df2.loadEntry("C", 0, p+5, data=qty)
+        self.ucost, qty = self.doGetValues()
+        self.df2.loadEntry("C", 0, p+4, data=self.ucost)
+        self.df2.loadEntry("C", 0, p+5, data=qty)
 
     def doUcost(self, frt, pag, r, c, p, i, w):
         self.ucost = w
-        if self.sprices == "N" or self.usell:
-            return
-        mup = getMarkup(self.sql, self.opts["conum"], self.group2,
-            self.code2, self.loc, 1)
-        if not mup:
-            return
-        self.usell = round((self.ucost * (100 + mup) / 100.0), 2)
-        if self.mkup == "N":
-            self.df2.loadEntry(frt, pag, p+1, data=self.usell)
-
-    def doUsell(self, frt, pag, r, c, p, i, w):
-        self.usell = w
 
     def doQty(self, frt, pag, r, c, p, i, w):
         self.qty = w
@@ -319,7 +289,7 @@
         if self.sql.getRec("strvar", where=whr, limit=1):
             self.sql.delRec("strvar", where=whr)
         self.sql.insRec("strvar", data=[self.opts["conum"], self.group2,
-            self.code2, self.loc, self.bin, self.qty, self.ucost, self.usell])
+            self.code2, self.loc, self.bin, self.qty, self.ucost, 0])
         self.opts["mf"].dbm.commitDbase()
 
     def doNextOne(self):
@@ -330,16 +300,15 @@
             self.group2 = data[0]
             self.code2 = data[1]
             self.bin = data[4]
-            cst, self.usell, qty = self.doGetValues()
-            if self.sprices == "Y" and self.mkup == "N":
-                mxs = 8
-                data.extend([cst, self.usell, qty])
-            else:
-                mxs = 7
-                data.extend([cst, qty])
+            self.ucost, qty = self.doGetValues()
+            data.extend([self.ucost, qty])
             p = self.df2.pos
-            for x in xrange(0, mxs):
-                self.df2.loadEntry("C", 0, (p-5+x), data=data[x])
+            if self.costs == "N":
+                xs = 6
+            else:
+                xs = 5
+            for x in range(0, 7):
+                self.df2.loadEntry("C", 0, (p + x - xs), data=data[x])
             self.df2.focusField("C", 0, p)
 
     def doGetValues(self):
@@ -354,21 +323,16 @@
                 cst = bal[0]
         else:
             cst, qty = self.doGetCost(self.group2, self.code2)
-        sel = 0
-        if self.sprices == "Y" and self.mkup == "N":
-            strprc = self.sql.getRec("strprc", where=[("stp_cono",
-                "=", self.opts["conum"]), ("stp_group", "=", self.group2),
-                ("stp_code", "=", self.code2), ("stp_loc", "=", self.loc),
-                ("stp_level", "=", 1)], limit=1)
-            if strprc:
-                sel = strprc[self.sql.strprc_col.index("stp_price")]
-        return (cst, sel, qty)
+        return (cst, qty)
 
     def doGetCost(self, grp, code):
-        bals = Balances(self.opts["mf"], "STR", self.opts["conum"],
-            int(self.sysdtw / 100), keys=(grp, code, self.loc))
-        vals = bals.doStrBals()
-        return (vals[7], vals[5][0])
+        if self.costs == "N":
+            ind = "I"
+        else:
+            ind = self.costs
+        cost, bal = getCost(self.sql, self.opts["conum"], grp, code,
+            loc=self.loc, ind=ind, bal=True)
+        return (cost, bal[0])
 
     def exitPage2(self):
         self.df2.closeProcess()

=== modified file 'str/st5030.py' (properties changed: -x to +x)
--- old/str/st5030.py	2020-04-21 08:42:36 +0000
+++ new/str/st5030.py	2020-04-24 10:31:08 +0000
@@ -37,8 +37,8 @@
             self.opts["mf"].startLoop()
 
     def setVariables(self):
-        self.sql = Sql(self.opts["mf"].dbm, ["strmf1", "strtrn", "strvar"],
-            prog=self.__class__.__name__)
+        self.sql = Sql(self.opts["mf"].dbm, ["strloc", "strmf1", "strtrn",
+            "strvar"], prog=self.__class__.__name__)
         if self.sql.error:
             return
         gc = GetCtl(self.opts["mf"])

=== modified file 'str/st5040.py' (properties changed: -x to +x)
--- old/str/st5040.py	2020-04-21 08:42:36 +0000
+++ new/str/st5040.py	2020-06-21 09:51:00 +0000
@@ -119,13 +119,9 @@
                 ("stp_code", "=", code),
                 ("stp_loc", "=", loc),
                 ("stp_level", "=", 1)]
-            prc = self.sql.getRec("strprc", where=whr, limit=1)
-            if prc:
-                self.sql.updRec("strprc", cols=["stp_price"], data=[sell.work],
-                    where=whr)
-            else:
-                self.sql.insRec("strprc", data=[self.opts["conum"], grp, code,
-                    loc, 1, sell.work])
+            self.sql.delRec("strprc", where=whr)
+            self.sql.insRec("strprc", data=[self.opts["conum"], grp, code,
+                loc, 1, sell.work])
         # Test for Variances
         bals = Balances(self.opts["mf"], "STR", self.opts["conum"], self.curdt,
             keys=(grp, code, loc, ("P", self.opts["period"][0])))

=== modified file 'str/st6010.py' (properties changed: -x to +x)
--- old/str/st6010.py	2020-04-21 08:42:36 +0000
+++ new/str/st6010.py	2020-04-28 13:53:31 +0000
@@ -174,7 +174,8 @@
             return "Invalid Code, Does Not exist"
         self.oldcod = w
         self.oldnot = "%3s%s" % (self.oldgrp, w)
-        self.df.loadEntry(frt, pag, p+1, data=acc[4])
+        desc = acc[self.sql.strmf1_col.index("st1_desc")]
+        self.df.loadEntry(frt, pag, p+1, data=desc)
 
     def doNewCod(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec("strmf1", where=[("st1_cono", "=",

=== modified file 'str/st6020.py' (properties changed: -x to +x)
--- old/str/st6020.py	2020-03-01 12:48:20 +0000
+++ new/str/st6020.py	2020-05-28 10:33:31 +0000
@@ -28,7 +28,7 @@
 import time
 from TartanClasses import ASD, Balances, CCD, GetCtl, ProgressBar, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import getMarkup, showError
+from tartanFunctions import showError
 
 class st6020(object):
     def __init__(self, **opts):
@@ -49,8 +49,7 @@
             return
         self.glint = strctl["cts_glint"]
         self.locs = strctl["cts_locs"]
-        self.levels = strctl["cts_plevs"]
-        self.automu = strctl["cts_automu"]
+        self.plevs = strctl["cts_plevs"]
         if self.glint == "Y":
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -72,9 +71,7 @@
                 self.sysdtw,"N",self.doDate,None,None,("efld",)),
             (("T",0,1,0),("IRB",r1s),0,"Cost Method","",
                 "L","N",self.doMethod,None,None,None),
-            (("T",0,2,0),("IRB",r2s),0,"Selling Prices","",
-                "N","N",self.doSell,None,None,None),
-            (("T",0,3,0),("IRB",r2s),0,"Clear Minuses","",
+            (("T",0,2,0),("IRB",r2s),0,"Clear Minuses","",
                 "Y","N",self.doMinus,None,None,None)]
         tnd = ((self.endPage,"y"),)
         txt = (self.exitPage,)
@@ -87,13 +84,6 @@
 
     def doMethod(self, frt, pag, r, c, p, i, w):
         self.method = w
-        if self.automu == "N":
-            self.sell = "N"
-            self.df.loadEntry(frt, pag, p+1, data=self.sell)
-            return "sk1"
-
-    def doSell(self, frt, pag, r, c, p, i, w):
-        self.sell = w
 
     def doMinus(self, frt, pag, r, c, p, i, w):
         self.minus = w
@@ -162,17 +152,6 @@
             rec[2], self.date, rtn, self.cnt, "ST-RVAL", "", dqty, dval, 0,
             self.curdt, txt, 0, "", "", "STR", 0, "", self.opts["capnm"],
             self.sysdtw, 0])
-        if self.sell:
-            self.sql.delRec("strprc", where=[("stp_cono", "=",
-                self.opts["conum"]), ("stp_group", "=", rec[0]),
-                ("stp_code", "=", rec[1]), ("stp_loc", "=", rec[2])])
-            for x in range(self.levels):
-                lev = x + 1
-                mup = getMarkup(self.sql, self.opts["conum"], rec[0], rec[1],
-                    rec[2], lev)
-                prc = round((dval * (100 + mup) / 100.0), 2)
-                self.sql.insRec("strprc", data=[self.opts["conum"], rec[0],
-                    rec[1], rec[2], lev, prc])
         if self.glint == "N":
             self.cnt = self.cnt + 1
             return

=== modified file 'str/st6030.py' (properties changed: -x to +x)
--- old/str/st6030.py	2020-04-21 08:42:36 +0000
+++ new/str/st6030.py	2020-08-04 12:24:16 +0000
@@ -143,8 +143,8 @@
                     where=[("st1_cono", "=", self.opts["conum"]),
                     ("st1_group", "=", rec[0]), ("st1_code", "=", rec[1])])
                 key = "%03i%-3s%-20s" % (self.opts["conum"], rec[0], rec[1])
-                self.sql.insRec("chglog", data=["strmf1", "U", key, "st1_type",
-                dte, self.opts["capnm"], "N", "X", 0])
+                self.sql.insRec("chglog", data=["strmf1", "U", key,
+                    "st1_type", dte, self.opts["capnm"], "N", "X", "", 0])
             p.closeProgress()
             mess = """%s Items Will be Marked as Redundant.
 
@@ -182,15 +182,19 @@
         self.grp = w
 
     def doCode(self, frt, pag, r, c, p, i, w):
+        whr = [
+            ("st1_cono", "=", self.opts["conum"]),
+            ("st1_group", "=", self.grp),
+            ("st1_code", "=", w)]
         if self.flag == "C":
-            typ = "<>"
+            err = "Invalid, Not Normal"
+            whr.append(("st1_type", "=", "N"))
         else:
-            typ = "="
-        chk = self.sql.getRec("strmf1", where=[("st1_cono",
-            "=", self.opts["conum"]), ("st1_group", "=", self.grp),
-            ("st1_code", "=", w), ("st1_type", typ, "X")], limit=1)
+            err = "Invalid, Not Redundant"
+            whr.append(("st1_type", "=", "X"))
+        chk = self.sql.getRec("strmf1", where=whr, limit=1)
         if not chk:
-            return "Invalid Code"
+            return err
         if self.flag == "C":
             qty = self.sql.getRec("strtrn", cols=["sum(stt_qty)"],
                 where=[("stt_cono", "=", self.opts["conum"]),
@@ -199,16 +203,23 @@
             if qty[0]:
                 return "Balance Exists"
         self.cod = w
-        self.df.loadEntry(frt, pag, p+1, data=chk[4])
+        desc = chk[self.sql.strmf1_col.index("st1_desc")]
+        self.df.loadEntry(frt, pag, p+1, data=desc)
 
     def endPage(self):
         if self.flag == "C":
-            typ = "X"
+            old = "N"
+            new = "X"
         else:
-            typ = "N"
-        self.sql.updRec("strmf1", cols=["st1_type"], data=[typ],
+            old = "X"
+            new = "N"
+        self.sql.updRec("strmf1", cols=["st1_type"], data=[new],
             where=[("st1_cono", "=", self.opts["conum"]),
             ("st1_group", "=", self.grp), ("st1_code", "=", self.cod)])
+        dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
+        key = "%03i%-3s%-20s" % (self.opts["conum"], self.grp, self.cod)
+        self.sql.insRec("chglog", data=["strmf1", "U", key,
+            "st1_type", dte, self.opts["capnm"], old, new, "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.clearFrame("T", 0)
         self.flag = ""

=== modified file 'str/st6040.py' (properties changed: -x to +x)
=== modified file 'str/stc110.py' (properties changed: -x to +x)
--- old/str/stc110.py	2020-04-21 08:42:36 +0000
+++ new/str/stc110.py	2020-05-28 15:23:06 +0000
@@ -41,11 +41,14 @@
             return
         mods = ctlmst["ctm_modules"]
         self.genleg = False
+        self.slspos = False
         for x in xrange(0, len(mods), 2):
             if mods[x:x + 2] == "GL":
                 self.genleg = True
-                break
-        tabs = ["strctl", "strloc", "tplmst", "chglog"]
+            elif mods[x:x + 2] == "PS":
+                self.slspos = True
+        tabs = ["strctl", "strloc", "strgmu", "strcmu", "strprc",
+            "tplmst", "chglog"]
         if self.genleg:
             tabs.extend(["ctlctl", "genmst"])
         self.sql = Sql(self.opts["mf"].dbm, tabs, prog=self.__class__.__name__)
@@ -63,6 +66,11 @@
             self.ctl = [
                 ["stk_soh", "Stock on Hand", 0],
                 ["stk_susp", "Stock Reconciliation", 0]]
+            if self.slspos:
+                self.ctl.extend([
+                    ["pos_cash", "Cash Takings", 0],
+                    ["pos_card", "Card Takings", 0],
+                    ["pos_vchr", "Vouchers", 0]])
             ctlctl = gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
                 return
@@ -85,6 +93,7 @@
                 ("tpm_system", "=", "STR")],
             "order": "tpm_tname"}
         r1s = (("Yes","Y"),("No","N"))
+        r2s = (("No","N"),("Last Cost","L"),("Average Cost","A"))
         if self.genleg:
             glm = {
                 "stype": "R",
@@ -103,7 +112,20 @@
                 (("T",0,2,0),"IUI",7,self.ctl[1][1],"",
                     self.ctl[1][2],"N",self.doGenAcc,glm,None,("efld",)),
                 (("T",0,2,0),"ONA",30,"")]
-            seq = 3
+            if self.slspos:
+                fld.extend([
+                    (("T",0,3,0),"IUI",7,self.ctl[2][1],"",
+                        self.ctl[2][2],"N",self.doGenAcc,glm,None,("efld",)),
+                    (("T",0,3,0),"ONA",30,""),
+                    (("T",0,4,0),"IUI",7,self.ctl[3][1],"",
+                        self.ctl[3][2],"N",self.doGenAcc,glm,None,("efld",)),
+                    (("T",0,4,0),"ONA",30,""),
+                    (("T",0,5,0),"IUI",7,self.ctl[4][1],"",
+                        self.ctl[4][2],"N",self.doGenAcc,glm,None,("efld",)),
+                    (("T",0,5,0),"ONA",30,"")])
+                seq = 6
+            else:
+                seq = 3
         else:
             fld = []
             seq = 0
@@ -112,12 +134,13 @@
                 self.acc[2],"N",self.doLocs,None,None,None),
             (("T",0,seq + 1,0),"IUI",1,"Number of Price Levels","",
                 self.acc[3],"N",None,None,None,("between",1,5)),
-            (("T",0,seq + 2,0),("IRB",r1s),0,"Automatic Markup","",
-                self.acc[4],"N",None,None,None,None),
+            (("T",0,seq + 2,0),("IRB",r2s),0,"Automatic Markup","",
+                self.acc[4],"N",None,None,None,None,None,
+                "Calculate Selling Prices Based on Markup Percentages"),
             (("T",0,seq + 3,0),"INA",20,"Orders Template","",
                 self.acc[5],"N",self.doTplNam,tpm,None,None),
             (("T",0,seq + 4,0),"ITX",50,"Email Address","",
-                self.acc[6],"N",None,None,None,None)])
+                self.acc[6],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -141,10 +164,16 @@
             self.df.focusField("T", 0, 1, clr=False)
 
     def doGlint(self, frt, pag, r, c, p, i, w):
+        if self.slspos:
+            idx = 11
+            skp = "sk10"
+        else:
+            idx = 5
+            skp = "sk4"
         if w == "N":
-            for x in xrange(1, 5):
+            for x in xrange(1, idx):
                 self.df.loadEntry(frt, pag, p+x, data="")
-            return "sk4"
+            return skp
 
     def doGenAcc(self, frt, pag, r, c, p, i, w):
         des = self.getDes(w)
@@ -174,9 +203,16 @@
         data = [self.opts["conum"]]
         if not self.genleg:
             data.append("N")
+        if self.genleg:
+            if self.slspos:
+                idx = 11
+                pos = (1, 3, 5, 7, 9)
+            else:
+                idx = 5
+                pos = (1, 3)
         for x, d in enumerate(self.df.t_work[0][0]):
-            if self.genleg and x < 5:
-                if x in (1, 3):
+            if x and self.genleg and x < idx:
+                if x in pos:
                     y = int((x - 1) / 2)
                     chk = self.sql.getRec("ctlctl", where=[("ctl_cono",
                         "=", self.opts["conum"]), ("ctl_code", "=",
@@ -188,30 +224,59 @@
                     else:
                         self.sql.insRec("ctlctl", data=[self.opts["conum"],
                             self.ctl[y][0], self.ctl[y][1], d, "", "N", "N"])
-                elif x in (2, 4):
-                    continue
                 else:
-                    data.append(d)
+                    continue
             else:
                 data.append(d)
         if self.new:
             self.sql.insRec("strctl", data=data)
         elif data != self.acc[:len(data)]:
-            self.sql.updRec("strctl", data=data, where=[("cts_cono", "=",
-                self.opts["conum"])])
+            col = self.sql.strctl_col
+            data.append(self.acc[col.index("cts_xflag")])
+            self.sql.updRec("strctl", data=data, where=[("cts_cono",
+                "=", self.opts["conum"])])
+            # Check and Fix Markup prices
+            plevs = data[self.sql.strctl_col.index("cts_plevs")]
+            automu = data[self.sql.strctl_col.index("cts_automu")]
+            if automu in ("A", "L"):
+                grps = self.sql.getRec("strgrp", cols=["gpm_group"],
+                    where=[("gpm_cono", "=", self.opts["conum"])])
+                for grp in grps:
+                    for lvl in range(1, plevs + 1):
+                        self.sql.delRec("strcmu", where=[("smc_cono",
+                            "=", self.opts["conum"]), ("smc_group",
+                            "=", grp[0]), ("smc_level", "=", lvl),
+                            ("smc_markup", "=", 0)])
+                        gmu = self.sql.getRec("strgmu", cols=["smg_markup"],
+                            where=[("smg_cono", "=", self.opts["conum"]),
+                            ("smg_group", "=", grp[0]), ("smg_level", "=",
+                            lvl)], limit=1)
+                        if gmu:
+                            if not gmu[0]:
+                                self.sql.delRec("strgmu", where=[("smg_cono",
+                                    "=", self.opts["conum"]), ("smg_group",
+                                    "=", grp[0]), ("smg_level", "=", lvl)])
+                            self.sql.delRec("strcmu", where=[("smc_cono",
+                                "=", self.opts["conum"]), ("smc_group", "=",
+                                grp[0]), ("smc_level", "=", lvl),
+                                ("smc_markup", "=", gmu[0])])
+                self.sql.delRec("strprc", where=[("stp_cono", "=",
+                    self.opts["conum"])])
+            # Chglog
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["strctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.strctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         if self.locs == "N":
             acc = self.sql.getRec("strloc", cols=["srl_desc"],
-                where=[("srl_cono", "=", self.opts["conum"]), ("srl_loc", "=",
-                "1")], limit=1)
+                where=[("srl_cono", "=", self.opts["conum"]),
+                ("srl_loc", "=", "1")], limit=1)
             if not acc:
-                self.sql.insRec("strloc", data=[self.opts["conum"], "1",
-                "Location Number One", "", "", "", ""])
+                self.sql.insRec("strloc", data=[self.opts["conum"],
+                    "1", "Location Number One", "", "", "", ""])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'str/stc210.py' (properties changed: -x to +x)
--- old/str/stc210.py	2020-04-21 08:42:36 +0000
+++ new/str/stc210.py	2020-04-23 10:17:07 +0000
@@ -85,8 +85,10 @@
         if self.new == "Y":
             self.sql.insRec("struoi", data=data)
         elif data != self.old[:len(data)]:
-            self.sql.updRec("struoi", data=data, where=[("unm_cono", "=",
-                self.opts["conum"]), ("unm_unit", "=", self.uoi)])
+            col = self.sql.struoi_col
+            data.append(self.old[col.index("unm_xflag")])
+            self.sql.updRec("struoi", data=data, where=[("unm_cono",
+                "=", self.opts["conum"]), ("unm_unit", "=", self.uoi)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'str/stc220.py' (properties changed: -x to +x)
--- old/str/stc220.py	2020-03-01 12:48:20 +0000
+++ new/str/stc220.py	2020-05-27 12:06:28 +0000
@@ -56,9 +56,9 @@
         odr = "unm_unit"
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"],name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=col, order=odr, where=whr, conum=self.opts["conum"],
-            conam=self.opts["conam"], repprt=self.df.repprt)
+            heads=heads, cols=col, order=odr, where=whr,
+            conum=self.opts["conum"], conam=self.opts["conam"],
+            repprt=self.df.repprt)
         self.df.enableButtonsTags(state=state)
         self.closeProcess()
 

=== modified file 'str/stc310.py' (properties changed: -x to +x)
--- old/str/stc310.py	2020-04-21 08:42:36 +0000
+++ new/str/stc310.py	2020-05-28 10:34:14 +0000
@@ -43,7 +43,8 @@
         if not strctl:
             return
         self.glint = strctl["cts_glint"]
-        self.levls = strctl["cts_plevs"]
+        self.plevs = strctl["cts_plevs"]
+        self.automu = strctl["cts_automu"]
         return True
 
     def mainProcess(self):
@@ -84,12 +85,13 @@
                 "","N",self.doCos,glm,None,("notzero",)))
             self.fld.append((("T",0,4,0),"ONA",30,""))
             row = 5
-        self.fld.append((("T",0,row,0),"IUD",5.1,"Mark-Up    Lv1","",
-            "","N",None,None,None,("efld",)))
-        if self.levls > 1:
-            for x in range(1, self.levls):
-                self.fld.append((("T",0,row,0),"IUD",5.1,"Lv%s" % (x+1),"",
-                    "","N",None,None,None,("efld",)))
+        if self.automu in ("A", "L"):
+            self.fld.append((("T",0,row,0),"IUD",5.1,"Mark-Up    Lv1","",
+                "","N",None,None,None,("efld",)))
+            if self.plevs > 1:
+                for x in range(1, self.plevs):
+                    self.fld.append((("T",0,row,0),"IUD",5.1,"Lv%s" % (x+1),"",
+                        "","N",None,None,None,("efld",)))
         but = (
             ("Accept",None,self.doAccept,0,("T",0,2),("T",0,0)),
             ("Cancel",None,self.doCancel,0,("T",0,2),("T",0,0)))
@@ -132,13 +134,15 @@
                     self.df.loadEntry(frt, pag, p+3,
                             data=des[0])
                 p = 7
-            for lev in range(self.levls):
-                mup = self.sql.getRec("strgmu", cols=["smg_markup"],
-                    where=[("smg_cono", "=", self.opts["conum"]), ("smg_group",
-                    "=", self.group), ("smg_level", "=", lev + 1)], limit=1)
-                if not mup:
-                    mup = [0]
-                self.df.loadEntry(frt, pag, p+lev, data=mup[0])
+            if self.automu in ("A", "L"):
+                for lev in range(self.plevs):
+                    mup = self.sql.getRec("strgmu", cols=["smg_markup"],
+                        where=[("smg_cono", "=", self.opts["conum"]),
+                        ("smg_group", "=", self.group), ("smg_level",
+                        "=", lev + 1)], limit=1)
+                    if not mup:
+                        mup = [0]
+                    self.df.loadEntry(frt, pag, p+lev, data=mup[0])
 
     def doVat(self, frt, pag, r, c, p, i, w):
         vat = self.sql.getRec("ctlvmf", cols=["vtm_desc"],
@@ -190,15 +194,18 @@
         if self.new == "Y":
             self.sql.insRec("strgrp", data=data)
         elif data != self.acc[:len(data)]:
-            self.sql.updRec("strgrp", data=data, where=[("gpm_cono", "=",
-            self.opts["conum"]), ("gpm_group", "=", self.group)])
+            col = self.sql.strgrp_col
+            data.append(self.acc[col.index("gpm_xflag")])
+            self.sql.updRec("strgrp", data=data, where=[("gpm_cono",
+                "=", self.opts["conum"]), ("gpm_group", "=", self.group)])
         self.sql.delRec("strgmu", where=[("smg_cono", "=", self.opts["conum"]),
             ("smg_group", "=", self.group)])
-        for lvl, mup in enumerate(self.df.t_work[0][0][x:]):
-            if not mup:
-                continue
-            self.sql.insRec("strgmu", data=[self.opts["conum"], self.group,
-                lvl + 1, mup])
+        if self.automu in ("A", "L"):
+            for lvl, mup in enumerate(self.df.t_work[0][0][x:]):
+                if not mup:
+                    continue
+                self.sql.insRec("strgmu", data=[self.opts["conum"],
+                    self.group, lvl + 1, mup])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'str/stc320.py' (properties changed: -x to +x)
--- old/str/stc320.py	2020-04-21 08:42:36 +0000
+++ new/str/stc320.py	2020-05-27 12:06:44 +0000
@@ -87,9 +87,8 @@
             ["g","NA",30.0,"Description"]]
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=data,
-            heads=heads,
-            cols=cols, conum=self.opts["conum"], conam=self.opts["conam"],
-            ttype="D", repprt=self.df.repprt)
+            heads=heads, cols=cols, conum=self.opts["conum"],
+            conam=self.opts["conam"], ttype="D", repprt=self.df.repprt)
         self.df.enableButtonsTags(state=state)
         self.closeProcess()
 

=== modified file 'str/stc410.py' (properties changed: -x to +x)
--- old/str/stc410.py	2020-04-21 08:42:36 +0000
+++ new/str/stc410.py	2020-04-23 10:19:41 +0000
@@ -105,8 +105,10 @@
         if self.new == "Y":
             self.sql.insRec("strloc", data=data)
         elif data != self.acc[:len(data)]:
-            self.sql.updRec("strloc", data=data, where=[("srl_cono", "=",
-            self.opts["conum"]), ("srl_loc", "=", self.loc)])
+            col = self.sql.strloc_col
+            data.append(self.acc[col.index("srl_xflag")])
+            self.sql.updRec("strloc", data=data, where=[("srl_cono",
+                "=", self.opts["conum"]), ("srl_loc", "=", self.loc)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'str/stc420.py' (properties changed: -x to +x)
--- old/str/stc420.py	2020-03-01 12:48:20 +0000
+++ new/str/stc420.py	2020-05-27 12:07:09 +0000
@@ -56,9 +56,9 @@
         odr = "srl_loc"
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=col, order=odr, where=whr, conum=self.opts["conum"],
-            conam=self.opts["conam"], repprt=self.df.repprt)
+            heads=heads, cols=col, order=odr, where=whr,
+            conum=self.opts["conum"], conam=self.opts["conam"],
+            repprt=self.df.repprt)
         self.df.enableButtonsTags(state=state)
         self.closeProcess()
 

=== added file 'tab/__init__.py'
=== modified file 'tab/tb1010.py' (properties changed: -x to +x)
--- old/tab/tb1010.py	2020-04-21 08:42:36 +0000
+++ new/tab/tb1010.py	2020-08-07 09:26:41 +0000
@@ -26,7 +26,7 @@
 
 import os
 from TartanClasses import RepPrt, Sql, TartanDialog
-from tartanFunctions import askQuestion, copyList, makeArray
+from tartanFunctions import askQuestion, copyList, makeArray, getPrgPath
 from tartanWork import dattyp, tabdic
 
 class tb1010(object):
@@ -188,8 +188,8 @@
 
     def doColSeq(self, frt, pag, r, c, p, i, w):
         self.colseq = w
-        for n, c in enumerate(self.fld[self.colseq][1:]):
-            self.df.loadEntry("C", 1, p + n + 1, data=c)
+        for n, s in enumerate(self.fld[self.colseq][1:]):
+            self.df.loadEntry("C", 1, p + n + 1, data=s)
 
     def endPage1(self):
         pos = int(self.df.col / self.df.colq[1]) - 1
@@ -215,8 +215,8 @@
 
     def doIdxSeq(self, frt, pag, r, c, p, i, w):
         self.idxseq = w
-        for n, c in enumerate(self.idx[self.idxseq][1:]):
-            self.df.loadEntry("C", 2, p + n + 1, data=c)
+        for n, s in enumerate(self.idx[self.idxseq][1:]):
+            self.df.loadEntry("C", 2, p + n + 1, data=s)
 
     def doIdxCol(self, frt, pag, r, c, p, i, w):
         if w and w not in self.valcol:
@@ -256,7 +256,7 @@
                         ddd.append(d)
                 fmt += "\n"
                 tabdic[self.tab]["idx"].append(ddd)
-            fle = os.path.join(self.opts["mf"].rcdic["prgdir"], "stdtab.py")
+            fle = os.path.join(getPrgPath(), "stdtab.py")
             outf = open(fle, "w")
             outf.write("""tabdic = {""")
             tabs = list(tabdic.keys())

=== modified file 'tab/tb1020.py' (properties changed: -x to +x)
--- old/tab/tb1020.py	2020-04-21 08:42:36 +0000
+++ new/tab/tb1020.py	2020-06-21 12:41:03 +0000
@@ -64,7 +64,7 @@
             if self.opts["cln"]:
                 self.doCleanDatabase()
             if self.opts["ver"]:
-                sql = Sql(self.dbm, "verupd", err=False,
+                sql = Sql(self.dbm, "verupd", error=False,
                     prog=self.__class__.__name__)
                 if not sql.getRec("verupd"):
                     sql.insRec("verupd", data=[self.opts["ver"], self.sysdtw])
@@ -90,8 +90,8 @@
                 return
         else:
             self.dbm = self.opts["mf"].dbm
-        self.sql = Sql(self.dbm, ["ffield", "ftable", "verupd"],
-            err=False, prog=self.__class__.__name__)
+        self.sql = Sql(self.dbm, ["ffield", "ftable", "verupd"], error=False,
+            prog=self.__class__.__name__)
         if "verupd" in self.sql.error:
             self.oldver = (0, 0)
         elif self.sql.error:
@@ -301,8 +301,9 @@
         self.dbm.commitDbase()
 
     def doNewTable(self):
-        sql = Sql(self.dbm, self.table, err=False, prog=self.__class__.__name__)
-        if sql.error:
+        sql = Sql(self.dbm, self.table, error=False,
+            prog=self.__class__.__name__)
+        if sql.error or self.table == "ctllog":
             data = None
         else:
             # Read Existing Table
@@ -323,7 +324,7 @@
         DBCreate(dbm=self.dbm, opts=opts)
         ndata = []
         if data:
-            sql = Sql(self.dbm, self.table, err=False,
+            sql = Sql(self.dbm, self.table, error=False,
                 prog=self.__class__.__name__)
             # Create Dictionaries
             olddic = {}
@@ -358,9 +359,15 @@
                         new = old[olddic[nam][0]]
                     elif nam in olddic:
                         try:
-                            new = CCD(old[olddic[nam][0]], typ, siz).work
+                            ccd = CCD(old[olddic[nam][0]], typ, siz)
+                            if ccd.err:
+                                raise Exception
+                            new = ccd.work
                         except:
-                            new = ""
+                            if typ[1].lower() in ("a", "x"):
+                                new = ""
+                            else:
+                                new = 0
                     elif self.table == "ctlrep" and nam == "rep_cono":
                         new = old[olddic["rpm_cono"][0]]
                     elif self.table == "ctlrep" and nam == "rep_code":
@@ -373,6 +380,14 @@
                         new = 1
                     elif self.table == "bwlctl" and nam == "ctb_mscat":
                         new = 0
+                    elif self.table == "bwlgme" and nam == "bcg_sfor":
+                        new = old[olddic["bcg_shots_for"][0]]
+                    elif self.table == "bwlgme" and nam == "bcg_sagt":
+                        new = old[olddic["bcg_shots_agt"][0]]
+                    elif self.table == "bwlgme" and nam == "bcg_a_sfor":
+                        new = old[olddic["bcg_a_shots_for"][0]]
+                    elif self.table == "bwlgme" and nam == "bcg_a_sagt":
+                        new = old[olddic["bcg_a_shots_agt"][0]]
                     elif self.table == "crsmst" and nam == "crm_stat":
                         new = "N"
                     elif self.table == "drsmst" and nam == "drm_stat":
@@ -434,7 +449,7 @@
                     ("rptjon", "rpj_rnam", "rpj_col"),
                     ("rptord", "rpo_rnam", "rpo_column"))
                 for tab in tabs:
-                    sql = Sql(self.dbm, tab[0], err=False,
+                    sql = Sql(self.dbm, tab[0], error=False,
                         prog=self.__class__.__name__)
                     if sql.error:
                         continue
@@ -485,6 +500,42 @@
             self.opts["mf"].updateStatus("")
             if self.opts["bar"]:
                 pb.closeProgress()
+        # Fix Stores Markup
+        tabs = ["ctlmst", "strctl", "strgrp", "strgmu", "strcmu"]
+        sql = Sql(self.dbm, tabs)
+        coys = sql.getRec("ctlmst", cols=["ctm_cono"])
+        for coy in coys:
+            sctl = sql.getRec("strctl", cols=["cts_plevs", "cts_automu"],
+                where=[("cts_cono", "=", coy[0])], limit=1)
+            if sctl:
+                if sctl[1] == "N":
+                    sql.delRec("strgmu", where=[("smg_cono", "=", coy[0])])
+                    sql.delRec("strcmu", where=[("smc_cono", "=", coy[0])])
+                else:
+                    if sctl[1] == "Y":
+                        sql.updRec("strctl", cols=["cts_automu"], data=["L"],
+                            where=[("cts_cono", "=", coy[0])])
+                        sctl[1] = "L"
+                    grps = sql.getRec("strgrp", cols=["gpm_group"],
+                        where=[("gpm_cono", "=", coy[0])])
+                    for grp in grps:
+                        for lvl in range(1, sctl[0] + 1):
+                            sql.delRec("strcmu", where=[("smc_cono", "=",
+                                coy[0]), ("smc_group", "=", grp[0]),
+                                ("smc_level", "=", lvl),
+                                ("smc_markup", "=", 0)])
+                            gmu = sql.getRec("strgmu", cols=["smg_markup"],
+                                where=[("smg_cono", "=", coy[0]), ("smg_group",
+                                "=", grp[0]), ("smg_level", "=", lvl)], limit=1)
+                            if gmu:
+                                if not gmu[0]:
+                                    sql.delRec("strgmu", where=[("smg_cono",
+                                        "=", coy[0]), ("smg_group", "=",
+                                        grp[0]), ("smg_level", "=", lvl)])
+                                sql.delRec("strcmu", where=[("smc_cono",
+                                    "=", coy[0]), ("smc_group", "=", grp[0]),
+                                    ("smc_level", "=", lvl), ("smc_markup",
+                                    "=", gmu[0])])
         # Standard Records
         if self.opts["mf"] and self.opts["mf"].window:
             spl = SplashScreen(self.opts["mf"].body,
@@ -492,16 +543,17 @@
             self.opts["mf"].updateStatus("Creating Standard Records")
         elif self.opts["bar"]:
             print("Creating Standard Records .... Please Wait")
-        sql = Sql(self.dbm, ["ffield", "frelat"], err=False,
+        sql = Sql(self.dbm, ["ffield", "frelat"], error=False,
             prog=self.__class__.__name__)
         if not sql.error:
             sql.sqlRec("Delete from frelat")
             self.doPopulate(sql, "frelat", "_cono")
-        sql = Sql(self.dbm, "wagrcv", err=False, prog=self.__class__.__name__)
+        sql = Sql(self.dbm, "wagrcv", error=False,
+            prog=self.__class__.__name__)
         if not sql.error:
             sql.sqlRec("Delete from wagrcv")
             self.doPopulate(sql, "wagrcv")
-        sql = Sql(self.dbm, ["tplmst", "tpldet"], err=False,
+        sql = Sql(self.dbm, ["tplmst", "tpldet"], error=False,
             prog=self.__class__.__name__)
         if not sql.error:
             for tpl in stdtpl:
@@ -511,7 +563,7 @@
                 sql.insRec("tplmst", data=dat)
             for dat in datdic["tpldet"]:
                 sql.insRec("tpldet", data=dat)
-        sql = Sql(self.dbm, ["wagtxa", "wagtxr"], err=False,
+        sql = Sql(self.dbm, ["wagtxa", "wagtxr"], error=False,
             prog=self.__class__.__name__)
         if not sql.error:
             try:

=== modified file 'tab/tb1030.py' (properties changed: -x to +x)
--- old/tab/tb1030.py	2020-04-21 08:42:36 +0000
+++ new/tab/tb1030.py	2020-06-21 11:38:23 +0000
@@ -227,8 +227,8 @@
                     idx = getattr(self.sqi, "%s_col" % self.table)
                     dat.append(newdata[idx.index(fld)])
             whr = []
-            for num in xrange(len(col)):
-                whr.append((col[num], "=", dat[num]))
+            for num, ccc in enumerate(col):
+                whr.append((ccc, "=", dat[num]))
             chk = self.sqi.getRec(tables=self.table, where=whr)
             if chk:
                 showError(self.opts["mf"].body, "Duplicate Key",

=== modified file 'tab/tb1040.py' (properties changed: -x to +x)
--- old/tab/tb1040.py	2020-04-21 08:42:36 +0000
+++ new/tab/tb1040.py	2020-06-21 11:37:19 +0000
@@ -140,12 +140,11 @@
     def doCopyTables(self):
         p1 = ProgressBar(self.opts["mf"].body, mxs=len(self.tables),
             typ="Copying Database")
-        err = None
         for num, tab in enumerate(self.tables):
             p1.displayProgress(num)
             if tab[0] not in ("ftable", "ffield"):
                 if tab[0] not in tabdic:
-                    print("NO", tab)
+                    print("NO", tab, "in tabdic")
                     continue
                 self.opts["mf"].updateStatus("Adding Table %s" % tab[0])
                 opts = [("-t", tab[0]), ("-x", False)]
@@ -161,12 +160,9 @@
             if dat:
                 p2 = ProgressBar(self.opts["mf"].body, inn=p1, mxs=len(dat),
                     typ="Populating Table %s" % tab[0])
-                err = sqt.insRec(tab[0], data=dat, dofmt=False, pbar=p2)
+                sqt.insRec(tab[0], data=dat, dofmt=False, pbar=p2)
+                self.opts["mf"].dbm.commitDbase()
                 p2.closeProgress()
-                if err:
-                    showError(self.opts["mf"].body, "Table Error", err)
-                if not err:
-                    self.opts["mf"].dbm.commitDbase()
         p1.closeProgress()
 
     def doCloseProcess(self):

=== modified file 'tab/tb3010.py' (properties changed: -x to +x)
--- old/tab/tb3010.py	2020-04-21 08:42:36 +0000
+++ new/tab/tb3010.py	2020-05-27 11:51:35 +0000
@@ -143,8 +143,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__, 0,
-                ext="pdf")
+                self.__class__.__name__, 0, ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=1, pdfnam=pdfnam,
                 header="Table Fields and Indexes", repprt=self.df.repprt,

=== renamed file 'std/tartanFunctions.py' => 'tartanFunctions.py' (properties changed: -x to +x)
--- old/std/tartanFunctions.py	2020-04-21 08:42:36 +0000
+++ new/tartanFunctions.py	2020-10-15 17:17:21 +0000
@@ -27,14 +27,9 @@
 from __future__ import generators
 
 def importTkinter():
-    import sys
     try:
-        if sys.version_info.major == 3:
-            import tkinter as tk
-            import tkinter.ttk as ttk
-        else:
-            import Tkinter as tk
-            import ttk as ttk
+        import tkinter as tk
+        import tkinter.ttk as ttk
         return tk, ttk
     except:
         return None, None
@@ -119,13 +114,14 @@
         default - Whether to return default settings if no file.
     """
 
-    import getpass, os, sys
+    import os, sys
+    from TartanClasses import FITZ
     # Defaults
-    try:
-        user = getpass.getuser()
-    except:
-        user = ""
-    prgdir = getPrgPath()
+    if FITZ:
+        vwr = [""]
+    else:
+        win = os.path.join(getPrgPath(), "uty", "SumatraPDF.exe")
+        vwr = ["/usr/bin/evince", win]
     if sys.platform == "win32":
         tardir = os.path.normpath("C:/Tartan")
     else:
@@ -133,21 +129,17 @@
     opts = {
         "dbase": ["SQLite"],
         "dbname": ["tartan"],
-        "dbhost": ["localhost"],
         "dbdir": [os.path.join(tardir, "fle")],
+        "dbhost": [""],
         "dbport": [""],
-        "dbuser": [user],
+        "dbuser": [""],
         "dbpwd": [""],
-        "prgdir": [prgdir],
         "bupdir": [os.path.join(tardir, "bup")],
         "wrkdir": [os.path.join(tardir, "wrk")],
         "upgdir": [os.path.join(tardir, "upg")],
-        "vwr": ["/usr/bin/evince",
-            os.path.join(prgdir, "uty", "SumatraPDF.exe")],
-        "prn": ["/usr/bin/lp",
-            os.path.join(prgdir, "uty", "SumatraPDF.exe")],
-        "cnv": ["", ""],
-        "exp": ["", ""],
+        "vwr": vwr,
+        "prn": [""],
+        "exp": [""],
         "geo": [0],
         "plc": ["C"],
         "img": ["Y"],
@@ -177,7 +169,7 @@
         "cbg": ["#add8e6"],
         "sfg": ["#000000"],
         "sbg": ["#90ee90"]}
-    pths = ("dbdir", "prgdir", "bupdir", "wrkdir", "upgdir")
+    pths = ("dbdir", "bupdir", "wrkdir", "upgdir")
     # Read and load rcfile
     if not rcfile:
         rcfile = os.environ.get("TARTANRC")
@@ -228,7 +220,7 @@
             if o in ("bfg", "bbg"):
                 but = True
                 continue
-            elif len(opts[o]) == 1 or sys.platform != "win32":
+            if len(opts[o]) == 1 or sys.platform != "win32":
                 rcdic[o] = opts[o][0]
             else:
                 rcdic[o] = opts[o][1]
@@ -236,12 +228,6 @@
             rcdic[o] = int(rcdic[o])
         if o == "acnf" and rcdic[o].lower() == "y":
             rcdic["acnf"] = "L"
-        if o == "prgdir" and rcdic[o].count("_MEI"):
-            # Pyinstaller one file
-            rcdic[o] = prgdir
-        if o in ("vwr", "prn") and rcdic[o].count("_MEI"):
-            # Pyinstaller one file
-            rcdic[o] = os.path.join(prgdir, "uty", os.path.basename(rcdic[o]))
         if o == "errs" and rcdic[o] == "M":
             rcdic[o] = "Y"
     if but:
@@ -271,35 +257,38 @@
         # Create missing directories
         check = []
         for pth in pths:
-            if pth in rcdic and not os.path.isdir(rcdic[pth]):
+            if pth and pth in rcdic and not os.path.isdir(rcdic[pth]):
                 if rcdic[pth] not in check:
                     check.append(rcdic[pth])
         if check:
             try:
                 for d in check:
-                    os.makedirs(d)
+                    if d:
+                        os.makedirs(d)
             except:
-                return "error"
-    rcdic["prgdir"] = getPrgPath()
+                return "makedir (%s)" % d
     return rcdic
 
 def parsePrg(text):
-    prg = text.split(" -")
-    exe = prg[0].strip()
-    if prg[0].count(" "):
-        cmd = ['"%s"' % prg[0].strip()]
+    a = b = 0
+    text = text.strip()
+    if " /" in text:
+        a = text.index(" /")
+    if " -" in text:
+        b = text.index(" -")
+    if a and b:
+        if b > a:
+            exe = text.split(" /")[0]
+        else:
+            exe = text.split(" -")[0]
+    elif a:
+        exe = text.split(" /")[0]
+    elif b:
+        exe = text.split(" -")[0]
     else:
-        cmd = [prg[0].strip()]
-    if len(prg) > 1:
-        d = False
-        for x in prg[1:]:
-            if x == "-":
-                d = True
-            elif d:
-                d = False
-                cmd.append("--%s" % x.strip())
-            else:
-                cmd.append("-%s" % x.strip())
+        exe = text
+    cmd = [exe]
+    cmd.extend(text.replace(exe, "").strip().split())
     return exe, cmd
 
 def showException(scrn, path, mess, maxTB=None, xits=None, dbm=None):
@@ -320,7 +309,10 @@
         t = time.localtime()
         t = time.strftime("Date: %Y-%m-%d Time: %H:%M:%S", t)
         host = platform.uname()[1]
-        user = getpass.getuser()
+        try:
+            user = getpass.getuser()
+        except:
+            user = "Unknown"
         onam = platform.platform()
         fnam = os.path.join(path, "errors.txt")
         if os.path.isfile(fnam):
@@ -358,9 +350,9 @@
                 pass
             if opened:
                 dbm.closeDbase()
-    if sys.version_info.major == 3:
+    try:
         title = str(sys.exc_info()[0])
-    else:
+    except:
         title = str(sys.exc_type)
     cla, exc, trbk = sys.exc_info()
     if type(cla) == str:
@@ -381,7 +373,7 @@
     excMess = ""
     for ta in excTb:
         excMess = excMess + ta + "\012"
-    mess = mess + "\012\012%s\012%s\012%s" % (excMess, excName, excArgs)
+    mess = str(mess) + "\n\n%s\n%s\n%s" % (excMess, excName, excArgs)
     if path:
         doSaveExc()
     if scrn:
@@ -519,8 +511,8 @@
      attach = A list of attachments
      skip   = Skip mail errors
      """
-    import os, sys, time
-    from TartanClasses import Dbase, SplashScreen, Sql
+    import os, subprocess, sys, time
+    from TartanClasses import Dbase, ViewPDF, SplashScreen, Sql
 
     # Email Document
     sp = None
@@ -579,7 +571,7 @@
                     subj = "PDF Report"
             while not ok:
                 if splash:
-                    sp = SplashScreen(mf.body,
+                    sp = SplashScreen(mf.window.focus_displayof(),
                         "E-Mailing the Report to:\n\n%s\n\nPlease Wait....." %
                         toad[0])
                 if not attach or not attach[0]:
@@ -592,9 +584,10 @@
                     if skip:
                         ok = "SKIPPED"
                     else:
-                        ok = askQuestion(mf.window, "E-Mail Error", "Problem "\
-                            "Delivering This Message.\n\nTo: %s\nSubject: "\
-                            "%s\n\nWould You Like to Retry?" % (toad, subj))
+                        ok = askQuestion(mf.window.focus_displayof(),
+                            "E-Mail Error", "Problem Delivering This "\
+                            "Message.\n\nTo: %s\nSubject: %s\n\nWould "\
+                            "You Like to Retry?" % (toad, subj))
                         if ok == "yes":
                             ok = None
                         else:
@@ -620,86 +613,77 @@
             pass
         if repeml[4].lower() == "n":
             return
-    # Print/View Document
+    if repprt and (repprt[1].lower() == "x" or repprt[2] == "export"):
+        return
+    if repprt and repprt[2] and repprt[2].lower() == "none":
+        return
     try:
-        if repprt and (repprt[1].lower() == "x" or repprt[2] == "export"):
-            return
         if repprt and (repprt[1].lower() == "v" or repprt[2] == "view"):
-            # Execute viewer command
+            # View Document
             chk = pdfnam.split(".")[-1]
             if chk == "svg":
                 import webbrowser
                 webbrowser.open_new(pdfnam)
             else:
-                vwr = mf.rcdic["vwr"]
-                if sys.platform == "win32" and not os.path.exists(vwr):
-                    vwr = os.path.join(getPrgPath(), "uty", "SumatraPDF.exe")
-                exe, cmd = parsePrg(vwr)
-                if not os.path.isfile(cmd[0]):
-                    raise Exception
-                cmd.append(pdfnam)
-                os.spawnv(os.P_WAIT, exe, tuple(cmd))
-        elif repprt and (repprt[2] and repprt[2].lower() != "none"):
-            if splash:
-                sp = SplashScreen(mf.body,
-                    "Printing the Report\n\n           Please Wait....")
-            cnv = mf.rcdic["cnv"]
-            prn = mf.rcdic["prn"]
-            if sys.platform == "win32" and not os.path.exists(prn):
-                cnv = ""
-                prn = os.path.join(getPrgPath(), "uty", "SumatraPDF.exe")
-            if cnv:
-                # Convert pdf to ps
-                exe, cmd = parsePrg(mf.rcdic["cnv"])
-                cmd.append(pdfnam)
-                pfl = pdfnam.replace(".pdf", ".ps")
-                cmd.append(pfl)
-                os.spawnv(os.P_WAIT, exe, tuple(cmd))
-            else:
-                pfl = pdfnam
-            exe, cmd = parsePrg(prn)
-            if not os.path.isfile(cmd[0]):
-                raise Exception
+                ViewPDF(mf, pdfnam)
+            return
+        # Print Document
+        if splash:
+            sp = SplashScreen(mf.window.focus_displayof(),
+                "Printing the Report\n\nPlease Wait....")
+        if repprt[2] == "Default":
             if sys.platform == "win32":
-                # Windows
-                if repprt[2] == "Default":
-                    from win32print import GetDefaultPrinter
-                    repprt[2] = GetDefaultPrinter()
-                if exe.lower().count("acrord32"):
-                    cmd.extend(["/t", pfl, '"%s"' % repprt[2]])
-                elif exe.lower().count("sumatra"):
-                    cmd.extend(["-print-to", '"%s"' % repprt[2], pfl])
-                elif exe.lower().count("gsprint"):
-                    cmd.extend(["-printer", '"%s"' % repprt[2], pfl])
-                elif exe.lower().count("foxit"):
-                    cmd.extend(["/t", pfl, '"%s"' % repprt[2]])
-                elif exe.lower().count("redpr"):
-                    cmd.extend(["-P", '"%s"' % repprt[2], pfl])
-                elif exe.lower().count("pdfp"):
-                    cmd.extend(["-p", '"%s"' % repprt[2], pfl])
-                else:
-                    cmd.append(pfl)
-            elif mf.rcdic["cnv"]:
-                # Linux with pdf convert
-                if repprt[2] == "Default":
-                    cmd.append(pfl)
-                else:
-                    cmd.extend([("-P%s" % repprt[2]), (pfl)])
-            elif repprt[2] == "Default":
-                # Linux without pdf convert using default printer
-                cmd.append(pfl)
+                import win32print
+                prt = win32print.GetDefaultPrinter()
             else:
-                # Linux without pdf convert using selected printer
-                cmd.extend(["-P", repprt[2], pfl])
-            os.spawnv(os.P_NOWAIT, exe, tuple(cmd))
-            if splash:
-                sp.closeSplash()
-    except:
-        if splash and sp:
-            sp.closeSplash()
-        showException(mf.body, mf.rcdic["wrkdir"],
-            "Output Error\n\nVwr: %s\nCnv: %s\nPrn: %s" %
-            (mf.rcdic["vwr"], mf.rcdic["cnv"], mf.rcdic["prn"]))
+                proc = subprocess.Popen("lpstat -d", shell=True, bufsize=0,
+                    stdin=subprocess.PIPE, stdout=subprocess.PIPE,
+                    stderr=subprocess.PIPE, close_fds=True)
+                prt = proc.stdout.readline()
+                if type(prt) == bytes:
+                    prt = prt.decode("utf-8")
+                prt = prt.strip().split(":")
+                if len(prt) != 2:
+                    raise Exception("No Default Printer")
+                prt = prt[1].strip()
+        else:
+            prt = repprt[2]
+        prn = mf.rcdic["prn"]
+        if prn:
+            exe, chk = parsePrg(prn)
+            if not os.path.exists(exe):
+                prn = None
+        if prn:
+            cmd = []
+            fle = False
+            for c in chk:
+                if "%p%" in c:
+                    c = c.replace("%p%", prt)
+                if "%f%" in c:
+                    fle = True
+                    c = c.replace("%f%", pdfnam)
+                cmd.append(c)
+            if exe.lower().count("sumatra") and len(cmd) == 1:
+                cmd.extend(["-print-to", "%s" % prt, pdfnam])
+            elif exe.lower().count("foxit") and len(cmd) == 1:
+                cmd.extend(["/t", pdfnam, prt])
+            elif cmd[0].endswith("lp") and len(cmd) == 1:
+                cmd.extend(["-d", prt, pdfnam])
+            elif cmd[0].endswith("lpr") and len(cmd) == 1:
+                cmd.extend(["-P", prt, pdfnam])
+            elif not fle:
+                cmd.append(pdfnam)
+            subprocess.Popen(cmd, stdout=subprocess.PIPE)
+        else:
+            printPDF(prt, pdfnam)
+        if splash and sp:
+            sp.closeSplash()
+    except Exception as err:
+        if splash and sp:
+            sp.closeSplash()
+        showException(mf.window.focus_displayof(), mf.rcdic["wrkdir"],
+            "Output Error %s\n\nVwr: %s\nPrn: %s\n" % (err, mf.rcdic["vwr"],
+            mf.rcdic["prn"]))
 
 def textFormat(text, width=30, blong=True):
     """
@@ -741,7 +725,7 @@
                     elif flenam.lower() == name.lower():
                         return os.path.join(root, flenam)
 
-def sendMail(server, ex, to, subj, mess="", attach=[], embed=[], check=False, timeout=30, local=None, err=False, wrkdir="."):
+def sendMail(server, ex, to, subj, mess="", attach=None, embed=None, check=False, timeout=30, local=None, err=False, wrkdir="."):
     """
     A routine to email a message, embed files and/or attach files.
 
@@ -759,21 +743,21 @@
         err     = The widget to display the exception, defaults to False
         wrkdir  = The work directory, defaults to "."
     """
-    import mimetypes, os, smtplib, socket, sys
-    if sys.version_info.major == 2 and sys.version_info.minor < 6:
+    import mimetypes, os, smtplib, socket
+    try:
+        from email import encoders as Encoders
+        from email.mime.base import MIMEBase
+        from email.mime.text import MIMEText
+        from email.mime.image import MIMEImage
+        from email.mime.multipart import MIMEMultipart
+        from email.utils import COMMASPACE, formatdate
+    except:
         from email import Encoders
         from email.MIMEBase import MIMEBase
         from email.MIMEText import MIMEText
         from email.MIMEImage import MIMEImage
         from email.MIMEMultipart import MIMEMultipart
         from email.Utils import COMMASPACE, formatdate
-    else:
-        from email import encoders as Encoders
-        from email.mime.base import MIMEBase
-        from email.mime.text import MIMEText
-        from email.mime.image import MIMEImage
-        from email.mime.multipart import MIMEMultipart
-        from email.utils import COMMASPACE, formatdate
 
     def mysubj(subj):
         words = subj.split()
@@ -804,16 +788,19 @@
         if check:
             smtp.quit()
             return True
-    except:
-        if not check and err:
-            showException(err, wrkdir, "Mail Server (%s %s) "\
-                "Invalid or Unavailable" % (host, port))
+    except Exception as chk:
+        showException(err, wrkdir, "Mail Server (%s %s) "\
+            "Invalid or Unavailable\n\n%s" % (host, port, chk))
         return
     if type(to) == str:
         to = [to]
-    if type(attach) == str:
+    if attach is None:
+        attach = []
+    elif type(attach) == str:
         attach = [attach]
-    if type(embed) == str:
+    if embed is None:
+        embed = []
+    elif type(embed) == str:
         embed = [embed]
     msgRoot = MIMEMultipart("mixed")
     msgRoot["From"] = ex
@@ -823,7 +810,7 @@
         int(subj[:3])
         subj = subj[4:]
     except:
-        subj = subj
+        pass
     subj = subj.replace("'", "").replace("(", " ").replace(")", " ")
     if not mess:
         if attach:
@@ -1039,21 +1026,19 @@
         start = 0
     pos = -1
     while pos == -1:
-        for p in xrange(start, len(text)):
+        for p in range(start, len(text)):
             c = text[p]
             # If the label is Exit, try and make x the hot key
             if text == "Exit" and c == "E" and "X" not in used:
                 continue
-            if (ord(c) in xrange(65, 91) or \
-                    ord(c) in xrange(97, 123)) and \
-                    c.upper() not in used:
+            if ord(c.upper()) in range(65, 91) and c.upper() not in used:
                 if not widget:
                     used.append(c.upper())
                 pos = p
                 break
         if pos == -1:
             more = False
-            for x in xrange(65, 91):
+            for x in range(65, 91):
                 if chr(x) not in used:
                     text = "%s %s" % (text, chr(x))
                     more = True
@@ -1062,33 +1047,48 @@
                 break
     return text, pos
 
-def showPrinters(wrkdir="."):
+def getPrinters(wrkdir="."):
     """
     Function to return all avalaible printers.
     """
-    import sys
-    data = ["None", "Default"]
-    if sys.platform == "win32":
-        try:
+    import subprocess, sys
+    data = []
+    try:
+        if sys.platform == "win32":
+            import win32print
+            win32print.GetDefaultPrinter()
+        else:
+            proc = subprocess.Popen("lpstat -d", shell=True, bufsize=0,
+                stdin=subprocess.PIPE, stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE, close_fds=True)
+            prt = proc.stdout.readline()
+            if type(prt) == bytes:
+                prt = prt.decode("utf-8")
+            prt.strip().split(":")[1]
+        data.append("Default")
+    except:
+        pass
+    try:
+        if sys.platform == "win32":
             from win32print import EnumPrinters
             lst = EnumPrinters(2)
             for l in lst:
                 data.append(l[2].strip())
-        except:
-            showException(None, wrkdir, "Show Printer Error")
-    else:
-        try:
+        else:
             import subprocess
             proc = subprocess.Popen("lpstat -a", shell=True, bufsize=0,
-                stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
+                stdin=subprocess.PIPE, stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE, close_fds=True)
             lst = proc.stdout.readlines()
             for l in lst:
-                l = str(l.rstrip()).replace('"', "").replace("'", "")
+                if type(l) == bytes:
+                    l = l.decode("utf-8")
+                l = l.rstrip().replace('"', "").replace("'", "")
                 if l.count("accepting requests"):
                     p = l.split()
                     data.append(p[0].strip())
-        except:
-            showException(None, wrkdir, "Show Printer Error")
+    except:
+        showException(None, wrkdir, "Get Printer Error")
     return data
 
 def removeFunctions(nam, dec=0):
@@ -1376,9 +1376,9 @@
         if pwd:
             cf = PwdConfirm(mf, conum=coy, system="GEN", code="CtlAcc")
             if not cf.pwd or cf.flag == "no":
-                return "%s Is An Integrated Control Account" % acc
+                return "%s Is A Control Account" % acc
         else:
-            return "%s Is An Integrated Control Account" % acc
+            return "%s Is A Control Account" % acc
     return rec
 
 def chkAggregate(fld):
@@ -1435,18 +1435,13 @@
 def runModule(mod, **popt):
     import importlib
     try:
-        # Python 2
-        com = importlib.import_module(mod)
-    except:
-        # Python 3
-        try:
-            from tartanWork import pkgs
-            pkg = pkgs[mod[:2]]
-            com = importlib.import_module("..%s" % mod, "%s.subpkg" % pkg)
-        except:
-            return
-    exe = getattr(com, mod)
-    return exe(**popt)
+        from tartanWork import pkgs
+        pkg = pkgs[mod[:2]]
+        com = importlib.import_module("..%s" % mod, "%s.subpkg" % pkg)
+        exe = getattr(com, mod)
+        exe(**popt)
+    except Exception as err:
+        return err
 
 def doChkCatChg(mf, cono, memno, nxtdt):
     from TartanClasses import Sql
@@ -1547,40 +1542,28 @@
     """
     import os, sys
 
-    def viewFile(name, wait):
-        if args["rcdic"] and args["rcdic"]["exp"]:
-            exe, cmd = parsePrg(args["rcdic"]["exp"])
-            if not os.path.isfile(exe):
-                exe = None
-        else:
-            exe = None
-        if not exe:
-            err = False
-            if sys.platform == "win32":
-                try:
+    def viewFile(exe, cmd, name, wait):
+        if not cmd:
+            try:
+                if sys.platform == "win32":
                     os.startfile(name)
-                except:
-                    err = True
-            else:
-                try:
-                    os.spawnv(wait, "xdg-open %s" % name)
-                except:
-                    if os.path.isfile("/usr/bin/ooffice"):
-                        os.spawnv(wait, "/usr/bin/ooffice",
-                            ("ooffice", name))
-                    elif os.path.isfile("/usr/bin/libreoffice"):
-                        os.spawnv(wait, "/usr/bin/libreoffice",
-                            ("libreoffice", name))
+                else:
+                    import subprocess
+                    if wait:
+                        subprocess.call(["xdg-open", name])
                     else:
-                        err = True
-            if err:
-                showError(None, "Error", "No Valid Export Application")
+                        subprocess.Popen(["xdg-open", name])
+            except Exception as err:
+                showError(None, err, "No Valid Export Application")
             return
         try:
-            cmd.append(name)
-            os.spawnv(wait, exe, tuple(cmd))
-        except:
-            showError(None, "Error", "The Application"\
+            import subprocess
+            if wait:
+                subprocess.call(cmd + [name])
+            else:
+                subprocess.Popen(cmd + [name])
+        except Exception as err:
+            showError(None, err, "The Application"\
                 "\n\n%s\n\nIs Not Found or Not Accessible" % exe)
             return
 
@@ -1588,10 +1571,17 @@
         view = True
     else:
         view = args["view"]
-    if "wait" not in args or not args["wait"]:
-        wait = os.P_NOWAIT
+    if view:
+        if args["rcdic"] and args["rcdic"]["exp"]:
+            exe, cmd = parsePrg(args["rcdic"]["exp"])
+            if not os.path.isfile(exe):
+                exe = cmd = None
+        else:
+            exe = cmd = None
+    if "wait" not in args:
+        wait = False
     else:
-        wait = os.P_WAIT
+        wait = args["wait"]
     if type(args["xtype"]) == str:
         args["xtype"] = [args["xtype"]]
     types = []
@@ -1599,8 +1589,9 @@
         types.append(t.upper())
 
     if "C" in types:
-        flenam = open(args["name"] + ".csv", "w")
         head = ""
+        name = args["name"] + ".csv"
+        flenam = open(name, "w")
         for valc in args["colsh"][-1]:
             if type(valc) in (list, tuple):
                 text = valc[0]
@@ -1637,7 +1628,7 @@
         flenam.close()
         if view and "X" not in types:
             # View the csv file
-            viewFile(args["name"] + ".csv", wait)
+            viewFile(exe, cmd, name, wait)
         if "X" not in types:
             return
 
@@ -1686,10 +1677,7 @@
             else:
                 sheet.write(rowx, 0, valx, hxf)
             rowx += 1
-            if valx:
-                blank = True
-            else:
-                blank = False
+            blank = bool(valx)
         if blank:
             rowx += 1
         # Column headings
@@ -1846,10 +1834,11 @@
                     sheet.write(rowx, colx, valx,
                         getStyle(hxf, num=xf_map[args["forms"][colx][0]]))
         # Save the spreadsheet
+        name = args["name"] + ".xls"
         book.save(args["name"] + ".xls")
         # View the spreadsheet
         if view:
-            viewFile(args["name"] + ".xls", wait)
+            viewFile(exe, cmd, name, wait)
 
 def ftpDownload(server, srce, name=None, word=None, dest=None, close=False, check=False):
     import ftplib
@@ -1862,10 +1851,7 @@
     try:
         ftp = ftplib.FTP(server, name, word)
         if check:
-            if srce in ftp.nlst():
-                found = True
-            else:
-                found = False
+            found = bool(srce in ftp.nlst())
         else:
             if close:
                 ofle = open(dest, "wb")
@@ -2101,9 +2087,11 @@
             break
     return code
 
-def getGreens(text, needed, keep=[]):
+def getGreens(text, needed, keep=None):
     if not text:
         return None, None, None, "No Greens Entered"
+    if keep is None:
+        keep = []
     greens = {}
     rinks = 0
     grns = text.split(",")
@@ -2283,6 +2271,242 @@
     if recs:
         return recs[-1][0]
 
+def getCost(sql, cono, group, code, loc=None, qty=1, ind="I", recp=False, tot=False, bal=False):
+    """
+    recp    True or Line of a Sales Document which is a Recipe
+                 [document type [I/C/O/W/Q], docno, lineno]
+    qty     The number of items
+    ind     "L" - Only return Last Cost
+            "A" - Only return Average Cost
+            "I" - Only return Value Indicator Cost
+            ( )   or a tuple of indicators e.g. ("A", "L")
+    tot     True - Return total cost
+    bal     True - Return Quantity and Cost balances
+    """
+    from TartanClasses import ASD, CCD
+    # Check for Recipe
+    if not recp:
+        chk = sql.getRec("strmf1", cols=["st1_type"], where=[("st1_cono",
+            "=", cono), ("st1_group", "=", group), ("st1_code", "=", code)],
+            limit=1)
+        if chk[0] == "R" and loc:
+            recp = True
+    if recp:
+        # Recipe
+        items = []
+        if type(recp) in (list, tuple) and "slsiv3" in sql.tables:
+            tab = "slsiv3"
+            col = ["si3_rgroup", "si3_rcode", "si3_rqty"]
+            whr = [
+                ("si3_cono", "=", cono),
+                ("si3_rtn", "=", recp[0]),
+                ("si3_docno", "=", recp[1]),
+                ("si3_seq", "=", recp[2])]
+            items = sql.getRec(tab, cols=col, where=whr)
+        if not items:
+            tab = "strrcp"
+            col = ["srr_rgroup", "srr_rcode", "srr_rqty"]
+            whr = [
+                ("srr_cono", "=", cono),
+                ("srr_group", "=", group),
+                ("srr_code", "=", code),
+                ("srr_loc", "=", loc)]
+            items = sql.getRec(tab, cols=col, where=whr)
+    else:
+        # Single Item
+        items = [[group, code, qty]]
+    # Variables
+    acost = 0
+    lcost = 0
+    scost = 0
+    tcost = 0
+    csts = []
+    for c in ind:
+        csts.append(c)
+    # Items
+    for ggg, ccc, qqq in items:
+        ac = 0
+        lc = 0
+        sc = 0
+        tc = 0
+        vin = sql.getRec("strmf1", cols=["st1_value_ind"],
+            where=[("st1_cono", "=", cono), ("st1_group",
+            "=", ggg), ("st1_code", "=", ccc)], limit=1)
+        if vin[0] == "N":
+            idx = len(csts)
+            csts = []
+            for _ in range(idx):
+                csts.append("N")
+        elif "I" in csts:
+            csts = [vin[0]]
+        elif vin[0] == "S" and "A" in csts:
+            csts[csts.index("A")] = vin[0]
+        # Cost Prices
+        where = [
+            ("stt_cono", "=", cono),
+            ("stt_group", "=", ggg),
+            ("stt_code", "=", ccc)]
+        grp = "stt_cono, stt_group, stt_code"
+        if loc:
+            where.append(("stt_loc", "=", loc))
+            grp += ", stt_loc"
+        bals = sql.getRec("strtrn", cols=["sum(stt_qty)", "sum(stt_cost)"],
+            where=where, group=grp, limit=1)
+        if not bals:
+            bals = [0, 0]
+        if "A" in csts:
+            # Average Cost
+            if bals[0] and qqq == bals[0]:
+                ac = round((bals[1] / qty), 2)
+                tc = bals[1]
+            elif bals[0]:
+                ac = round((bals[1] / bals[0]), 2)
+        if "L" in csts:
+            # Last Cost
+            whr = where[:]
+            whr.append(("stt_type", "in", (1, 3)))
+            chk = sql.getRec("strtrn", cols=["stt_qty", "stt_cost"], where=whr,
+                order="stt_capdt desc, stt_seq desc")
+            for rec in chk:
+                q = CCD(rec[0], "SD", 11.2)
+                c = CCD(rec[1], "SD", 11.2)
+                if q.work and q.work > 0 and c.work:
+                    lc = round((c.work / q.work), 2)
+                    break
+        if "S" in csts:
+            # Standard Cost
+            whr = [
+                ("stc_cono", "=", cono),
+                ("stc_group", "=", ggg),
+                ("stc_code", "=", ccc)]
+            if loc:
+                whr.append(("stc_loc", "=", loc))
+            std = sql.getRec("strcst", cols=["stc_cost"], where=whr, limit=1)
+            if std:
+                sc = std[0]
+        if recp:
+            if tc:
+                acost = float(ASD(acost) + ASD(tc))
+                tcost = float(ASD(tcost) + ASD(tc))
+            else:
+                acost = float(ASD(acost) + ASD(round(ac * qqq, 2)))
+            lcost = float(ASD(lcost) + ASD(round(lc * qqq, 2)))
+            scost = float(ASD(scost) + ASD(round(sc * qqq, 2)))
+        else:
+            acost = ac
+            lcost = lc
+            scost = sc
+            tcost = tc
+    prcs = []
+    vals = []
+    if recp:
+        bals = [1, 0]
+    for flg in csts:
+        if flg == "A":
+            prcs.append(acost)
+            if tcost:
+                vals.append(tcost)
+            else:
+                vals.append(round(qty * acost, 2))
+        elif flg in ("Y", "L"):
+            prcs.append(lcost)
+            vals.append(round(qty * lcost, 2))
+        elif flg == "S":
+            prcs.append(scost)
+            vals.append(round(qty * scost, 2))
+        elif flg == "N":
+            prcs.append(0)
+            vals.append(0)
+    if len(csts) == 1:
+        if tot:
+            if bal:
+                return prcs[0], vals[0], bals
+            else:
+                return prcs[0], vals[0]
+        elif bal:
+            return prcs[0], bals
+        else:
+            return prcs[0]
+    elif tot:
+        if bal:
+            return prcs, vals, bals
+        else:
+            return prcs, vals
+    elif bal:
+        return prcs, bals
+    else:
+        return prcs
+
+def getSell(sql, cono, group, code, loc=None, lvl=1, recp=False, ind=None):
+    """
+    recp   - True or Line of a Sales Document which is a Recipe
+                 [document type [I/C/O/W/Q], docno, lineno]
+    ind    - None - Price Level (1), Marked Up Price (2) or Last Price (3)
+             "P"  - Price Level Only (Can Return Zero)
+             "L"  - Last Price Only (Can Return Zero)
+    """
+    from TartanClasses import CCD
+    # Check for Recipe
+    if not recp:
+        chk = sql.getRec("strmf1", cols=["st1_type"], where=[("st1_cono",
+            "=", cono), ("st1_group", "=", group), ("st1_code", "=", code)],
+            limit=1)
+        if chk[0] == "R":
+            recp = True
+    # Check Price Record
+    prc = sql.getRec("strprc", cols=["stp_price"], where=[("stp_cono",
+        "=", cono), ("stp_group", "=", group), ("stp_code", "=", code),
+        ("stp_loc", "=", loc), ("stp_level", "=", lvl)], limit=1)
+    if prc and prc[0]:
+        # Price Level
+        return prc[0]
+    elif ind == "P":
+        return 0
+    # Last Selling Price
+    lst = 0
+    where = [
+        ("stt_cono", "=", cono),
+        ("stt_group", "=", group),
+        ("stt_code", "=", code),
+        ("stt_loc", "=", loc)]
+    whr = where[:]
+    whr.append(("stt_type", "in", (7, 8)))
+    whr.append(("stt_sell", "<>", 0))
+    chk = sql.getRec("strtrn", cols=["stt_qty", "stt_sell"], where=whr,
+        order="stt_capdt desc")
+    for rec in chk:
+        qty = CCD(rec[0], "SD", 11.2)
+        sel = CCD(rec[1], "SD", 11.2)
+        if qty.work < 0 and sel.work:
+            lst = round((sel.work / qty.work), 2)
+            break
+    # Check for Automatic Markups
+    ctl = sql.getRec("strctl", cols=["cts_automu"], where=[("cts_cono",
+        "=", cono)], limit=1)
+    mui = ctl[0]
+    if mui == "A":
+        chk = sql.getRec("strmf1", cols=["st1_value_ind"], where=[("st1_cono",
+            "=", cono), ("st1_group", "=", group), ("st1_code", "=", code)],
+            limit=1)
+        if chk[0] == "S":
+            mui = "S"
+    if not recp and (mui == "N" or ind == "L"):
+        # Not a Recipe and ind=L or No Markups
+        return lst
+    # Markup Prices
+    prc = 0
+    if mui in ("A", "L", "S") and not prc:
+        # Cost Price
+        cst = getCost(sql, cono, group, code, loc, ind=mui, recp=recp)
+        if cst:
+            # Price Markup
+            mkp = getMarkup(sql, cono, group, code, loc, lvl)
+            if mkp:
+                prc = round((cst * (100 + mkp) / 100.0), 2)
+    if not prc:
+        return lst
+    return prc
+
 def getMarkup(sql, cono, group, code, loc, level):
     mkp = 0
     gpm = sql.getRec("strgmu", cols=["smg_markup"], where=[("smg_cono",
@@ -2354,7 +2578,9 @@
 def copyList(orig):
     import copy, inspect
 
-    def myCopy(orig, newo):
+    def myCopy(orig, newo=None):
+        if newo is None:
+            newo = []
         for x in orig:
             if type(x) in (list, tuple):
                 newx = []
@@ -2498,7 +2724,7 @@
                 lout = {}
                 doprint(style.layout(wid), 0)
                 keys = list(lout.keys())
-                keys.sort
+                keys.sort()
                 for key in keys:
                     opts = lout[key]
                     if opts[0].split(".")[-1] == typ:
@@ -2560,5 +2786,148 @@
             ScrollHtml(scrn=scrn, mess=html, horizontal="auto")
     except:
         return
+
+def doAutoAge(dbm, system, cono=None, chain=None, acno=None, pbar=None):
+    from TartanClasses import ASD, Sql
+    tab = "%strn" % system
+    age = "%sage" % system
+    sql = Sql(dbm, [tab, age],  __name__)
+    col = getattr(sql, "%s_col" % tab)
+    if system == "crs":
+        pfx = "crt"
+        sql.delRec(age, where=[("cra_cono", "=", cono),
+            ("cra_acno", "=", acno)])
+        whr = [
+            ("crt_cono", "=", cono),
+            ("crt_acno", "=", acno)]
+    elif system == "drs":
+        pfx = "drt"
+        sql.delRec(age, where=[("dra_cono", "=", cono),
+            ("dra_chain", "=", chain), ("dra_acno", "=", acno)])
+        whr = [
+            ("drt_cono", "=", cono),
+            ("drt_chain", "=", chain),
+            ("drt_acno", "=", acno)]
+    else:
+        pfx = "mlt"
+        sql.delRec(age, where=[("mta_cono", "=", cono),
+            ("mta_memno", "=", acno)])
+        whr = [
+            ("mlt_cono", "=", cono),
+            ("mlt_memno", "=", acno)]
+    crw = whr[:]
+    crw.append(("%s_tramt" % pfx, "<", 0))
+    drw = whr[:]
+    drw.append(("%s_tramt" % pfx, ">", 0))
+    cdt = "%s_curdt" % pfx
+    amt = "%s_tramt" % pfx
+    cr = sql.getRec(tab, where=crw)             # Credit transactions
+    if cr:
+        dr = sql.getRec(tab, where=drw)         # Debit transactions
+        if dr:
+            for cno, ctr in enumerate(cr):      # For each credit transaction
+                if pbar:
+                    pbar.displayProgress()
+                ccdt = ctr[col.index(cdt)]      # Current period
+                cbal = ctr[col.index(amt)]      # Credit amount
+                camt = cbal                     # Amount to allocate
+                for dno, dtr in enumerate(dr):  # For each debit transaction
+                    dbal = dtr[col.index(amt)]  # Debit amount
+                    if not dbal:
+                        continue
+                    damt = float(ASD(dbal) + ASD(camt))
+                    if damt < 0:
+                        camt = damt
+                        damt = 0.00
+                    else:
+                        camt = 0.00
+                    diff = float(ASD(dbal) - ASD(damt))
+                    dr[dno][col.index(amt)] = damt
+                    if diff:
+                        data = [cono]
+                        if system == "drs":
+                            data.append(chain)
+                        data.append(dtr[col.index("%s_type" % pfx)])
+                        if system == "mem":
+                            data.append(dtr[col.index("%s_refno" % pfx)])
+                        else:
+                            data.append(dtr[col.index("%s_ref1" % pfx)])
+                        data.append(ccdt)
+                        data.append(ctr[col.index("%s_type" % pfx)])
+                        data.append(ctr[col.index("%s_ref1" % pfx)])
+                        data.extend([diff, 0])
+                        sql.insRec(age, data=data)
+                    if not camt:
+                        break
+                diff = float(ASD(cbal) - ASD(camt))
+                if diff:
+                    data = [cono]
+                    if system == "drs":
+                        data.append(chain)
+                    data.append(ctr[col.index("%s_type" % pfx)])
+                    if system == "mem":
+                        data.append(ctr[col.index("%s_refno" % pfx)])
+                    else:
+                        data.append(ctr[col.index("%s_ref1" % pfx)])
+                    data.append(ccdt)
+                    data.append(ctr[col.index("%s_type" % pfx)])
+                    data.append(ctr[col.index("%s_ref1" % pfx)])
+                    data.extend([diff, 0])
+                    sql.insRec(age, data=data)
+
+def getImage(name, siz=None, fle=None):
+    import base64, io
+    from TartanClasses import Image, ImageTk
+    from tartanImages import aliases, images
+    stk = name.lower().split()[0]
+    if stk not in images and stk not in aliases:
+        return
+    if stk in aliases:
+        stk = aliases[stk]
+    dec = io.BytesIO(base64.b64decode(images[stk]))
+    img = Image.open(dec)
+    if siz is not None:
+        img = img.resize(siz, 0)
+    if fle:
+        img.save(fle)
+    else:
+        return ImageTk.PhotoImage(img)
+
+def printPDF(prt, fle, cpy=1):
+    import sys
+    if sys.platform == "win32":
+        import io, fitz, win32con, win32gui, win32print, win32ui
+        from PIL import Image, ImageWin
+        hdl = win32print.OpenPrinter(prt)
+        fd = fitz.open(fle)
+        rect = fd[0].MediaBox
+        siz = [int(rect[2]), int(rect[3])]
+        mat = fitz.Matrix(4.16667, 4.16667)
+        clip = fitz.Rect(0, 0, siz[0], siz[1])
+        dst = (0, 0, int(rect[2] * 20), int(rect[3] * -20))
+        dev = win32print.GetPrinter(hdl, 2)["pDevMode"]
+        if siz[0] > siz[1]:
+            dev.Orientation = 2
+        hdc = win32gui.CreateDC("WINSPOOL", prt, dev)
+        dcf = win32ui.CreateDCFromHandle(hdc)
+        dcf.SetMapMode(win32con.MM_TWIPS)
+        dcf.StartDoc(fle)
+        for _ in range(cpy):
+            for pge in fd:
+                dcf.StartPage()
+                dlist = pge.getDisplayList()
+                pix = dlist.getPixmap(matrix=mat, clip=clip, alpha=False)
+                buf = io.BytesIO()
+                buf.write(pix.getImageData(output="ppm"))
+                img = Image.open(buf)
+                dib = ImageWin.Dib(img)
+                dib.draw(hdc, dst)
+                dcf.EndPage()
+        dcf.EndDoc()
+        del dcf
+    else:
+        import subprocess
+        subprocess.Popen(["/usr/bin/lp", "-d%s" % prt, "-n%s" % cpy, fle],
+            stdout=subprocess.PIPE)
 # END
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== added file 'tartanImages.py'
--- old/tartanImages.py	1970-01-01 00:00:00 +0000
+++ new/tartanImages.py	2020-11-26 14:43:42 +0000
@@ -0,0 +1,202 @@
+"""
+SYNOPSIS
+    These are various images used in TARTAN.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2020 Paul Malherbe.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <https://www.gnu.org/licenses/>.
+"""
+
+aliases = {
+    "abort": "no",
+    "accept": "yes",
+    "accounts": "ledger",
+    "add": "insert",
+    "all": "show",
+    "alter": "convert",
+    "amend": "edit",
+    "amendment": "edit",
+    "apply": "yes",
+    "arrivals": "print",
+    "automatic": "auto",
+    "back": "left",
+    "c/card": "ccard",
+    "cancel": "no",
+    "change": "convert",
+    "chgpwd": "users",
+    "chgusr": "users",
+    "choice": "question",
+    "contacts": "users",
+    "continue": "yes",
+    "create": "convert",
+    "credit": "refund",
+    "crop/print": "print",
+    "crsmaint": "edit",
+    "crsquery": "question",
+    "declaration": "print",
+    "deladd": "truck",
+    "delete": "close",
+    "deposits": "print",
+    "detail": "show",
+    "display": "show",
+    "doabout": "about",
+    "domanual": "help",
+    "doquick": "help",
+    "draw": "edit",
+    "drsmaint": "edit",
+    "drsquery": "question",
+    "edi": "import",
+    "enquire": "question",
+    "entered": "users",
+    "fixed": "entries",
+    "former": "left",
+    "forward": "right",
+    "generate": "process",
+    "goto": "edit",
+    "history": "age",
+    "interrogate": "question",
+    "logout": "quit",
+    "maintain": "edit",
+    "manual": "edit",
+    "members": "teams",
+    "modify": "convert",
+    "movements": "question",
+    "next": "right",
+    "non": "users",
+    "none": "no",
+    "notes": "edit",
+    "normal": "age",
+    "payment": "cash",
+    "rates": "discount",
+    "recipe": "entries",
+    "replace": "convert",
+    "reprint": "print",
+    "re-sequence": "reorder",
+    "reset": "clear",
+    "rotate": "convert",
+    "search": "find",
+    "showcal": "calendar",
+    "statement": "show",
+    "strmaint": "edit",
+    "strquery": "question",
+    "sysend": "quit",
+    "sysupd": "network",
+    "tarbck": "backup",
+    "tarcfg": "preferences",
+    "tarexp": "export",
+    "tarmrg": "import",
+    "tarres": "restore",
+    "tarusr": "users",
+    "tb1040": "copy",
+    "toggle": "convert",
+    "transact": "edit",
+    "upgrade": "update",
+    "view": "preview",
+    "void": "no"}
+images = {
+    "about": "R0lGODlhMAAwAPYAAABXrgBYrwBaswBeugxhtQBhvQ5luRFktxRpvAFmwwNoxgtrxgBnyABrzAttyRRvxAtyzxdwxhtzxhNyyhx0yABu0QBx1Qt10wB12wh32QB43wx62hN30RV51Bx80hR+2h1/2CR8zzV9wyV/0QB74wB/6R2C2zWCzDuFyyWA0y2D0iWF2iuG2C2J2zWH0jWJ1j2L1DWM2jyO2T2R3ACB7AqG7Q6I7RWF5R+K5hSL7hmN7iOS7iuX7y+Y8DOa8D2f8UCEx0KKzkuMy1GOylGRz1qUzkWP00WQ1UyS1EWU20yW2kyY3VSW1FuX0VSY1lya1VSb21ye22We1Wqf02Gd2Fyg3WSg12yi1mSj3Gyl23an13Sn2XSq3Hyt3EWj8Uum8k6o8nyv4ISx3Yu13pO53oSz4Iu34Iy44ZS74Zy/4pzA46XF5rPP6bfS67rS6sba7v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAHEAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AcYKDhIWGh4iJiouMjY6PkJGLAAEBAAICAQKSkgCel5eYoqIDnJOgAQQiQkVTU01CIgYDAgO2pocCngdDYmlkacFqw8NdRAi2pbiCugIHRWTR0b9jYmjX2GhNDwXduJgBKGPj5GJSU9FbUmJjZ+7uMAkJBZyYBlNi+fpiRW5w/3DeFNFXpkyYMlgWyItUy8CVLhAjdinCBiDAN0y4dAnDkeMVBwsdNZSypWRJLVq2FLFocUoYLjBhvsQyISSjAQWKXNmZ5UqWn1K6sASIhsrPo0ejNGjQyBYKKVKsRLVCVaqWof/GPMHCtWtXGUsX4ZTQpMmTs2ijnBWCFU6TKP5w4VaZS9dD2EQ4gzDZy5eJk71OUKwZ6gYFlMOIE0M5cvfQPAlIIkuejEQJkhODAbY5oaSz5yWglYBeYsJCBUTdThhZzbr1kddHTgTZwkXIiSNJcCfZzbt3jAqnHSuAgQKFERjIkyuHcQTGixcwZMyQQV369BkzkmDHniG4oQQRXJxwQb48+efo08uIgT6G+/fw3X+w4DjBBBUqRrjQj18FCxchSCABBQQWSEEKMbDAQgsMNhhDgy3MR18h8iTggAcjZKhhCimM8EBbcESwwogrKEgiDiSSYAEGGBjSgAJLNTCBBzSO4AEIN37Y1gQm9NjjDT+uYMIHLBbpYgMMxP7YwAUTcNCBkx0sAKIDH5jQQQcfZJllBkUWScKRMVbQAHAVXGCmmQssoMBQC2zg5gduboDBil1iQEIJR4pJ5p4VmGbBimuypACLdLJIgp2GIvplIQ1Y0Cifff4pqQUJDNVAnYnaScKhmy5KiJiO/hlppJNawIClGGiQKqKactopnoaUKuuKdDZgqaqcttrproiUOuevmNrKUgMkaLDrsZuWoGyvc9IKbJ0kCGsRsceWkOydyi57yJ+EdnmoohhICxC1ryab7bmJYArupnaK+08F2GJ7bgk00EuDIt4qiqy7cFQwb7Y0BCzwvYpoYGyxhiJbwVD+AgzwwAQv4iqyGIsAx2+jFigrsL0CO4KsvAuD+E/GEA/8iLXxZhuyyBdwDHEk/5ZQwwUi/7NBDjWUzEm99Cprww0dgFCie+u9wMIIIOCggw0vmwKxDTrswIMPP3jxBRhfePGDDzzsoEPOHS8Tx9NRS+1DDz3w0PXXJos9SMk01CD33HC7bQjceEdsNyJ47+3334AH7nYgADs=",
+    "account": "R0lGODlhMAAwAPYAAAECAQULBQgOBwoMCggVCAodChUVFRsbGw0iDRItERM0Exk/GSMiIysrKzIyMjw7PEE/PxtDGiRdIyZhJSlpKS12LS57LjB2LzB6LzF3MDF7MEZGRklJSVFPTlVVVFlYV1pZWWRiYW9vb3BwcHt7eoB+fS+ALzOEMzaJNTiKNzyVOz6dPUCeP0CiP0GfQEGkQIWFhY2MjJOQj5SUlJqamqCenqWlpaqqqrGxsb29vd3d3OPj4ujo5+vr6vX19f7+/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AQIIAhIWGh4iJiouDAw0bHJGSkJKTlZeXlJEbEA4DhYMHJDY3Nqalpqmqq6ykpjWpNzUzHYSCQAADJDc3MA4NwMHCw8TFwhsxJQcAt7gOpDi+xtPUww8wIczNAA+8ODiosaSopeWxvOHjqDMzH9q3AA023zObG/f4+fkc+v35HjKyNcM1AMY3EgcMKFyoMCHDhxAjOkhm4B0uAAxg8KLBsSMNdh45zhDZEWTIkTRszNoQIAC8lgY2eJgJoqbNmyA+gPCA84NPnDtteuDw4JMtABEoIAiAiGnTRE4NRV1EKEILFRoqJAggoUKFDBksWMiAIcMFDBXEes2gIexYs/4X4qqtENerBAkIqrJo0eJFhAAoXqQAq6FwW8OIEys2zNawCRMKqvLluyBACg0FALTUvLlzZ0ItPzMV0FlABAuRkU5uEUHAiQkDRnycIYMdStsjc+MWSdt2DBgMEFRIbXVyBAIpJAzI8eOHj+bQnT+P7px68+nOeUAoMFwyXxZ/ky+XTt0H9uvmy5/3seOBcOLfV1RGoTzHefTW75OH7qOHDvfdqcbCXvPVl59+6UWXIH88tMcdcXvxFR5szCl434L8XdifgwFGECFrAZwggQEVXmdddeod6AMPDzzonYQhThCACLP1hpuNN+aI22/BdbjaAgKkkEJmnDFlZGhGFv4pWmiFtBSBBvDx5QKQJwgG1gWKXQCWBRh0qSVbFXSZVWNiaWCBmai9yEJlVb7wggtuxinnnG/SaWcLK5iQpoADzufmCi64sFoLH0424KCHDroCnifsaVWEfwWW6GqTflfod4Pi+QKej0E4GZsuXEpopqMimumkekYJ4wlwmurqq5O5sChfeTq62l9tRjjgpZViimihKzSqKogowOorpaL2uoJYqq4Q6abHGsprspe+EKyto7Jp6bSnnirqCtdGSSBgm1Lb7bmG0pqqXhGyaS2vpPYqb6LrqvYpYIH+iq606Ib7YgtUQkupt/rC6q+9lBEQ2MAFI9uwutiuKnCvpYA6/DCnEQNMrqUEG0sqngcXt6i7gAqKLLwfkxosZHrN6me+Hs/Lba3DgtoqvxdXjDPNhCQwK4is3hxtuic3fHAAFXzqWqbg7js0ocAKywwABFSwwgtAFrua0Jb+DDWvXmMc2SABJLBAZgpEoPbabLft9ttuL6CAAgS8Q9XdeOMdCAA7",
+    "age": "R0lGODlhZABkAPYAALccHLkdHb4gH7YkJL8hILYsLcIjIMYmItYvKdUwKdkxKuA2LeM4LuY6MOw/M+5ANPNCNfNCNvRCNfRDNfRCNrRVWLRaXbReYbRpbLN5fexkXMJnZ9h1celtZniQnLOHjLKIjIOZpIecp5GlrpOmr5WosZirtLGlq7GorrGssrK1u8iRkd6dmtqko6+9xK++xK++xbK7wLC9xLC9xbC+xLC+xbLAx7rHzb3JzsLO08XQ1cjS1szW2s7X287X3M7Y28/Y28/Y3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEIAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAAGQAZAAAB/6AQoKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqIowM6QzMKmRMrKyL6A0s7KwjriyLp41vDK6jMDBnsEyNMOKt8adyMrLiM28x8HR0oYxyCucK8gxsBMQ5OXmECrIHOfs7e7kHMgq7+QUnBH05enB6/n+5vGCzfMXIdM/cvt49TvoLyCvgf8wHWyQENcGhv82yGtw8JKEgwIqzrqgACM9BRfkCTgowdLBBABEyroQwOS7ACkFAkjQsdJBAzGRXQDAwCa7BQByPgRgoOckhgGCBhta0qg5BUnlAajpNBKFg1FPIKsAoKpVclgrIDux9aC9Sf5f/x0AkAFZAaJnyzEAUABZBgAH3FKK6w9rgRS8MABYmbecAAAYeKW4azbfW0mE/QEtAEIWCgsAACxoXA4pAAsoZH2421QwXIYOgG4dEDpAZdIKogKgHdqAA4aXvZpE8HjrAY6kzzWYG5oAT4zBIWVm+OB3cnoOHhiN/mj69e9WuTvSAL78WQ2UOphfb7JDevbw/7mfpD6+fXfzJbVgwb+///8ABijggAQWaGALlPSg4IIMNujggxBGKOGEFCqYYIUYZqjhhgxeyOGHIIboYYgkljjhiCamqGIPKK7oIogtvihjhjHO2MMONkJYo4w7iGBCjg7u6KIOInjgwY9ALv4opIo9GmkkkkkuaWKTTj6ZJIuTAKlDCFVWCaWNUoa4ZZddlgBkmB+OSWaZOaK5oZprsjmjmxnCGWeZPMhIZ4V23tklCXm6uOeEOXDp552ACpqlioUeemiiKg4KYaOOHjpCoCZK6iCllVqKKYmaNniDDaSWauqpqKaaQ4qhXlliq66KuGistGIpSa21woqrhrruimGvvlLYaw44FGvsscgmq6wOrM5K4g2dVioCjpk6+2y0fk4bqbXXYkumttveuiK03joJbriRvEiut+eiC4mM63barruPzBjvofPS64iN98aZr76N5Nhvl/8CzAiQAxtZsMGLJDnwwgwrcuW9EGNHnIir61ZsMSKxQqvxxofQigO1rlYS7JkmnwxmJUCoLCMQl7j8IiZByKyiD5nUbDOJOG/S8s4bwgxKDz8UbfTRSCet9NJMN620rdlELfXUVFdt9dVYZ6311lx37fXXYIcNSSAAOw==",
+    "auto": "R0lGODlhMAAwAPYAACMnKyMoKyE1MC40OjA2PTpSUR9jQR5sRTdgVDhhVDRoVzl7W0BFT0BFUE9TWGVqc2i6OXO3NHe+NnO+OG3EPHLBOWvTPhSVVSCeWhmlVxamWhmmWBarXBqsXAq9XxeyXRiwXRe/XRq9Wz6yTSenUyynUiqqUyShXjetUSW0Vyy1ViG+WDexVBWuYQ2+YRSxYRK7ZCOvYiSxZFutRU+3RkO0SlK3RFW5RFi8Q160SEOyUGCuRGGyRmuzQ0mze0K5eRjGXxfMXzfHTzjHTyLHXDzNUS/QVwrFYwbOZQnNZwbNaAjOaBHFYxbMYQjQZy3KeTHLeyvRfE3JSZm/JJa5Np68NZi9OaW+Nay/M6vKH7nGGbfLHJvPJ5jTK4XCMt3TDsnPFsPPGeDOCejTB+TZC/fZBP7aAM3EKtjFJ9TFKO7IIVC8g33KpY7PsY/QsqHHurXk08LGzsXK0cfe2sjd2t7i6uHj7OTn8Ofq8uns9AAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAHoAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AeoKDhIWETk5HSYuMSYaPkJGFjUeKi06MlUuSnJCNS0mVi0uki5WYSYidnUelqYmWjUlMlqihHquQlqSglUeYwEunS0VESkqiTrmFraO9isCpob+kXTgulUqMy4KxmadJoMKaTkYWZFszK42qudCUrUuomMNNFGFlYlw1TJjylau8map1aZoTUE6YpNASoUOHD7FEcWoFDJUiUOEG2jp4BIIOhw9pgXOkS5q0I7QQLpIiopZFlClAgOzgARqiTYa80XuHqkmWGhe/hTvyAWSGDt4AThI3kOIlJUPGTODwa2BGJU9+dNjgEETVaZMucYSGMUmTIlzMhLmhQpEoUv5KosCZ40MDSBBMpi0ilLHpwYNJpGQZY6ZwGTAUgMRCIhePHbozO2DLyDfVOJWMVtSQAMbMFy82SmSwxBgOnjp38LSZuWEDE16DwpFCKWunixY3ynjhoIEr3rim6+BRLQNk6w5eRwkq9TaaQWEswNjYYNfhCyim7dhRHcM4166vjwiyassqRiYVRM+M8SYP6jxtujvMcBQ5SIDmM+5spA1I5AwFPBDHcG7I14EJJHAQWWuvGVSeL2I1JRMIJxRQwAAOyFEgSBr0kIOCrCEnkjwFGWSSXqGAgEECDRAQAAALFOeQBhlgYUVXW33nUFCvTENiOLAw4sQLCRTgYgAG1P7XQW86oHEGCw4dN1N55CEykDaIwKBAiwAguYFMB/ZwRRpqqHHGFTyYoKND0uz0jlCMaMklAAbY10EGJYiJRplnVLGDCR20MJOQJhYkyiVyEgAAnSeAmcF3LTR5BgobgJjCoKn48uNszaSSaJdJejdTCjZKGahRL/U4FE+JBoCkkqYG2kIPM4A4E30dIEKOLYcu0uqrYMYaZQkmCHprBi20oEdzo4SC0RK/1tnBpaaCeecGLVxqbH0pdAMkYL06EW19ra1plEPGzjfTcqiQQouQ0doZq0y4Rnankh0MgshOGIm7paJIsmZujtimkK2gj1pbGYq+/uuqAY1GqaO1SsUauwF9LZwgKAiEPPOKvy0+rKOw8+Gr7qXrEvIuog4HLCqOW9WX7rWngmSIC6440YGRIht8b6AoI4xsBxH/bO8j3y5ygQBIaiz0qCBc7JDP9Nq7VSSv+HLBAUXXi6669nqNIyd66eqoyQSHbXW+rPyCChM52iu12mEvw04SLqzpqNVzs8aNHoBNwwSYe8utt0N/j6fXEoPbJ7ZxVic+SE2NDF6u4fZZLPkkFcHQms9G6Zgt25s/AgsMM4ONeOmrzJI6cpIHAgA7",
+    "backup": "R0lGODlhMAAwAPMAACER/iER/yIR/iIR/yES/iES/yIS/iIS/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAgAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAABP4QyUnpKeeEu++pYChWwwFoWadmxiEc7ShTAGG0Wa7vPHHNoRPv4CNmisWhDjhRwljQp5MHFE6npUN2m8HIdgZbGHfFmaMtgyhgNbqvcB1ARI4rz1K8iDcex/GAGXttSHaGanuGd2iMHyMsdRlcWpI5BD6XRJg+XjNtO0KhGSeFbkU3XxMleHYYHq+OCAZzID9NdZOTmruoFFkhswW1Ay+iJqOmFwQhAz4hOQWItRodOpzCM4LTkAEBTN8U0hXHSS624CDiMnVmkZGUsRbxX2nvuZXaFK60TMROxqJAIOmVSkIjOBVwuNqRSF4aZQUKEIg4USI2VVeWJcwn4QYMDOYTiYB0Ne1TjhMJyTwz8ILKniLhcgiw4BHGTHSJ5iGwNKFGgBYlAJTAGeTZMYOspLgYQHSdJAkA2EGxaFFLkxzoWsbyOKDeR5FG5HFkghWbIrFEMZzotDPM1Ioh0RI9gvUWi5GaaIz9luMGy3RDLu400fQYDKA6KQRoJhcnXQI/tZBkMhkdmCiHbWTbC6QFSj5vKQYQjEMjuLpttXg1gDdTYyZCidBsZUHItyTDaragCjfekhln6ASw8TWk8Y1PRgxwpe5ZOT4VCJCK0aRYcsuLpQuYpTMOAaZNv2UBOCt84WPREkuIAAA7",
+    "books": "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",
+    "bottom": "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",
+    "bounce": "R0lGODlhIgAwAPcAAAAAAB8SCCEUBiEXCC8aDDUkCTQgDTQkDFY4D1Q6DlU8DkAhEE0oE1YqFVAtFFMuFV8sFlE2EVIxFVY3FFg3FFQ5E1o7Els9EVw8Elw4FmE9FGQzGG0/G286HHU8HXQ/HV1AEG5ODmdCE21KE25NEG1CG21HGW5HG25KGXFPEHJKFnZOFnJDHXdBHHdCHndLG3ZPG3pNGnpIHnlKHnRQFHZSFnpVEHlUEn5WE3hTFnhUFH9ZE3RQGnZQGndQG3ZRG39MIIBZEoNcEYZfEIddFoZcF4tfF4xdF4BTG4RWG4hRHopUHohWH4ZcGoddG4VbHopgEYpgEolgFZFlE5BkFZdrFZdpFp5tFptlHpVoGJVoGpZoHJ9qHZ9wE6RzEqJwH6p2Hqp4GIZAIIdMIoZNI45KJI9KJJZIJJ5NJpxOJoxRI4xRJJNSJpRXJplTJptbJ5xbKKRRKKVUKahVKY5hIJJkIJpjIJ9iJpxrIKhvIKNiKKZjKqpjLLpmL7ZrLbRpLsR8K8N6LMlqMtBvNMd0M8t2Ncx1NdFzNdV0Ntl2N9l3N9d+Ntl6ON56ONh8OLqBILyCI7+FIL6EJMqPFsGHG8iMG9SUHNmZG9+eGt6cHuGfHeejHOWiHuaiH+qlHeymHe6nH++oG++oHvCpHfGpHvKqHvOqHvSrH/WsHvitH/muHseKJcmJIciIIs+OIMyOJMyOJcyNKNKEK9KBLd2PLt6OL9SVIteWItWUJNWVJNmRJtqZIt2bINWBNd6DN9+LM9yAOOCdIeefIOufJeCTKeuZLOeMOemPOOqIPO2KPe+NPO6MPfGNPvKYNvaaNvadNPidNPmdN/CVOPWXOfSVOvSWO/WWO/KRPPORPfOSPPWSPfOUPPWWPPeZOfaYOuejIOSgI+6mIPKnI/inJ/WpIfWoI/erIvesIPirIvmrI/qtIfqvIPquIfyuJfekK/ejLfehL/eiLvmnKfmmKvijLvmkLfagMfihMfqhMfujMfmhM/qhMgAAAAAAAAAAAAAAACH5BAEAAPwAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAACIAMAAACP4A+QkcKCBEkBgsBipcyLChQDUdLmhq16xQGYcYHdrx5WILqHHdHLVAkLGkQCHFFpWAJGreMRlQhgEyiVGBJXyETrwi9e4OjU3ypLWh2VBLOGh/YOQ6RcxEpFLurBkiyhAMOWdwnuxil8eHLVP0tjEyQ3XgACnipq2pE8zcCjrg1t27pihNWYEgSLCiRgbPN2EWeFiZkgTIhwZ3+RXhgiTbmCZVbBSocCMKFj1sNiQ2IkuCnwcHalAa4oTXuX3aGsVJTGQWgQgpfsTqNElHJnTPlCFCkziBBgNfKuVYxSkUji7loi0bdCYxvyUZJF3a8ciTKl0qjgQCJkiMcyUTYIh9opJlVKp6v/ZwcMDAOb8AKHChajUCkzp43pgdkgPBPb8et6ASDxNepGNPNckkMod/AoUhSj69iOCKPtwg04cHDAp0BS3YsIFBLcbwkaFCL7zhxgIUzDDiiiy2KBAALvID40AzxmjjjTjSVGOOPPbo449ABinkkEQWaeSRQu4Yo5IjMomkjQEBADs=",
+    "bowls": "R0lGODlhMAAwAPYAAAAAAAkGBQsIBg4JCxINDRURDhkSDxYPEBUSEhsVFBwaGSAYFiEeHSMgHyYiIiglJSsoJy4rKjEuLjYxMTo2NT46OkI+PkRAP0dDQ0lFRUxJRk1JSlJNTlVQT1ZSUlpWVVxYV15aWmJdXmZhX2VgYWplZW5panZycnp1dX56eoJ9fYSAf4N/gIaBgomEhIqFiY+JipONjZaSjZaOkJaSkZyWlpyYl5uWmp+ZnKKdnaahoq6qp6qnqK6pqrGtrbOusbaysrm0tbq3uL66usO/wMfExcnFxs7Ly9HNzdTP0NbS0tnV1dzX2N3a2uHd3uTi4ujm5uro5+3r6/Dv7vTy8////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFYAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AVoKDhIWDBAQDAQOMjY6PjwmGk4YJigCYmZqbnJsBC5STBJoIERokKC0vq6ytrqsqHAmYkqGCo5gPJTpJU1RVwMHCw8RVRxu0oQsBAAEWNk/F0tPCURzNlAa5NVLU3tRHs7WEBZgeSt/p0yAAA4XlASbd6kcqHyI00ekt2IOzASV+qaOhQBMFI+lkYCLETMO8dEAQcJqgj5pCAIcANECiDti1TjS+XRyECUbHKk8cdAIQQuRCK6MmRDnppGAnDy4xWsE042QVKhVWpshpRRuDJj6r0OiU4AjRASw7Gmnxg8qUEcwyIbiRcCGzHOp0FBQgjwqNCgwccACibiQABP4cvw2ZlSnkzydQTl48ACDCw2lQKGzCmRTYxVEb0qngxEFg0ovMTHxTYlNT4sJVIANo8e1EJwuOfV7EFMNbyk4P8hYeDYArtRwrBbBdrcn1tBArWYbuyNp2MSkScg+YLbo2NSUSc0dg8tj4tCFZMwVIjglDxbbOpfXghGBGBE0anOjNXmz7JgVAcpRgkKlC3K6ZfBODvulBDAQfYqiwMItBD+zxUdNEZZhQ4AImA2DgQg4xlNABD/BhIt8wQG2ywWKaKODBE1T8NU1v3pCwiQgodLICb+QVw8ImJpTQyQQefpgiMStqogIQLJAgQXQDIAQMFT6kQANSw4BIzUeZgPoFDBQ5QJAJhFVMIUICFDgAARFFzigMD1BlMkARwyghGAA4AENDAj44ocQGGIRmZDFibSJBjEewp+QHHzAxAQ1AKIBOMG8KA0UK5WxiUjEuBPADMCJk4EQJQIhFpGGalCYMFT1Y0IkIMQLjhAROVeFDAiogAUQEIgzDTwCjpAqMFD500CUm01VAw27DxKBaFTEwoIACHEwKzAcACDAKA0t4GoQPP/zgww48BIHEFN/MJEwTQRixGxIFScIMCJ1i5k0UHfRD1wd/ipsOEuUCAIogXSoAQgsy1Gvvvfjmq++9LYBgEwKFLJPbwASv9AkllkRX8MKaLDKOIIEAADs=",
+    "calendar": "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",
+    "cash": "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",
+    "ccard": "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",
+    "check": "R0lGODlhFAAUAPEAADIyMjMzMwAAAAAAACH5BAEAAAIALAAAAAAUABQAAAI5lIKpG3YM1XO0UmmzwXq3h3ReyGVYaSUOeqnjl7qv18LzKc/gEoevXynxejaQhlWsJUWkiHPlZBgKADs=",
+    "clear": "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",
+    "close": "R0lGODlhMAAwAPcAAGITBHsnAoMAAIwAAJMAAJsAAKQBAKwAAKUJAKoMAKMICLMAALsBALELAL0MAbgODqcUAKoSAKwcAKcZALIaAL8cALgUAKkTE6weHrcWFogpApssDIwzA4gzB5c3Bpc2F6wjAKQnBrIkALMtALwkAKM/Aaw8AKwyBrU0ALo8ALk2ArM3GKk2FKQtJrchIbkoKLU1MsMAAMsAAMAMAMIUAMUbAcMVEMYjAMgmAMUtAMosAMgrDss0AM47AMY7A9A/AMU5F8UoJMYzMsc6OsU2JZhMAaxCAKRJAKpJALtCALRNAbxLALRGBKxdAbZdALtWAaRJHrdQGbllAZ5GIZlMO51QP4dDM6lJKLpVLLdXOK5TK7tqLrp0NqxvNsBEAM1DAMJMAMlLANFDANNMAMVTAMtVAMVYActcAdZUANZaANlcANJXFc1kAMhoANRkANliANNsAN1rAMt0ANZzANx0ANt7AM9fJNNaNs9WLMRkN8BwNtRhPrtJSbZYQ79cWKtUTr1iQp5uY6l2ZLR+aMpGRcNeRM1SUsZVVdJaWdNfSM1qTdh0R8ZnU9NtXNNnU850W9t5VtFsRMdiYcpkY8tpadNkZNZsasp1Yt58Ydl0bN19bNd3Y89zc9Rzc9x7edd6ddyCAOKEALqDbLyEZL+QYbuJdMiWXtWaXsOIZ9+CbdWaYcaHdNyCdd2BeceRe+CFecWhf7GLht2Dg9+JgtmJht2VldGbieCGhOGKhOKPj+ORj+WcnOCWlt6vi9alh8emm9SomOOyitOvot22reWmpuinp+Osp+qzs+u+vuS6ueO3ptXCvubHvefJxvHY2PLm5PXs5fXr6fnu7Pnw7vr39vz49v///+3l4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAANgAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4AsQkcSLCgwYMIEypcyLChw4QDBhCYSJFixIcYsUWUOLGAx48FLF7MCDFiRwUY+Ezq9ImTJD4XDIQkMJJkQZMEClygVAtZM2RAgyarxUdByI02BQowqZOSsWNQo0qNSuyQTJoDbDI18KJWsa9gw4IlRpbYJwwGsGZcmtPAkFq74sqdS3cuLRcK1DpkeoAQrVq5dAkeLDiX4cOIc929mrWhxAIGXMiSRavVK1yYM+O6xfnWZM+TJ3fKILNmScgPLLVqxap161ewV1v2RNtTp9u3aRs6ULoxQrYG+mYa3ojWNGGPNqVankqTpuGWJk1i5oySpEqWLAVZcFShxOAPEP41asRo1TRr1oAxegQJk3tMkBodOpQMvbNDfhBVMrTgQAHTBEUE2QFCOOLIetGgZ001thSiCCQQQnJgH8MoaE0zf/BhCCIu8EYTQgIesAAhiRSSxTUWomdLFnksskgkWWRRYYrJwMAHIUL0959vARJgwAIP3JEIHlesUk2K1riiRR55YHHFjBY+80cLQgwxhAMe8qhUTiI6gMcddzgpypEWVlMKFFBMIQyS0UwJgxBCBMHAAqUZNFFwC8ygwxp42BHFFGOmaOYHa6b4DBUfrEBEEDbEMKd/HxJ05wIN1MDDF2issUYUHwxCjaDMIHlNFRsougMNMzDw6EwFcbkAA/439CDGGGikkYYSHQiCJJtUaKCCDzzoUAOqMfR3VUEe/QirrLSq8QYbSHAgCJm7XmOFBiZ80UMPOgiL6pzHDvSYiAzgIGutb8QRhxtIBBDIp6JaEYARZaAxxg/c4lBDqrx5FOCADOh5LhpqxEEHHU4EAMAyu8YCgAZPqKGGvfjqcAMNj8r0b3CqmjsrGunG0cYRAfyy64KCBHDEGW6kgYYYP/CAA8bGFlCQAXg6EOsPzbrBBskmn4xyB0qwMfEYYnBbQ8YG3HzAAapaKoYYtZaBRAdBC73gIB4ocYbLMOtAM29NExQcuRbo0MMXY4RhhAfAIAkNLNSiV80oXdc7xv4XPMywgLFlD4SziAvozEMPKZgAt9xdFEFK3QuOUsISZeytgwOP+tfq038vUEEOKoyweIrQdNGEFE2YgmQ1qEwexhcV/P30AQdx/rcFJIywQdykbyGFHKDIIYUpkFuDiglL+GBB50/X3l/nFIAQQqgWQsOFE8CDErwUqkDuixFJkMA8nQcRwPwBDUgAAgvUWwONHk+0MUcddYRShxxtnEJtL0okoUIDhOtPQjrXuQio7wTNcF8elEAGNsBhDnSoAx3mILzuWaMXT1iCFygQQAGCaE6yO4ABQbACZeQhCUsgA8vcAIcWzgEObGDDKYJhBjKEz3ZzWgjUQihCCYxgBOIoSEESwEAGFZ4hhj5jwxnMUEMviCABOAxcQlTFPAMkQAIiAGIKvIDCIpahDGY4wxnACAYVcJBzVGyIAGLgqP6QzYAiQEEQkzDEJYBhCSlcQgpGkAA8vcpRDxkAGzOHMwRAAAQgAGIQhUhHFIAAAgrwIwPYmBECsLGNZCskBCYggQmAYAITgADOzvZHStokBjKQARUzKZNWQmZw5GJAKhmQFIEsIJWOImQmZxfLVMqAdrVUCiplMEgQEvBVkxwmLYNZEAHIkpjFVFUyfbkAZnoHape85KMEYM1uevOb4AynQAICADs=",
+    "connect": "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",
+    "convert": "R0lGODlhMAAwAPYAAKWCLqiELqiEMaiGO+O1Peu8Pe/APfnMN/TGOfbJOvrOOfzQN/zQOqiIRamLTLyWTauNUb2ZVLuaW8GcVMCdWM+lR8ehT8WgV8ukU8OgXM6rX9WuW9uzVOW9XsGgYc6rZcelaNexZ9qzZd+4Y9e1atq3a9u6eOK+bO/CQ/nORPLHTvTLTfjPS/zRQu3EVuzEXPTOXPvVVfnVXO3EY+/JZeXCbOnDbO/MbfPNYvLObPfSY/rWZPvZZvfVbfnWafrZaerGcevKdeTDfuvLfPDOdffVcfnWcfnZc/TUfffYevnZeH2Kl3+MmIGOm4WRnoeUoYqWo4yZpo2cq5GfrZShr5Wjspqot52su6GuvKOxvtm7gubHhevMhO7Rh/TVgqa0wqm3xKy5xq68ybK/yrXCzrbF1LrH0rrJ1r3M2MDN1sHO2cXR2wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGwAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AbIKDhIWGh4iJiosmQkNBQURBQEAnIYuYi1tDSEo/Pj48oqM9OTYimamCXF6eozw7sbE6OzKxPjkjiTYQqVteRp+horLFsraxNBuGMzgOmV1Jw6PGMrbW19gyOh2EMzo6z4tePzyfr7E8oD47sO3a1zsvgi8wMTDiiFrkn+WkNyc0XJgQ4cKFDfWy7Yghg+GMF9ZgwGigiN+Pi6J61MiwCAPEGCBDNmQoY2Iiixh/AJGgqgIKBSkUwFTQIkUKFisGIOpSDiMPIyVUESpwoKiCokgRCDjExZM/HkU+CC3EwejRpAEOkTMnyojUqUMZMECaoGiCrIW4HEn5gwRYQv4GxooVSxYtISRczQF5O8iAArqAzS4ltOXIqyMs+cadC3jsgQSDB20V9cMGXzYFEmjezBlBAgMACjklFuGyAAACUgNYzZp1ISGGRcVwcZnvkHILFXCo/fY2jxgMWljgDRZvDJksJhCfiuQHCxYpVCyfCsJDhgkTHkw/9KV79yvbU2FBQx7NGTHhM30pTx59+kXrzZ9B8+X9IjHkz+gHbz9RGfPySVHIEkww0UQTTiSYYBQMPnFZFvPpd0YZhURxxRVZZPFFFmGEIQYZZJhhBhWX4SffeRVikeEXYHg4RogiVvGghBLyN4gUGXIYxhgvkpFGGiReNsaJExqCI4c89uloBhlB8iVGhBOeUV8hU2yYJIgx1gYGjRNSaEgVLe6IZRpmOHHZF1zud4gUYojRo49prJGGjGBtGWUZE7r3pZsw/rjGn2mAMdWTEpZhaBkOHlKFkj/G+SegWWQixn9cGiogIlVgaUYWjj76qBliYNGkIFaAMYYZaR5KJ6YwyhhFp56qsYYaaIiIp37l0WjohFMsYkWWgkBhhqd/qmHssbTmWul5iSry66iCcPoosrQmm598u54RaSZV9HqIE2GkIeuxaFhLpH5liNEscVFk8R+5ys5nRhlZMNGfhWCAeCiIYFwBRX8AB6xKIAA7",
+    "copy": "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",
+    "cut": "R0lGODlhMAAwAPYAAAAAAAgIBwwMDBMTExgXFhkYFxwcGyEfHyIhHyUkIykoJi0tKzAvLTEwLjU1Mzk3Nzs6Nzs7OkA+PUJBPUVEQ0tKR01NS1BOSVRSTVRUU1hXUVtZVV1dXGFeWWRiX2VkYmxpZGxraXBtZ3FvbnRybnV0cnl3dHx6dX18eoJ/eYGBfYaEhIyKhI2MipGOh5WSjJKRkZiWkJ2Zkp+em6Gfm6eknaWko6yqpa2trLGvrLOyrru3r7W0s7i3try6tr28usC9tMTBvMTDwsvHwMvJxc/NytDOydPRzdbU0dnX0t3b1t/d2eDf3OPi3ubl4ezq5+7s6PLx7gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFIAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AUoKDhIWGh4iJiouMjY6PkJGSk44AAJCWlIiZj5yahZ6NlpefgwMKCgOOAw4LBKWCAAolJgqkigALLSwMt5oADjY3FAKMBRY9PBG+lAAROkEeDYwVJ0Q6y7DOPUcqEwaKDig3SDcOzJPOPEkxGgXosQ82S0s059oRPUs1IAyqh8d+RGHXAF4kABR+MPHhYoMDcIaqFXEShMU9WBVwICly44SFA4bEkTtSg8Q0WFIorNBI5IUGA74AyKPnIwWGBCgFZVhxZMkNEAuKDRJQoUcUJTU2uMopxUAGIU+CqLiwVNCCD0KgHHHx4F9OZziWJKkh4hsAAQ8+vCiiZMcJW/5MBUWAobDihXdObxxJEsRFBwRxB3FgoaTJz1QNQgBpkuSGBwmAAzfNECTKkRcUFlhAwaNIkBgSvAYGFkPIER8mNHAYp0OGCAQGczr48ENJjhUcQtSQcSGBaMlScrX4EQRHiQ8pQCSIHdhBhxxEZoSQkCAA87gAEqTAIX2BdeCbBDjQUGL6AQHXvwIIEMAAhQoPEqAHP6q+pQAEDAxAbz9Us/4ABljfJwJ6UuAo/3FiHygDxoKgJA066F9wD0qYniEVDpKhhBhOyIiHFHaIzoaiGDQhiSR+eOKKI4KIS4YRaghjiioqSGOENJYIYCIC/rIjjz8SGCOQOYJn5JFIJgOZUyAAOw==",
+    "disconnect": "R0lGODlhMAAwAPelAHZTDnVUD3dVE3VXE3dYF3hXGnlbHHhaHXlbI3pcIXldJXtfJ2BgYH19fX5+fqp8LY94TY95T7GBKseIBs6LA8eKDs6OC8iMFsePHs6RFMibF8iQHc6TH86UHcefG+OeH86hGs2kHO6lG/etF/yvFvGnGfSpGP+xFf+xFv+yGP+zHP+0HseQJM6WJNiYJ9iaLsSYPsqcPeCcIMWhIMWlJM2nIcSoJsqsJcSkK9CsP96qOf+1I/+2JP+4Kf+4K+e6NvTNLPXOLc2fRMunQd+uQNeqS+CuQP6/Qv/AQ5CQkJGRkaCgoKenp6qqqq2trbCwsLGxsbOzs7S0tLe3t7u7u7y8vL29vb6+vr+/v//Vgv/Wg+nYnPDeocDAwMHBwcLCwsPDw8TExMXFxcbGxsfHx8jIyMnJycrKysvLy8zMzM3Nzc7Ozs/Pz9DQ0NHR0dLS0tPT09TU1NXV1dbW1tfX19jY2NnZ2dra2tvb29zc3N3d3d7e3t/f3+/s3vHt3ODg4OHh4eLi4eLi4uPj4uPj4+fm4uTk5OXl5ebm5ufn5+jo6Onp6erq6uvr6+3s6ezs7O3t7e7u7e7u7u/v7/z35fv47/Dw8PHx8fLy8vPz8/T09PX19fb29vf39/j4+Pn5+fr6+vv7+/z8/P39/f7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKYAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4ATQkcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48gQ4ocSVLkAiFFSh5M0AFJFpUFDWToQeIBzIEELOwQYeOmQAEUVMigobJKGYEAWqB4MUNlG0+lJEHgYOKHB5VsOo0iVcoRESAaEiqAEUMjG02iLNmxRInLkIQINhzRknENpk+iRkGSE6nSI4QHLvg4IQFjGkudOnkiJepRHEigGBksUIFHCRyGJWFKpGlTJ1KhHD/ypIjggAkrPtzAaKYRpk6A3ljqDJoRnEacSpsKwCKFixoYyyyadGkUpz9vNGsaBWoRnEWbEEXAMEJHCIxkEEHajsk4HzeQLP51/6ToTaJMg4wEAYFxzKFGeu40elR8kx43jSQV94TITSI/W+SAkReCKLLJXnAwwsgko2SiRxuLQMKgJ4e4UUgfgWD0xiGITPIJJHHAoYgiDGKCBxuLNAKJKJ0YMgckkmBxURd0GGLIJZ80AscbiCQCySiY3MFGIos8IgoniMxHxUVOkDGHIIJY8oltbhxyyCOjXGLHGocosogkiziXUZNy/PHHJJ4s8kYbhBDSyCiT1MElIj2+sREUY8CxBx+SkOYGG4AAsogok9DBh41udBSFGG7ooQcknSDSxhp8/JHIlIAIwkZHhsQRBRhu4IEHpIiwocYeqPLBhxoe/QHIGWxSfMGGHXc80uIacOSRhx5oeERIHnbkQQYUX6hRRx24EQLHHXecAVIedMBRRxpPdIHGHHMQgsixZICUxBJ1yBGHQE5ggUYccqQ7BkgOJJGEQU1cYcYbcIQBEgMNKIEQE1OMYYVPAAcs8MADBQQAOw==",
+    "discount": "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",
+    "down": "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",
+    "edit": "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",
+    "email": "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",
+    "end": "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",
+    "enter": "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",
+    "entries": "R0lGODlhMAAwAPYAAD8/P0ZGRkxMTFJSUl1dXXBwcBqLdx6NeiGOeyWQfiuUgjGXhjSYhzWZiDuci0Gfj0WhkUuklFGnmFWpm1ysn16uoWGvomWxpGq0p221qXG3q3S5rn29soaGhouLi5SUlJmZmYK/tKenp66urrOysru7u4XBtozFu5HHvpPIv5fKwZrMw6DOx6LPyKTRyavUzbDW0LXZ07vc1r/e2MPDw83NzcDe2dPT097e3uHf38Pg3Mji3s3l4dDn49Tp5tzt6uPi4uHv7Ozs7OXx7+fx8Oz08vP08/j39/P49/X5+f39/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6ASoKDhIWGh4iJiouMjY1Hi0mOSpKTj46QloyQlUqQmYOgm6GkgqKahKeoiKqClZ+jpYews41ILihBq6mXhSgJBxEyu4ydhjILB8oKJ0WYmq2/BwgI0xW6ia3Z2UNHLQ3T1QcrxJYvEC5JPBTABwowhkc0JCIj9vYk9/j6I/n3+SWM/HhgIMGGIUVOLDCw4VSRDgACSJxIsaLFih6KYEhwwkIwGUlkbMBGqAQAEThSqly5MofLHD5YpkSiIoEJJSaWnSCi5EaNQiAECClHaMeCCUV0JFOW4MWRAh+ADhhq5CVMHEBWZgXi42VKIECUFJmgQEcRCQfaUSgiZEBUQv4gpiopcbGuxQ5GTCRQgVOZMgc8lLR9O+iDXBz8Euvzdw+IjAQXkLwAlqCyC0GDpQ4t9wOCAx8DwyHQkCkzXLlHjKhOfSS1kdarYxvxlOHdEQyiIfwYZHpQ3KElCAgfTrz4cA9IWBg8soIatQQxCPUW9FtJjQ7Ys2vfnr0GjwYRiPBg4ByBCVHTlVRfVaSCghljwx2YwFO6W827TiBQcUTvtAMM7GBIetXd8MGBCCaooAhHzKCABUjEoEA4CZAz4H2nATcAAQN0yOGGHnY4wAhDQNAAaBAUVA0GSBxCIGpCxCjjjDMWccQGCVymQUHKPLCbKfYRRp1QmryAwAXeTN64DDyeXCikenJN8oMDBkBwQgPUKMMBLYUQSOQkLTwIjnwSDKGIl5s5ssECP+iAVjUL6LDIi2kqAkkREUjQ4hAcJLAfI3RuQ4gPCtykBJ9HttgkIoE6YqQGQ8AAQQIY/Dgnhr5F2UgI0zyQgANOOeJlWI9MwNQGljYihAAgFEJDAB3QIOustM4KxA8MGCCMEDXU6mutENFgSFAAFBtAscgmSwIPDoQwRA4dHJvstMkey+osPtSg7bbcbitEET8C0e245OJAlCznpqvuouuiK2gsz7QLijbp0luOve1aEggAOw==",
+    "error": "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",
+    "execute": "R0lGODlhMAAwAPYAABwcHjAwNDY2PDs7Pzo6QkxMVU5OWVdXWFdXYVtbZF1daWFhY2Nja2pqbWZmcWpqdG5ufXJydXR0fXt7e3V1gnt7hHx8iYKCg4KCjY2NjoWFkYuLlYyMm5KSlJKSnJqam5SUo5mZpJycqp6esKKipaOjq6ensaystKWlu6qqvbOztLOzu7u7vq2twbOzxb6+w7e3yLu7ysDAx8PDzcrKzsTE0cvL1M/P2dHR1dTU3NnZ3tfX4dzc4+Li5uTk6unp7uzs8fLy9PX1+Pv7/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEQAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6ARIKDhIWGh4iJiouENjMzNoySk4VCQ0NClJqFMYYJl5cJhjObiSc9QSWFCqBDCoUlQTwnpYU5lkM9q62vhD2XQjm1gyutMIIlMzmtOjOqRDCtK8OCBECgQTk/uK3APzo/oD8E1IIi3d3cmK2WIuWCAj5C8/SW9Jj260I+Au9ENUHqCRwoMEiNTTZyeBhkI4jDgEIC4ijBwYKFDiVwOKQXMEgkQR5y3EgU4keQHzYm1ADy8KGKBwoUOHjwgAEDmStaOgRio0INHydDIMoBpCgQH0Yf9tjwQAKFp1ChPtjQg2UQo0iNjjQUgofRr0ZlSKhgsYKEBwsWNKVgkYKEF/5Fr4IF0sOdIQY2gPwoulfvDLYWHyRYQCjtA4sWKMj4wZixXp4MEgHgwKMx4x4YMleInIgBhcwYKlvmwQEAoxM+Uv/wUUIDBgsNGDW44LoEY9UtJuXg4eNHjxkcOGyIMCnCBg0cZvRI7WPrIgq8ffToQSL4BU0Xgpfgzb0CoxA9uO8o4YEDBU0TPHgoscMHj/dCD61Y4SJFjPfvbZQI4eE6pQsehFBCDfjxMMMJLsw3CAg87FAgfjWYUEIHpXggggk2PFggCIJQAEMNNtzg4A4O1nDCCRRu0oEJJ9DQYIM73GBDDDGcRwQEKOSYYwot0GhDCid8UMoHK5xwQw0w1P6nY44SdLjkki3UIAMMz2hSAgsvzPDkkjYSUcCXBoCwZA04yLACCZqQsEIMONSwJAgGGPAlIhC0oKMLv82AJiUkPNKDC0tCwIgBKNiJQgpA4IDDMZSwECIQhrbQggGSFFpoCzd8k4MKk6hAIhA3SCrpCJNw4IKkLrigVw86cLqICjr0sFeSp7rAgSSptkArDDMIURQPLCjCgldACIFkkrsqckIMosYAAww08iBEYzhgScgLL+DgmBA80OhsDanaR4shItiJ6oc01kBgRHtJlwMNNOQADmMB8WCDujEgmaukdhVSbgsuPKuuujYk5JBjXzXmUA4F36vus7mSeggCAMu7sEEAIMgY4g2KbjNPUrj4kMPIDecQQgAb0IoASSAMMIgIIt2QAw461IyKTuHVjINII/dLgIWbiPCevLFOZ/TR4bHqIA9VUnPAbkjLKuttvRntXg4H+MPCyDxMbdnXjYXHgw7BlnOBDvj1wIJJOrX0AwvS5ezfMMp0TZ0gC3yg0UM4fEAYESRMNzYp1LxQtA6FTNDSBIUUzYMM7zRgQw+ME3JBS3MLcoEPOMTmDxEZGKL4Q5UTkuLniExgEmOloz4JCR10sKfrtEsSCAA7",
+    "exit": "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",
+    "export": "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",
+    "filter": "R0lGODlhMAAwAPZhAC8xQD4+TkI/T0NBT0JCUUxMXFFOXlRUZFhXZ1xcbF5fcWBdbmBfcF5hc2RjdGtod2VmeWZoemtqe3Jvf3Nwf25ugG5whHNzhXt4hnV3iXd5i3t7jH1+koF+jH+BlIOAjoKDlIiGl4SGmImHmIaJmoqMnpCOnIyPoo6QoY+TqJOUpZaXqZaZq5ucrZuesJ+gr5+hsaOjs6ils6aot6qptqanuKepuausvLCvva6wv7Gwva+vwK6xwbO0xLe5xrm5x7W3yLa4yby9y7/Azr7B0MHCzsPE0snH0sfI1srK1czN2s/Q3dLT3tTV4tbY4tna5tXZ6dzd6eDf7N/g5t/g7OLj7unp7uXm8ejn8ufo8uvs9e7v+O/w+vHx9vLz+/f4//39/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGEAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AYYKDhIWGh4iJiogxMTQ3OkBBQkWVRUNCPz04NDIyjouKNjEzMzc3Oz9FSEtRrlFNQjk2Mz1MVVNLOS8vjjo6oWFJRTElJy0xPEJGS1BUWVxfYGBaSUE7N0Na019FLSUiISYtQkmKwx4WHCkzQENISlBRVdDS1EpAPDdGW9NgSTFUoDgBIoIDHUXOtUCRAgYPd0aUNHlCRUu0aVrw6TOyDcyXJC5UiCzhwUQRJopiKFlixMiQIUeSSHxypR5GjTeIdASjhIajHkVi0liUwUaRJUyYNEkKZSK9LV6+fNHCBMklJlq6dLHCRIkRITRKPOjwYZGGGUOWPNuKywkTlv4viRQxkmTJkiRJrP7A8UJFhwkLDAiY0GHRhhhC1Hrx50+LkRszePhIQoVLlytPlBTBIUNFiL+BBzzAYJZFD8qLGVNDYuNUECRXPGqJwqRIj84hMEgI7cBBqA0zYNtjrAXJDFJAjMT+kiWK5tsqRvxlYKDAgWAJzjLJohpMFySQb/QwUkWqlipMjAS58e3DhQQCCgxQFKVHFiQQRNxQcuUityZxRcQdGF5EkYQQ7KmQTgIEEGDAOVEI0oQHEbAgxBMW2eOFEy8J4cMQVXh0xRJBjKKCCBlEUIAA1yUCgSEIeLBfFVqk9kUURfygiRAhelEFEj3cEJII7zn4YDCERP6wQhEYdiHVF1Wot2N5WzxhRJABgVBBdS0iSUgHOyyBRY1SXYFEED0AVYUXV0ChHg8BcdBAAQl4acgBKxghxRZamNdEEJoUQeMVTXyVQ0AXIIBAl4lkgAgAEOzQhBZbbPHFFoWiKehsLAnRQzESIFBnKCLMYAgKChDQgnJcQFXgV8ldcUUUSyDhaQsbJOAbkkFoMQgQQpgaBgc6PMHFsWza+poUsy7hVQ8qSODAqEhqYVEURAhBSAtIYOGFF3wWKgQSVTTr1Q0i9GbnIFk0ccgOT3zLp5sRMdvUEkK0cMGL6y6Sp7d8SuHVLVXc+wMJBvUbyg1NQLXFiMxIIYUTTtUg8cIFESgcjBB7YkEoEky40kQTPXQggcbBwKAEFlhU0QQ8TzSFhAoVnIxyKJJeIUWhRiylhA373szrRE3MhYQRQHSgrtChvNDzEkUsE8QKEDDANJI7wPOVEDVgQO3Vi5CjRBJftRAq2Ei+IJFXZqPtpQ9PCBHDBW572UMVQHiwa92hDOHFEBTyHUwSXyARuOCLLPHFEiJYgPgiTIDRBAoaPK5I5FCowIHliUQeBQsecI6I56CLfogTYEBRuumFoP556KwT4sQXULggQuyye1E7Cbi7HQgAOw==",
+    "find": "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",
+    "first": "",
+    "gnu-head": "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",
+    "groups": "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",
+    "gtk": "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",
+    "help": "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",
+    "home": "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",
+    "import": "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",
+    "info": "R0lGODlhMAAwAPcAAAAAADk5OUxMTFBQUAJEhQ1JhgFGjANIjQ1MixRQjhxUjgFKlABOmw1RlwFQnwxVnRdXlxxVkRVYmB5enyVclShbkSJcmCVhnStimjNnnDVonDtsnQFSowtXowBXrQNZrw9bqBBdqgZbsApdsR1jqg5gshNjtBhnthxptiFioSlmoypopytqqjFqpDxuozFuqT9woClvtSNuuSdxuit0uzF3vjR5vkBwn0BvoUNzpEp5pkx8rFJ+rUt9sER/uzt+wVuDq02AtE6DuFKCtF+JslSGuVSIvGGHrWKJr2WMtGOOumeRvG2UvHiXtXGXvnqZuj6BwkKCw0mHxUyJxlKLxVOOyFqSy2GXzWSZzmicz3ScxXOfy2ye0HehzHikz2+g0nSk03qm032p1ZGovqOjo7Ozs4WjwYimxZKqw5ivxJSuyJqwx560zIGs14Su2Iew2Yuz2pK33JW53Zq83qm3w6+6w6S4zK6+zaS70bTCz7jBy6rE37fF0b3I0r/M2qPC4arG4rXK4L3P477V6sbGxsTHyczMzMPN1sbR28jS39PT09PX2tzc3MLT5MvW4svZ5cHV6cXZ68vc79Ha49fh7OPj4+Pn6uTo7ezs7Ofs8e7y9O3z+fT09PL1+fz8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAJ8AIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4APwkcSLCgwYMIEypcyLChw4cQIyYUQIYQI0yePGFiRIiMAIkPBZThlDEjp5MnS2Iq8xEkwgCESnLCRBOTpUo4GVXCRNIToQAuC5aRebKmTUw4c1a6mLFMUIGMiBZNpOZJkiRP0PjJyagrSUYuBfQs2QlREg0VNOTYwWMHjAwagNzp2rWSxpYPB5Qs+UhHBAxDtsAZtGlTJDlusgzJoIMPXbueBkAcm1GJAgxCuIiBA2mvJMRguPTAAIRuVE4PT3vitAmHghZUsIBxEyfT2E5z4IjhcqWKChiLGCmKCpbhUJSaMER4McUKl9lxLqH0tCm3GDBYrEh5kSG4Tk9OFf4GMHnSRYIVUahc4RLGDRxBNDVxOqwbu5UpUVZsoEsSaMKYNRGBQAo1pOccGGK8EYcglljSiBxwuBEGF9nhZ8MEpX1HyESr0YRIARLE8MMPU1SBxXNtuPEGHHHA8YaEofUmRRQ20CBBH11hhJdQGlmCiQ4IkCDDiFJU4dxzYojRxpJihBGjFVRI8UMNNICwA13gIcQTTocU0AEKMswwYolWYBFGHHPs4UcjjlB4hRVV4DclCiM84BgjJx0kgEY4IYEACCaEOWIUJQKC0kw0vQmnnDbIMMIIHSSxlI4GkeFJUhY0YMKjKIgJBaGAkKcJTYvOCIUNJzw6wgcqJOUJGf4GGeJJV4cQ8MCmIngQ6Ig//JFRJ51wookmU+AXxQ8ybKqqCAwcspRPBuHZVRoEdGCCCbl64IEIJ/Aaha8oHUtDqqo+KoIIDqyB06wGYaLJcE8cYC2u2m6r7QglwCHTCOeeWy6/6J6B00wGaSQcEgZ0MAK99TYsxl7b+lvuuR44wEQllpBUMCaKKIIwBwuXkG3D2raxF8AiTEyxxQN70i7HijRhgAMLM0yyF2Px+6+52jJwBk0EF4Rnx2gQwEDKyo5cL84plVsCyh584AEDeNDEbkExGaKIHkZ7UDO/JH/gBU8nPb1sv9pywMAkVm9YkKWKaF3BARx4bcLT2eYqQv4X8XHyL8X1crDCTCTBWtCelRhiCA8HMLBtCSfgHbEIW/jIk7IAk8wAE4R7suNAPClOR+McnGvCCeT6qwXGNGF7rtQNc7DAIylhgtBQihuyAd3bjoD6CcqasDpOmGSubbZqD7EaSeEZhLjidRywAMgLn4ACCsCXoIVOOI1Acr0ONEDJWJ8TFJMihBgChAHTP3r69cBvzz3sx2vrAANa7OX2SxqlrzvpH/jAwnygBS3YYTg60cIWthA7BihvL/5JyFA4QohCUKBxDtDWB5aQu449phJpc8ACWtCJvTRPIVFBXwV3twAG1E0J/tOaIrwDQg6IkAeUKU5DMGKICqpPeqAMYMAKgFAEIxTRCEYswhCCuAAtnARYntAERPTiCfRBzwXSa2EQOaC2IDJgAQvYgSPclZLIRGQAGKGg6IBggSyC8Y0XSMIhjEISTkgGJFHBRO5kqAc0WAUra3AW8ax2taAM5VJ77JgHP9iyLD1FIDDJyEbipkgE6gQjGfnJIw83EpnUpIwaYckmJ1IRpsyEIx4Z5UMAwEoAqPKVsIwlQgICADs=",
+    "insert": "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",
+    "last": "R0lGODlhMAAwAPffAAAAAAQEBAYGBgcHBwgICAkJCQ0NDQ4ODg8PDxAQEBERERISEhQUFBYWFhcXFxgYGBkZGRoaGhsbGx0dHR8fHyEhISIiIiMjIyQkJCUlJScnJygoKCkpKSoqKisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5OTk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4mJiYqKioyMjI+Pj5CQkJGRkZOTk5SUlJWVlZaWlpiYmJqampubm5ycnJ6enp+fn6CgoKGhoaOjo6SkpKWlpaampqenp6ioqKmpqa2tra6urq+vr7CwsLGxsbKysrOzs7S0tLW1tba2tre3t7q6ury8vL29vb6+vr+/v8DAwMHBwcPDw8TExMXFxcbGxsfHx8jIyMnJycrKyszMzM3Nzc7Ozs/Pz9DQ0NHR0dPT09TU1NXV1dbW1tfX19jY2Nra2tvb29zc3N3d3d7e3t/f3+Dg4OHh4eLi4uPj4+Tk5OXl5ebm5ufn5+jo6Onp6erq6uvr6+zs7O3t7e7u7u/v7/Dw8PHx8fLy8vPz8/T09PX19fb29vf39/j4+Pn5+fr6+vv7+/z8/P39/f7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAOAAIf8LSW1hZ2VNYWdpY2sOZ2FtbWE9MC40NTQ1NDUALAAAAAAwADAAAAj+AMEJHEiwIEE9evIoXIjQoMOHEAviuUPRTp2LGO1QvIMnokeIF+nMkQPnTZs2bNicfANHzhw6Fz/KBDdnThyTas6MCeOFy5YtXLyEGXNGTZs3cWrOfCgnDhw3asyA2VLlSRYwamqqAZPlSZUtYMyocQMnjpylBN+YTEOmSxUoZPxgAjWqlKm7pUZl8kMGSpUuZNIcfYMWnBs2asp4oeKEziZRqWDZyrWLFy9duWrFYnXKEx0nVLyUUcPGzdI2a9CIydJEDaVRrXIBI1bM2LFjxowRGxas1y1YqjCpaZJFDJo1bWSuSWPmSxUmgkCtykXsmDJlzJo5296M2bJkxYb+/coFK9UgJlW+mEmzxmOaNIqnRGlEytawZMuaPYsmbdo0av5JEw00zihjjDC+1NJKJFFMIdp7EKFxRltSQFFJKbocs4wz0EhDTTXXXIPNiCFaU8000RRYDDC5vLIJFFIAdgYaD5lBxmJJNFLKLskw0yE11mCTjTbcFGnkNtpgY8000DBzTDC6wCJJEqGRYYZDZYzxhRVHBEKKLsl8osw0QWazDTfdpKlmN0UieQ010TSDjDC6vELIEVZ8MUYZBo3BVRNmgHJLMs0wAkku2JzZjTeMfuOoo4yyuU021UjjDDLB5NLKGcSBMUZBYkwVhRGUtHJMM9EwooghnkzT6KP+sD7qTTdIWiNNM8cAU4snRkQBlhgEgeGFFUnAMQovPlKzyCGD/CEILrFG+w0ZYWBhxRZoRMNMMb3AIkcSVngBxkBfeJEFFERo0koyzkhjDSKE/MEHHnRMQo20j4pBRRE+/LAENc8kEwwuohABRRZefCGQF1tYoQQXovCCKoiFAMLHHXKgNscs+H4jRhM91HADEdfcyi0sXShxrRcCbZFFFETwoQoyz5CZTSB94CEHG2eUIUYYikwjbRdG1MDCCz1oUw00AtfyBxFRZLEFOFtocYUTPlzCSjDPUIONNn/sMUcbZvDkExdqxBItFkG0MMIJN2xTMjPD6BKKD05coYX+y1hMoUQSoLzSyzHSmNnHHW+gEcYW1laBRRZcJCL0o1TwYIIGH8jATTbUOGNML68kocQUj1sbxRFTjCLLLzRXw00cdKwxBlVRQAFjFVl00QbHjkZxwwcUZNACN9tU8wwyv8hCxRFRWIHFFW8V4UUptACTDDTWbNOCDVRWxcQSTDghhRVafEHGI0JDMUMGDFCQAq3WMA0MLWAU4dcVVjA2hBqm1BKMMtHIngpAcIEIPMACJIjBDoawBNJtwXxvgIURUCABAkjgBPCLhjKCUYs2DAE0VqjCFJoghDSYwhb/i8Y1tpGCD1TAAQYIwAAUIIEMiIAFNwjCEqpQBlcMwQT+EAAABExAq2toMBi2YIMQmjCFKlBBCiTsQv9SmL0WWuABBxBAARZQwxG0IIdLIIQ0vkGEE1TwghncYC2+sEQpUEE+TRhCFKhnPextYwUhwIAEGICABDSAAhsggQtwAIVVPKoIKaDAAtwHP/nRQgpDaEKDpBCFJhDBCKpj3TOqsQ0XlIADFZDAAx4wAQx8AAUxwEM0YIWEFmSghsMr3vGSZwQiSJKSUGhCEW5wCcEZwxnUyIYMUiCCDVygAhXIQAdIwANSRIsJMviAKTXHOc/1YhQ3KEIToBAFcEDBCUfYgR5YoYthMEMa17jBC1AwAg9woAMgIEEbniEtKNzgBCD+gJvcpEE3XfxhB0dwAhQE8s0k/MAKp/Df9arRAxvAYAUnKIEJchCKjlWhBy9IAdKUxjQOZuEHSRCoQJ7gBCUIQQedgEUvitEMaQyhBzeYAQxcAAd6dmwLRLiBDEZWsmZwCxU6EIISnPCEgTRhCUXQQRpUgYtgJOMZSiDCD3aAhFJ07FFdYEIQfDAEKABMYLhwgw6KsIQmEKQJTEACEHBgCZUWgxlRYMIR+OAMb1xVVmxSmra4BQocAAEJTDArQZaQhCHooAupqAUwjoEFMJhCG9tY1F1nVatb5aoWYtDBEJKwBIMsQQlG+AEN/BCbYPxBGNKohpnQ9CpZzYp4lLL+FKZyUQga/MAISuisQf5GhIY64hW6EAYyUEWNa0C2SGtiE/G08aY4zUkXlrBBD4gguod8FglD2IEPMgELXQTjGMx4RmqvYaZtmPe82bhGpZ7hJCjdbYFIyC1E/maEIOSgB494hWyKQagfVcMa1rgGgKtBDWlAoxngYZElepCDIBihuhGhbxB0YANAtKIWvQgGf5nhjGdAIxoghsYznMEM8PSmFoWwgQ4cDGGP0FcIPJhBFzgBC1xkeBjGQEYyrqOMZCDDGLzpBS5AEYYZ8EAID1bCUpKABCMMwQc3qIEaRAGLWuiiF78ARjC2DIxf9EIXtUBFG0TGVSMgIQmFYfKTEYgQBB7YoAZU6EPgZEGLWtiiFrSQxSj8YIUa2IAHQSDCEc5cGIEwuclsZnANZAAEJmgBDWjQAhOAIIMa3DfQZiZ0oQei5loOAQg+4IEOcoADHORABzzwARCGcMlBo3nTBkHCEY5ghCIQYQhCEEIQgpBrVhfBCLNGAqwjggRZz9oIyE72rAct7GHLpNjQjnazCxMQADs=",
+    "ledger": "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",
+    "left": "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",
+    "message": "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",
+    "network": "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",
+    "new": "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",
+    "no": "R0lGODlhMAAwAPUAAK4PD70CArUPD7sNDaQVFakUFLQREbgQEMMFBcwGBsQKCsoMDNMDA9sDA9MLC9oJCc4SEtIUFNsSEtUZGdgdHeIDA+wDA+QKCuwKCvMDA/kGBvIKCvoMDOQXF+UcHOseHvkTE/YbG9wiIuQjI+wjI+MrK+sqKvQjI/klJfItLeYwMOk0NO46OvQyMvkxMfE+Pvk+PvRDQ/lERPdISPhKSgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADUAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAABv7AmnBILBqPyKRyyWw6n9CodLq0VKjFhkVq0Wyu2Fojw8k0nhYQzKUBT8coGSrDaGbUNJrrO2VkUHkzc3VJfiAyeXl7bk4PGSeJNDMndEkWITExNJmSi09+JzEzm3kyJ1tIGSkznKQxKRtnTKCZnLUulUcNGy21vq9mSwwWoay+My98SVopv7UpGLJHwycvvtYxLcpKDRjNL+DgmSkW0kQJGB/W6+IvGIzcGCTh9K/RRQkW8/ThLe9QDOS9YMFiIEEWJu4JyafuYEGCKxQClOfQoYkLdRJUIFHxYMIHVBhc4LiiJAuTJKJV+FDS5IqTF81J0eihpc0VIzqwvFmyxP4FmVNorijBsyXRoSVHXAAZZkiCBzWJqpi6gqqKoURHPGDadIiCBh5KEBVLVqyKrFu7GvkqoaxYEWfFanWg9oiCByNEiCC7t4SIERII1cX3QK/hw3onNBgwmAiDBxQQSxYh4QHjxgkcREa8ObLnCAwUDH5KobRpEaX1mi49AfSCrgYyT6Awu/Zs1hNy56YNWjSWAwkSRNAdYXjuCA4cGNdNPIFvKcCF54YAYUL1CBCCBx9evLj14s6hJ1hAvbz57K8LLEhw/nz4J9EhkG8f/HmN9fPPL1igwL4S4AqQt19+CyCQwAFGDDDegANSV6B/RwxgIIP7DbCeAgggGKFzDJrKt18CCEBIhIT98dffiRgqoCESByAQYn8DBNgfiAoQEKGLGIaIY38hGsCEASnu+KKLCBRQBAFE4qijAgEgMICRTRjQZJI5EnnZiAhMmaWLTdYIRQESEjllAE2uOAQBEpKZZZMBXAkFmmqOmSEScJJpp5lSDGCnnW5GuCeeU0jJZxMHkAklbGQK8AQBNg5GwKGNRSrppJRW6kQQADs=",
+    "ok": "R0lGODlhMAAwAPUAAACTAACUAACVAACWAACYAACZAACaAACbAACcAACdAACfAACgAAChAACjAACkAACmAACnAACoAACqAACrAACsAACtAACuAACvAACxAACyAACzAAC1AAC2AAC4AAC5AAC7AAC8AAC9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACIAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAABv5AkXBILBqPyKRyyWw6n9CodEqtWq/YrHbL7Xq/4LARIGYGBIJycsBmq42EuJzwHhbueHy9YOj7/QdqCIOEhQiCCYmKi2oKjo+QCk4LDFQLl5iZC04MnVOdoKGeTQ2lpVGmqalODq2uDk+vsq1OD7a3t024u7ZOEL/AwRBLwsVQEcjJyhFJy85SEtHS0xJH1NdUEhPb3N1F2t3hVhXk5eYVQxTn51gW7u/wFiIX8fFaF/j5+vv8XBj/AAMKDOglg8GDCBMaBKOhocOHEMVsmEixYsUyHDJq3JjxTYePIEPWEeGhpMmSI4V8WLkSRMohIGK6fDkkRAiaOHPq3MmzZwEQADs=",
+    "open": "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",
+    "paste": "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",
+    "populate": "R0lGODlhMAAwAPAAADe1xAAAACH5BAEAAAEAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAAquMj6nL7Q+jnLTai7M2gPYdAOJIfkwpWuianuvExmbCQvK9yM3N57HL09F+imCvSDzgQkFkkllTHodR6IsqRCyf2mWXWPVxrderw8sRoiTZNHhMNn/L7TiJXXKH7fcHfYzmlMc3Irgn9XfYhLWm18gY1hZIOBhY52j0OKeJmVkoJofo2QfK2WlkEyqKime6epk6CHSo0hILgpuru8vb6/sLHCw8TFxsfIycUAAAOw==",
+    "postgresql": "R0lGODlhMAAQAPYAABATFhIWGRUaHh4eHhwgIyEoLi0tLSQtNCYwNy0xNCcxOS41OzM0NDM3Ojw8PDI6QTlGUEVFRUxMTExXX1RUVFtbW0RWY1JfaFdnc1htfmRkZGxsbHR0dHt7e097n2N1hG15g2h9jX5/gFJ+oXaEj1uEpmSLq2iPrXONomuRr3eTqm+UsXGVsneZtXiatXyduIODg4yMjJOTk5ycnIiXooKYqZKgrIOiu4imvpCktJuptJOrv5+tuaSkpKqqqqivtbW1tbW6vbu8vI2pwZOuxJaxxp2zxZu1yaS2xae4xq66xaW7zqy9y7K7w7q9wKm/0b3BxLbAybvEy6zB0rPG1brG0L7K1LfJ2LzN28LCwsHGy8XIysvLzMTO1szP0cPS3tTU1Nvc3MbV4MnX4srY49zl7OTk5OHp7+zs7OTr8O/z9/T09PP2+fb5+v7+/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAEAAAB/6AboJra21uhGtqhIKMjY6PkIaQaF5QUFxCFRQbP0FbZo4+WZCOZ0M3ZW1YOC9PbGVLjG1ZSEREVDYBFgUgOyQwYG1CQGGbbVw+W2BhWWFoPkJrRy1FU1cmV2IrR1gmjGZNODc4TygCGQgXFgoPFT0NFDEMEj4RGg4VIgYyFf0xTyWmlGHxRJCYE09OMAKj5MaNI1RqBDgA4UMCFDkYcLCXRUOMCjDczJCwYYOPARsqMAhz5QSOEyZuUCGzTaGgMA1vIMHCgwCKIToShKBhYMZIDR45bDADgyQHIAM6dOBABMuUFEc8TBvxgkqJMmzcoGly6sgRFA9UDJmCYUEDGP5CItDrMIOLhAoOJMCAsYYDBQk9ppxYgWUNERYpSqSYUmKFmENQiDw8gsOIQyZMdPRY4yZMmEPHKmjQu6gNGDCC0pxhdKaMGtds1DDiYvnIkyJLHBIRowV1IzRozPQQ0QMNqeODvoUbIuULE4c4xEAR4tuNGQoUOkhys50RZ+6Cts/iIKkNFCRMhFRZdWOIlShQPt+sAERCFhlPgQCZkWXGlh4d9AAGB8N0IIMZWXTQz3ZoZCEEFEE4cQoRToABCiNh4LOBVFlQIIMG9lQwgwMdSCCCBECQWEFKQHzU3SBmSHGKEU48EgaKaHQADAVZ2BNBBz4wsIFHFYBhwJAwUEywxQwVvBieF6cgUd03HRgXBgcazNCGDEDIkMUaMWwQgxAcrNGDBhyA0UNJIhzHUBJQGPfId9zR2Z2ckhQyiJ6krOEFF3IiJ+igggQCADs=",
+    "preferences": "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",
+    "preview": "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",
+    "print": "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",
+    "process": "R0lGODlhMAAwAPcAAHC9H1+3L2i5J3O+LH28LXW7Nm+rNXzDHHzJHHzVEn/bD2rGK3TDJXXDLXzIKnXENXfTKG6nRX3FXoWzGr6oCKStHrOsFYe+JJ2xLK+3KL26ItyJC82cB9ySBNqcAdeXCMmbG9OXG82NFuuOAuyODPSLBeSUBOuUAuSbAeudAuOcC+ubCuiTDvOVAvOcAvWdCOmcFfKYE9iiBsK2DsqtFci4G9m4FdWhEeOkAu2jAeKrAuysA+ujDOmqDPKlAfyjAfSsAvqtAvasCvusCvanCe2zA+y5B/WzAfu0AvW5Av28AvW0Cv20C/y7CfW+C+usHeWnF/utEvSnFOq1Gfy8FPa8HfW5FNWXLdyoJsC1ItimNuapJum2KPa6Jeq8NeW2M/CzOobLHIfUGZPZGIDODYfhDYPMJIHFK4jIKJPMK4rUJpTUKILJOJTMNozVOJbYM7rbLLPINafYNbjbOKjMLqHgLfXCAfzBAvnEC/XCEfXDG/rBF+zABurEJPbGKO7IOvfHNszVNoy9RYavX7WyQIu5aI+wb66kZ9KpT+W3SOy7Uty7ee6/ZIvFQ4rVRJjbQoTCWJDERbnZQavXU63cY7Tgad3FUvfKR/TUSPbMUvXSU/jWWOjHUOnKafTLaO7RZvfVZ+vJdvPNdezcduzTd/nWdfbYeLaYjpeqiZaqm6Wnmqirl6mkrKepp62zqKmrt7OztLu7tbu7u7W2uLCxsdy3krfYttndlerWhPbWh/XalezLjcnsm9DvmPnkh/fkle3glcLEvMDWrfPZqNzzu9Tuq/vmpvvkqvXmp/jotvzxu/rytu30tKyewLm4wcPExMnJy9TKy9PRy9TT09nY2czO1OHb2Pnexd7g2NbzxP3txvToxOX3zvz1yP3t2f700v761P302/783M7R4Obd5eXl5ezs6+nr4fDv7+/46f714v7+5f7+7Pzz7+/v8PPz8/X/9P7+9f33/fb9/f7+/vf3+PDu8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4A6QkcODAeu3j04LGDJy/eunnxko0aZYoUMHHz5AmMh5AeR48dCYocGZKjRoTrRGnSlElTp2XxToacN2+kzZscIYakp+zSnj149gDyxU4exI0mbyr9SE8csl3J1mn0+EuPkqtKrIACR69mvG/AkBUV6FWpyHjicG3StOmXOngQP+G5Q/eOkz/KNiYDhWmTrnBMdy7tJgqTn5+Zcin7einJHSWP7/j5xa7dMVB+8PhxCdMoU7PxcF2iAvkOE0CjuhnrcvVOk6tUQHX7lSmPkiZN9GDqBE7eybOC4wGzSqXJYyd+NtXGihUJoE1/bF81nueTuoE1z4qUp6yPa8iQm/44cWLncevWc2+/puvEVEzBNjmixXQVCVbj5pXYKf+4CZP+zHWxjHYDTYUdPPT4YsRVTDBXn37lqWffHfZdlYQm8dBk1kZkydNNH0og0aCDSIjIxGtYUXjfEqZ0VZOBAsHlkTjdgCOOOu1080cSTSTBHBJNUNHga7gl4SOQ9iVBhSnsgANOON6IExKC8nwTyiellCJKLrn4wWMSJZaoxBJTTMGHEUYcASaYISa5xyZZZglKJ+EQ1NAxnOhhBRVOdMGFj0yIad8SXWjyyzbL6OKJF0WoGOYRVlhRRRVddGGFH8MU1BApVRzhaYlLhBmmElN80s1BSH1Dig1giohEEv5LtDrEq1N4wg5Z9GjzBxNDqCnqr1PkAk5JAskjji9THDFEoEeEikQUTKhJaTf0GEUPMkY8GwUSQHALBBBHdFtEKJ81VKw865jyBBNBeLpEEEEI4amaRSTjEYLhJLIDvO0i0W643XpRp1cIheQbOIr0gISnQbzrbxBFFPHFNiAZJQ4pTwTh7RHcLrxELvHAQ2VHOwn3xBHwCtFDmvBuoQhMdtLDDjJepLDEtzgH0YM29KSzTnwDdfMnEPDuUES4T+SiDlPZxVMPPd94IkUUQuAMxBTXIZghgU19AcQQ4BLxQw9/GFOUgQyheys9vwghxA4+4NyHNzQ1hFB21VY7j/44XuRABBFA+PADEaCI0xVBJBv0CxdEW+3DF94Um5NHBNUEjhdADA7EDt9iwVtZ9DxUk5VQxO1D3HD7AEVeCsGYOE9bfEtE3Jv3wEMixnymEDKJrPDDD6cH78MOOIAscoGUD7SOLlAEHnwOOQj+gxa3oJpRMlC48EMOqQcPdw5efAO0ht0oosLp0O9AhPY52BDIHMXIR08yPAyugw4+RC98DjiQ4ttHGaJJTdhhCijwIHDQI0L9clADSdRhDJUgBjtulS8XvOB+6Msf9F6QAyjkIhxSOpxA2gEOXWABB8CDXg5S4AMdzGAOb1jDGN5AiWJoZB2kUMH2Vpi/FKRAhf4u6GAokrG2EWpDFCfMgQtckAIcoJCBcxiDFGW4Bkp4BRkg8EAKRtACFWjxBTFwYgpe4AIVfMETujCGMXQhCjDAAAU+HKMPcNDEGUjiDQoowxhk2AZevCgtiugEIzoRik5IoQVhpOMKXABHFkjhBjSgAQ4siIMVOpGSNYDDG9SgBjGIYQxt6MXaGsKOdUzwIODgwgla4MMV+DB6LmABDeAAhxmYYI4pQIEMcBADGDQwDXtMQyfRwIuCYYcsNdlGCFqJAjj+MAce0MAkHOEISdBABSloAf9Q8AENSGINDlBDGDjJhmLqDW8byUgoPpDLZsKxBS7ggAbk4AY0oCENcP6ogQdQsMQP1EAOakBDGMyQADE4ghiV24jdOPINLJignc00QQtIcIM4qIEMYUADBCDwiDhQQAUq+CcCEGAGNBwgAQ8gRkbk95kADoOdLHjoCSI6Ag5Y4AJmCMMZHuCAB3Q0AxmYBBsc4AAz5DQSCE0efA63iA5M1AQoKIEXt7AFFciAAhc4QwMYcIYzmCENj3AEG87AADMgIAyCSOpSz7KLEJzgrSYggQgsEQ5duLUDFsAAGxawgAZcgAEMKABPD3AGAqR1rSRhhzh2cYUOmKADISCFVL7R2BGQgAMV+OsBBkCAAggWsAMQRDbq5hF0jmQeWkMGIkSgBbFkhB2J2P4ACUbQAQpUYAIC8KwABsCAzkIiG+dCLIc2wo5wDINnNKkHO3bRgQ58oAMiAAEhBBGAASwAAAIwQCG4wZC8CTe47NCQi5wmj2uI4AMmGEEJNhAKZkggAALI7nZBghTBzOMd5shvOchBDmtQgxrjCPA0piENaVQjGqs1wWOvUAtp2KIQETDAIIQxDWpYAxvYKEc5zmEOe9ijJvUoBzSeIQtY0MIVq3jFK1ihihazohksTsUrTkHjQxxiFazIcStQYQhUtCLHrmiFimkRi1gEQxrl8Ig9qDHgET8jGM9whiyKLAtZzAIWrqDFK2ABC2fQwsS0uDKXrVzlWcjiGWiGBi40BlwOc9ikHvW4L37d8Q575NccGs6znvOcX3f4mc7vgHOcM7Khm8Co0IgeSEAAADs=",
+    "question": "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",
+    "quit": "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",
+    "refund": "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",
+    "reorder": "R0lGODlhMAAwAPcAAH4CBjtXWUZZXUZYWVBJTXVPUEdbYVxrbWV0eHd3emhraogGB5cMDI8VDpoSDpYPEZISE5wTEpkZF4oQE6gNC6sRDqMUE6wUFKUaF6oYGLUaHLgWF6sNEbQgG7seIYwmKpk5OagoK742M6orL8MUFsEdIcQ4OcQ6QJRTUKdYWq9PT4dvbrh3eLBlZsJDQslXWchxcmu8GHS/LW6zLnzKHXnFJ3m9UHWWaWSMUH3IcIzUHIzaFZTbFZPbG5baGZDWFJrhGYPNI4bMKYvSIYvZIJbZI4vSOJzjKaDgIIa7Ta6CfoWvY82BfZDRU6TZTKzaV53kS6bjSLrkX5bHbbDXdKvgaBp3nSV3myV7pXJ/gSaCqjmEpyyEtDmMuDyRt3mFiH+KkH2YlmuziVmOplaYqUSUuVeXt0aMq2qVpFWgv2inuH6xsV2viD2UzkaZx1icyUmf0FeixE+j01Gl1Far2k+hz3WrxXiyyXu22WeszHu74oKLjoKGjIWNloiTlZGbnbWWlJ+4krehm5OZooOrvIKmtJWut5Ots6Ojo6usrKGoqquxsqmxu7Ozs728vLa6u7KnqseYmcmJicG9vc24u9K5uM2rqIzOkbvVlbLQj5/Gu7rAvbvGvLnXqcTZpcHEvszXt9LCvYOswYqzyJS5zZa3xYa93Zm906e8x7i9w6i81YC84MG+wpvC1qbEzLnEyabG2LnMz73N4cPExMnGxsbKxsrKxcvGycXKy8vLy8fGydLOzdrJysvRzsrTx9PSzdvTzdPUyMzN0sbK1NPN0tfN1MzT08zZ3MbT1tTU1NrW1NvZ1tXV2tnW3NTa2d3c3NTY1uDc2uDGxd/i3eHh39rX4cvR4uHd5N3j5ePj4+3t7fX19f7+/vf39wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4AuQkcSLCgwYMIEypcyLDhwm4QI0qcSLGiRYXanj3Lhi2ax44bp1279mzas2vRsmnMpnKjymwpNcbceFBbMpYcp03DyVKnTp47s11jmVLozqJDWdIsuPFZMmXLnDFLRjUZs6vKoFHVWlVZVatfqXqlqrIbwW7NmiVbhgyWLGVjmQUDBeoZNGZaoenVuxav16x48SZzqlHbWbvGnsGiYwrar6vMQDmJQsWTp2BW4W4Nm5Xr2KqGB3azCy3aKcbJgC2DBtUJjyJHolTB5AlUMmfVlq3Gu4yqYK5Vt52tanoOHmvMjh0zdqxTDx88evSA7YRKJlDGjAlLZqwX36fQCP5TFS6a+Ok8ePSsWq+nVRMe0Xvo0BEkSJMbChDo1//FWDLgVeVCnkDdcAXMKXLQIceCC8axRhXxyTdEDRTiYIAABmQ4gAL+hQXacGIhGMcpsLhi4iVQACGdDzoMUV8NMgTCSCKL1JjIJgCGFdpAXSF4RzLRPAOKFEhIF10RLQZBYRLKoPRMVs9MRRUxHu7ITTddkQIHHsck48kTPEAnXQ9DuChEDTFMcU0yj3n4i4fJWIkld8poaZwmUcTHww7SJXlmDTdk8cUXghL6B1X+EePfL8IICOJTpLgBRxpN9ACfpa8RQV8QZ84wgACghjrAAcJ4ZQww3LEZ53C77FKnG/5pXHLEa0X4IN0OOxghBA0yyLDEIH8E+wewfyhiTDGUBNOLorkkk4ucyQhjjDKjtKFGnj0AAd1rTmASDBU01DADJtcws5pu4TGzXSSV9LJLgANe2ey7pbQhBhA7FGGpD010YlUzwcgQgwy0ELMdgMowg40kkmCjnbOOlpfLtPXmgC98RrBRhimywOJWJmla8+4je/hh8slhpKCCH45QtcuzIOYCzCheNAHEnk9oUoYbZezcxRu+JJHJL7ksA0YAAnyadAAFiBDCAH8wk8vUcuZCdDCjnGEED0BkEowqO5uhxhtvqNGLLbjssh0jX4Dh9h5hKKFCCSPw8Ugy7xoj5/4uvfQycxlbZ8JML6h0UYYqwgwjDDHE7EJ0L836dhstL5CwgQlvTi3MLdBOnQwhXBhRhTXF7KJKF2bEwosvahtDCQy0TE2lMsb8YokLJGhAggjQQN4ozKJNLTMhbdjgCSu3EINKz6S4okorrzAjSQlM/LLLJsEiIokJluuugiKsEE31WbnE/ssoXIgByjC8/FLKFl14EX8XZCADQwUiWHLMHhuq4MEGHdCABjaAggAMQhm1GF/wpvYL0I0BFMiIXSzMQEEKnkENu1BBBTbwAl4AIgUm2MAGBDjAEOQnES/LxSyqNrVdgO4NocCFLW4hDFzEAhe4GAYuelGJEVxgA/4heIEIPMABDGRAhBngQAuOsQtb2EJ4VauFLly4BTM4MRe6qEUtaLHFW9BCGIDYgAUucAEOcCADGbiAETFQgRGE4ha3iMUtprbCs9xCF1MkBBbIMIwn4iKBfcThLZDBAgpY4JAYSOQY1cgBCVhCGLHDhS5UWMfg4fEWa9CCF/Jwh07ewQ6imEUutphBBkTglIc85Ckd8ABJ9GIWWYydKCtJoPLNYheFwIIud4kFLZwhFbSYBS4oMYIGOOCUyHyABRggAUCokBbQnAU0VSinWVhzFqgohDbXUAhCmEELW0iFNYchCAkwwAHoPGYEIPAAEDzyE7d4RTCvqQtaXuma0v7kxQxzcYtdGAIL4fwEK3KhhAcY9AEQYCcEFqACW8yCFfiM6CyycRZrQnQWn7gm8v65BVTk4hPJSMECGtCAhJp0ASCA5yR1MU98OsJK27hmRiNKC0NcYQtqGAUhRDGID0xgAUBdAEJ/ioIw7OGoiojoJ15a0Vk44hWzmMQnxDkJXdgUC1bQpRXO8AhBKCEFIPgAAAAAVAAQ4EIBSAAtJjGJh06CqaJ5KyvYetFNQBQVaBiDXvWKBnnesBaOAMQKUICCD6zAD3wAQ1Jf0dZZvMIRFBXNLFKRUUdYdhKb2MQkxGnNjEJ1qo946yxigQxk7AJ5V3TqWy3rVCtxgxaOeM4rW2O72tVaNraO2ARt2TqJRzgiFam47W3fyli2moUg2nCEb32r3OYKV7mzVS5zhTvd50r3GTW5hUSDOVOaRhOan4imNeuJz4zSIhoK2cY2uqGNbWjjvdrIRnx5Qt/6whe+3VDvQbahEWKg7ZrSfUQjBkzgAhd4EQaeLj6bdRLDjGYWAm5EIhKBiApb+MIYzrCGLzzhAT9iFtMwC3vnGw2+pNCJXqyFUy87CcYOV5Tlo8Ukq6KRjbT3uAc5LkXU69739ri96o3IlYSM44IEBAA7",
+    "restore": "R0lGODlhMAAwAPMAAP4YRv8YRv4ZRv8ZRv4YR/8YR/4ZR/8ZRwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAgAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAABP4QyUnrOSbcfUL9YPhhg3YUF3peBjeIcCVwdG1zcWgXQsH7vd8Nl5McADbCRXlgMlPQ1ao4XPlOqCtqcOEevF5BbLYxCAzmVpXFxrRbIgH5gjyu7zVDSF1V+aMGKIEYgoUHOjRpaXhqjW8ne3N2k3iVhyGSO1F/hJ2DnwUxS08bnJxHLQCpq1+XMKR/ZLIXM05LtxcxLxIDBI6WpikTuyOuCEcmUsF0rG4UKHsEBB9oGrMHs0yqSB8FAKEgG0oiJgMCvgNcdSEFLe2Io1xF8xPQ4Up1pQD0/OGlv6o4BPDBB82XfhNWSKuxTAUqDwgpeNmEjZbFikyIHVNBAGKIff5G3IisZO9YKWHs9Ex44o6AD5cFYLokYrKGCDTTKAD41gGZTwAagB6h8NOECF9dQHDJZEMiLpcimvAxFrEmjagZZgxwBzJi0SYwxDGUQq+OE5U6pjqK+bJk1Bo5RQDQ2sJghp/GTJD6OlUDnEvJ1hBFYavJ08OosCVE6oYtW50OLd3oagTJXaGUDWAOyvnr5i8GwVmwmRBx4dNP+fDjKflG1i8xqeoQ0Pmz7c6CcG0g47HY1FaGgzdFMPGRY5g5mMquYA40hrq1gYr6HFdEbEswyJydZ1xmWwF15E1Qzo/N5dq1iVL3GnjIuJWHq6ovsTPZB6Zo5fMb8Lm3fnoteAVB2QcRAAA7",
+    "results": "R0lGODlhMAAwAPc6AACrqQCrqQCrqQCqqACqqACqqACqqACrqQCrqQCrqQCrqQCqqACqqACqqACrqACrqQCrqQutrDC3uDK4uTG3uTK3uTG3uRGvrgCrqQCrqQWsqyi1tjK4uTG3uTK3uTK4uRuxsgCrqQCrqQCrqQytrY3T2ev2+O33+e33+ev2+FTDxACqqACqqEvAweTz9u73+e33+e33+e/3+bzl6BSwrwCrqQCrqQCrqBSvr7nj5/////3+/lrFxwCqqACpp2nLzOP19SK1swCqqACrqQCqqEa8wN3x8/3+/lrFxwCpp2nLzOP19SK1swCqqACrqQCqqEe9wN7x9PX6/NDr7/j8/VvFx2nLzOP19SK1swCrqQCrqUi9wd7x9Pj7/YLQ1Rywspza3lnExgCqqACrqQusrK7e4/j7/YPQ1QmsqwCqqBOurxywsgCrqQCrqQCrqQCppwCrqQCrqTG2ucTm64XR1gmsqwCrqQCrqQCrqQCqqAOrqgOrqgOrqgOrqgCpp2nLywCrqQCqqBmvsQusrACrqQCrqQCqqVXDxa3h467i5K7h5FDBw2jLywCrqQCrqACrqQCrqQOrqqrf4qXe4GvLzACrqQOrqqzg46jf4WzMzACrqQCrqACqqACqqACqqACqqAOrqqzg46fe4WzMzACrqRqxsjC3uTC3uTC3uTC3uSi1tgmsrKzg4wCrqRSwr7zl6O73+ez3+ez3+e33+eTz9k7Aw6jf4iO1s+P19WzMzafe4SK1s2zMzOP19WzMzKff4QCqqCK1s+P19WzMzajf4ajf4WzMzQCrqROwr7jk5u34+Ov39+v39+v39+Hz9Ei/wX/R0+v39+v39+v393/R00i/wQCrqRixsC64ti64ti64ti64tiW1tASsqg2urSu3ti64tg2urQCrqQCrqQCqqACqqACqqACqqACrqQCrqQCqqACqqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4AAQgcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48gGwYQMIBAgQIGDiAomEDBAgYnCzRw8AAjhAgSJlCoYOEChoIZNGzg0KGDhw8gQoi4OIJECRMnUKRQsaIgixYuXsCAEUPGDBo1Ltq4gSOHDh07ePQo6OPH2bc6gAQRcnEIkSJGzh5BspZgEiVwzy5h0sSikydQouiQMoVKlb4Dk1gJrOMKlsIUs2jZwkVHFy9fwIQRU1AyZcuYJ44hU0aHmTNo0qhZw6aN7TZu3kwOjLoinDhy5tCpY+cOnjx69vDhs6ePnz+nL1sEFEjQIEIBChk6hCiRIkWJEP4tYhQ9NcVGjh4FAAApkiTKkyiV51jJ0iXKmDLNp6hpE6dOAHryCSihUCbKKPtJJAIppZhyCiqopKLKKqwYiCBv0k3UiiuvwBKLLLLMQksttliYYERC3IILZbnoYiKG5kHUxC5LUMaLKC/C1dtETWBxBWWj4BjYgSfK6COQQsJFJIwU9fhjYEHm+NaOEjmJpJRnURlRE0z0Qpkvv1D2iy+U9UIYRcAEIwxlwxBDWTHGUCZMMMBQdAwyySizDDPMNOPMM9BEIw2f0kxDTTXONMPnMsokg8wxFD1gzTXYZKONNttw040334BzKTjfhNMNN9tcmg0211hTE0XijENOOSuwmnMOOumosw6s66iTDjrnmANrOeSMI05IxBZr7LHIJqvsssw26+yzIAUEADs=",
+    "ribbon": "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",
+    "right": "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",
+    "save": "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",
+    "send": "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",
+    "show": "R0lGODlhMAAwAPYAAFNTU1paWmVlZWxsbHJycgBSvwdYwgpawxNfxRZhxhlkxx1myR9oyiRszCpvzi1xzjR20Tt61EF/1kSB1kWC2EqF2lCH21OK3FmO31uQ31yP4F6R4GSV4mua5XGe53Gf6HWh6Xqk6Y+Pj5aWlqampqysrLS0tLy8vI2w3ZO034Co7oqu7o2x7Za24Jy645W3742x8ZO185288p69/KG+5qG+96G/+6XB56vF6q/I7bHK7qbC9KrF9K/I9aTB/avF+LbN87jP9L3S9cTExMzMzNPT09vb28PW9sfY+cvc+dHf+tTi+9zn/OPj4+zs7PT09Pn38v369f39/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFMAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NAAsAAAAADAAMAAAB/6AU1MihCOFhIiGiIuKiouHIo6IgpQjUpeYmZqbnJ2aIpSCIlI+Mzs7MDE8KyoyLyAfHh0dHBsZGBcWFRUUExG/EA8PDQ0MCgkIB1KgoaM2P0tIPUhAQjxAOyGytLUZF9+7EhLAwg7ExgkJysyVUjY9SkFCSTJCQDIsIR+z3bfgvb4iQAg2jJiCYwaWhRokZUYNJkti9GAiY8WSI/u4ZfB2YVcvYATPHVN3ICE7UVKYKFGZJImSJEhgHpkp5IgQITqC6NipI0eOG0Bv0KDhwkWLoylQKAxl6VIUp1KiSH2aiapUKFGhYI3KlSqUqUspjbo0pKyJJidMnCgxRMoQE/4lSBApYgJuibpGpDzR++RJlL6A956c0vTJkBNDiMx9q1YxkbqJhxRx4qSJk0uBMzt5cnnwWMNziwwxclhyYiNEJKfOi6kvlL58NYdF6an2pr2tYQOmPJvhpSZNjDR5ItzIkyZFggMHLrzy8uJGohspktwI78GFpyd2UoQ09dSLFY8ukvqEaNFlExM5kdpy78+mRQc378QE6vLthzRRf3j6XBOJpXVCZwvBJ5lowiFHHnn+KabgXIp1d96CJ5AwhGALFRbhYdWxByAR09FFxH4nkBbZeiaAWFcJI1z4Hmb6kRceacglFpxoip1Qo3rmlSibZ5hJSF1lyVWHmndCfv6X4oKoLTgihkwFCWITRBwHooQKUsegjBF2CeCKxr14SYjyjdgkk1oqFh2VqQW4mWwjZJgbZ5e9aSdleOaJp2XAUcbZn1CKZVsnuu0FWGx9baZooLQ9ERoRToAYYRO14ZbZpZyJ6ehyzHXnRILBgfpccqF1RyV1wjFK2CVO6DfqkFoiNyJyCgJYRFpv6QcXYsOJGSmVIU4H3GQSmkneYSewRyVi/KE1BIHN/FaqpN8JF6OMyIKImHg4ipeYqk21CuJpjs1lhAndoabeXMBqeV4JXKo6CmyDxqbXvZYaylcm8rIKIYTfHThXoZgSfCi4rApJJqoLFuzwpWLWextumOzhey9msMUZpRStvrVehEaYd9i4s+5Xsn908QeicEByrN6xqHqr2sikqRlyJIY0Eskk0XKMLmodr1YWe12ua7IJY3HyBAEL+RZpfJLO9bSaXKop2QlJa7J006u6zOCR6QEXWnClJifrvPvqJQDXTgN44GjJmnBZvU2IkBnHTLOdtb4HW1pxxbjVTWeiebPdlBR8WkYnpRf7/TfidvvpxNps0+bEXSXcFTKArTVOLyZ17zlA5YIq3bjWqENOWROUk961xKaDbjcRALheOuy21W1EALa3g7ttT4hQe++iPCLJzow8ovxgxDfvfO+BAAA7",
+    "stop": "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",
+    "tartan": "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",
+    "tarupd": "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",
+    "tcltk": "R0lGODlhMAAkAPUAAP/////39fvEufmXhPRrUvNYPPNWOO1GKvJJKew+IO07Hes3Gu1MMvVzW/3i3vqsnfiBafRfRPNHJO00Fe45GvE+HfJCIPmzpfVLJ/hSLPu8sPVlSvqllPmhkPpXMPtaMvxcNO9CI/7v7PZyWPdTL/zLw/ROLPWEb/eMeP/6+fugjf3b1P7q5uIqFPvHvuImEP1fNupGMOxSPO9lUPh4XvR5ZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAJAAABv5AgHBIJAYEA0LBcEAkFAsFo+EoWq9YoeMBiUgmlIrYQi5bKhTKIMu2XgyTsUUiwWAy+DweI6lMNG1aGwccRR0IFGR1eR4eH48fIJIgjxkYFiEibRwLnQtEI4mLjY+TpqeUGX0bbB0LISELB0IBEYl3jpAfjbwkGSQkpJIfGRYTJVgDCiEIsWsiJhV1wb17dnx02biVEhQnV8ohJggKEUIEFBJ4vpbYZGJhCAhnFWQmjaoUEFYoCgjjCRAEAKBhgoU7liTQq4BgA4oHJTQVSWHAwh5jyIic8GfCRAgFVQAcSIdHoYICEDRIbCNAGh8KI4pw4OiRAiAhC9LZSQBhYP4gIg4SnSlQpMSyjt1UEIkQR0KIBCt+FtEQZYFAIiwSiCOBYME3ItDAdGqxwYVUIQU6KYg6JAWDreQaYHHBdMKLuwykFsx5ocgGBSa4lmvDYkABuyF+OlgwYUJMIv0QkDCh4ECKsyJWZglwoLECzUYldPzI4uzZDY0nKB0iAtboBRlNB0IxoVPepYA9LngwxAGBjwxKyx5SkALj2ACU/ev6FcCJKLAUKLg8fEUaBRRYDTEqjpx2AAQ4AouFXGoARBWkhwQQAJa8ypdTRPBHAgQMD10LybZlAfu+ISP440QCmgTAgFUe2AfDB12tJxUKQlUQgk8ELePEAlGlEEMLAf7VBwMIJMAiWwmiWEDBauy5F8tNMrTgYgImSMLVAn2ddZ40fZhABAEBMSfEDC7KIEITHgj231kEuJTUdhyFMAsADSzQwicbSUYOAbI9cMslElAHQAQhAIOAARwUsAwsBLwyzmCmOVCPHX2g0BuCH3ikVWDjMLMmUbIZUMEdl1hA4QOA2QdiMJPsMhkz1GlwQo1sqECSJRUcCQAECnj44SQwdPohZWwJ0MILT2bh5kGWnKFZAwloSkkwkXQKQjNauPhCB21sMGkfNBRRA2CRfMCVex6CQBkBKiTg4ndZKOBSoJoRZJWYWm1AwwFhRjKjiy3U8BMYc5gopxUHLJPAAjEF+JQCtng60UIIAjwIRhp8WiECAQwwMO4QF0D30QL7StVACBQQQKFpNbxlAATCEREEADs=",
+    "teams": "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",
+    "top": "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",
+    "trash": "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",
+    "truck": "R0lGODlhMAAeAPYAABMTExsbGyQkJCkpJywsKzExLDQ0Mzo6Njw8O0REPUhIPUREQ0tLRU1NS1JSTVpaTVRUU1tbVFxcWmFhV2NjW2lpXWVlYWtrZW1tbHFxZnNza3p6bXNzcnt7c3x8e4KCdIKCfIqKfYSEg4qKhY2Ni5SUhJOTjJubjZWVk5mZlp2dnKKinrGxmaSko6qqp6ysq7GxrLS0s7i4try8u8DAtcPDvsTEw8jIx8zMy9DQz9XV1NjY19zc3ODg3+Li4ujo5+vr6/Hx8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEIAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAHgAAB/6AQoKDhIIqhygvNi+MLy2HLZEtL4crLSiFmZqGh4wxMzg2MTo2OKamNqk2M6wxri8xNpuFKCorLjEyNjk6PD6/PDGKvj8+xTM8M6Q6P8U+OzOzgq4zN7w8vr/aPj02Ojg94dw+vTg8ODk7POo6LtJCyuvy2NvANjw6QEH7/P39QEBwvFO2o+A8bL6ymdPhr6G/gAPTFTSYLSE2b/mC6NO4D6BGgAB/3Ii4jiK9evdw/AC5ciUQl8a0yZImQyJFccAu7sBhzFk9bT14BJ05a0Y6HTooAvOB0MbOHj5eeMDgwYMIER5GaCWR4laKC9KM7kiqTijUnDy83Zsh4cACDP4NCBAYQHdAAbcQLlyYMEsGjoJIsYULSi+tDmUqGkCQQIIDAgQJBggYQABvBxQjMGzyi7RXL6EImx624cECCBIrVjBIcMAAXQKQG2BoIQOFBk0ybnT+bJbwxRwzYmQQ8WKGixUVEBwoIJmAAQQNKKCQMcOEphi8OgsOB/p3LhUueq0Y8YF16wMHEjRoIAGDiEMfMr3IUbLs4KBQ0+JwtMKWCxMhpFCBAw04YCCBBkJAgQUaeHAbIaOgRRhToZUilQUkqBADDjfcMIMKV4kwQogjkIBCLceNQMgL+bzkUkjODLWICBiQIIMOvIwF3CQuuNBCj7BQt0oLIAyigiI4BP7mA0ghMZVKC1WhEAM9LcEgAgomfKDBBRp02cEHIIhgwgkdCBIJLJ6wUkqHN6Bjww0viEBCC6PwAJIPK5jwwgofZEBBBXp1oEEGG5wgg4pCoDCJK4zOoMqjusWpISs4yGDCDTxkucEFFUQQAQUUXBBCBhloEMIHGwjCgQUYYMCBqx6YeGItkMyAggcqlGIDDQ4EAAEOJgxqgacRTDABqH9SQOiDQgjgrAAEQGuAc9Ma0BoCCxhgQQulzADDAdCOYAIHF1AggbkVVGCBXhewSuggAgAgr1zTymvvvb7mygsMBTwWAQYREKgYBItJIEEEBhuMQXwLxDuvARAsEMC99sYGEEAELbSpwwkPUIXBiCKA4EGYIYY54ogmpCCIAQtY0IAABsDlnMUABCDAxAE8YAIMNNRwQgQWSNDABR8UvUEHG2xQdAhMN10CC5kEYAAJEjg3AALw2nxXAlwrEAF0CBTwgAIPTKBYBEqPzXUCDKS6CQcLyEVAA5owcIC9DkyFgAAQzHKvAZlYEDECBAQg2QDPIWDAtHI5W/F6AhQgl83Oyt1wzQEgIIEHmEgzVdAQrLeAco3fLMACDUhss1yPrbcYqxwQEggAOw==",
+    "uncheck": "R0lGODlhFAAUAPAAADMzMwAAACH5BAEAAAEALAAAAAAUABQAAAIsTICpC3YM1XO0UmmzwdryfiWgJ44hYp5NupXsZ8KjDNKdreGZTj5R5PhBDAUAOw==",
+    "undo": "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",
+    "up": "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",
+    "update": "R0lGODlhMAAwAPcAAAQKHgMFKAYMOR8gNA0ZUxYkWBkiTisxUhkfdRgpaRMudBs2exMpaSUteCo1fCs3eDI7eSo0aTdDeC1Af1BWdGVqfS07gy03iTI7gzE8jDI2hSgvhR1CiipDhzlDhDNDjDhKizxSjCpFkzREkzVKkzlLli5SnTtUmzxZnTlVlztXpDBYsDlpty9pvRhIqURMh0dVi0JMmEVXmlVflVhllV9xmEhkmXx9jGh1nXV8l2NslkNbo0Zcp1dcrEllq0lmp1RqqFtyq115qkhptVNutFllsF10tFd4uUlzrWJsqWx9rGh1qHR8p2N0s2t7u2Z8tnZ+tWRtujNe0zJcyThpxz12yi9n0jpo1zly2Dx64ENsw0Zpykd4x1l9xktz2UV+4m53wnqMnHeSn1yFunyFrHaFqW2IuXSEs3WIuH2Ru22SuT+H2j6K5VaFxUeI2FiF1UyW21yV10+Fz2mGxXaMw2iXzn2axXiVyWuX1muQ3HyjzXWl2Hm03Wan2EWE5lqL5lWY52OU7Xep4myy53y75muq51Wj54mLmouTnoePjoOKrYeLpIiYrJOepYaJsoqTvIaXtZWevoylt5SivZeoup2mqaqzubO2u6artcDAvYiXxpKawoWe0oCNwYyizIekypelx4an1pWr1oq43Jm015e1z6KryKm1yLW6yae42LS616Gt1Yi645i35JCy8K294aW145TF37nCyKrE3bjE2IfF6ZbK6JTT74XI85fI85vc+5nV9ozT9afH5rzN5LfH5anV7rzV66ja9bjb9L3H853k/aTl/azq/arl/LXp+Lny/cfGysTM28nM08zW29TX2NPRzOPe2ubj3sTM5sTU68zb7MnW59bc6MrY8dTd9enf58bo7dzk69ni6Mjr/dzm9Nfn9sX1/Nf5/OHl6+zt6+bo5vXy7Pr46+Pn8+Pq8+vt8+Pt+uvv+evy9OXy/evy++z6/uT4+fT19Pn29Pf59Pz99fL1/PX7/f7+/vn2/fPu6gAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAACP4A8QkcSFBgvYMFEw6sR5ChwocQDUYkaG+iRXwHHV4ceM+ePXft3hXUGDEjwo0C79175+7bN27f3uXDeDLhzIUCb+KDh24myYTv3q371s0aNWrZ2KHkmC+bqk1MFl3DCPFePqHfth399Wvat3v4dD5Ux0yVphkvIESAQIYb1Yf57L1L9y0bNV+/eqVSRa3iQ4b5rjFJ0KCwhg0xNLGrqTAuOmvVsPnq1QsWrFW+3oH9i+8bFAcaNGBAvIkqw59v8bW7hmoaNVitYInaNAve5pEM7WlqoKGBhAY9So/UOY9ePp36UKn6RUpUqE+Qai/UONMUBAsZHlyPYgrh8YJiZ/7eZEbplShPduygoQXx2osHGS5MCPGgya+DN9ldOnTjxqH/l6iT0DWPmHUHHWakAc5tgNkDBQQZZGDBE2nAsIQz9dCDDzo3HEBBDo6sYgooOeRQwQ3mhIWQM5CkgsYccwQBCjwGOTQNBhpE+IMSpkyTAzMMnXKABExo4olZZ5zxyCqRHDAAKipqKMsjoowxRhBCBKMSVfYoocEIGYBwRhj43HPKVIsEIIEjTNAhihFGNNEEHVCcAQoFASyCj3EzMeIJHUcc8UMatlE1TQwjjGBBEzqME9ZMiQRAABRBnCEKET4QMYQRdAQRBBrZGJAnPn5xUwYnQBBBRA3U0ITPJv4QJFqCEpPgc85MmABAwAJByOBKFENsMcQQXXRBBBB0kBIBAQJcEhZYoEDyxLAyUALWPesE0QEJI0SxhKP15KOOAQQwMAIKRPwhxRbCauHFG0PUYYQQ2NBQwAHt2FpPN2XcwYMPMijhDljYhPBBCSOA4YhA8+BziAAKKFACD29IIcUVXnixxR9eBPIGC3XAYkEBBOhJzzn1OHLHDz78AEOr+LzyAQkk8OAElOHac0ACHCzgQyssTGHxxV64kssWVQTiwgpDbEBAAfbkcw4+p6BhhAoyhJBKmZuMQPMPZ0ylISoGLKDCGMGIcwQLVXDxxh9/7LF2IFZMYUUXHIjAgP4qtuJTzRlHqMBDCJCUSccHKXxgxBLyOLRIASpw8IM38PARByCAyMFFC0iEsgcVV2AxxRsmmMCAInuqtoQTJ+wg5kpojJACCE+QcQ9CODCARBcohNLLEFVYYQUWWFgRyj2tUPHFF24jscICOLjKxBytg8AES2eMcEIITjximg4irMDFHr/o8YYbfrDxhR9ZCOKNIFWg70YcR6xggg6uKmJGCa7rwI47aCABCrjnPYfUwARVYMEchtELYcABDmtwgwQFUYdCrIENhoBDHOTAghREDyGOYJ3rlrAOAH5gBydwgiLogZAzqIALWqiDHuqADD4QYhB92AMwbKGGQhiCDf5wkIMeONEGI5yBJvcgA+tikIElaCYNIOCBCp6Qg3dk6FUo0FwfCAGHQcSiD7WoRTLwIQ5W4AIXgxjEKMBRRhvU6iDwyEETRhCDDzChIqAIwQ5U0IS2XNEXP5CDHPbAhz7wQRe1IAQhgCEOYOwCF7woBh/0MIxh4IEG7EEZN85ABDp6gAwCoQUMfsCDIpxBFvjQhz3YsYQ2xGEPrACjLY5xi2IYQxi34EUiaxELPfSCFG0Yw2KmRosn/GAEJYCAKcpUDRvIgAc8QEMk8GEOeeAjFWPAwx5cwYda3OIYtFRGMopRDF3cIhbhsIXn2kCKVOoDH9JCGAgkwDd8uOMMKP7wgQrMUIZ0yMOa8egXIXLhTV0UQxkIBecxbimMUZDCG6EwgzvqcY55qEMJRkgUBmCQjjLdAxQp8IEPPrVMerAwGGrQoS12YYxjKEMc4kjoMZABDFaMAhh2oMbtNGSKJsggURBgAlgYQg0kiPQHaugnQu4xCz3kQhi7KMYxtiGOeIQjGclQBjJ2wYpc6GEWGDkHtpTQhA+ACQN8O8hK6MCyHwQBEpTYUz3gAY9ZlOIWu9AFMpKxjXAoIxxX3cUuctGKXtyDG8sQyCSeIAMLfAADM1AKQXwBhEz9wA5p8MU9WBiPbsiiFMAAhkGlWoxkXFUYvYiFLK5hD2swYRrEWP5CETLgAQtEABQFuYc7NPGDQAlBFJBwCz3K4QxZUEIMpegFMIQhjNAOw66SoAQqniEPZyxBBnRoQoSyQ4N1pKZM1BACEo7QhmRNwi3keIYsLNGIMIhBDNGVhCQYEYYwMAITy3iGOVSxBA28AAQ50k4qbgcYjOQDHKkQwhFgxIlXUIIb+4LGMjJxCUw0YhGHQAQiGoEJS8giv9LIhyqSIBr4XCACZFgHgQvSjm6IQghzuIMdPPGLUzCjHeSIBjR2LOFl+JjH0IhGOVI0iR5cwAIPsMAGlpCNdWSkIPToRjVA8QQ6cCIUmJlGM7hxjnOQoxzSKIc2yiHmcuhDH+aYx81MHiGDDWDgAQ5oQBKmQWCS5KMe5nhGNUShhhmTAhbUAEc2rqEOk5pUzXHJxzwa9qhHxOACDojAAhJgAAo0484C0dBColyNWUjiE6J4xS8CvY6g8OnOWyoIOsigAQT4BgZN2AQqxKYQwLyEFiNKxai3gY532OM27cmBDsoQCRtfox2oUQg92rGOa9Di2ZBBBzt+bZF5NMMa3RhHN8hcDk1vxB7x+MY1qgGOcUzbLxPxiF+AvRSPtiMkmmE3RHzS7oik+iKnqfdI9F0jiwQEADs=",
+    "users": "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",
+    "voucher": "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",
+    "warning": "R0lGODlhMAAwAPYAAAAAABgAABUVFSAgIC0tLTc3Nzs7O0EjAHxhC1VJI0VFRU1NTVZWVl5eXmlpaXR0dH19fZNoAIFmEIZrFYhtF5R2FIpzKY54MYZ/aM+cANOhBOOtAOSxDuSxEea1G9+4Oee5JOe9N+rBPZiERZuITKGPVq+cXurDQ+vFS+zHUezIVO3LXN/Fcd3GfeLFZ+7NY+PFaO3Oau/QbuTKdOnOd+nOeu/RcezSffDTdfDVe4SEhJKSkqampqysrLCwsLy8vNjHkNvLlt/Pme3Tg/HXgvLYh/LZiuvXl+PTne7amfPdk/PenefXoerapO3dqfPfoOrfu/LgpvPjrcfHx83NzdXQwdPT093b1Nzc3PDlwOXj2+nm2+zp3/jv0uTj4+nn4ezq4+zs7PDt5vHv6PTy6/n27vT09Pn38f368v39/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGoAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AaoKDhIWGh4iJiouMjY6PkJGMO1NmZlM7kpqDCmZpaZafYQqbkQ2WYV6qqpYNpY+oq6pYXpavjT9pYampslhmP7eKDqC7YWBbWlqyaa7Ch7Vmu1xRT9bLXr9ez4bE0rtLSuJKScwO3IS/lmZZREbv71CrYVrogt6WZET7/PvYXmnOocMCCpQTHDhyJMyh0Mk8LOiIFTRjI4YMGzZkaLz4ZVVAbgQ/nYnyoqQLDBhgxCjZ5OEziZ/MrFCxYoWJBg1M1KwJxqPAVyE/PUGRomgJBgxKFE2B4kivMBBfPfj0CY2IEyiykliwgERWFCc89Ez1sVTQNDk2gLh6goQCBf4jTpwAsWHDjF1eoJaCUDBNmQ51N3gAYcFAAQseOATuwKVXWUkE190IHBiBAAEIKNe9ayxqJL7ryADWLGHAAAmaN3AAY+zxo1phLA1JvYECAQITaHPe5dmRDl27xnigbZsABdocxLT+2eiXsSGKUxc/TruGMTO9F/1WdSwx8dvUU3dgvcu1ory8atCuO339hhpjdmFvtF3VltG0K9yu4J5D/PLMIYJFL17M4N4GGiSQgAYH1iCNJdkZwhcWtGgR3YEYbtABGfKZV8iAFBaY4Ygb3IDKfIhMZQWFV1xIonsbfuOhILRQiAULGWZwwAEZZGjiOhGq4YAZVqzYYoYRBMkQQAQZckAGKh4OWKQVLYyoI48jJrEOioSkgcWUH7z4YgxbplEAISpaQYUVYYo5YgighAIBITykoeaaQLg5ogwTpeEDIT2k4QUVa1pRRRCIJioEEowyysSjTUTqxKROSGHppV3E5EkawXACCqGFTrmijdnMg558W25K1armRQZqqF/aSIssxly3DqusmmHIApuqKeqKo9Yoy6kn3oprGg8gApAo89R6XWyphkKVqqs6g4gOPyx77LbcrmoGFTuciQ4A5Npj7rnoBgIAOw==",
+    "white": "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",
+    "yes": "R0lGODlhMAAwAPYAAD+7DkC7D0WkH0apH0W9FEi/F0eyHka7GEm+GUeoIEmuIVKsKU2zIlK8JVWyKlmzLVy7LlyzMF69MGOzNWW9Nma2OGe6OGy8PE3BG1HEHlXFJFjGJlrJJlfAKFrGKVzJK1/KMGHGL2PNLmTDM2PLM2nKNm3FOmrNOmfQMWvSNW7QPnLUPHfYP3rMRXPSQ3vVRHzaRHfTSXvWTn3ZS3/XUoHeR4PeSYDXU4PaVIjeV4TZWIncXIXgTIrgVY/hXYzdYZDeZZLgZ5bha5nlapzkc6Hld6PmeqbofgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEgAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6ASIKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnI8vNi2djzU2paGii58+Qzk8L6iJpD5GR0U5MK+whBcwNT5FRsFFPTW5uhcvNTtFzM1EPTAwuiYvMD9EREXY2No5LMacJiwwO9vm2ELeLxWJJisWkeLk2EBEQvdCREHeKxftKwApPDrxbUcQIAjtAQnCEAfACYlKpGAxA6CJRidSkDuI8McPhEB+vGChQlHGFzt+4FCR4qKiEitQepxJ80eMFCcUkUjxQseOnzRUoBgRMYWLn0iT7tCxIkWJlylU0MCBQ4dVGS5SEC0UQaILq2B14FiqQwbLrYhIiJBKo61bGv4yToBAiyQCCRQr3rq9wXdGChJ0DY1AIcKFDBlwDx+OEcPFUEERUOBVTFmxC7WBD40QgcIFY8+NGTdOIQKEhA8eXIAGLbqxCBECG0H4sFa17dsuSnz4AAK37xO7H0CCwOGDUd+qT7gAoTy5C+XNQeyOIOnBBw7MSchdPuIECebLe58YTx5Ehw8LKDnYoOEDiRK9QciXSz+79u8eNGy4tECDBg/yBSjggPJ9wF4HmfSXgQYgAOgBgA02+CCAH/jXACcdYOCffw9uuIEHG4SYQQYXdtIABhgsuOGKGmSAYominIjijDO6WAAGDOiCBAM0oogAigQgkKOOSBhAwJFHFjCQ5JBE7ogkkggo0CQhChAAwJUHJDBlIQMcAAABAmxpiAAGiGnmmWimqeaabLaZSSAAOw==",
+    "zoom": "R0lGODlhMAAwAPYAACwsLjMzNzU2Oj8+QklJTU1LUVZUW1hWXlpYX11bYl9eaGFfZmBfaWNhZ2Riamlnbmtpb2dmcmxqcm1senFvdXFvfHl2f49LAJFNA5FPCJRTD5ZXFqZbArRhALdmDa9yGppcI4xlLJxiJ51hKdNzAdR3Cdt/C9V6ENd+Gt2BEOiKAPKUBP+aAvCYF/+kG9eCJtiCJdmFK+uUIP+jI/ekKv+lKf+oLPWoM/+vM/+xNbeIQvyzRf+6Tf+7UXNyg3p3gHx5gnd3iXl4i3x8kIF+hoJ/iYWCi4mGjoqIj4mHkYyKk4WFnI+NmZGPm5ORnoqLpI6PqpeWo5qZppGSrpudu6Sks6iot6yru6GjxKSnyaepzairz7Cxwbe3yby9z6ut0q6x16+y2L6/0bK13La54ri75Ly/6b7B7cHC1cPF2MbI28nL38zO4sjL6c7Q5NDS5tPV6tfZ78HF8sXJ98bK+dvd89TX+dTY+d7h9+Hk+wAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAHoAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAADAAMAAAB/6AeoKDhIWGhkaJFkBEiUqHkJGSgolAFpeYl0BARpOekUZAP5pGTE1NTEdEmJyfroKiFj9JVWhvdbh1cGpXTZYWRK+emxZHXHF5ycrLdV5MpMKQqxZSbMvX13FWlhIS0YWWQFV12OXLXRQGBxTflJfj5vF4d1QJBgntSZZR5PHmdnToPDlwoME3UUCs+SsHkM4cMxPURVNiqcoyPMkwxgM4R86cOVQOGDD4alURhQuXNXT48UxEfK/2aVQ2s9ydjzhxQlHnzZUlLv5q5rGTMyedLfYcuDryA0ialMpuFs1JxsFIVyZRLrzDcmrLl66UWDDyBipRrznP+JD46YiFIv5uFs5DW1QtW09EfhDRapNuUYgGGLhC8uMHGn9S/X6kQ4ZBwZgWrMTj2tUvnSz2SH6y1KTftZWKFy+5J8xI06fXuHoMPYdOmQikhVmSUpMr65xTDASOZmSRF2Vnb38cYxVBO1FKynIUPueMEHVKv7m14KRNQOF05Iw2sKCdoEsPgoyprNjMEpEw2xEo0EBkBCyrF8shP+fL2gPpXfXYIYjAgAACIIDeEFqc0VpALGU3xhIL6HZANDzkIKEO/wEQgB4O2HOPD09gAcYYY4CRxRRBKKDOY8JEiIOEN4RgISEJaKiOAg00oIBIDibQ0ys74OCjjy6s8MEhCyRAkG4OHqaAQAMQfPNCCjT86AILVEpCwQIPQJDAA97pEUMJJJgQ5ZRUsuBCl67EQMKaYbZQJpU2oOmJmmyS0AEHKpQZp5ySfFlnBxhcgCcLM/DZJ5hsAnrBohzIYGgkfia66KQgPAoJnYkGekGglVp6CKJrKrpoBp16WggKf2p6AammfprppBiU2iohJ4SqagYjzHoIDHYG6muuuh7iwa3ABnsICBpksIGxkAQCADs="}
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== renamed file 'std/tartanWork.py' => 'tartanWork.py' (properties changed: -x to +x)
--- old/std/tartanWork.py	2020-04-20 12:42:42 +0000
+++ new/tartanWork.py	2020-07-29 09:10:20 +0000
@@ -264,6 +264,7 @@
             "carried_forward": [["", "NA", 22, "Carried Forward"], []],
             "contact_details": [["", "RW", 30, "Contact Name & Address"], []],
             "deliver_to": [["", "RW", 30, "Delivery Address (All Lines)"], []],
+            "line_unit": [["", "RW", 30, "Unit Description and Room"], []],
             "line_value": [["", "SD", 13.2, "Line Value"], []],
             "total_balance": [["", "SD", 13.2, "Total Account Balance"], []],
             "total_movements": [["", "SD", 13.2, "Total Movements"], []],
@@ -422,6 +423,7 @@
     ("MST", "TarRes", "Allow Database Restore"),
     ("MST", "UnbalBatch", "Allow Override of Unbalanced Batches"),
     ("MST", "YearEnd", "Allow Year End to be Run for a Finalised Period"),
+    ("RCA", "DateOver", "Allow Override of Transaction Date"),
     ("RCA", "Overpaid", "Allow Override of Overpayment"),
     ("RTL", "NewAcc", "Allow Capture of New Account"),
     ("RTL", "Super", "Supervisor Password"),
@@ -1159,7 +1161,7 @@
             [15, 'brt_invno', 'UI', 9.0, 'Invoice Number', 'Invoice-N'],
             [16, 'brt_invdt', 'd1', 10.0, 'Invoice Date', 'Invoice-Dt'],
             [17, 'brt_crnno', 'UI', 9.0, 'C/Note Number', 'CrNote-N'],
-            [18, 'brt_crndt', 'UI', 10.0, 'C/Note Date', 'CrNote-Dt'],
+            [18, 'brt_crndt', 'd1', 10.0, 'C/Note Date', 'CrNote-Dt'],
             [19, 'brt_capnm', 'TX', 20.0, 'Capture Name', 'Capture-Name'],
             [20, 'brt_capdt', 'd1', 10.0, 'Capture Date', 'Capture-Dt'],
             [21, 'brt_xflag', 'UA', 1.0, 'Export Flag', 'X'],
@@ -1416,11 +1418,11 @@
             [6, 'bcg_ocod', 'UI', 6.0, 'Opposition Code', 'O-Code'],
             [7, 'bcg_rink', 'UA', 2.0, 'Rink Code', 'RK'],
             [8, 'bcg_group', 'UI', 1.0, 'Group', 'G'],
-            [9, 'bcg_shots_for', 'UI', 2.0, 'Shots For', 'SF'],
-            [10, 'bcg_shots_agt', 'UI', 2.0, 'Shots Against', 'SA'],
+            [9, 'bcg_sfor', 'UI', 2.0, 'Shots For', 'SF'],
+            [10, 'bcg_sagt', 'UI', 2.0, 'Shots Against', 'SA'],
             [11, 'bcg_points', 'UD', 5.1, 'Points', 'Pnts'],
-            [12, 'bcg_a_shots_for', 'UI', 2.0, 'Shots For', 'SF'],
-            [13, 'bcg_a_shots_agt', 'UI', 2.0, 'Shots Against', 'SA'],
+            [12, 'bcg_a_sfor', 'UI', 2.0, 'Shots For', 'SF'],
+            [13, 'bcg_a_sagt', 'UI', 2.0, 'Shots Against', 'SA'],
             [14, 'bcg_a_points', 'UD', 5.1, 'Points', 'Pnts'],
             [15, 'bcg_aflag', 'UA', 1.0, 'Abandoned Flag', 'F'],
             [16, 'bcg_seed', 'UI', 2.0, 'Seed Number', 'SN'],
@@ -1526,8 +1528,8 @@
             [1, 'chg_act', 'UA', 1.0, 'Action Type', 'A'],
             [2, 'chg_key', 'NA', 30.0, 'Record Key', 'Record-Key'],
             [3, 'chg_col', 'NA', 20.0, 'Column Name', 'Column-Name'],
-            [4, 'chg_dte', 'UL', 14.0, 'Change Time', 'Date-Time-Chgd'],
-            [5, 'chg_usr', 'NA', 20.0, 'User Name', 'User-Name'],
+            [4, 'chg_dte', 'TS', 14.0, 'Change Time', 'Date-Time-Chgd'],
+            [5, 'chg_usr', 'NA', 20.0, 'User Login', 'User-Login'],
             [6, 'chg_old', 'TX', 50.0, 'Old Details', 'Old-Details'],
             [7, 'chg_new', 'TX', 50.0, 'New Details', 'New-Details'],
             [8, 'chg_xflag', 'UA', 1.0, 'Export Flag', 'X'],
@@ -1730,7 +1732,7 @@
             [3, 'clg_type', 'UI', 2.0, 'Transaction Type', 'TT'],
             [4, 'clg_cono', 'UI', 3.0, 'Company Number', 'Coy'],
             [5, 'clg_period', 'UI', 3.0, 'Financial Period', 'Per'],
-            [6, 'clg_start', 'UL', 14.0, 'Starting Time', 'Starting-Time'],
+            [6, 'clg_start', 'TS', 14.0, 'Starting Time', 'Starting-Time'],
             [7, 'clg_xflag', 'UA', 1.0, 'Export Flag', 'X']],
         'idx': [
             ['Control Log File', 1, 'U', 'clg_login', 'clg_user', 'clg_prog',
@@ -2245,7 +2247,7 @@
             [4, 'grt_refno', 'Na', 9.0, 'Reference Number', 'Reference'],
             [5, 'grt_payee', 'TX', 50.0, 'Payee', 'Payee'],
             [6, 'grt_amount', 'SD', 13.2, 'Amount', 'Amount'],
-            [7, 'grt_flag', 'UA', 1.0, 'Used Flag', 'F'],
+            [7, 'grt_flag', 'UA', 1.0, 'Allocated Flag', 'A'],
             [8, 'grt_xflag', 'UA', 1.0, 'Export Flag', 'X'],
             [9, 'grt_seq', 'US', 10.0, 'Sequence', 'Sequence']],
         'idx': [
@@ -2670,7 +2672,7 @@
             [6, 'mlm_gender', 'UA', 1.0, 'Gender Code', 'G'],
             [7, 'mlm_nation', 'UA', 2.0, 'Nationality', 'NA'],
             [8, 'mlm_dob', 'd1', 10.0, 'Date of Birth', 'Birth-Date'],
-            [9, 'mlm_idnum', 'UL', 13.0, 'Identity Number', 'ID-Number'],
+            [9, 'mlm_idnum', 'NA', 13.0, 'Identity Number', 'ID-Number'],
             [10, 'mlm_occup', 'UI', 3.0, 'Occupation', 'OC'],
             [11, 'mlm_proposer', 'UI', 6.0, 'Proposer', 'Propos'],
             [12, 'mlm_seconder', 'UI', 6.0, 'Seconder', 'Second'],
@@ -2759,7 +2761,7 @@
             [18, 'psc_c5', 'UI', 5.0, 'Quantity C5', 'Q-C005'],
             [19, 'psc_c2', 'UI', 5.0, 'Quantity C2', 'Q-C002'],
             [20, 'psc_c1', 'UI', 5.0, 'Quantity C1', 'Q-C001'],
-            [21, 'psc_rec', 'D1', 10.0, 'Reconciliation Date', 'Recon-Date'],
+            [21, 'psc_rec', 'd1', 10.0, 'Reconciliation Date', 'Recon-Date'],
             [22, 'psc_xflag', 'UA', 1.0, 'Export Flag', 'X']],
         'idx': [
             ['Cash Count', 1, 'U', 'psc_cono', 'psc_host', 'psc_user',
@@ -3211,7 +3213,7 @@
             [6, 'scg_ktyp', 'UA', 1.0, 'Key Type', 'K'],
             [7, 'scg_scod', 'UI', 6.0, 'Skip Code', 'S-Code'],
             [8, 'scg_ocod', 'UI', 6.0, 'Opposition Code', 'O-Code'],
-            [9, 'scg_rink', 'UI', 1.0, 'Rink Number', 'R'],
+            [9, 'scg_rink', 'UA', 2.0, 'Rink Code', 'RK'],
             [10, 'scg_sfor', 'UI', 2.0, 'Shots For', 'SF'],
             [11, 'scg_sagt', 'UI', 2.0, 'Shots Against', 'SA'],
             [12, 'scg_pnts', 'UD', 3.1, 'Points', 'Pnts'],
@@ -3241,7 +3243,7 @@
             [1, 'scr_ccod', 'UI', 3.0, 'Competiton Code', 'CCD'],
             [2, 'scr_rnum', 'UI', 2.0, 'Round Number', 'RN'],
             [3, 'scr_date', 'D1', 10.0, 'Round Date', 'Round-Date'],
-            [4, 'scr_time', 'UI', 4.0, 'Start Time', 'STime'],
+            [4, 'scr_time', 'UI', 4.0, 'Starting Time', 'STime'],
             [5, 'scr_xflag', 'UA', 1.0, 'Export Flag', 'X']],
         'idx': [
             ['Competition Round Records', 1, 'U', 'scr_cono', 'scr_ccod',
@@ -3251,8 +3253,8 @@
             [0, 'scs_cono', 'UI', 3.0, 'Company Number', 'Coy'],
             [1, 'scs_ccod', 'UI', 3.0, 'Competiton Code', 'CCD'],
             [2, 'scs_snum', 'UI', 2.0, 'Section Number', 'SN'],
-            [3, 'scs_rnum', 'UI', 2.0, 'Round Number', 'SN'],
-            [4, 'scs_club', 'NA', 30.0, 'Club Code', 'Cod'],
+            [3, 'scs_rnum', 'UI', 2.0, 'Round Number', 'RN'],
+            [4, 'scs_club', 'UI', 3.0, 'Club Code', 'Cod'],
             [5, 'scs_name', 'NA', 30.0, 'Club Name', 'Club-Name'],
             [6, 'scs_xflag', 'UA', 1.0, 'Export Flag', 'X']],
         'idx': [
@@ -3347,13 +3349,23 @@
         'idx': [
             ['Stores Code Price Markups', 1, 'U', 'smc_cono', 'smc_group',
                 'smc_code', 'smc_loc', 'smc_level']]},
+    "strcst": {
+        "fld": [
+            [0, 'stc_cono', 'UI', 3.0, 'Company Number', 'Coy'],
+            [1, 'stc_group', 'UA', 3.0, 'Product Group', 'Grp'],
+            [2, 'stc_code', 'NA', 20.0, 'Product Code', 'Product-Code'],
+            [3, 'stc_loc', 'UA', 1.0, 'Location', 'L'],
+            [4, 'stc_cost', 'UD', 10.2, 'Standard Cost', 'Cost-Price']],
+        "idx": [
+            ['Stores Standard Cost Prices', 1, 'U', 'stc_cono', 'stc_group',
+                'stc_code', 'stc_loc']]},
     'strctl': {
         'fld': [
             [0, 'cts_cono', 'UI', 3.0, 'Company Number', 'Coy'],
             [1, 'cts_glint', 'UA', 1.0, 'Integration', 'I'],
             [2, 'cts_locs', 'UA', 1.0, 'Multiple Locations', 'L'],
             [3, 'cts_plevs', 'UI', 1.0, 'Selling Price Levels', 'P'],
-            [4, 'cts_automu', 'UA', 1.0, 'Automatic Markup', 'A'],
+            [4, 'cts_automu', 'UA', 1.0, 'Automatic Markup', 'M'],
             [5, 'cts_tplnam', 'NA', 20.0, 'Orders Template', 'Template-Name'],
             [6, 'cts_emadd', 'TX', 50.0, 'Email Address', 'Email Address'],
             [7, 'cts_xflag', 'UA', 1.0, 'Export Flag', 'X']],
@@ -3400,14 +3412,13 @@
             [3, 'st1_type', 'UA', 1.0, 'Type of Item (N/R)', 'T'],
             [4, 'st1_desc', 'NA', 30.0, 'Description', 'Description'],
             [5, 'st1_uoi', 'NA', 10.0, 'Units Of Issue', 'U.O.I'],
-            [6, 'st1_units', 'UI', 7.0, 'Units Per Pack', 'Units'],
-            [7, 'st1_value_ind', 'UA', 1.0, 'Value Indicator', 'V'],
-            [8, 'st1_vatcode', 'UA', 1.0, 'VAT Code', 'V'],
-            [9, 'st1_chn_excl', 'UI', 3.0, 'Exclusive Chain', 'Exc'],
-            [10, 'st1_acc_excl', 'NA', 7.0, 'Exclusive Account', 'Exa'],
-            [11, 'st1_sls', 'UI', 7.0, 'Sales Account', 'Sal-Acc'],
-            [12, 'st1_cos', 'UI', 7.0, 'COS Account', 'COS-Acc'],
-            [13, 'st1_xflag', 'UA', 1.0, 'Export Flag', 'X']],
+            [6, 'st1_value_ind', 'UA', 1.0, 'Value Indicator', 'V'],
+            [7, 'st1_vatcode', 'UA', 1.0, 'VAT Code', 'V'],
+            [8, 'st1_chn_excl', 'UI', 3.0, 'Exclusive Chain', 'Exc'],
+            [9, 'st1_acc_excl', 'NA', 7.0, 'Exclusive Account', 'Exa'],
+            [10, 'st1_sls', 'UI', 7.0, 'Sales Account', 'Sal-Acc'],
+            [11, 'st1_cos', 'UI', 7.0, 'COS Account', 'COS-Acc'],
+            [12, 'st1_xflag', 'UA', 1.0, 'Export Flag', 'X']],
         'idx': [
             ['Stores Masterfile 1', 1, 'U', 'st1_cono', 'st1_group',
                 'st1_code']]},
@@ -3459,17 +3470,16 @@
             [2, 'pot_group', 'UA', 3.0, 'Product Group', 'Grp'],
             [3, 'pot_code', 'NA', 20.0, 'Product Code', 'Product-Code'],
             [4, 'pot_uoi', 'NA', 10.0, 'Units Of Issue', 'U.O.I'],
-            [5, 'pot_units', 'UI', 7.0, 'Units Per Pack', 'Units'],
-            [6, 'pot_desc', 'NA', 30.0, 'Description', 'Description'],
-            [7, 'pot_qty', 'SD', 11.2, 'Quantity Ordered', 'Qty-Order'],
-            [8, 'pot_price', 'UD', 10.2, 'Unit Price', 'Unit Price'],
-            [9, 'pot_disper', 'UD', 6.2, 'Discount', 'Disc-%'],
-            [10, 'pot_vatcod', 'UA', 1.0, 'VAT Code', 'V'],
-            [11, 'pot_vatrat', 'UD', 6.2, 'VAT Rate', 'Rate'],
-            [12, 'pot_capnm', 'TX', 20.0, 'Capture Name', 'Capture-Name'],
-            [13, 'pot_capdt', 'd1', 10.0, 'Capture Date', 'Capture-Dt'],
-            [14, 'pot_xflag', 'UA', 1.0, 'Export Flag', 'X'],
-            [15, 'pot_seq', 'US', 10.0, 'Sequence', 'Sequence']],
+            [5, 'pot_desc', 'NA', 30.0, 'Description', 'Description'],
+            [6, 'pot_qty', 'SD', 11.2, 'Quantity Ordered', 'Qty-Order'],
+            [7, 'pot_price', 'UD', 10.2, 'Unit Price', 'Unit Price'],
+            [8, 'pot_disper', 'UD', 6.2, 'Discount', 'Disc-%'],
+            [9, 'pot_vatcod', 'UA', 1.0, 'VAT Code', 'V'],
+            [10, 'pot_vatrat', 'UD', 6.2, 'VAT Rate', 'Rate'],
+            [11, 'pot_capnm', 'TX', 20.0, 'Capture Name', 'Capture-Name'],
+            [12, 'pot_capdt', 'd1', 10.0, 'Capture Date', 'Capture-Dt'],
+            [13, 'pot_xflag', 'UA', 1.0, 'Export Flag', 'X'],
+            [14, 'pot_seq', 'US', 10.0, 'Sequence', 'Sequence']],
         'idx': [
             ['Purchase Order Transactions', 1, 'U', 'pot_seq'],
             ['', 2, 'U', 'pot_cono', 'pot_ordno', 'pot_group', 'pot_code'],
@@ -3516,7 +3526,7 @@
             [12, 'stt_curdt', 'D2', 7.0, 'Current Date', 'Curr-Dt'],
             [13, 'stt_desc', 'NA', 30.0, 'Description', 'Description'],
             [14, 'stt_chain', 'UI', 3.0, 'Chain', 'Chn'],
-            [15, 'stt_acno', 'NA', 7.0, 'Debtor', 'Debtor'],
+            [15, 'stt_acno', 'NA', 7.0, 'Account Number', 'Acc-Num'],
             [16, 'stt_rep', 'Na', 3.0, 'Salesman', 'Rep'],
             [17, 'stt_styp', 'UA', 3.0, 'System Type', 'Sys'],
             [18, 'stt_trdis', 'UD', 6.2, 'Trade Discount', 'Tr-Dis'],
@@ -3691,7 +3701,7 @@
         'fld': [
             [0, 'ctw_cono', 'UI', 3.0, 'Company Number', 'Coy'],
             [1, 'ctw_glint', 'UA', 1.0, 'Integration', 'I'],
-            [2, 'ctw_regno', 'UL', 10.0, 'Registration Number', 'Reg-Num'],
+            [2, 'ctw_regno', 'NA', 10.0, 'Registration Number', 'Reg-Num'],
             [3, 'ctw_sdlno', 'NA', 10.0, 'SDL Number', 'SDL-Num'],
             [4, 'ctw_uifno', 'NA', 10.0, 'UIF Number', 'UIF-Num'],
             [5, 'ctw_trade', 'UI', 4.0, 'Trade Code', 'T-CD'],
@@ -3802,9 +3812,9 @@
             [4, 'wgm_sname', 'NA', 30.0, 'Surname', 'Surname'],
             [5, 'wgm_fname', 'NA', 30.0, 'First Names', 'First Names'],
             [6, 'wgm_dob', 'd1', 10.0, 'Date of Birth', 'DOB'],
-            [7, 'wgm_idno', 'UL', 13.0, 'ID Number', 'ID-Number'],
+            [7, 'wgm_idno', 'NA', 13.0, 'Identity Number', 'ID-Number'],
             [8, 'wgm_spouse', 'NA', 16.0, 'Spouse Name', 'Spouse Name'],
-            [9, 'wgm_spouse_id', 'NA', 16.0, 'Spouse ID Number', 'Spouse ID'],
+            [9, 'wgm_spouse_id', 'NA', 13.0, 'Spouse ID-Number', 'ID-Number'],
             [10, 'wgm_addr1', 'NA', 30.0, 'Address Line 1', 'Address Line 1'],
             [11, 'wgm_addr2', 'NA', 30.0, 'Address Line 2', 'Address Line 2'],
             [12, 'wgm_addr3', 'NA', 30.0, 'Address Line 3', 'Address Line 3'],
@@ -3861,8 +3871,8 @@
             [15, 'wt1_taxdd', 'SD', 13.2, 'Tax Ded Ded', 'Tax-Ded-Ded'],
             [16, 'wt1_nondd', 'SD', 13.2, 'Non Ded Ded', 'Non-Ded-Ded'],
             [17, 'wt1_psded', 'SD', 13.2, 'Pseudo Deduction', 'Pseudo-Ded'],
-            [18, 'wt1_uifpay', 'UI', 11.0, 'UIF Deduction Pay', 'UIF-Pay'],
-            [19, 'wt1_sdlpay', 'UI', 11.0, 'SDL Deduction Pay', 'SDL-Pay'],
+            [18, 'wt1_uifpay', 'UI', 9.0, 'UIF Deduction Pay', 'UIF-Pay'],
+            [19, 'wt1_sdlpay', 'UI', 9.0, 'SDL Deduction Pay', 'SDL-Pay'],
             [20, 'wt1_shift', 'SD', 13.2, 'Shifts', 'Shifts'],
             [21, 'wt1_drbal', 'SD', 13.2, 'Balance C/F', 'Balance'],
             [22, 'wt1_capnm', 'TX', 20.0, 'Capture Name', 'Capture-Name'],
@@ -3985,9 +3995,9 @@
         ["F","mm_sy","tarBck",0,"Backup Database"],
         ["F","mm_sy","tarRes",5,"Restore Database"],
         ["F","mm_sy","tarCfg",0,"Preferences"],
-        ["F","mm_sy","doManual",0,"Manual (SYS)"],
+        ["F","mm_sy","doManual SYS",0,"Help"],
         ["F","mm_sy","sysEnd",0,"Quit"],
-        ["F","mm_ms","doManual",0,"Manual (CTL)"],
+        ["F","mm_ms","doManual CTL",0,"Help"],
         ["PNNY","ms_fm","msc110",7,"System Record Maintenance"],
         ["PNNY","ms_fm","ms1010",5,"Company Records Maintenance"],
         ["PYNN","ms_fm","ms1020",5,"Department Records Maintenance"],
@@ -4005,10 +4015,10 @@
         ["PNNY","mm_uy","rp1010",2,"Report Generator"],
         ["PYYY","mm_uy","rp1020",3,"Report Stream"],
         ["PNNN","mm_uy","tp1010",5,"Template Manager"],
-        ["F","mm_uy","doManual",0,"Manual (UTY)"],
+        ["F","mm_uy","doManual UTY",0,"Help"],
         ["F","mm_hp","doAbout",0,"About"],
-        ["F","mm_hp","doManual",0,"Reference Manual"],
-        ["F","mm_hp","doQuick",0,"Quick Start Guide"]],
+        ["F","mm_hp","doManual REF",0,"Reference Manual"],
+        ["F","mm_hp","doManual QST",0,"Quick Start Guide"]],
 
     # General Ledger Routines
     "glmen": [
@@ -4055,7 +4065,7 @@
         ["PNNN","gl_tb","gl6080",1,"Missing Account Numbers"],
         ["PYYY","gl_qy","gl4010",0,"Interrogation (Normal)"],
         ["PYYN","gl_qy","gl4020",1,"Interrogation (Financials)"],
-        ["F","mm_gl","doManual",0,"Manual (GEN)"]],
+        ["F","mm_gl","doManual GEN",0,"Help"]],
 
     # Creditor's Ledger Routines
     "crmen": [
@@ -4086,7 +4096,7 @@
         ["PYNN","cr_tb","cr6020",3,"Transaction Reallocations"],
         ["PYNY","cr_tb","cr6030",5,"Account Redundancy"],
         ["PYNY","mm_cr","cr4010",0,"Interrogation"],
-        ["F","mm_cr","doManual",0,"Manual (CRS)"]],
+        ["F","mm_cr","doManual CRS",0,"Help"]],
 
     # Debtor"s Ledger Routines
     "drmen": [
@@ -4130,7 +4140,7 @@
         ["PYNY","dr_tb","dr6030",5,"Account Redundancy"],
         ["PYNN","dr_tb","dr6040",3,"Populate Credit Ratings"],
         ["PYNY","mm_dr","dr4010",0,"Interrogation"],
-        ["F","mm_dr","doManual",0,"Manual (DRS)"]],
+        ["F","mm_dr","doManual DRS",0,"Help"]],
 
     # Stores Ledger Routines
     "stmen": [
@@ -4145,7 +4155,8 @@
         ["PYNN","st_fm","stc310",3,"Product Groups"],
         ["PYNN","st_fm","stc410",3,"Locations"],
         ["PYNY","st_fm","st1010",3,"Masterfile Records"],
-        ["PYNN","st_fm","st1020",3,"Selling Prices"],
+        ["PYNN","st_fm","st1020",3,"Standard Cost Prices"],
+        ["PYNN","st_fm","st1030",3,"Fixed Selling Prices"],
         ["PYYY","st_dc","st2010",2,"Purchase Orders"],
         ["PYYY","st_dc","st2020",2,"Goods Received Notes"],
         ["PYYY","st_dc","st2030",2,"Goods Issued Notes"],
@@ -4174,7 +4185,7 @@
         ["PYNY","st_tb","st6030",5,"Stock Redundancy"],
         ["PYYY","st_tb","st6040",5,"Cancel Purchase Orders"],
         ["PYYY","mm_st","st4010",0,"Interrogation"],
-        ["F","mm_st","doManual",0,"Manual (STR)"]],
+        ["F","mm_st","doManual STR",0,"Help"]],
 
     # Sales Invoicing Routines
     "simen": [
@@ -4194,7 +4205,7 @@
         ["PYYN","si_rp","si3090",1,"Cancelled Sales Documents"],
         ["PYNN","si_tb","si6010",5,"Change Customer Order Number"],
         ["PYNN","si_tb","si6020",5,"Cancel Outstanding Documents"],
-        ["F","mm_si","doManual",0,"Manual (SLS)"]],
+        ["F","mm_si","doManual SLS",0,"Help"]],
 
     # Point of Sale Routines
     "psmen": [],
@@ -4203,7 +4214,7 @@
         ["PYLY","mm_ps","ps2010",2,"Data Capture"],
         ["PYLY","mm_ps","ps2020",1,"Cash Declaration"],
         ["PYYN","mm_ps","ps2030",5,"Cash Reconciliation"],
-        ["F","mm_ps","doManual",0,"Manual (POS)"]],
+        ["F","mm_ps","doManual POS",0,"Help"]],
 
     # Assets Register
     "armen": [
@@ -4229,7 +4240,7 @@
         ["PYNN","ar_rp","ar3050",1,"Notes Listing"],
         ["PYNN","ar_tb","ar6010",5,"Change Asset Codes"],
         ["PYYY","mm_ar","ar4010",0,"Interrogation"],
-        ["F","mm_ar","doManual",0,"Manual (ASS)"]],
+        ["F","mm_ar","doManual ASS",0,"Help"]],
 
     # Bookings Manager
     "bkmen": [
@@ -4254,7 +4265,7 @@
         ["PYNN","bk_rp","bk3070",1,"Account Statements"],
         ["PYNN","bk_rp","bk3080",1,"Reprint Documents"],
         ["PYNN","bk_rp","bk3090",1,"Summary Report"],
-        ["F","mm_bk","doManual",0,"Manual (BKM)"]],
+        ["F","mm_bk","doManual BKM",0,"Help"]],
 
     # Loan's Ledger
     "lnmen": [
@@ -4278,7 +4289,7 @@
         ["PYNN","ln_rp","ln3050",1,"Notes Listing"],
         ["PYNN","ln_tb","ln6010",5,"Change Account Numbers"],
         ["PYLY","mm_ln","ln4010",0,"Interrogation"],
-        ["F","mm_ln","doManual",0,"Manual (LON)"]],
+        ["F","mm_ln","doManual LON",0,"Help"]],
 
     # Member's Ledger
     "mlmen": [
@@ -4311,7 +4322,7 @@
         ["PYNN","ml_tb","ml6010",3,"Transaction Reallocations"],
         ["PYLY","mm_ml","ml1010",1,"Member Records"],
         ["PYYY","mm_ml","mlm010",4,"Month End Routine",0],
-        ["F","mm_ml","doManual",0,"Manual (MEM)"]],
+        ["F","mm_ml","doManual MEM",0,"Help"]],
 
     # Rental's Ledger (Basic)
     "rtmen": [
@@ -4334,7 +4345,7 @@
         ["PYNN","rt_tb","rt6010",5,"Change Account Numbers"],
         ["PYNY","mm_rt","rt4010",1,"Interrogation"],
         ["PYNY","mm_rt","rtm010",4,"Month End Routine",0],
-        ["F","mm_rt","doManual",0,"Manual (RTL)"]],
+        ["F","mm_rt","doManual RTL",0,"Help"]],
 
     # Rental's Ledger (Extended)
     "rcmen": [
@@ -4362,7 +4373,7 @@
         ["PYNY","rc_qy","rc4020",0,"Tenants Interrogation"],
         ["PYNY","mm_rc","rc2010",2,"Data Capture"],
         ["PYNY","mm_rc","rcm010",4,"Month End Routine"],
-        ["F","mm_rc","doManual",0,"Manual (RCA)"]],
+        ["F","mm_rc","doManual RCA",0,"Help"]],
 
     # Salaries & Wages Routines
     "wgmen": [
@@ -4390,7 +4401,7 @@
         ["PYNN","wg_rp","wg3060",1,"Notes Listing"],
         ["PYNN","wg_rp","wg3070",1,"Payslips Reprint"],
         ["PYNY","mm_wg","wg4010",0,"Interrogation"],
-        ["F","mm_wg","doManual",0,"Manual (WAG)"]],
+        ["F","mm_wg","doManual WAG",0,"Help"]],
 
     # Staff Loan Routines
     "slmen": [
@@ -4407,7 +4418,7 @@
         ["PYNN","sl_rp","sl3030",1,"Master Listing"],
         ["PYNN","sl_rp","sl3040",1,"Statements"],
         ["PYLY","mm_sl","sl4010",0,"Interrogation"],
-        ["F","mm_sl","doManual",0,"Manual (SLN)"]],
+        ["F","mm_sl","doManual SLN",0,"Help"]],
 
     # Bowling Club Routines
     "bcmen": [
@@ -4443,7 +4454,7 @@
         ["PYNN","bc_tb","bc6010",3,"Change Tab Numbers"],
         ["PYNN","bc_tb","bc6020",3,"Delete Visitors' Tabs"],
         ["PYNN","bc_tb","bc6030",3,"Clear History"],
-        ["F","mm_bc","doManual",0,"Manual (BWL)"]],
+        ["F","mm_bc","doManual BWL",0,"Help"]],
 
     # Book Clubs
     "bsmen": [
@@ -4453,7 +4464,7 @@
         ["PNNY","bs_fm","bsc210",0,"Author Records"],
         ["PYNY","mm_bs","bs1010",0,"Book Records"],
         ["PYNY","mm_bs","bs3010",0,"Books Listing"],
-        ["F","mm_bs","doManual",0,"Manual (BKS)"]],
+        ["F","mm_bs","doManual BKS",0,"Help"]],
 
     # Sectional Competitions
     "scmen": [
@@ -4465,14 +4476,14 @@
         ["PYNN","mm_sc","sc3010",0,"List Entries"],
         ["PYNN","mm_sc","sc2020",0,"Competiton Draw"],
         ["PYNN","mm_sc","sc2030",0,"Capture Results"],
-        ["F","mm_sc","doManual",0,"Manual (SCP)"]],
+        ["F","mm_sc","doManual SCP",0,"Help"]],
 
     # Cash Analysis Routines
     "csmen": [],
     "csmod": [
-        ["PYNY","mm_cs","cs2010",0,"Capture Analysis"],
-        ["PYNY","mm_cs","cs3010",0,"List Analysis"],
-        ["F","mm_cs","doManual",0,"Manual (CSH)"]],
+        ["PYNY","mm_cs","cs2010",0,"Cash Takings"],
+        ["PYNY","mm_cs","cs3010",0,"Cash Report"],
+        ["F","mm_cs","doManual CSH",0,"Help"]],
 
     # Telephone Directory
     "tdmen": [
@@ -5136,7 +5147,7 @@
             "N", "L", "R", "N", 34.0, 6, 49.0, 77.0, 4.0, 81.0, 1, 20],
         ["booking_invoice", 23.0, "C", "B", "H", "Unit Description",
             "courier", 10, "#000000", "Y", "N", "N", "L", "TLRB", "Y", 49.0,
-            37, 129.0, 72.0, 5.0, 77.0, 0.0, "brt_udesc", "courier", 10,
+            37, 129.0, 72.0, 5.0, 77.0, 0.0, "line_unit", "courier", 10,
             "#000000", "N", "N", "N", "L", "R", "N", 49.0, 37, 129.0, 77.0,
             4.0, 81.0, 1, 20],
         ["booking_invoice", 24.0, "C", "B", "H", "Qty", "courier", 10,

=== added file 'uty/__init__.py'
=== modified file 'uty/bm1010.py' (properties changed: -x to +x)
--- old/uty/bm1010.py	2020-04-21 08:42:36 +0000
+++ new/uty/bm1010.py	2020-07-19 09:32:12 +0000
@@ -25,31 +25,24 @@
 """
 
 import glob, imghdr, os, time
-
 try:
     import requests
     REQ = True
 except:
     REQ = False
 try:
-    from markdown import markdown as MARKDOWN
+    from markdown import markdown
+    MARKDOWN = True
 except:
     MARKDOWN = False
 try:
-    from PIL import Image as PIL
-except:
-    PIL = False
-try:
-    import xlrd as XLRD
-except:
-    XLRD = False
-try:
-    import ghostscript as GHS
-except:
-    GHS = False
+    import fitz
+    FITZ = True
+except:
+    FITZ = False
 
-from TartanClasses import FileImport, GetCtl, ShowEmail, SplashScreen, Sql
-from TartanClasses import TartanDialog
+from TartanClasses import FileImport, GetCtl, Image, ShowEmail, SplashScreen
+from TartanClasses import Sql, TartanDialog
 from tartanFunctions import askQuestion, getSingleRecords, sendMail, showError
 
 class bm1010(object):
@@ -74,7 +67,7 @@
                 self.sms.append(ctlsys["sys_%s" % fld])
         else:
             self.sms = ["N"]
-        if not self.smtp[0] and self.sms[0] != "Y":
+        if not self.smtp[0] and self.sms[0] == "N":
             showError(self.opts["mf"].body, "SMTP/SMS Error",
                 "There is NO SMTP Server nor SMS Service Available.")
             return
@@ -434,6 +427,12 @@
     def doFltGen(self, frt, pag, r, c, p, i, w):
         self.fltgen = w
 
+    def doFltPP(self, frt, pag, r, c, p, i, w):
+        self.personal = w
+
+    def doFltND(self, frt, pag, r, c, p, i, w):
+        self.namdet = w
+
     def doFltTo(self, frt, pag, r, c, p, i, w):
         self.fltto = w
         if self.ulist == "C":
@@ -543,7 +542,9 @@
                 err = "This '%s' is Not a Valid Email Address" % eml
                 break
             self.loadData(tit, nam, eml)
-        if err and self.fi.impign == "N":
+        if self.fi.impdat == []:
+            self.impxit = True
+        elif err and self.fi.impign == "N":
             showError(self.opts["mf"].body, "Import Error", err)
             self.impdat = []
             self.impxit = True
@@ -595,7 +596,7 @@
             w = w.split(",")
             pdf = []
             for f in w:
-                if f.split(".")[-1].lower() == "pdf" and GHS:
+                if f.split(".")[-1].lower() == "pdf" and FITZ:
                     pdf.append(f)
                     continue
                 if not imghdr.what(f):
@@ -623,39 +624,38 @@
                 "Converting PDF to Images\n\nPlease Wait")
             for fnam in pdf:
                 try:
-                    self.doGhostscript(fnam)
+                    self.doFitz(fnam)
                 except:
                     pass
             sp.closeSplash()
-        if self.embed and PIL:
+        if self.embed and Image:
             sp = SplashScreen(self.df.mstFrame,
                 "Resizing Images for Mailing\n\nPlease Wait")
-            for n, i in enumerate(self.embed):
+            for n, e in enumerate(self.embed):
                 try:
-                    img = PIL.open(i)
+                    img = Image.open(e)
                     siz = img.size
                     if siz[0] > 1024:
                         new = img.resize((1024, int((siz[1]*1024)/siz[0])), 1)
-                        i = os.path.join(self.opts["mf"].rcdic["wrkdir"],
-                            os.path.basename(i))
-                        new.save(i)
-                        self.embed[n] = i
+                        e = os.path.join(self.opts["mf"].rcdic["wrkdir"],
+                            os.path.basename(e))
+                        new.save(e)
+                        self.embed[n] = e
                 except:
                     pass
             sp.closeSplash()
         self.fle["ftype"] = (("Attachment", "*"),)
 
-    def doGhostscript(self, fnam):
+    def doFitz(self, fnam):
         b = os.path.basename(fnam.replace(" ", "_"))
         e = b.split(".")[-1]
         o = os.path.join(self.opts["mf"].rcdic["wrkdir"],
             b.replace(".%s" % e, ""))
         f = o + "_%03i.jpg"
-        args = ["-q", "-dNOPAUSE", "-dJPEGQ=100", "-r300x300",
-                "-sstdout=/dev/null", "-sstderr=/dev/null",
-                "-sDEVICE=jpeg", "-sOutputFile=" + f, fnam,
-                "-c", "quit"]
-        GHS.Ghostscript(*args)
+        doc = fitz.open(fnam)
+        for num, pag in enumerate(doc):
+            pix = pag.getPixmap()
+            pix.writeImage(f % num)
         fls = glob.glob(o + "*.jpg")
         fls = sorted(fls, reverse=True)
         idx = self.embed.index(fnam)
@@ -674,7 +674,7 @@
                 return "Invalid {{ substitution in Message"
         self.mess = w
         if MARKDOWN:
-            self.html = MARKDOWN(self.mess)
+            self.html = markdown(self.mess)
         else:
             self.html = self.mess
 
@@ -698,7 +698,7 @@
                     "Invalid {{ substitution in Message")
                 return
         if MARKDOWN:
-            self.html = MARKDOWN(self.mess)
+            self.html = markdown(self.mess)
         else:
             self.html = self.mess
         self.doEnd()

=== modified file 'uty/fc1010.py' (properties changed: -x to +x)
=== modified file 'uty/pkgprg.py' (properties changed: -x to +x)
--- old/uty/pkgprg.py	2020-04-21 08:42:36 +0000
+++ new/uty/pkgprg.py	2020-12-12 11:18:17 +0000
@@ -4,6 +4,7 @@
 import glob
 import os
 import shutil
+import subprocess
 import sys
 import time
 
@@ -11,7 +12,11 @@
 sv = "root@mail"              # ftp login@server
 vv = 5                        # Version number
 bv = "Tartan-%s" % vv         # Version directory
-sys.path.extend(glob.glob(os.path.join(bd, bv, "???")))
+vd = os.path.join(bd, bv)
+if not os.path.isdir(vd):
+    print("Invalid Version Directory: %s" % vd)
+    sys.exit()
+sys.path.append(vd)
 from tartanFunctions import findFile, sendMail
 from ms0000 import VERSION
 
@@ -25,21 +30,33 @@
         print("%s Command Failed" % cmd, ret)
         sys.exit()
 
+def addPage(doc, fle, last=False):
+    exeCmd("aspell -c %s --lang en_GB" % fle)
+    data = open(fle, "r")
+    for d in data.readlines():
+        doc.write(d)
+    if not last:
+        doc.write("\n")
+        doc.write(".. raw:: pdf\n")
+        doc.write("\n")
+        doc.write("    PageBreak\n")
+        doc.write("\n")
+    data.close()
+
 print("Packaging...")
+email = False
+mkcd = False
 newver = None
-revision = None
-system = "t"
+publish = False
+test = False
 verinc = False
 windows = False
-publish = False
-email = False
-mkcd = False
-opts, args = getopt.getopt(sys.argv[1:], "b:ceir:s:v:hwp")
+opts, args = getopt.getopt(sys.argv[1:], "b:cehiptv:w")
 for o, v in opts:
     if o == "-h":
-        print("Usage: pkgprg [-h help] [-b base directory] [-i increment] "\
-            "[-s system] [-v new version] [-w windows] [-p publish] "\
-            "[-e email] [-r last revision] [-c create cd]")
+        print("Usage: pkgprg [-b base directory] [-c create cd] [-e email] "\
+            "[-h help] [-i increment] [-p publish] [-t test] [-v new version] "\
+            "[-w windows]")
         sys.exit()
     elif o == "-b":
         bd = v
@@ -49,174 +66,124 @@
         email = True
     elif o == "-i":
         verinc = True
-        system = "t"
     elif o == "-p":
         publish = True
-    elif o == "-r":
-        revision = v.lower()
-    elif o == "-s":
-        system = v.lower()
+        windows = True
+    elif o == "-t":
+        test = True
     elif o == "-v":
         newver = v
     elif o == "-w":
         windows = True
-
+if publish:
+    mkcd = True
 if not os.path.exists(bd):
     print("Invalid Base Directory (%s)" % bd)
     sys.exit()
-
-if verinc and not system == "t":
-    print("Cannot Increment %s" % system)
-    sys.exit()
-
 pypath = findFile(start=[bd], name=bv, ftyp="d")
 if not pypath:
     print("%s/%s directory not found" % (bd, bv))
     sys.exit()
-
+# Change to pypath directory
+os.chdir(pypath)
 for d in ("TartanExe", "TartanOld", "TartanSve"):
     if not os.path.exists(os.path.join(bd, d)):
         os.makedirs(os.path.join(bd, d))
-
-exeCmd("rm -f `find %s -name '*.pyc'`" % pypath)
-exeCmd("rm -f `find %s -name '*.pyo'`" % pypath)
-exeCmd("rm -f `find %s -name '*.bak'`" % pypath)
-exeCmd("rm -f `find %s -name '[abcdefgh]'`" % pypath)
-exeCmd("rm -f `find %s -name '[abcdefgh].py'`" % pypath)
-os.chdir(pypath)
-
-while system not in ("r", "t"):
-    system = raw_input("System, (T)artan, (R)NE: ").lower()
-
-dirs = ["mst", "tab"]
-if system == "r":
-    system = "rnehol"
-    chgfle = "tarchg"
-    dirs.extend([
-        "ass", "crs", "drs", "gen", "ibt", "lon", "rtl", "sls", "str", "uty"])
-    custom = ["rne", [
-        "ar6020", "ar6030", "cr1010", "cr2010", "cr2020", "cr2030", "cr3030",
-        "cr3070", "cr3080", "cr3120", "cr3130", "cr3140", "cr3150", "cr3160",
-        "cr3170", "cr3180", "cr3190", "cr3200", "cr4010", "cr6010", "cr6020",
-        "gl3030", "gl3100", "gl3110", "gl3120", "gl3130", "gl3140", "gl3150",
-        "glc310", "glc410", "glc510", "ib2010", "ib2020", "ib3010", "ib3020",
-        "ib3030", "ib3040", "ibc110", "ln2020", "ms1010", "msy030", "ss1010",
-        "tartanWork"]]
-    exclude = [
-        "dr1020", "dr2030", "dr6040", "drc210", "drc220", "drc510", "drc520",
-        "drc610", "drc620", "drc710", "drc810", "msy020", "si3010", "si3070",
-        "sic110", "st1020", "st2010", "st2020", "st2030", "st2040", "st3010",
-        "st3020", "st3030", "st3040", "st3050", "st3060", "st3070", "st3080",
-        "st3090", "st3100", "st3110", "st3120", "st4010", "st5010", "st5020",
-        "st5030", "st5040", "st6010", "st6020", "st6030", "st6040", "stc220",
-        "stc320", "stc410", "stc420", "tb1010", "tb1040", "tb3010", "bm1010",
-        "pm1010", "pw1010", "rp1020"]
-elif system == "t":
-    system = "tartan"
-    chgfle = "tarchg"
-    dirs.extend([
-        "ass", "bkm", "bks", "bwl", "crs", "csh", "drs", "gen", "lon", "mem",
-        "pos", "rca", "rtl", "sls", "str", "scp", "uty", "wag"])
-    custom = [""]
-    exclude = ["pw1010"]
+csys = "Tartan"
+cver = list(VERSION)
+if not newver:
+    if verinc:
+        vinc = raw_input("Increment Version (y/n): ")
+    else:
+        vinc = "n"
+    if vinc.lower() == "y":
+        cver[1] += 1
+        newver = "%s.%s" % (cver[0], cver[1])
 else:
-    sys.exit()
-csys = system.capitalize()
-
-ver = list(VERSION)
-if system == "tartan":
-    if not newver:
-        if verinc:
-            vinc = raw_input("Increment Version (y/n): ")
+    cver = list(newver.split("."))
+    if len(cver) != 2:
+        print("Invalid -v option (%s)" % newver)
+        sys.exit()
+    for x in range(2):
+        cver[x] = int(cver[x])
+if newver and newver != "%s.%s" % VERSION:
+    if not os.path.isfile("changes.txt"):
+        raw_input("changes.txt File Not Found! Ctl-C to Abort")
+    #try:
+    if 'a' == 'a':
+        # Change version number in ms0000.py, SYS.rst, Downloads.rst
+        old = open("ms0000.py", "r")
+        lin = old.readlines()
+        old.close()
+        new = open("ms0000.py", "w")
+        for l in lin:
+            s = l.split()
+            if len(s) > 1 and s[0] == "VERSION" and not l.count("int"):
+                l = "    VERSION = %s\n" % str(tuple(cver))
+            new.write(l)
+        new.close()
+        os.chmod("ms0000.py", 0o755)
+        old = open("doc/SYS.rst", "r")
+        lin = old.readlines()
+        old.close()
+        new = open("doc/SYS.rst", "w")
+        oldver = None
+        for l in lin:
+            if l[:9] == ":Version:":
+                oldver = l.split()[1].strip()
+                l = ":Version:   %s\n" % newver
+            elif oldver:
+                l = l.replace(oldver, newver)
+            new.write(l)
+        new.close()
+        old = open("doc/Downloads.rst", "r")
+        lin = old.readlines()
+        old.close()
+        new = open("doc/Downloads.rst", "w")
+        oldver = None
+        for l in lin:
+            if l.count("The latest version of Tartan is"):
+                oldver = l.split()[6]
+                date = time.strftime("%d %B, %Y", time.localtime())
+                part = date.split()
+                day = int(part[0])
+                if day in (1, 21, 31):
+                    day = "%sst" % day
+                elif day in (2, 22):
+                    day = "%snd" % day
+                elif day in (3, 23):
+                    day = "%srd" % day
+                elif day > 3 and day < 21:
+                    day = "%sth" % day
+                elif day > 23 and day < 31:
+                    day = "%sth" % day
+                newdte = "%s%s" % (day, date[2:])
+                l = "The latest version of Tartan is %s and was "\
+                    "released on the %s.\n" % (newver, newdte)
+            elif oldver:
+                l = l.replace(oldver, newver)
+            new.write(l)
+        new.close()
+        # Update repository version control
+        if vv == 5:
+            sta = "/usr/bin/bzr status"
+            dif = "/usr/bin/bzr diff"
         else:
-            vinc = "n"
-        if vinc.lower() == "y":
-            ver[1] += 1
-            newver = "%s.%s" % (ver[0], ver[1])
-    else:
-        ver = list(newver.split("."))
-        if len(ver) != 2:
-            print("Invalid -v option (%s)" % newver)
-            sys.exit()
-        for x in range(2):
-            ver[x] = int(ver[x])
-    if newver and newver != "%s.%s" % VERSION:
-        if not os.path.isfile("%s/changes.txt" % pypath):
-            raw_input("changes.txt File Not Found! Ctl-C to Abort")
-        try:
-            old = open("%s/mst/ms0000.py" % pypath, "r")
-            lin = old.readlines()
-            old.close()
-            new = open("%s/mst/ms0000.py" % pypath, "w")
-            for l in lin:
-                s = l.split()
-                if len(s) > 1 and s[0] == "VERSION" and not l.count("int"):
-                    l = "    VERSION = %s\n" % str(tuple(ver))
-                new.write(l)
-            new.close()
-            os.chmod("%s/mst/ms0000.py" % pypath, 0o755)
-            old = open("%s/doc/SYS.rst" % pypath, "r")
-            lin = old.readlines()
-            old.close()
-            new = open("%s/doc/SYS.rst" % pypath, "w")
-            oldver = None
-            for l in lin:
-                if l[:9] == ":Version:":
-                    oldver = l.split()[1].strip()
-                    l = ":Version:   %s\n" % newver
-                elif oldver:
-                    l = l.replace(oldver, newver)
-                new.write(l)
-            new.close()
-            old = open("%s/doc/Downloads.rst" % pypath, "r")
-            lin = old.readlines()
-            old.close()
-            new = open("%s/doc/Downloads.rst" % pypath, "w")
-            oldver = None
-            for l in lin:
-                if l.count("The latest version of Tartan is"):
-                    oldver = l.split()[6]
-                    date = time.strftime("%d %B, %Y", time.localtime())
-                    part = date.split()
-                    day = int(part[0])
-                    if day in (1, 21, 31):
-                        day = "%sst" % day
-                    elif day in (2, 22):
-                        day = "%snd" % day
-                    elif day in (3, 23):
-                        day = "%srd" % day
-                    elif day > 3 and day < 21:
-                        day = "%sth" % day
-                    elif day > 23 and day < 31:
-                        day = "%sth" % day
-                    newdte = "%s%s" % (day, date[2:])
-                    l = "The latest version of Tartan is %s and was "\
-                        "released on the %s.\n" % (newver, newdte)
-                elif oldver:
-                    l = l.replace(oldver, newver)
-                new.write(l)
-            new.close()
-            os.chmod("%s/mst/ms0000.py" % pypath, 0o755)
-            # Update Bazaar version control
-            if revision:
-                sta = "/usr/bin/bzr status -r %s" % revision
-                dif = "/usr/bin/bzr diff -r %s" % revision
-            else:
-                sta = "/usr/bin/bzr status"
-                dif = "/usr/bin/bzr diff"
-            sta += " > ver/ver_%s.%s.status" % tuple(ver)
-            exeCmd(sta)
-            dif += " > ver/ver_%s.%s.diff" % tuple(ver)
-            exeCmd(dif)
-            if os.path.isfile("%s/changes.txt" % pypath):
-                exeCmd("mv %s/changes.txt ver/ver_%s.%s.changes" %
-                    (pypath, ver[0], ver[1]))
-            # Create changes module
-            chg = open("%s/std/%s.py" % (pypath, chgfle), "w")
-            chg.write('changes = """')
-            for x in range(99, -1, -1):
-                nam = "ver_%s.%s" % (5, x)
-                fle = os.path.join(pypath, "ver", "%s.changes" % nam)
+            sta = "/usr/bin/git status"
+            dif = "/usr/bin/git diff"
+        sta += " > ver/ver_%s.%s.status" % tuple(cver)
+        exeCmd(sta)
+        dif += " > ver/ver_%s.%s.diff" % tuple(cver)
+        exeCmd(dif)
+        if os.path.isfile("changes.txt"):
+            exeCmd("mv changes.txt ver/ver_%s.%s.changes" % (cver[0], cver[1]))
+        # Create changes module
+        chg = open("tarchg.py", "w")
+        chg.write('changes = """')
+        for x in range(9, 1, -1):
+            for y in range(99, -1, -1):
+                nam = "ver_%s.%s" % (x, y)
+                fle = os.path.join("ver", "%s.changes" % nam)
                 if os.path.isfile(fle):
                     chg.write(nam + "\n")
                     chg.write(("=" * len(nam)) + "\n")
@@ -224,300 +191,209 @@
                     for line in lines:
                         chg.write(line)
                     chg.write("\n")
-            for x in range(6):
-                for y in range(99, -1, -1):
-                    for z in range(999, -1, -1):
-                        nam = "ver_%s.%s.%s" % (x, y, z)
-                        fle = os.path.join(pypath, "ver", "%s.changes" % nam)
-                        if os.path.isfile(fle):
-                            chg.write(nam + "\n")
-                            chg.write(("=" * len(nam)) + "\n")
-                            lines = open(fle, "r")
-                            for line in lines:
-                                chg.write(line)
-                            chg.write("\n")
-            chg.write('"""')
-            chg.close()
-            # Create changes rst
-            rst = open("%s/doc/Changes.rst" % pypath, "w")
-            chg = __import__(chgfle)
-            rst.write(chg.changes)
-            rst.close()
-            # Create current file
-            cur = open("%s/TartanExe/current" % bd, "w")
-            cur.write("%s\n" % newver)
-            cur.close()
-            # Commit Bazaar
-            exeCmd("/usr/bin/bzr commit -m 'ver_%s.%s'" % tuple(ver))
-            exeCmd("/usr/bin/bzr log > ver/ver_%s.%s.log" % tuple(ver))
-        except:
-            print("Error Creating New Version")
-            sys.exit()
-
+            for y in range(999, -1, -1):
+                for z in range(99, 0, -1):
+                    nam = "ver_%s.%s.%s" % (x, y, z)
+                    fle = os.path.join("ver", "%s.changes" % nam)
+                    if os.path.isfile(fle):
+                        chg.write(nam + "\n")
+                        chg.write(("=" * len(nam)) + "\n")
+                        lines = open(fle, "r")
+                        for line in lines:
+                            chg.write(line)
+                        chg.write("\n")
+        chg.write('"""')
+        chg.close()
+        # Create changes rst
+        rst = open("doc/Changes.rst", "w")
+        chg = __import__("tarchg")
+        rst.write(chg.changes)
+        rst.close()
+        # Create current file
+        cur = open("%s/TartanExe/current" % bd, "w")
+        cur.write("%s\n" % newver)
+        cur.close()
+        # Commit repository
+        if vv == 5:
+            exeCmd("/usr/bin/bzr commit -m 'ver_%s.%s'" % tuple(cver))
+            exeCmd("/usr/bin/bzr log > ver/ver_%s.%s.log" % tuple(cver))
+        else:
+            exeCmd("/usr/bin/git add ver")
+            exeCmd("/usr/bin/git commit -am 'ver_%s.%s'" % tuple(cver))
+            if not test:
+                push = raw_input("Push Version (y/n): ")
+                if push == "y":
+                    exeCmd("/usr/bin/git push -u origin master")
+    #except:
+    #    print("Error Creating New Version")
+    #    sys.exit()
+# Create a zip of the repository
+if os.path.exists("%s/tarzip.zip" % bd):
+    os.remove("%s/tarzip.zip" % bd)
+if vv == 5:
+    exeCmd("/usr/bin/bzr export --format=zip --root= %s/tarzip.zip" % bd)
+else:
+    exeCmd("/usr/bin/git archive --format=zip HEAD -o %s/tarzip.zip" % bd)
+# Update the zip with uncommitted files
+exeCmd("zip -qr %s/tarzip ass/*.py bkm/*.py bks/*.py bwl/*.py crs/*.py csh/*.py drs/*.py gen/*.py lon/*.py mem/*.py mst/*.py pos/*.py rca/*.py rtl/*.py scp/*.py sls/*.py str/*.py tab/*.py ms0000.py TartanClasses.py tartanFunctions.py tartanImages.py tartanWork.py uty/*.py wag/*.py" % bd)
+# Create a new system directory
+if os.path.exists("%s/tardir" % bd):
+    shutil.rmtree("%s/tardir" % bd)
+os.mkdir(os.path.join(bd, "tardir"))
+# Unzip the repository into the system directory
+os.chdir("%s/tardir" % bd)
+exeCmd("unzip -qq %s/tarzip" % bd)
+os.remove("%s/tarzip.zip" % bd)
+# Rename and/or Remove paths and files
+if os.path.isfile("readme.md"):
+    os.remove("readme.md")
+if os.path.isdir("ver"):
+    shutil.rmtree("ver")
+# Create tarimp module for pyinstaller
+ofl = open("tarimp.py", "w")
+ofl.write("# Tartan Modules to Include with Pyinstaller Exe\n")
+ofl.write("import pkg_resources.py2_warn\n")
+ofl.write("import sys\n")
+for fle in glob.iglob("*.py"):
+    if fle.count("__pycache__"):
+        continue
+    ofl.write("import %s\n" % fle.replace("/", ".").replace(".py", ""))
+for fle in glob.iglob("???/*.py"):
+    if fle.count("__pycache__"):
+        continue
+    ofl.write("import %s\n" % fle.replace("/", ".").replace(".py", ""))
+ofl.close()
+# Create zip file for pyinstaller
 print("")
-zipfle = "%s-%s" % (system, vv)
-print("Creating %s.zip in your TartanSve directory ..... Please Wait" % zipfle)
-
+os.chdir(bd)
+zipfle = "tartan-%s" % vv
+print("Creating %s.zip in TartanSve directory ..... Please Wait" % zipfle)
 if os.path.exists("%s/TartanSve/%s.zip" % (bd, zipfle)):
     os.remove("%s/TartanSve/%s.zip" % (bd, zipfle))
-
-prg = ["%s/%s/%s" % (pypath, "std", "sitecustomize.py")]
-std = []
-
-for pth in dirs:
-    lst = os.listdir(os.path.join(pypath, pth))
-    lst.sort()
-    for fle in lst:
-        if exclude and fle[:6] in exclude:
-            continue
-        if fle[6:] in (".py", "_%s.py" % custom[0]) and fle[5] == "0":
-            prg.append("%s/%s/%s" % (pypath, pth, fle))
-
-def storeWord(word):
-    try:
-        std.index(word+".py")
-    except:
-        std.append(word+".py")
-
-def extractModule(prg, sys):
-    for fle in prg:
-        try:
-            if sys == "p":
-                fl = open(fle, "r")
-            else:
-                fl = open("%s/%s/%s" % (pypath, "std", fle), "r")
-        except:
-            #print("ERROR", sys, fle)
-            continue
-        dd = fl.readlines()
-        qq = "n"
-        for ll in dd:
-            if ll.count('"""') == 1:
-                if qq == "n":
-                    qq = "y"
-                else:
-                    qq = "n"
-            if qq == "y":
-                continue
-            if ll[0] == "#":
-                continue
-            ll = ll.rstrip().replace(",", "")
-            if ll.find("import") != -1:
-                words = ll.split()
-                for num, wrd in enumerate(words):
-                    if wrd == "from":
-                        storeWord(words[num+1])
-                        break
-                    if wrd == "import":
-                        for x in range(num+1, len(words)):
-                            if words[x] == "as":
-                                break
-                            storeWord(words[x])
-                        break
-        fl.close()
-
-def addpage(doc, fle, last=False):
-    exeCmd("aspell -c %s --lang en_GB" % fle)
-    data = open(fle, "r")
-    for d in data.readlines():
-        doc.write(d)
-    if not last:
-        doc.write("\n")
-        doc.write(".. raw:: pdf\n")
-        doc.write("\n")
-        doc.write("    PageBreak\n")
-        doc.write("\n")
-    data.close()
-
-# Create import_list
-extractModule(prg, "p")
-extractModule(std, "s")
-for fle in std:
-    if fle == "tarchg.py" and not system == "tartan":
-        continue
-    if os.path.isfile("%s/std/%s" % (pypath, fle)):
-        prg.append("%s/std/%s" % (pypath, fle))
-os.chdir(os.path.join(pypath, "std"))
-if system == "rnehol":
-    # Work File for RNE
-    prg.append("%s/std/tartanWork_rne.py" % pypath)
-prg.sort()
-# End of import_list.py
-
-ifl = "%s/std/%simp.py" % (pypath, system[:3])
-mfl = "%s/std/%smod.py" % (pypath, system[:3])
-if os.path.exists(ifl):
-    os.remove(ifl)
-if os.path.exists(mfl):
-    os.remove(mfl)
-if os.path.exists("%s/tmp" % pypath):
-    shutil.rmtree("%s/tmp" % pypath)
-os.mkdir("%s/tmp" % pypath)
-in1 = open(ifl, "w")
-in2 = open(mfl, "w")
-in1.write("# Tartan Modules to Include with Pyinstaller Exe\nimport sys\n")
-lst = []
-for pp in prg:
-    nm1 = os.path.basename(pp).replace("_%s.py" % custom[0], "")
-    if custom[0] and nm1 in custom[1]:
-        shutil.copy(pp, "%s/tmp/%s.py" % (pypath, nm1))
-        exeCmd("zip -qj %s/TartanSve/%s %s/tmp/%s.py" %
-                            (bd, zipfle, pypath, nm1))
-    else:
-        exeCmd("zip -qj %s/TartanSve/%s %s" % (bd, zipfle, pp))
-    p = os.path.basename(pp).replace("_%s" % custom[0], "")
-    p = p.split(".")
-    if p[0] not in ("ms0000", ) and p[1] == "py" and custom:
-        mod = p[0].replace("_%s" % custom[0], "")
-    else:
-        mod = p[0]
-    if str(mod)[5] == "0" and str(mod) not in lst:
-        in1.write("import %s\n" % mod)
-        lst.append("%s" % mod)
-in1.close()
-in2.write("# List of Tartan Modules Packaged for a Distribution\n")
-in2.write("modlst = %s" % str(lst))
-in2.close()
-exeCmd("ln -fs %s ~/wrk/tarimp.py;zip -qj %s/TartanSve/%s ~/wrk/tarimp.py" %
-    (ifl, bd, zipfle))
-exeCmd("ln -fs %s ~/wrk/tarmod.py;zip -qj %s/TartanSve/%s ~/wrk/tarmod.py" %
-    (mfl, bd, zipfle))
-os.chdir(pypath)
-if os.path.exists("%s/tmp" % pypath):
-    shutil.rmtree("%s/tmp" % pypath)
-man = "Manual"
-fles = ["doc/SYS.rst", "doc/CTL.rst"]
-if system == "rnehol":
-    fles.extend([
-        "doc/GEN_rne.rst",
-        "doc/ASS.rst",
-        "doc/CRS_rne.rst",
-        "doc/DRS.rst",
-        "doc/IBT.rst",
-        "doc/LON.rst",
-        "doc/RTL.rst",
-        "doc/STR.rst",
-        "doc/SLS.rst"])
+if vv == 5:
+    exeCmd("zip -qr %s/TartanSve/%s tartan --exclude \*.bzr\*" % (bd, zipfle))
 else:
-    fles.extend([
-        "doc/GEN.rst",
-        "doc/ASS.rst",
-        "doc/BKM.rst",
-        "doc/CRS.rst",
-        "doc/DRS.rst",
-        "doc/LON.rst",
-        "doc/MEM.rst",
-        "doc/RTL.rst",
-        "doc/RCA.rst",
-        "doc/STR.rst",
-        "doc/SLS.rst",
-        "doc/POS.rst",
-        "doc/WAG.rst",
-        "doc/SLN.rst",
-        "doc/BKS.rst",
-        "doc/BWL.rst",
-        "doc/CSH.rst",
-        "doc/SEC.rst"])
-fles.extend(["doc/UTY.rst", "doc/HLP.rst"])
-doc = open("doc/%s.rst" % man, "w")
-for fle in fles:
-    if system == "tartan":
-        exeCmd("zip -q %s/TartanSve/%s %s" % (bd, zipfle, fle))
-    if fle == fles[-1]:
-        addpage(doc, fle, True)
-    else:
-        addpage(doc, fle)
-doc.close()
-exeCmd("zip -q %s/TartanSve/%s doc/gnugpl.*" % (bd, zipfle))
-exeCmd("rst2pdf doc/%s.rst -o doc/Manual.pdf -s doc/mystylesheet" % man)
-exeCmd("zip -mq %s/TartanSve/%s doc/Manual.pdf" % (bd, zipfle))
-if system == "tartan":
-    exeCmd("rst2pdf doc/QST.rst -o doc/QuickStart.pdf -s doc/mystylesheet")
-    exeCmd("zip -q %s/TartanSve/%s doc/QuickStart.pdf" % (bd, zipfle))
-# exeCmd("zip -qr %s/TartanSve/%s fnt/*.ttf" % (bd, zipfle))
-exeCmd("zip -qr %s/TartanSve/%s img/*" % (bd, zipfle))
-exeCmd("zip -qr %s/TartanSve/%s uty/SumatraPDF.exe" % (bd, zipfle))
-# Create tgz file
-if os.path.isdir("%s/prg" % bd):
-    shutil.rmtree("%s/prg" % bd)
-os.mkdir("%s/prg" % bd)
-os.chdir("%s/prg" % bd)
-exeCmd("unzip -q %s/TartanSve/%s-%s" % (bd, system, vv))
-if os.path.exists("~/wrk/tarimp.py"):
-    os.remove("~/wrk/tarimp.py")
-if os.path.exists("~/wrk/tarmod.py"):
-    os.remove("~/wrk/tarmod.py")
-for fle in ("fdb", "fpdf", "ghostscript", "nmb", "paramiko", "progressbar", "pyasn1", "pychart", "simpleodspy", "smb", "uty", "xlrd", "xlwt"):
-    try:
-        shutil.rmtree(fle)
-    except:
-        pass
-if publish or verinc:
-    # Move Current to Old
-    exeCmd("mv %s/TartanExe/%s_%s.* %s/TartanOld/" %
-        (bd, csys, vv, bd))
-    # Create Source tgz
-    exeCmd("tar -czf %s/TartanExe/%s_%s.%s.tgz *" %
-        (bd, csys, ver[0], ver[1]))
-    # Create Source zip
-    exeCmd("cp -p %s/TartanSve/%s-%s.zip %s/TartanSve/%s_%s.%s.zip" %
-        (bd, system, vv, bd, csys, ver[0], ver[1]))
+    exeCmd("zip -qr %s/TartanSve/%s tartan --exclude \*.git\*" % (bd, zipfle))
+#shutil.rmtree("%s/tartan" % bd)
 if windows:
     # Python windows executable
     if vv == 5:
-        exeCmd("wine2 wineconsole c:/PyInstall/maker.bat %s" % system)
+        dd = "%s/.wine2/drive_c/PyInstall" % bd
+        exeCmd("wine2 cmd /c %s/maker.bat tartan" % dd)
     else:
-        exeCmd("wine3 wineconsole c:/PyInstall/maker.bat %s" % system)
-    if publish or verinc:
-        exeCmd("cp -p %s/TartanExe/%s-%s.exe %s/TartanExe/%s_%s.%s.exe" %
-            (bd, system, vv, bd, csys, ver[0], ver[1]))
-        exeCmd("cp -p %s/TartanExe/%s_upd-%s.exe "\
-            "%s/TartanExe/%s_%s.%s_upd.exe" %
-            (bd, system, vv, bd, csys, ver[0], ver[1]))
-    if not system == "rnehol" and publish:
-        # Publish
-        print("")
-        print("Version Number is %s.%s" % tuple(ver))
-        print("")
-        if system == "tartan":
-            # Dropbox
-            exeCmd("rm /home/paul/Dropbox/Updates/%s*" % csys)
-            exeCmd("cp -p %s/TartanExe/%s_%s.%s.tgz "\
-                "/home/paul/Dropbox/Updates/" %
-                (bd, csys, ver[0], ver[1]))
-            exeCmd("cp -p %s/TartanExe/%s_%s.%s.exe "\
-                "/home/paul/Dropbox/Updates/" %
-                (bd, csys, ver[0], ver[1]))
+        names = []
+        proc = subprocess.Popen("/usr/bin/virsh list --name --state-running",
+            shell=True, bufsize=0, stdin=subprocess.PIPE,
+            stdout=subprocess.PIPE, close_fds=True)
+        for l in proc.stdout:
+            names.append(l.strip().decode("utf-8"))
+        if "win10" in names:
+            os.system("ssh windows PyInstall\\\\maker.bat tartan")
+        else:
+            dd = "%s/.wine3/drive_c/PyInstall" % bd
+            exeCmd("wine3 cmd /c %s/maker.bat tartan" % dd)
+if publish:
+    # Publish
+    # Documentation
+    os.chdir(pypath)
+    man = "doc/Manual.rst"
+    fles = ["doc/SYS.rst", "doc/CTL.rst", "doc/GEN.rst", "doc/ASS.rst",
+            "doc/BKM.rst", "doc/CRS.rst", "doc/DRS.rst", "doc/LON.rst",
+            "doc/MEM.rst", "doc/RTL.rst", "doc/RCA.rst", "doc/STR.rst",
+            "doc/SLS.rst", "doc/POS.rst", "doc/WAG.rst", "doc/SLN.rst",
+            "doc/BKS.rst", "doc/BWL.rst", "doc/CSH.rst", "doc/SCP.rst",
+            "doc/UTY.rst", "doc/HLP.rst"]
+    doc = open(man, "w")
+    for fle in fles:
+        if fle == fles[-1]:
+            addPage(doc, fle, True)
+        else:
+            addPage(doc, fle)
+    doc.close()
+    # Move Current to Old
+    exeCmd("mv %s/TartanExe/%s_%s.* %s/TartanOld/" % (bd, csys, vv, bd))
+    # Create Source tgz and zip
+    exeCmd("tar -czf %s/TartanExe/%s_%s.%s.tgz %s/tartan" %
+        (bd, csys, cver[0], cver[1], bd))
+    exeCmd("cp -p %s/TartanSve/tartan-%s.zip %s/TartanSve/%s_%s.%s.zip" %
+        (bd, vv, bd, csys, cver[0], cver[1]))
+    # Rename Windows exe's
+    exeCmd("cp -p %s/TartanExe/tartan-%s.exe %s/TartanExe/%s_%s.%s.exe" %
+        (bd, vv, bd, csys, cver[0], cver[1]))
+    print("")
+    print("Version Number is %s.%s" % tuple(cver))
+    print("")
+    if not test:
+        # Dropbox
+        exeCmd("rm /home/paul/Dropbox/Updates/%s*" % csys)
+        exeCmd("cp -p %s/TartanExe/%s_%s.%s.tgz "\
+            "/home/paul/Dropbox/Updates/" % (bd, csys, cver[0], cver[1]))
+        exeCmd("cp -p %s/TartanExe/%s_%s.%s.exe "\
+            "/home/paul/Dropbox/Updates/" % (bd, csys, cver[0], cver[1]))
         # FTP Server
         exeCmd("ssh %s rm /srv/ftp/%s*" % (sv, csys))
-        exeCmd("rsync -az %s/TartanExe/current %s:/srv/ftp/ "\
-            "--progress" % (bd, sv))
-        exeCmd("rsync -az %s/TartanExe/%s* %s:/srv/ftp/ "\
-            "--progress" % (bd, csys, sv))
+        exeCmd("rsync -az %s/TartanExe/current %s:/srv/ftp/ --progress" %
+            (bd, sv))
+        exeCmd("rsync -az %s/TartanExe/%s* %s:/srv/ftp/ --progress" %
+            (bd, csys, sv))
         exeCmd("ssh %s chmod a+r /srv/ftp/*" % sv)
         exeCmd("ssh %s chown paul:paul /srv/ftp/*" % sv)
-        if system == "tartan":
-            exeCmd("rsync -az %s/%s/doc/Manual.rst "\
-                "%s:/var/www/tartan.co.za/htdocs/Manual/Manual.rst "\
-                "--progress" % (bd, bv, sv))
-            exeCmd("rsync -az %s/%s/doc/QST.rst "\
-                "%s:/var/www/tartan.co.za/htdocs/QuickStart/QuickStart.rst "\
-                "--progress" % (bd, bv, sv))
-            exeCmd("rsync -az %s/%s/doc/Downloads.rst "\
-                "%s:/var/www/tartan.co.za/htdocs/Downloads/ "\
-                "--progress" % (bd, bv, sv))
-            exeCmd("rsync -az %s/%s/doc/Changes.rst "\
-                "%s:/var/www/tartan.co.za/htdocs/Changes/ "\
-                "--progress" % (bd, bv, sv))
-if system == "tartan":
-    os.remove("%s/%s/doc/QuickStart.pdf" % (bd, bv))
-if email:
+        # Web documents
+        exeCmd("rsync -az %s/%s/doc/Manual.rst "\
+            "%s:/var/www/tartan.co.za/htdocs/Manual/Manual.rst "\
+            "--progress" % (bd, bv, sv))
+        exeCmd("rsync -az %s/%s/doc/QST.rst "\
+            "%s:/var/www/tartan.co.za/htdocs/QuickStart/QST.rst "\
+            "--progress" % (bd, bv, sv))
+        exeCmd("rsync -az %s/%s/doc/Downloads.rst "\
+            "%s:/var/www/tartan.co.za/htdocs/Downloads/ "\
+            "--progress" % (bd, bv, sv))
+        exeCmd("rsync -az %s/%s/doc/Changes.rst "\
+            "%s:/var/www/tartan.co.za/htdocs/Changes/ "\
+            "--progress" % (bd, bv, sv))
+        # Create CD
+        if os.path.isdir("%s/TartanCD" % bd):
+            shutil.rmtree("%s/TartanCD" % bd)
+            exeCmd("mkdir %s/TartanCD" % bd)
+        if os.path.isdir("%s/tempcd" % bd):
+            shutil.rmtree("%s/tempcd" % bd)
+        # Executables
+        exeCmd("mkdir %s/tempcd" % bd)
+        exeCmd("mkdir %s/tempcd/Other" % bd)
+        exeCmd("cp -p %s/TartanExe/Tartan* %s/tempcd/" % (bd, bd))
+        exeCmd("cp -pr %s/TartanExe/* %s/tempcd/Other/" % (bd, bd))
+        exeCmd("rm %s/tempcd/Other/Tartan*" % bd)
+        exeCmd("rm %s/tempcd/Other/Rnehol*" % bd)
+        exeCmd("rm %s/tempcd/Other/??????-[5,6].exe" % bd)
+        auto = open("%s/tempcd/AUTORUN.INF" % bd, "w")
+        auto.write("""[autorun]
+    shell\install=&Install
+    shell\install\command=Tartan_%s.%s.exe
+""" % (cver[0], cver[1]))
+        auto.close()
+        exeCmd("todos -o %s/tempcd/AUTORUN.INF" % bd)
+        exeCmd("chmod a+x %s/tempcd/AUTORUN.INF" % bd)
+        # Add Documentation
+        exeCmd("rst2pdf %s/%s/doc/Manual.rst -o %s/tempcd/Manual.pdf "\
+            "-s %s/%s/doc/mystylesheet" % (bd, bv, bd, bd, bv))
+        # Make CD iso
+        exeCmd("mkisofs -r -J -l -D -V 'Tartan Systems %s.%s' "\
+            "-p 'Paul Malherbe paul@tartan.co.za' -copyright 'Paul Malherbe' "\
+            "-o %s/TartanCD/Tartan.iso -graft-points /\=%s/tempcd" %
+            (cver[0], cver[1], bd, bd))
+        shutil.rmtree("%s/tempcd" % bd)
+        #if verinc and windows:
+        #    # Sourceforge
+        #    os.chdir("%s/TartanExe" % bd)
+        #    exeCmd("cp -p %s/doc/readme.md ." % pypath)
+        #    exeCmd("%s/uty/upload.sh %s" % (pypath, newver))
+if email and not test:
     # Email Users
-    chgfle = "%s/ver/ver_%s.%s.changes" % (pypath, ver[0], ver[1])
+    chgfle = "%s/ver/ver_%s.%s.changes" % (pypath, cver[0], cver[1])
     if os.path.isfile(chgfle):
         serv = ["mail", 465, 2, 1, "paul", "Pakati!@"]
         mfrm = "paul@tartan.co.za"
-        subj = "Tartan Update %s.%s is Available" % tuple(ver)
+        subj = "Tartan Update %s.%s is Available" % tuple(cver)
         info = open(chgfle, "rb")
         data = info.readlines()
         info.close()
@@ -533,25 +409,22 @@
         addrs = [
             "admin@amadlelo.co.za",
             "admin@blueberry.co.za",
-            "alickbb@iafrica.com",
             "cnurrish@telkomsa.net",
             "deonk@spargs.co.za",
             "frikkie@lando.co.za",
             "galloway@awe.co.za",
             "jane@acsconsulting.co.za",
             "joannej@buildinn-el.co.za",
-            "karen@spargs.co.za",
             "keith@barrowdale.co.za",
             "lawrence@hawcweb.co.za",
             "liezelstroud@gmail.com",
-            "lorraine@agfin.co.za",
             "lorraine@acsaccounting.co.za",
+            "lorraine@multitrust.net",
             "marindag@buildinn-el.co.za",
             "marlene@acsonline.co.za",
             "mcbagro@gmail.com",
             "mel@acsaccounting.co.za",
             "mike@annettelaing.co.za",
-            "nathan@barrowdale.co.za",
             "no2pigstash@hotmail.com",
             "paul@tartan.co.za",
             "paulabergh@mweb.co.za",
@@ -565,43 +438,5 @@
                 sendMail(serv, mfrm, addr, subj)
             else:
                 sendMail(serv, mfrm, addr, subj, mess=(text, html))
-if mkcd:
-    # Create CD
-    if os.path.isdir("%s/TartanCD" % bd):
-        shutil.rmtree("%s/TartanCD" % bd)
-        exeCmd("mkdir %s/TartanCD" % bd)
-    if os.path.isdir("%s/tempcd" % bd):
-        shutil.rmtree("%s/tempcd" % bd)
-    # Executables
-    exeCmd("mkdir %s/tempcd" % bd)
-    exeCmd("mkdir %s/tempcd/Other" % bd)
-    exeCmd("cp -p %s/TartanExe/Tartan* %s/tempcd/" % (bd, bd))
-    exeCmd("cp -pr %s/TartanExe/* %s/tempcd/Other/" % (bd, bd))
-    exeCmd("rm %s/tempcd/Other/Tartan*" % bd)
-    exeCmd("rm %s/tempcd/Other/Rnehol*" % bd)
-    exeCmd("rm %s/tempcd/Other/??????-[5,6].exe" % bd)
-    exeCmd("rm %s/tempcd/Other/??????_upd-[5,6].exe" % bd)
-    auto = open("%s/tempcd/AUTORUN.INF" % bd, "w")
-    auto.write("""[autorun]
-    shell\install=&Install
-    shell\install\command=Tartan_%s.%s.exe
-""" % (ver[0], ver[1]))
-    auto.close()
-    exeCmd("todos -o %s/tempcd/AUTORUN.INF" % bd)
-    exeCmd("chmod a+x %s/tempcd/AUTORUN.INF" % bd)
-    # Add Documentation
-    exeCmd("rst2pdf %s/%s/doc/Manual.rst -o %s/tempcd/Manual.pdf "\
-        "-s %s/%s/doc/mystylesheet" % (bd, bv, bd, bd, bv))
-    # Make CD iso
-    exeCmd("mkisofs -r -J -l -D -V 'Tartan Systems %s.%s' "\
-        "-p 'Paul Malherbe paul@tartan.co.za' -copyright 'Paul Malherbe' "\
-        "-o %s/TartanCD/Tartan.iso -graft-points /\=%s/tempcd" %
-        (ver[0], ver[1], bd, bd))
-    shutil.rmtree("%s/tempcd" % bd)
-if system == "tartan" and verinc and windows and publish:
-    # Sourceforge
-    os.chdir("%s/TartanExe" % bd)
-    exeCmd("cp -p %s/doc/readme.md ." % pypath)
-    exeCmd("%s/uty/upload.sh %s" % (pypath, newver))
 print("DONE")
 # END

=== modified file 'uty/pm1010.py' (properties changed: -x to +x)
--- old/uty/pm1010.py	2020-03-01 12:48:20 +0000
+++ new/uty/pm1010.py	2020-08-07 09:32:03 +0000
@@ -28,7 +28,8 @@
 
 import csv, os, shutil, struct, sys
 from TartanClasses import MyFpdf, TartanDialog
-from tartanFunctions import askChoice, askQuestion, doPrinter, showError
+from tartanFunctions import askChoice, askQuestion, doPrinter
+from tartanFunctions import showError, showInfo
 try:
     import pyaes
     PYAES = True
@@ -56,13 +57,11 @@
         self.ecb = None
         self.ctr = None
         self.change = False
+        home = os.path.expanduser("~")
         if sys.platform == "win32":
-            self.flenam = "C:\Tartan\secrets.dat"
+            self.flenam = os.path.join(home, "secrets.dat")
         else:
-            self.flenam = ".secrets.dat"
-            home = os.environ.get("HOME")
-            if home:
-                self.flenam = os.path.join(home, self.flenam)
+            self.flenam = os.path.join(home, ".secrets.dat")
         self.show = "*"
 
     def getSecret(self):
@@ -81,7 +80,9 @@
             but = None
             tnd = ((self.doEndSecret,"y"), )
         else:
-            but = (("Change",None,self.doChange,0,("T",0,1),("T",0,2)),)
+            but = (
+                ("Change",None,self.doChange,0,("T",0,1),("T",0,2)),
+                ("Exit",None,self.doExitSecret,0,("T",0,1),("T",0,2)))
             tnd = ((self.doEndSecret,"n"), )
         txt = (self.doExitSecret,)
         self.sw = TartanDialog(self.opts["mf"], tops=True, title=tit,
@@ -122,6 +123,9 @@
 
     def doExitSecret(self):
         self.sw.closeProcess()
+        if self.change:
+            self.change = False
+            self.getSecret()
 
     def mainProcess(self):
         pwm = {
@@ -171,7 +175,11 @@
     def doExport(self):
         self.df.setWidget(self.df.mstFrame, state="hide")
         typ = askChoice(self.opts["mf"].window, "Type", "Select the File Type",
-            butt=(("CSV", "C"), ("XML", "X")), default="CSV")
+            butt=(
+                ("CSV", "C", "Export to a csv file for Importing "\
+                    "into e.g. 'Password Safe'"),
+                ("XML", "X", "Export to a xml file for Importing "\
+                    "into e.g. 'KeePassX'")), default="CSV")
         self.df.setWidget(self.df.mstFrame, state="show")
         if typ == "C":
             fle = os.path.join(self.opts["mf"].rcdic["wrkdir"], "secrets.csv")
@@ -214,6 +222,14 @@
  </group>
 </database>""")
             xml.close()
+        showInfo(self.opts["mf"].body, "Export",
+            """The following file has been created:
+
+%s
+
+Please Note that this file is Unencrypted.
+
+This file will be treated as a Temporary File when Exiting Tartan.""" % fle)
         self.df.focusField("T", 0, 1)
 
     def doShow(self):
@@ -379,6 +395,9 @@
     else:
         rcdic = loadRcFile()
     mf = MainFrame(rcdic=rcdic)
-    pm1010(**{"mf": mf, "capnm": getpass.getuser()})
+    try:
+        pm1010(**{"mf": mf, "capnm": getpass.getuser()})
+    except:
+        pass
 
 # vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'uty/pw1010.py' (properties changed: -x to +x)
=== modified file 'uty/rp1010.py' (properties changed: -x to +x)
--- old/uty/rp1010.py	2020-04-21 08:42:36 +0000
+++ new/uty/rp1010.py	2020-08-07 09:32:05 +0000
@@ -265,8 +265,8 @@
             self.df.setWidget(self.df.B1, "normal")
         else:
             self.newrep = "n"
-            for x in xrange(1, len(rep)):
-                self.df.loadEntry(frt, pag, p+x, data=rep[x])
+            for num, dat in enumerate(rep[1:-1]):
+                self.df.loadEntry(frt, pag, p+num+1, data=dat)
             self.doLoadReport(self.repnam)
             self.df.setWidget(self.df.B3, "normal")
 
@@ -329,8 +329,8 @@
         if not rep:
             return "Invalid Report"
         self.cpynam = w
-        for x in xrange(1, len(rep)):
-            self.df.loadEntry(frt, pag, p+x, data=rep[x])
+        for num, dat in enumerate(rep[1:-1]):
+            self.df.loadEntry(frt, pag, p+num+1, data=dat)
 
     def doCpyEnd(self):
         self.doLoadReport(self.cpynam)
@@ -373,12 +373,11 @@
         # Tables
         dat = self.sql.getRec("rpttab", where=[("rpt_rnam","=",repnam)])
         if dat:
-            for d in xrange(0, len(dat)):
-                p = d * self.df.colq[1]
-                t = dat[d][1]
-                self.df.loadEntry("C", 1, p, data=d)
-                self.df.loadEntry("C", 1, p+1, data=t)
-                dsc = self.doGetTableDesc(t)
+            for d1, d2 in enumerate(dat):
+                p = d1 * self.df.colq[1]
+                self.df.loadEntry("C", 1, p, data=d1)
+                self.df.loadEntry("C", 1, p+1, data=d2[1])
+                dsc = self.doGetTableDesc(d2[1])
                 if dsc:
                     self.df.loadEntry("C", 1, p+2, data=dsc)
 
@@ -719,8 +718,7 @@
             for x in xrange(0, len(self.df.c_work[4])):
                 if not self.df.c_work[4][x][1]:
                     break
-                else:
-                    v.append([x, self.df.c_work[4][x][1]])
+                v.append([x, self.df.c_work[4][x][1]])
             tit = "Select Variable"
             hd = ("V", "Description")
             state = self.df.disableButtonsTags()
@@ -906,13 +904,11 @@
         for r in self.df.c_work[1]:
             if not r[1]:
                 break
-            else:
-                tab.append(r[1])
+            tab.append(r[1])
         for r in self.df.c_work[2]:
             if not r[2]:
                 break
-            else:
-                tab.append(r[2])
+            tab.append(r[2])
         if not tab:
             return "No Tables Selected"
         dat = tuple(tab)
@@ -986,9 +982,8 @@
 
     def doSetNextSeq(self):
         for pag in xrange(1, (len(self.df.tags) + 1)):
-            d = self.df.c_work[pag]
-            for seq in xrange(0, len(d)):
-                if not d[seq][1]:
+            for seq, dat in enumerate(self.df.c_work[pag]):
+                if not dat[1]:
                     break
             self.df.loadEntry("T", pag, 0, data=seq)
 
@@ -1007,7 +1002,7 @@
         for num, but in enumerate(self.df.butt):
             if num in (0, 1):
                 continue
-            elif state == "normal":
+            if state == "normal":
                 but[3] = 1
             else:
                 but[3] = 0
@@ -1163,8 +1158,7 @@
         for x in xrange(0, len(self.df.c_work[1])):
             if not self.df.c_work[1][x][1]:
                 break
-            else:
-                tabs.append(self.df.c_work[1][x][1])
+            tabs.append(self.df.c_work[1][x][1])
         if not tabs:
             return
         # JOINS
@@ -1172,10 +1166,9 @@
         for x in xrange(0, len(self.df.c_work[2])):
             if not self.df.c_work[2][x][1]:
                 break
-            else:
-                # Type, Table Name and Columns
-                jons.append([self.df.c_work[2][x][1],
-                    self.df.c_work[2][x][2], self.df.c_work[2][x][3]])
+            # Type, Table Name and Columns
+            jons.append([self.df.c_work[2][x][1],
+                self.df.c_work[2][x][2], self.df.c_work[2][x][3]])
         # COLUMNS, EXPRESSIONS, GROUPS, STOTS and GTOTS
         cols = []
         temp = []
@@ -1273,13 +1266,12 @@
             for t2 in tabs:
                 if t2 == t1:
                     continue
-                recs = self.sql.getRec("frelat", cols=["rel_col1",
-                    "rel_col2"], where=[("rel_tab1", "=", t1), ("rel_tab2",
-                    "=", t2)])
+                recs = self.sql.getRec("frelat", cols=["rel_col1", "rel_col2"],
+                    where=[("rel_tab1", "=", t1), ("rel_tab2", "=", t2)])
                 if not recs:
                     recs = self.sql.getRec("frelat", cols=["rel_col1",
-                        "rel_col2"], where=[("rel_tab1", "=", t2), ("rel_tab2",
-                        "=", t1)])
+                        "rel_col2"], where=[("rel_tab1", "=", t2),
+                        ("rel_tab2", "=", t1)])
                 for rel in recs:
                     if not rels.count(rel):
                         rels.append(rel)

=== modified file 'uty/rp1020.py' (properties changed: -x to +x)
--- old/uty/rp1020.py	2020-04-21 08:42:36 +0000
+++ new/uty/rp1020.py	2020-07-07 13:34:50 +0000
@@ -27,7 +27,7 @@
 import os, shutil, time
 from TartanClasses import GetCtl, SelectChoice, SplashScreen, Sql, TartanDialog
 from tartanFunctions import askQuestion, callModule, doPrinter, sendMail
-from tartanFunctions import showError, showPrinters, showWarning
+from tartanFunctions import showError, getPrinters, showWarning
 from tartanWork import allsys, tarmen
 
 class rp1020(object):
@@ -103,7 +103,7 @@
                 "st3080": [
                     ["", "", "", "Y", "Y"], []],
                 "st3090": [
-                    ["", "", "", "", "N"], []]}],
+                    ["", "", "", "", "N", "N"], []]}],
             "SI": ["INV", {
                 "si3020": [
                     ["", "", ""], []],
@@ -140,7 +140,10 @@
 
     def mainProcess(self):
         self.tit = "Stream Reports"
-        prts = showPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])
+        prts = getPrinters(wrkdir=self.opts["mf"].rcdic["wrkdir"])
+        data = prts[:]
+        if "Default" in data:
+            data.remove("Default")
         grp = {
             "stype": "R",
             "tables": ("rptstm",),
@@ -154,7 +157,7 @@
             "stype": "C",
             "titl": "Available Printers",
             "head": ("Name", "Description"),
-            "data": prts}
+            "data": data}
         r1s = (("E-Mail", "E"), ("Print", "P"))
         fld = [
             (("T",0,0,0),"INA",30,"Report Group", "",

=== modified file 'uty/td1010.py' (properties changed: -x to +x)
--- old/uty/td1010.py	2020-04-21 08:42:36 +0000
+++ new/uty/td1010.py	2020-06-21 11:51:42 +0000
@@ -129,9 +129,9 @@
 
     def doGroup(self, frt, pag, r, c, p, i, w):
         try:
-            w = eval(w)
+            grp = eval(w)
             self.group = ""
-            for g in w:
+            for g in grp:
                 if not self.group:
                     self.group = g[0]
                 else:
@@ -160,10 +160,12 @@
         self.df.focusField("T", 0, 1)
 
     def doTopEnd(self):
-        data = self.df.t_work[0][0]
+        data = self.df.t_work[0][0][:]
         if self.newmst:
             self.sql.insRec("telmst", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.telmst_col
+            data.append(self.acc[col.index("tdm_xflag")])
             self.sql.updRec("telmst", data=data, where=[("tdm_name",
                 "=", self.name)])
         self.opts["mf"].dbm.commitDbase()
@@ -284,8 +286,10 @@
             self.sql.insRec("telcon", data=data)
             self.opts["mf"].dbm.commitDbase()
         elif self.contyp == "chg" and data != self.conchg[:len(data)]:
-            self.sql.updRec("telcon", data=data, where=[("tdc_name", "=",
-                self.name), ("tdc_contact", "=", self.contact)])
+            col = self.sql.telcon_col
+            data.append(self.conchg[col.index("tdc_xflag")])
+            self.sql.updRec("telcon", data=data, where=[("tdc_name",
+                "=", self.name), ("tdc_contact", "=", self.contact)])
             self.opts["mf"].dbm.commitDbase()
         self.doChgExit()
 
@@ -337,6 +341,8 @@
                 if not chk:
                     self.sql.insRec("telmst", data=data)
                 elif data != chk[:len(data)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     self.sql.updRec("telmst", data=data, where=[("tdm_name",
                         "=", nam)])
             grps.append(["BKM", "Bookings"])
@@ -374,6 +380,8 @@
                 if not chk:
                     self.sql.insRec("telmst", data=data)
                 elif data != chk[:len(data)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     self.sql.updRec("telmst", data=data, where=[("tdm_name",
                         "=", nam)])
             grps.append(["BWL", "Bowls"])
@@ -401,6 +409,8 @@
                 if not chk:
                     self.sql.insRec("telmst", data=data)
                 elif data != chk[:len(data)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     self.sql.updRec("telmst", data=data, where=[("tdm_name",
                         "=", nam)])
                 con = rec[col.index("crm_mgr")]
@@ -412,6 +422,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
                 con = rec[col.index("crm_acc")]
@@ -423,6 +435,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
                 con = rec[col.index("crm_ord")]
@@ -434,6 +448,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
             grps.append(["CRS", "Creditors"])
@@ -461,6 +477,8 @@
                 if not chk:
                     self.sql.insRec("telmst", data=data)
                 elif data != chk[:len(data)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     self.sql.updRec("telmst", data=data, where=[("tdm_name",
                         "=", nam)])
                 con = rec[col.index("drm_mgr")]
@@ -472,6 +490,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
                 con = rec[col.index("drm_acc")]
@@ -483,6 +503,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
                 con = rec[col.index("drm_sls")]
@@ -494,6 +516,8 @@
                     if not chk:
                         self.sql.insRec("telcon", data=data)
                     elif data != chk[:len(data)]:
+                        col = self.sql.telcon_col
+                        data.append(chk[col.index("tdc_xflag")])
                         self.sql.updRec("telcon", data=data, where=[("tdc_name",
                             "=", nam), ("tdc_contact", "=", con)])
             grps.append(["DRS", "Debtors"])
@@ -556,6 +580,8 @@
                 if not chk:
                     self.sql.insRec("telmst", data=data)
                 elif data != chk[:len(data)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     self.sql.updRec("telmst", data=data, where=[("tdm_name",
                         "=", nam)])
             grps.append(["MEM", "Members"])
@@ -628,6 +654,8 @@
                 if not chk:
                     sql.insRec("telmst", data=dat)
                 elif dat != chk[:len(dat)]:
+                    col = self.sql.telmst_col
+                    data.append(chk[col.index("tdm_xflag")])
                     sql.updRec("telmst", data=dat, where=[("tdm_name",
                         "=", dat[0])])
             grps.append([grp, des])
@@ -684,10 +712,10 @@
             elif ss.selection[1] == "B" and self.df.last[0][0] != 1:
                 head = ["Contacts for %s" % self.name]
                 RepPrt(self.opts["mf"], name=self.__class__.__name__,
-                    tables=["telcon"],
-                    heads=head, cols=["tdc_contact", "tdc_desig", "tdc_telno",
-                    "tdc_celno", "tdc_email"], where=[("tdc_name", "=",
-                    self.name)], order="tdc_contact", prtdia=prtdia)
+                    tables=["telcon"], heads=head, cols=["tdc_contact",
+                    "tdc_desig", "tdc_telno", "tdc_celno", "tdc_email"],
+                    where=[("tdc_name", "=", self.name)], order="tdc_contact",
+                    prtdia=prtdia)
             elif ss.selection[1] == "C":
                 tit = ["Telephone Directory"]
                 grp = {
@@ -712,10 +740,10 @@
                         whr = None
                     odr = "tdm_name"
                     RepPrt(self.opts["mf"], name=self.__class__.__name__,
-                        tables=["telmst"],
-                        heads=head, cols=["tdm_name", "tdm_telno", "tdm_faxno",
-                        "tdm_mobile", "tdm_email"], where=whr, order=odr,
-                        repprt=self.pr.repprt, repeml=self.pr.repeml)
+                        tables=["telmst"], heads=head, cols=["tdm_name",
+                        "tdm_telno", "tdm_faxno", "tdm_mobile", "tdm_email"],
+                        where=whr, order=odr, repprt=self.pr.repprt,
+                        repeml=self.pr.repeml)
             elif ss.selection[1] == "D":
                 self.notes = NotesPrint(self.opts["mf"], 0, "", "TEL")
                 if not self.notes.data:
@@ -768,12 +796,14 @@
         self.pr.closeProcess()
 
     def doApply(self):
+        data = self.df.t_work[0][0][:]
         if self.df.frt == "T":
             if self.newmst:
-                self.sql.insRec("telmst", self.df.t_work[0][0])
+                self.sql.insRec("telmst", data=data)
             else:
-                self.sql.updRec("telmst", data=self.df.t_work[0][0],
-                    where=[("tdm_name", "=", self.name)])
+                data.append(self.acc[self.sql.telmst_col.index("tdm_xflag")])
+                self.sql.updRec("telmst", data=data, where=[("tdm_name",
+                    "=", self.name)])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'uty/tdc110.py' (properties changed: -x to +x)
--- old/uty/tdc110.py	2020-04-21 08:42:36 +0000
+++ new/uty/tdc110.py	2020-04-23 10:30:00 +0000
@@ -92,6 +92,8 @@
         if self.new:
             self.sql.insRec("telgrp", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.telgrp_col
+            data.append(self.acc[col.index("tdg_xflag")])
             self.sql.updRec("telgrp", data=data, where=[("tdg_group",
                 "=", self.group)])
         self.opts["mf"].dbm.commitDbase()

=== modified file 'uty/tp1010.py' (properties changed: -x to +x)
--- old/uty/tp1010.py	2020-04-21 08:42:36 +0000
+++ new/uty/tp1010.py	2020-08-07 09:32:07 +0000
@@ -27,9 +27,9 @@
 """
 
 import operator, os
-from TartanClasses import DrawForm, FileDialog, MyFpdf, RepPrt, Sql
-from TartanClasses import TartanDialog
-from tartanFunctions import askQuestion, parsePrg, showError, showInfo
+from TartanClasses import ViewPDF, DrawForm, FileDialog, MyFpdf, RepPrt
+from TartanClasses import Sql, TartanDialog
+from tartanFunctions import askQuestion, showError, showInfo
 from tartanWork import allsys, stdtpl, tptrtp
 
 class tp1010(object):
@@ -146,7 +146,6 @@
         fle = {
             "stype": "F",
             "types": "fle",
-            "initd": os.path.join(self.opts["mf"].rcdic["prgdir"], "img"),
             "ftype": (("JPG Files", "*.[j,J][p,P][g,G]"),)}
         fnt = {
             "stype": "C",
@@ -410,8 +409,8 @@
             self.newtpm = False
             self.ttype = tpm[self.sql.tplmst_col.index("tpm_type")]
             self.sttyp = tpm[self.sql.tplmst_col.index("tpm_sttp")]
-            for i, t in enumerate(tpm[1:]):
-                self.df.loadEntry(frt, pag, p+1+i, data=t)
+            for s, t in enumerate(tpm[1:]):
+                self.df.loadEntry(frt, pag, p+s+1, data=t)
         else:
             self.newtpm = True
             self.ttype = None
@@ -450,12 +449,12 @@
         rec = self.sql.getRec("ffield", cols=["ff_tabl", "ff_name",
             "ff_type", "ff_size", "ff_desc"], where=[("ff_tabl", "in",
             tuple(tabs))])
-        for r in rec:
-            if r[1] != "ctm_cono" and r[1][4:] == "cono":
-                continue
-            if r[1] in self.ignore:
-                continue
-            self.tptrtp[r[1]] = [[r[0]] + r[2:], []]
+        for rr in rec:
+            if rr[1] != "ctm_cono" and rr[1][4:] == "cono":
+                continue
+            if rr[1] in self.ignore:
+                continue
+            self.tptrtp[rr[1]] = [[rr[0]] + rr[2:], []]
         data = []
         for key in self.tptrtp:
             data.append([self.tptrtp[key][0][0], key]+self.tptrtp[key][0][1:])
@@ -485,15 +484,15 @@
                 self.df.loadEntry(frt, pag, p, data=self.sttyp)
                 return "rf"
         if w == "N":
-            for c in ("total_arrears", "month_exclusive", "month_tax"):
+            for txt in ("total_arrears", "month_exclusive", "month_tax"):
                 for m in self.mrg["data"]:
-                    if m[1] == c:
+                    if m[1] == txt:
                         self.mrg["data"].remove(m)
         else:
-            for c in ("current_balance", "30_day_balance", "60_day_balance",
+            for txt in ("current_balance", "30_day_balance", "60_day_balance",
                      "90_day_balance", "120_day_balance", "total_balance"):
                 for m in self.mrg["data"]:
-                    if m[1] == c:
+                    if m[1] == txt:
                         self.mrg["data"].remove(m)
 
     def doLineNo(self, frt, pag, r, c, p, i, w):
@@ -763,8 +762,8 @@
         if not self.cpymst:
             return "Invalid Template Name"
         self.cpynam = w
-        for i, t in enumerate(self.cpymst[1:]):
-            self.df.loadEntry(frt, pag, p+1+i, data=t)
+        for s, t in enumerate(self.cpymst[1:]):
+            self.df.loadEntry(frt, pag, p+s+1, data=t)
 
     def doCpyEnd(self):
         self.cpymst[0] = self.template
@@ -826,6 +825,8 @@
                 else:
                     self.sql.insRec("tpldet", data=dat[1:])
         self.opts["mf"].dbm.commitDbase()
+        showInfo(self.opts["mf"].body, "Import",
+            "The Template has been Imported.")
         self.df.focusField(self.df.frt, self.df.pag, 1)
 
     def doExport(self):
@@ -875,6 +876,9 @@
                 ttt.write("%s],\n" % txt)
         fle.close()
         ttt.close()
+        showInfo(self.opts["mf"].body, "Export",
+            "The Template has been Exported to:\n\n%s" %
+            self.opts["mf"].rcdic["wrkdir"])
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doPrint(self):
@@ -892,6 +896,7 @@
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doView(self):
+        self.df.setWidget(self.df.mstFrame, state="hide")
         self.frm = DrawForm(self.opts["mf"].dbm, self.template,
             wrkdir=self.opts["mf"].rcdic["wrkdir"])
         self.frm.doNewDetail()
@@ -908,19 +913,16 @@
                 dat = line[self.sql.tpldet_col.index("tpd_text")]
             if not dat:
                 if line[self.sql.tpldet_col.index("tpd_type")] == "I":
-                    dat = os.path.join(self.opts["mf"].rcdic["prgdir"],
-                        "img", "rectangle.jpg")
+                    dat = "rectangle"
                 else:
                     dat = " "
             line[self.sql.tpldet_col.index("tpd_text")] = dat
             self.frm.doDrawDetail(line, fmat=False)
         pdfnam = os.path.join(self.opts["mf"].rcdic["wrkdir"], "test.pdf")
         self.frm.output(pdfnam, "F")
-        if self.frm.chgsz:
-            self.frm.changeSize(pdfnam)
-        exe, cmd = parsePrg(self.opts["mf"].rcdic["vwr"])
-        cmd.append(pdfnam)
-        os.spawnv(os.P_WAIT, exe, tuple(cmd))
+        ViewPDF(self.opts["mf"], pdfnam)
+        self.opts["mf"].window.deiconify()
+        self.df.setWidget(self.df.mstFrame, state="show")
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 
     def doGetData(self, mrgcod, line):

=== added file 'wag/__init__.py'
=== modified file 'wag/sl1010.py' (properties changed: -x to +x)
--- old/wag/sl1010.py	2020-04-21 08:42:36 +0000
+++ new/wag/sl1010.py	2020-04-23 09:08:41 +0000
@@ -134,6 +134,8 @@
                 continue
             data.append(self.df.t_work[0][0][p])
         if data != self.rec[:len(data)]:
+            col = self.sql.waglmf_col
+            data.append(self.rec[col.index("wlm_xflag")])
             self.sql.updRec("waglmf", data=data, where=[("wlm_cono", "=",
                 self.opts["conum"]), ("wlm_empno", "=", self.empno),
                 ("wlm_loan", "=", self.loan)])
@@ -142,8 +144,8 @@
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["waglmf", "U",
                         "%03i%05i%02i" % (self.opts["conum"], self.empno,
-                        self.loan), self.sql.waglmf_col[num], dte,
-                        self.opts["capnm"], str(dat), str(data[num]), 0])
+                        self.loan), col[num], dte, self.opts["capnm"],
+                        str(dat), str(data[num]), "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 

=== modified file 'wag/sl2010.py' (properties changed: -x to +x)
=== modified file 'wag/sl2020.py' (properties changed: -x to +x)
=== modified file 'wag/sl2030.py' (properties changed: -x to +x)
=== modified file 'wag/sl3010.py' (properties changed: -x to +x)
--- old/wag/sl3010.py	2020-04-21 08:42:36 +0000
+++ new/wag/sl3010.py	2020-05-27 12:37:50 +0000
@@ -170,8 +170,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'wag/sl3020.py' (properties changed: -x to +x)
--- old/wag/sl3020.py	2020-04-21 08:42:36 +0000
+++ new/wag/sl3020.py	2020-06-21 12:11:44 +0000
@@ -234,8 +234,7 @@
             self.typeTotal()
             self.grandTotal()
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
@@ -341,16 +340,16 @@
         self.totind = "Y"
         self.pageHeading()
         tot = [0,0,0,0]
-        for x in xrange(0, len(sltrtp)):
+        for x, t in enumerate(sltrtp):
             qt = CCD(self.gqt[x], "SI", 8)
             am = CCD(self.gam[x], "SD", 13.2)
             dd = CCD(self.gdd[x], "SD", 13.2)
             if self.totsonly == "Y":
                 self.fpdf.drawText("%-44s %s %s %s" % \
-                (sltrtp[x][1], qt.disp, am.disp, dd.disp))
+                (t[1], qt.disp, am.disp, dd.disp))
             else:
                 self.fpdf.drawText("%-30s %s %s %s" % \
-                (sltrtp[x][1], qt.disp, am.disp, dd.disp))
+                (t[1], qt.disp, am.disp, dd.disp))
             tot[0] = tot[0] + qt.work
             tot[1] = float(ASD(tot[1]) + ASD(am.work))
             tot[2] = float(ASD(tot[2]) + ASD(dd.work))

=== modified file 'wag/sl3030.py' (properties changed: -x to +x)
--- old/wag/sl3030.py	2020-03-01 12:48:20 +0000
+++ new/wag/sl3030.py	2020-05-27 12:38:01 +0000
@@ -142,8 +142,7 @@
             self.fpdf.drawText()
             self.fpdf.drawText("%5s %-100s%s" % ("", "Total", tot.disp))
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'wag/sl3040.py' (properties changed: -x to +x)
--- old/wag/sl3040.py	2020-04-21 08:42:36 +0000
+++ new/wag/sl3040.py	2020-06-21 12:27:46 +0000
@@ -171,9 +171,9 @@
     def loadBalances(self, wlt):
         self.obal = 0.0
         self.cbal = 0.0
-        for x in xrange(0, len(wlt)):
-            dat = CCD(wlt[x][0], "d1", 10)
-            amt = CCD(wlt[x][5], "SD", 13.2)
+        for x, w in enumerate(wlt):
+            dat = CCD(w[0], "d1", 10)
+            amt = CCD(w[5], "SD", 13.2)
             if self.fdate and dat.work < self.fdate:
                 self.obal = float(ASD(self.obal) + ASD(float(amt.work)))
             if dat.work <= self.ldate:
@@ -242,8 +242,7 @@
 
     def doPrint(self):
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf.output(pdfnam, "F")
         doPrinter(mf=self.opts["mf"], conum=self.opts["conum"], pdfnam=pdfnam,
             header="%s Loan Statement at %s" % (self.opts["conam"], self.dated),

=== modified file 'wag/sl4010.py' (properties changed: -x to +x)
--- old/wag/sl4010.py	2020-04-21 08:42:36 +0000
+++ new/wag/sl4010.py	2020-10-02 10:23:23 +0000
@@ -255,7 +255,7 @@
         odr = "wlt_trdt, wlt_type, wlt_ref"
         state = self.df.disableButtonsTags()
         SRec(self.opts["mf"], screen=self.df.nb.Page2, title=tit, tables=tab,
-            cols=col, where=whr, order=odr, rows=12)
+            cols=col, where=whr, order=odr)
         self.df.enableButtonsTags(state=state)
         self.df.focusField("T", 2, 1)
 
@@ -287,8 +287,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'wag/wg1010.py' (properties changed: -x to +x)
--- old/wag/wg1010.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg1010.py	2020-06-21 12:21:47 +0000
@@ -26,7 +26,6 @@
 
 import time
 from TartanClasses import TartanDialog, RepPrt, Sql
-from tartanFunctions import luhnFunc
 
 class wg1010(object):
     def __init__(self, **opts):
@@ -97,12 +96,12 @@
                 "","N",None,None,None,("notblank",)),
             (("T",1,2,0),"ID1",10,"Date of Birth","",
                 "","N",self.doDOB,None,None,("efld",)),
-            (("T",1,3,0),"IUL",13,"ID Number","",
-                "","N",self.doIdNo,None,None,("notblank",)),
+            (("T",1,3,0),"INA",13,"ID Number","",
+                "","N",self.doIdNo,None,None,("idno",)),
             (("T",1,4,0),"INA",16,"Spouse Name","",
                 "","N",None,None,None,None),
-            (("T",1,5,0),"INA",16,"Spouse ID Number","",
-                "","N",None,None,None,None),
+            (("T",1,5,0),"INA",13,"Spouse ID Number","",
+                "","N",self.doIdNo,None,None,("idno",)),
             (("T",1,6,0),"INA",30,"Address Line 1","",
                 "","N",None,None,None,("notblank",)),
             (("T",1,7,0),"INA",30,"Address Line 2","",
@@ -175,7 +174,7 @@
             ("Bank",None,("T",0,0),("T",0,1)),
             ("Earnings",None,("T",0,0),("T",0,1)),
             ("Deductions",None,("T",0,0),("T",0,1)),
-            ("Balances",None,("T",0,0),("T",0,1)))
+            ("Ba_lances",None,("T",0,0),("T",0,1)))
         tnd = (
             (self.doEnd, "n"),
             (self.doEnd, "n"),
@@ -238,9 +237,9 @@
             self.new = False
             self.term = self.oldm[len(self.oldm)-1]
             d = 1
-            for p in xrange(0, self.df.pgs):
-                for x in xrange(0, self.df.topq[p]):
-                    self.df.loadEntry("T", p, x, data=self.oldm[d])
+            for pg in xrange(0, self.df.pgs):
+                for x in xrange(0, self.df.topq[pg]):
+                    self.df.loadEntry("T", pg, x, data=self.oldm[d])
                     d = d + 1
             self.ptyp = self.df.t_work[1][0][15]
             self.doLoadEarnDed("E")
@@ -261,12 +260,11 @@
         self.dob = w
 
     def doIdNo(self, frt, pag, r, c, p, i, w):
-        a = int(w / 10000000)
-        b = int(self.dob % 1000000)
-        if a != b:
-            return "ID Number Does Not Agree with Birth Date"
-        if not luhnFunc(int(w)):
-            return "Invalid ID Number"
+        if p == 6:
+            a = int(int(w) / 10000000)
+            b = int(self.dob % 1000000)
+            if a != b:
+                return "ID Number Does Not Agree with Birth Date"
 
     def doPayTyp(self, frt, pag, r, c, p, i, w):
         self.ptyp = w
@@ -381,13 +379,12 @@
         if not codes:
             return
         p = 0
-        for r in xrange(0, len(codes)):
-            for i in xrange(0, len(codes[r])):
+        for cod in codes:
+            for i, c in enumerate(cod):
                 if rtype == "E" and i == 3:
                     continue
-                else:
-                    self.df.loadEntry("C", pag, p, data=codes[r][i])
-                    p = p + 1
+                self.df.loadEntry("C", pag, p, data=c)
+                p = p + 1
         if focus:
             self.df.focusField("C", pag, p+1)
         else:
@@ -430,11 +427,13 @@
                 self.sql.insRec("wagmst", data=data)
                 for b in xrange(3):
                     data = [self.opts["conum"], self.empno, b+1,
-                        self.df.t_work[6][0][b]]
+                        self.df.t_work[6][0][b], ""]
                     self.sql.insRec("wagbal", data=data)
             else:
                 dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
                 if data != self.oldm[:len(data)]:
+                    col = self.sql.wagmst_col
+                    data.append(self.oldm[col.index("wgm_xflag")])
                     self.sql.updRec("wagmst", data=data, where=[("wgm_cono",
                         "=", self.opts["conum"]), ("wgm_empno", "=",
                         self.empno)])
@@ -442,9 +441,8 @@
                         if dat != data[num]:
                             self.sql.insRec("chglog", data=["wagmst", "U",
                                 "%03i%05i" % (self.opts["conum"], self.empno),
-                                self.sql.wagmst_col[num], dte,
-                                self.opts["capnm"], str(dat), str(data[num]),
-                                0])
+                                col[num], dte, self.opts["capnm"], str(dat),
+                                str(data[num]), "", 0])
                 for n, b in enumerate(self.df.t_work[6][0]):
                     lvl = n + 1
                     data = [self.opts["conum"], self.empno, lvl, b]
@@ -457,14 +455,16 @@
                         self.sql.insRec("wagbal", data=data)
                         continue
                     if data != self.oldb[n][:len(data)]:
+                        col = self.sql.wagbal_col
+                        data.append(self.oldb[n][col.index("wbl_xflag")])
                         self.sql.updRec("wagbal", data=data, where=whr)
                         for num, dat in enumerate(self.oldb[n]):
                             if dat != data[num]:
                                 self.sql.insRec("chglog", data=["wagbal", "U",
                                     "%03i%05i%i" % (self.opts["conum"],
-                                    self.empno, lvl), self.sql.wagbal_col[num],
-                                    dte, self.opts["capnm"], str(dat),
-                                    str(data[num]), 0])
+                                    self.empno, lvl), col[num], dte,
+                                    self.opts["capnm"], str(dat),
+                                    str(data[num]), "", 0])
             self.opts["mf"].dbm.commitDbase()
             self.df.last[0] = [0, 0]
             self.df.selPage("General")
@@ -499,7 +499,7 @@
         dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
         self.sql.insRec("chglog", data=["wagmst", "D", "%03i%05i" %
             (self.opts["conum"], self.empno), "", dte, self.opts["capnm"],
-            "", "", 0])
+            "", "", "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.df.focusField("T", 0, 1)
 
@@ -516,9 +516,8 @@
                 ["b","NA",30.0,"Values"]]
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=cols, conum=self.opts["conum"], conam=self.opts["conam"],
-            ttype="D")
+            heads=heads, cols=cols, conum=self.opts["conum"],
+            conam=self.opts["conam"], ttype="D")
         self.df.enableButtonsTags(state=state)
         self.df.focusField(self.df.frt, self.df.pag, self.df.col)
 

=== modified file 'wag/wg2010.py' (properties changed: -x to +x)
=== modified file 'wag/wg2020.py' (properties changed: -x to +x)
--- old/wag/wg2020.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg2020.py	2020-08-07 09:32:09 +0000
@@ -27,7 +27,7 @@
 import os, time
 from TartanClasses import ASD, CCD, GetCtl, LoanInterest, PrintPayslip
 from TartanClasses import ProgressBar, Sql, TartanDialog
-from tartanFunctions import askQuestion, chkGenAcc, dateDiff, getSingleRecords
+from tartanFunctions import askQuestion, dateDiff, getSingleRecords
 from tartanFunctions import mthendDate, payeTables, showError
 
 class wg2020(object):
@@ -58,6 +58,7 @@
             if gc.chkRec(self.opts["conum"], ctlctl, ["wag_ctl"]):
                 return
             self.wagctl = ctlctl["wag_ctl"]
+            self.slnctl = ctlctl["wag_slc"]
             tabs.extend(["ctldep", "ctlmst", "genmst", "genint", "gentrn"])
         self.sql = Sql(self.opts["mf"].dbm, tables=tabs,
             prog=self.__class__.__name__)
@@ -629,6 +630,8 @@
                 self.taxbl = float(ASD(self.taxbl) - ASD(amt))
             # Update Balance Records
             if old and tmp != old[:len(tmp)]:
+                col = self.sql.wagbal_col
+                tmp.append(old[col.index("wbl_xflag")])
                 self.sql.updRec("wagbal", data=tmp, where=bwh)
             if rind == "N":
                 rmt = 0
@@ -726,14 +729,14 @@
 
     def doFormulae(self):
         taxinc, retinc, totinc = self.doTaxableIncome()
-        if taxinc <= 0:
-            self.taxamt = 0
-            return
+        #if taxinc <= 0:
+        #    self.taxamt = 0
+        #    return
         ann = 0
         ret = 0
         self.taxamt, prb, arb, nrb, rmx = self.doCompute(taxinc)
         if taxinc != totinc:
-            ann, x, x, x, x = self.doCompute(totinc)
+            ann, _, _, _, _ = self.doCompute(totinc)
             ann = float(ASD(ann) - ASD(self.taxamt))
         yrend = mthendDate((self.taxyr * 10000) + 228)
         age = dateDiff(self.dob, yrend, "years")
@@ -898,43 +901,15 @@
         for t1 in tr1:
             empno = int(t1[self.sql.wagtf1_col.index("wt1_empno")])
             self.dept = int(t1[self.sql.wagtf1_col.index("wt1_dept")])
+            # Check that Department Accounts are Loaded
             cols = ["dep_dr_coy", "dep_dr_sal", "dep_dr_com", "dep_cr_coy",
                 "dep_cr_sal", "dep_cr_com"]
             self.glacno = self.sql.getRec("ctldep", cols=cols,
                 where=[("dep_cono", "=", self.opts["conum"]),
                 ("dep_code", "=", self.dept)], limit=1)
-            # Check that all G/L Accounts are Valid
-            err = None
-            if not self.glacno:
-                self.glacno = self.doGetControls()
-            if not self.glacno:
-                err = "y"
-            else:
-                if not self.glacno[0]:
-                    self.glacno[0] = self.opts["conum"]
-                chk = chkGenAcc(self.opts["mf"], self.glacno[0], self.glacno[1])
-                if type(chk) is str:
-                    err = "y"
-                if not self.glacno[2]:
-                    self.glacno[2] = self.glacno[1]
-                chk = chkGenAcc(self.opts["mf"], self.glacno[0], self.glacno[2])
-                if type(chk) is str:
-                    err = "y"
-                if not self.glacno[3]:
-                    self.glacno[3] = self.opts["conum"]
-                if not self.glacno[4]:
-                    self.glacno[4] = self.wagctl
-                chk = chkGenAcc(self.opts["mf"], self.glacno[3], self.glacno[4])
-                if type(chk) is str:
-                    err = "y"
-                if not self.glacno[5]:
-                    self.glacno[5] = self.glacno[4]
-                chk = chkGenAcc(self.opts["mf"], self.glacno[3], self.glacno[5])
-                if type(chk) is str:
-                    err = "y"
-            if err:
+            if not self.glacno:
                 showError(self.opts["mf"].body, "Department Error",
-                    "Department %s %s Has an Invalid GL Account Number. "\
+                    "Department %s %s Has No valid GL Account Numbers. "\
                     "Please Correct it and Re-Run Payslips." %
                     (self.opts["conum"], self.dept))
                 return
@@ -972,12 +947,6 @@
                         acc1 = self.glacno[2]  # Commission
                 elif not coy1:
                     coy1 = self.opts["conum"]
-                chk = chkGenAcc(self.opts["mf"], coy1, acc1)
-                if type(chk) is str:
-                    showError(self.opts["mf"].body, "Code Error",
-                        "Invalid GL Account %s %s for Code %s %s" %
-                        (coy1, acc1, wgtp, code))
-                    return
                 # Expense Record
                 eamt = float(t2[self.sql.wagtf2_col.index("wt2_eamt")])
                 if not eamt:
@@ -1002,12 +971,6 @@
                         coy2 = self.opts["conum"]
                     if not acc2:
                         acc2 = self.wagctl
-                chk = chkGenAcc(self.opts["mf"], coy1, acc1)
-                if type(chk) is str:
-                    showError(self.opts["mf"].body, "Code Error",
-                        "Invalid GL Account %s %s for Code %s %s " %
-                        (coy1, acc1, wgtp, code))
-                    return
                 # Control Record
                 eamt = float(ASD(0) - ASD(eamt))
                 self.doGenTrn(coy2, acc2, eamt)
@@ -1017,130 +980,6 @@
                         return
         return True
 
-    def doGetControls(self):
-        tit = ("Control Accounts",)
-        coy = {
-            "stype": "R",
-            "tables": ("ctlmst",),
-            "cols": (
-                ("ctm_cono", "", 0, "Coy"),
-                ("ctm_name", "", 0, "Name", "Y"))}
-        glm = {
-            "stype": "R",
-            "tables": ("genmst",),
-            "cols": (
-                ("glm_acno", "", 0, "Acc-Num"),
-                ("glm_desc", "", 0, "Description", "Y")),
-            "where": [("glm_cono", "=", self.opts["conum"])]}
-        fld = (
-            (("T",0,0,0),"OUI",1,"Department"),
-            (("T",0,0,25),"ONA",30,""),
-            (("T",0,1,0),"IUI",3,"Debit  Company","",
-                self.opts["conum"],"N",self.doGLCoy,coy,None,("notzero",)),
-            (("T",0,1,25),"ONA",30,""),
-            (("T",0,2,0),"IUI",7,"       Salary","Debit Salary",
-                "","N",self.doGLAcc,glm,None,("notzero",)),
-            (("T",0,2,25),"ONA",30,""),
-            (("T",0,3,0),"IUI",7,"       Commission","Debit Commission",
-                "","N",self.doGLAcc,glm,None,("efld",)),
-            (("T",0,3,25),"ONA",30,""),
-            (("T",0,4,0),"IUI",3,"Credit Company","",
-                self.opts["conum"],"N",self.doGLCoy,coy,None,("notzero",)),
-            (("T",0,4,25),"ONA",30,""),
-            (("T",0,5,0),"IUI",7,"       Salary","Credit Salary",
-                "","N",self.doGLAcc,glm,None,("notzero",)),
-            (("T",0,5,25),"ONA",30,""),
-            (("T",0,6,0),"IUI",7,"       Commission","Credit Commission",
-                "","N",self.doGLAcc,glm,None,("efld",)),
-            (("T",0,6,25),"ONA",30,""))
-        tnd = ((self.doCtlEnd,"n"), )
-        txt = (self.doCtlExit, )
-        state = self.df.disableButtonsTags()
-        self.tf = TartanDialog(self.opts["mf"], tops=True, title=tit,
-            eflds=fld, tend=tnd, txit=txt)
-        dep = self.sql.getRec("ctldep", cols=["dep_name"],
-            where=[("dep_cono", "=", self.opts["conum"]),
-            ("dep_code", "=", self.dept)], limit=1)
-        if not dep:
-            dep = "Unknown"
-        else:
-            dep = dep[0]
-        self.glacno = [0, 0, 0, 0, 0, 0]
-        self.tf.loadEntry("T", 0, 0, data=self.dept)
-        self.tf.loadEntry("T", 0, 1, data=dep)
-        self.doLoadGL()
-        self.tf.focusField("T", 0, 2)
-        self.tf.mstFrame.wait_window()
-        self.df.enableButtonsTags(state=state)
-
-    def doGLCoy(self, frt, pag, r, c, p, i, w):
-        name = self.sql.getRec("ctlmst", cols=["ctm_name"],
-            where=[("ctm_cono", "=", w)], limit=1)
-        if not name:
-            return "Invalid Company Number"
-        self.glcoy = w
-        if c == 6:
-            self.glacno[0] = self.glcoy
-        else:
-            self.glacno[3] = self.glcoy
-        self.tf.loadEntry(frt, pag, p+1, data=name[0])
-
-    def doGLAcc(self, frt, pag, r, c, p, i, w):
-        chk = chkGenAcc(self.opts["mf"], self.glcoy, w)
-        if type(chk) is str:
-            return chk
-        if c == 7:
-            self.glacno[1] = w
-        elif c == 9:
-            self.glacno[2] = w
-        elif c == 13:
-            self.glacno[4] = w
-        elif c == 15:
-            self.glacno[5] = w
-        self.doLoadGL()
-
-    def doLoadGL(self):
-        if not self.glacno:
-            return
-        if self.glacno[1]:
-            chk = chkGenAcc(self.opts["mf"], self.glacno[0], self.glacno[1])
-            if type(chk) is str:
-                desc = ""
-            else:
-                desc = chk[0]
-            self.tf.loadEntry("T", 0, 7, data=desc)
-        if self.glacno[2]:
-            chk = chkGenAcc(self.opts["mf"], self.glacno[0], self.glacno[2])
-            if type(chk) is str:
-                desc = ""
-            else:
-                desc = chk[0]
-            self.tf.loadEntry("T", 0, 9, data=desc)
-        if self.glacno[4]:
-            chk = chkGenAcc(self.opts["mf"], self.glacno[3], self.glacno[4])
-            if type(chk) is str:
-                desc = ""
-            else:
-                desc = chk[0]
-            self.tf.loadEntry("T", 0, 13, data=desc)
-        if self.glacno[5]:
-            chk = chkGenAcc(self.opts["mf"], self.glacno[3], self.glacno[5])
-            if type(chk) is str:
-                desc = ""
-            else:
-                desc = chk[0]
-            self.tf.loadEntry("T", 0, 15, data=desc)
-
-    def doCtlExit(self):
-        self.glacno = None
-        self.doCtlClose()
-
-    def doCtlEnd(self):
-        self.doCtlClose()
-
-    def doCtlClose(self):
-        self.tf.closeProcess()
-
     def doGenTrn(self, cono, acno, amnt, edes=None):
         if not edes:
             edes = "Salaries and Wages"

=== modified file 'wag/wg2030.py' (properties changed: -x to +x)
=== modified file 'wag/wg3010.py' (properties changed: -x to +x)
--- old/wag/wg3010.py	2020-03-01 12:48:20 +0000
+++ new/wag/wg3010.py	2020-05-27 12:38:41 +0000
@@ -95,15 +95,15 @@
                 return
             col = sql.wagmst_col
             dic = sql.wagmst_dic
-            self.fpdf = MyFpdf(name=self.__class__.__name__, head=80, auto=True,
-                foot=True)
+            self.fpdf = MyFpdf(name=self.__class__.__name__, head=80,
+                auto=True, foot=True)
             self.fpdf.header = self.doHead
             self.fpdf.set_font("Courier", "B", 12)
             cwth = self.fpdf.get_string_width("X")
             for rec in recs:
                 self.fpdf.add_page()
                 max1, max2 = 0, 0
-                for c in col:
+                for c in col[:-1]:
                     if max1 < len(dic[c][4]):
                         max1 = len(dic[c][4])
                     if max2 < int(dic[c][3]):
@@ -140,8 +140,7 @@
                             txt=CCD(rec[col.index(c)],
                             dic[c][2], dic[c][3]).disp)
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.head, repprt=self.df.repprt,
@@ -156,10 +155,9 @@
                 ["wgm_term",   "d1", 10, "Term-Date", "y"]]
             RepPrt(self.opts["mf"], conum=self.opts["conum"],
                 conam=self.opts["conam"], name=self.__class__.__name__,
-                    tables=tabs,
-                heads=[self.head], cols=cols, where=whr, order=odr,
-                opts=opts, repprt=self.df.repprt, repeml=self.df.repeml,
-                fromad=self.fromad)
+                tables=tabs, heads=[self.head], cols=cols, where=whr,
+                order=odr, opts=opts, repprt=self.df.repprt,
+                repeml=self.df.repeml, fromad=self.fromad)
         self.closeProcess()
 
     def doHead(self):
@@ -167,7 +165,7 @@
         self.fpdf.drawText(cdes, font=["courier", "B", 24])
         self.fpdf.drawText(font=["courier", "B", 14])
         self.fpdf.drawText(self.head, font=["courier", "B", 16])
-        self.fpdf.drawText()
+        self.fpdf.underLine(txt=self.head)
 
     def doExit(self):
         self.df.closeProcess()

=== modified file 'wag/wg3020.py' (properties changed: -x to +x)
--- old/wag/wg3020.py	2020-03-01 12:48:20 +0000
+++ new/wag/wg3020.py	2020-05-27 12:38:48 +0000
@@ -116,8 +116,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__,
-                self.opts["conum"], ext="pdf")
+                self.__class__.__name__, self.opts["conum"], ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
                 pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,

=== modified file 'wag/wg3030.py' (properties changed: -x to +x)
--- old/wag/wg3030.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg3030.py	2020-05-27 12:38:54 +0000
@@ -84,8 +84,7 @@
         self.head = ("%03u %-30s %38s %10s" % (self.opts["conum"],
             self.opts["conam"], self.sysdttm, self.__class__.__name__))
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         cod = self.sql.getRec("wagedc", cols=["ced_code"],
             where=[("ced_cono", "=", self.opts["conum"]), ("ced_type",

=== modified file 'wag/wg3040.py' (properties changed: -x to +x)
=== modified file 'wag/wg3050.py' (properties changed: -x to +x)
--- old/wag/wg3050.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg3050.py	2020-08-07 09:32:11 +0000
@@ -611,8 +611,7 @@
                 ext="pdf")
         elif not self.pdfnam:
             self.pdfnam = getModName(pth, self.__class__.__name__,
-                self.opts["conum"],
-                ext="pdf")
+                self.opts["conum"], ext="pdf")
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=90)
 
     def printHeader(self):
@@ -727,38 +726,37 @@
         # Employee Details
         # Removing 3070, pasport number and 3075, country of issue
         try:
-            if self.dob.work % 1000000 != int(self.idno / 10000000):
+            if self.dob.work % 1000000 != int(int(self.idno) / 10000000):
                 raise Exception
-            else:
-                try:
-                    btype = int(self.btype)
-                except:
-                    btype = 0
-                try:
-                    bacno = int(self.bacno)
-                except:
-                    bacno = 0
-                self.emprec = '3010,"%s",3015,"%s",3020,"%1s",3025,%04i,'\
-                    '3030,"%s",3040,"%s",3050,"%s",3060,%013i,3080,%08i,'\
-                    '3100,%010i,3125,"%s",3136,"%s",3147,"%s",3148,"%s",'\
-                    '3149,"%s",3150,"%s",3160,"%s",3170,%08i,3180,%08i,'\
-                    '3200,%08.4f,3210,%08.4f,3214,"%s",3215,"%s",3216,"%s",'\
-                    '3217,"%s",3218,"X",3230,"%s",3240,%01i,3241,%s,3242,%s,'\
-                    '3245,"%s",3246,%01i' % (self.irp5, self.ttyp, self.nature,
-                    self.taxyr, self.sname, self.fname, self.inits, self.idno,
-                    self.dob.work, int(self.taxno.work), self.emadd,
-                    self.cotel[:11].strip(), self.coad1[:24].strip(),
-                    self.coad2.strip(), self.coad3[:21].strip(), self.cocod,
-                    self.emp, self.start.work, self.term.work, self.base,
-                    self.pers, self.addr1, self.addr2, self.addr3, self.pcode,
-                    self.direct, btype, bacno, self.branch, self.payee,
-                    self.relate)
-                self.totrecs += 1
-                for code in (3010,3015,3020,3025,3030,3040,3050,3060,3080,
-                        3100,3125,3136,3147,3148,3149,3150,3160,3170,3180,
-                        3200,3210,3214,3215,3216,3217,3218,3230,3240,3241,
-                        3242,3245,3246):
-                    self.totcode += code
+            try:
+                btype = int(self.btype)
+            except:
+                btype = 0
+            try:
+                bacno = int(self.bacno)
+            except:
+                bacno = 0
+            self.emprec = '3010,"%s",3015,"%s",3020,"%1s",3025,%04i,'\
+                '3030,"%s",3040,"%s",3050,"%s",3060,%013i,3080,%08i,'\
+                '3100,%010i,3125,"%s",3136,"%s",3147,"%s",3148,"%s",'\
+                '3149,"%s",3150,"%s",3160,"%s",3170,%08i,3180,%08i,'\
+                '3200,%08.4f,3210,%08.4f,3214,"%s",3215,"%s",3216,"%s",'\
+                '3217,"%s",3218,"X",3230,"%s",3240,%01i,3241,%s,3242,%s,'\
+                '3245,"%s",3246,%01i' % (self.irp5, self.ttyp, self.nature,
+                self.taxyr, self.sname, self.fname, self.inits, self.idno,
+                self.dob.work, int(self.taxno.work), self.emadd,
+                self.cotel[:11].strip(), self.coad1[:24].strip(),
+                self.coad2.strip(), self.coad3[:21].strip(), self.cocod,
+                self.emp, self.start.work, self.term.work, self.base,
+                self.pers, self.addr1, self.addr2, self.addr3, self.pcode,
+                self.direct, btype, bacno, self.branch, self.payee,
+                self.relate)
+            for code in (3010,3015,3020,3025,3030,3040,3050,3060,3080,
+                    3100,3125,3136,3147,3148,3149,3150,3160,3170,3180,
+                    3200,3210,3214,3215,3216,3217,3218,3230,3240,3241,
+                    3242,3245,3246):
+                self.totcode += code
+            self.totrecs += 1
         except:
             showError(None, "Header Record Error", "There is a Problem "\
                 "with Employee %s's Record. Please Fix the Problem and "\

=== modified file 'wag/wg3060.py' (properties changed: -x to +x)
=== modified file 'wag/wg3070.py' (properties changed: -x to +x)
--- old/wag/wg3070.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg3070.py	2020-08-07 20:59:24 +0000
@@ -153,7 +153,6 @@
                 self.export.write("%1s%4s%1s%30s%013u%47s\r\n" % \
                     (2, self.bestac, "T", "", value, ""))
                 self.export.close()
-        ######################
         self.opts["mf"].closeLoop()
 
     def doPrint(self):

=== modified file 'wag/wg4010.py' (properties changed: -x to +x)
--- old/wag/wg4010.py	2020-04-21 08:42:36 +0000
+++ new/wag/wg4010.py	2020-10-02 10:23:32 +0000
@@ -96,9 +96,9 @@
             (("T",1,0,0),"ONA",30,"Surname"),
             (("T",1,1,0),"ONA",30,"Names"),
             (("T",1,2,0),"OD1",10,"Date of Birth"),
-            (("T",1,3,0),"ONA",16,"ID Number"),
+            (("T",1,3,0),"ONA",13,"ID Number"),
             (("T",1,4,0),"ONA",16,"Spouse Name"),
-            (("T",1,5,0),"ONA",16,"Spouse ID Number"),
+            (("T",1,5,0),"ONA",13,"Spouse ID Number"),
             (("T",1,6,0),"ONA",30,"Address Line 1"),
             (("T",1,7,0),"ONA",30,"Address Line 2"),
             (("T",1,8,0),"ONA",30,"Address Line 3"),
@@ -168,9 +168,9 @@
         self.df.loadEntry("T", 0, 1, data=acc[2])    # Department
         self.df.loadEntry("T", 0, 2, data=acc[3])    # Class
         d = 4
-        for pag in xrange(1, 4):
-            for x in xrange(0, self.df.topq[pag]):
-                self.df.loadEntry("T", pag, x, data=acc[d])
+        for pg in xrange(1, 4):
+            for x in xrange(0, self.df.topq[pg]):
+                self.df.loadEntry("T", pg, x, data=acc[d])
                 d = d + 1
         self.loadDetail()
         self.opts["mf"].updateStatus("")
@@ -259,7 +259,7 @@
         odr = "wt1_date"
         state = self.df.disableButtonsTags()
         SRec(self.opts["mf"], screen=self.df.nb.Page7, title=tit, tables=tab,
-            cols=wcp, where=whr, order=odr, rows=12)
+            cols=wcp, where=whr, order=odr)
         self.df.enableButtonsTags(state=state)
         self.doTaxYear()
 
@@ -306,8 +306,7 @@
             self.pageHeading()
             self.printInfo()
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-            self.__class__.__name__,
-            self.opts["conum"], ext="pdf")
+            self.__class__.__name__, self.opts["conum"], ext="pdf")
         if opt == "I":
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],

=== modified file 'wag/wgc110.py' (properties changed: -x to +x)
--- old/wag/wgc110.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc110.py	2020-04-29 16:01:44 +0000
@@ -138,7 +138,7 @@
             (("T",0,seq + 12,0),"INA",20,"Payslip Template","",
                 self.acc[14],"N",self.doTplNam,tpm,None,("efld",)),
             (("T",0,seq + 13,0),"ITX",50,"Email Address","",
-                self.acc[15],"N",None,None,None,None)])
+                self.acc[15],"N",None,None,None,("email",))])
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))
@@ -219,14 +219,17 @@
         if self.new:
             self.sql.insRec("wagctl", data=data)
         elif data != self.acc[:len(data)]:
+            col = self.sql.wagctl_col
+            data.append(self.acc[col.index("ctw_xflag")])
             self.sql.updRec("wagctl", data=data, where=[("ctw_cono",
                 "=", self.opts["conum"])])
             dte = long("%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3])
             for num, dat in enumerate(self.acc):
                 if dat != data[num]:
                     self.sql.insRec("chglog", data=["wagctl", "U",
-                        "%03i" % self.opts["conum"], self.sql.wagctl_col[num],
-                        dte, self.opts["capnm"], str(dat), str(data[num]), 0])
+                        "%03i" % self.opts["conum"], col[num], dte,
+                        self.opts["capnm"], str(dat), str(data[num]),
+                        "", 0])
         self.opts["mf"].dbm.commitDbase()
         self.doExit()
 

=== modified file 'wag/wgc210.py' (properties changed: -x to +x)
=== modified file 'wag/wgc220.py' (properties changed: -x to +x)
--- old/wag/wgc220.py	2020-03-01 12:48:20 +0000
+++ new/wag/wgc220.py	2020-05-27 12:08:26 +0000
@@ -66,8 +66,8 @@
         opts = "Sort Order: %s" % self.sort
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=cols, order=order, opts=opts, repprt=self.df.repprt)
+            heads=heads, cols=cols, order=order, opts=opts,
+            repprt=self.df.repprt)
         self.df.enableButtonsTags(state=state)
         self.opts["mf"].closeLoop()
 

=== modified file 'wag/wgc310.py' (properties changed: -x to +x)
--- old/wag/wgc310.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc310.py	2020-06-21 12:28:17 +0000
@@ -39,8 +39,8 @@
             "wagedc", "wagtf2"], prog=self.__class__.__name__)
         if self.sql.error:
             return
-        gc = GetCtl(self.opts["mf"])
-        wagctl = gc.getCtl("wagctl", self.opts["conum"])
+        self.gc = GetCtl(self.opts["mf"])
+        wagctl = self.gc.getCtl("wagctl", self.opts["conum"])
         if not wagctl:
             return
         self.glint = wagctl["ctw_glint"]
@@ -111,8 +111,8 @@
                 "A","N",self.doEmployeePortion,None,None,None),
             (("T",1,3,0),"IUI",3,"         Base","",
                 "","N",self.doEmployeeBase,bas,None,("between",0,7)),
-            (("T",1,4,0),"IUD",8.2,"         Amount","",
-                "","N",self.doAmount,None,None,("efld",)),
+            (("T",1,4,0),"IUD",8.2,"         Value","",
+                "","N",self.doValue,None,None,("efld",)),
             (("T",1,5,0),"IUD",8.2,"         Limit","",
                 "","N",self.doElim,None,None,("efld",)),
             (("T",1,6,0),"IUI",3,"         GL/Cono","",
@@ -125,7 +125,7 @@
                 "N","N",self.doEmployerPortion,None,None,None),
             (("T",1,9,0),"IUI",3,"         Base","Base",
                 "","N",self.doEmployerBase,bas,None,("between",0,7)),
-            (("T",1,10,0),"IUD",8.2,"         Amount","",
+            (("T",1,10,0),"IUD",8.2,"         Value","",
                 "","N",None,None,None,("efld",)),
             (("T",1,11,0),"IUD",8.2,"         Limit","",
                 "","N",self.doRlim,None,None,("efld",)),
@@ -187,12 +187,12 @@
             self.new = False
             d = 3
             self.df.loadEntry(frt, pag, p+1, data=self.acc[d])
-            for pag in xrange(1, self.df.pgs+1):
-                for x in xrange(0, self.df.topq[pag]):
-                    if pag == 2 and x == 1:
+            for pg in xrange(1, self.df.pgs+1):
+                for x in xrange(0, self.df.topq[pg]):
+                    if pg == 2 and x == 1:
                         continue
-                    self.df.loadEntry("T", pag, x, data=self.acc[d])
-                    if pag == 2 and not x:
+                    self.df.loadEntry("T", pg, x, data=self.acc[d])
+                    if pg == 2 and not x:
                         ror = self.sql.getRec("wagrcv", limit=1,
                             cols=["rcv_desc"], where=[("rcv_code", "=",
                             self.acc[d])])
@@ -224,6 +224,16 @@
                     return "sk5"
             else:
                 return "sk3"
+        elif self.rtype == "D" and self.code in (1, 2):
+            if self.code == 1:
+                self.df.loadEntry("T", 1, 1, data="V")
+                self.df.loadEntry("T", 1, 2, data="R")
+                return "sk5"
+            elif self.code == 2:
+                self.df.loadEntry("T", 1, 1, data="V")
+                self.df.loadEntry("T", 1, 2, data="R")
+                self.df.loadEntry("T", 1, 3, data=6)
+                return "sk3"
 
     def doDelete(self):
         t = self.sql.getRec("wagtf2", cols=["count(*)"],
@@ -237,8 +247,7 @@
         self.df.focusField("T", 0, 1)
 
     def doEmployeePortion(self, frt, pag, r, c, p, i, w):
-        self.portion = w
-        if self.portion == "A":
+        if w == "A":
             self.df.loadEntry(frt, pag, p+1, data=0)
             return "sk1"
 
@@ -246,7 +255,8 @@
         if w > 7:
             return "Invalid Employee Base"
 
-    def doAmount(self, frt, pag, r, c, p, i, w):
+    def doValue(self, frt, pag, r, c, p, i, w):
+        self.value = w
         if self.rtype == "E" and self.code < 6:
             self.df.loadEntry("T", 1, p+1, data=0)
             if self.glint != "Y":
@@ -258,6 +268,7 @@
                 return "sk1"
 
     def doElim(self, frt, pag, r, c, p, i, w):
+        self.elim = w
         if self.glint != "Y":
             self.df.loadEntry("T", 1, p+1, data=0)
             self.df.loadEntry("T", 1, p+2, data=0)
@@ -286,13 +297,30 @@
             return "Invalid Company"
 
     def doEglno(self, frt, pag, r, c, p, i, w):
-        if w:
+        if self.rtype == "D":
+            ctl = self.gc.getCtl("ctlctl", self.eglco)
+            if ctl and not self.gc.chkRec(self.eglco, ctl, ["wag_slc"]):
+                sln = ctl["wag_slc"]
+            else:
+                sln = None
+        else:
+            sln = None
+        if w and w != sln:
             chk = chkGenAcc(self.opts["mf"], self.eglco, w)
             if type(chk) is str:
                 return chk
         self.eglno = w
         if self.rtype == "D":
-            return "sk1"
+            if self.code == 2:
+                self.df.loadEntry(frt, pag, 9, data="R")
+                self.df.loadEntry(frt, pag, 10, data=6)
+                self.df.loadEntry(frt, pag, 11, data=self.value)
+                self.df.loadEntry(frt, pag, 12, data=self.elim)
+                self.df.loadEntry(frt, pag, 13, data=self.eglco)
+                self.df.loadEntry(frt, pag, 14, data=self.eglno)
+                return "sk7"
+            else:
+                return "sk1"
         if self.code < 6:
             self.df.loadEntry("T", 1, p+1, data="S")
             self.df.loadEntry("T", 1, p+8, data="Y")
@@ -403,8 +431,10 @@
         if self.new:
             self.sql.insRec("wagedc", data=dat)
         elif dat != self.acc[:len(dat)]:
-            self.sql.updRec("wagedc", data=dat, where=[("ced_cono", "=",
-                self.opts["conum"]), ("ced_type", "=", self.rtype),
+            col = self.sql.wagedc_col
+            dat.append(self.acc[col.index("ced_xflag")])
+            self.sql.updRec("wagedc", data=dat, where=[("ced_cono",
+                "=", self.opts["conum"]), ("ced_type", "=", self.rtype),
                 ("ced_code", "=", self.code)])
         self.opts["mf"].dbm.commitDbase()
         self.df.last[0] = [0, 0]

=== modified file 'wag/wgc320.py' (properties changed: -x to +x)
--- old/wag/wgc320.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc320.py	2020-06-21 12:24:20 +0000
@@ -102,12 +102,12 @@
                 "Must Pay", "Balance Number", "Hourly Limit",
                 "Monthly Deduction", "UIF Portion", "SDL Portion"]
         tables = []
-        for x in xrange(0, len(recs)):
-            for y in xrange(1, len(recs[0])):
+        for rec in recs:
+            for y in xrange(1, len(recs[0]) - 1):
                 lin = []
                 lin.append("")
                 lin.append(descs[y])
-                lin.append(recs[x][y])
+                lin.append(rec[y])
                 tables.append(lin)
         if self.rtyp == "E":
             typ = "Earnings"
@@ -121,8 +121,7 @@
                 ["c","NA",30.0,"Details"]]
         state = self.df.disableButtonsTags()
         RepPrt(self.opts["mf"], name=self.__class__.__name__, tables=tables,
-            heads=heads,
-            cols=cols, conum=self.opts["conum"], ttype="D",
+            heads=heads, cols=cols, conum=self.opts["conum"], ttype="D",
             conam=self.opts["conam"], lines=(len(descs) - 1),
             repprt=self.df.repprt, repeml=self.df.repeml,
             fromad=self.fromad)

=== modified file 'wag/wgc410.py' (properties changed: -x to +x)
--- old/wag/wgc410.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc410.py	2020-04-23 10:32:45 +0000
@@ -97,6 +97,8 @@
             if self.new == "Y":
                 self.sql.insRec("ctlmes", data=data)
             elif data != self.acc[:len(data)]:
+                col = self.sql.ctlmes_col
+                data.append(self.acc[col.index("mss_xflag")])
                 self.sql.updRec("ctlmes", data=data, where=[("mss_system",
                     "=", self.system), ("mss_message", "=", self.message)])
             self.opts["mf"].dbm.commitDbase()

=== modified file 'wag/wgc420.py' (properties changed: -x to +x)
--- old/wag/wgc420.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc420.py	2020-05-27 12:17:03 +0000
@@ -54,8 +54,7 @@
         return True
 
     def mainProcess(self):
-        self.tit = ("Wages Messages Master Listing (%s)" %
-            self.__class__.__name__,)
+        self.tit = ("Wages Messages Listing (%s)" % self.__class__.__name__)
         fld = []
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
@@ -76,8 +75,8 @@
 
     def printReport(self, recs):
         p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
-        self.head = ("%-24s %37s %5s %6s" % \
-            ("Tartan Systems", self.sysdttm, "", self.__class__.__name__))
+        self.head = ("%-24s %37s %5s %6s" % ("Tartan Systems", self.sysdttm,
+            "", self.__class__.__name__))
         self.fpdf = MyFpdf(name=self.__class__.__name__, head=self.head)
         self.pgnum = 0
         self.pglin = 999
@@ -112,8 +111,7 @@
         p.closeProgress()
         if self.fpdf.page and not p.quit:
             pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
-                self.__class__.__name__, 0,
-                ext="pdf")
+                self.__class__.__name__, 0, ext="pdf")
             self.fpdf.output(pdfnam, "F")
             doPrinter(mf=self.opts["mf"], pdfnam=pdfnam, header=self.tit,
                 repprt=self.df.repprt, fromad=self.fromad,

=== modified file 'wag/wgc510.py' (properties changed: -x to +x)
--- old/wag/wgc510.py	2020-04-21 08:42:36 +0000
+++ new/wag/wgc510.py	2020-06-21 12:22:50 +0000
@@ -101,8 +101,8 @@
             self.new = False
             for n, d in enumerate(txa):
                 self.df.loadEntry("T", 0, n, data=d)
-            for n, r in enumerate(txr):
-                for x, d in enumerate(r[1:]):
+            for n, t in enumerate(txr):
+                for x, d in enumerate(t[1:]):
                     self.df.loadEntry("C", 0, (n*4)+x, data=d)
 
     def doIncome(self, frt, pag, r, c, p, i, w):

