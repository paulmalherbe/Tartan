=== modified file '.bzrignore'
--- .bzrignore	2017-08-24 07:49:34 +0000
+++ .bzrignore	2018-02-14 15:38:29 +0000
@@ -76,3 +76,8 @@
 fle
 tmp
 upg
+scp/file13_1.csv
+scp/file13_2.csv
+scp/file13_3.csv
+scp/file13_4.csv
+scp/file13_5.csv

=== modified file 'bkm/bkc510.py'
--- bkm/bkc510.py	2017-08-24 07:49:34 +0000
+++ bkm/bkc510.py	2018-01-30 10:39:31 +0000
@@ -45,7 +45,7 @@
             "cols": (
                 ("bkc_ccode", "", 0, "Code"),
                 ("bkc_title", "", 0, "Title"),
-                ("bkc_sname", "", 0, "Surame", "Y"),
+                ("bkc_sname", "", 0, "Surname", "Y"),
                 ("bkc_names", "", 0, "Names", "F"),
                 ("bkc_email", "", 0, "Email Address"))}
         self.fld = (

=== modified file 'bwl/bc2010.py'
--- bwl/bc2010.py	2017-08-24 07:49:34 +0000
+++ bwl/bc2010.py	2017-10-07 10:33:08 +0000
@@ -430,7 +430,7 @@
         self.nbase = w
 
     def doRate(self, frt, pag, r, c, p, i, w):
-        if p == 5:
+        if p == 6:
             self.ratem = CCD(w, "UD", 6.2)
         else:
             self.ratev = CCD(w, "UD", 6.2)
@@ -701,7 +701,7 @@
             rnk = int(w[1])
         except:
             rnk = 0
-        if rnk < 1 or rnk > 6:
+        if rnk < 1 or rnk > 7:
             return "Invalid Rink"
         if w in self.bounce:
             yn = askQuestion(self.opts["mf"].body, "Rink Used",
@@ -1038,7 +1038,7 @@
                 "","N",self.doGreens,None,None,("notblank",),None,
                 "Available Greens in the format A,B or A,B345 showing "\
                 "Green Code and Rinks. If the Rinks are Not Entered they "\
-                "will Default to 6."))
+                "will Default to 6. To enter 7 rinks enter A7, B7 etc."))
         but = (("Cancel",None,self.doCancel,1,None,None,None,1),)
         state = self.df.disableButtonsTags()
         self.df.setWidget(self.df.mstFrame, state="hide")
@@ -1103,7 +1103,7 @@
                         qty += 1
                         num -= 1
         if self.teams:
-            needed = len(self.teams)
+            needed = len(self.teams) / 2
         else:
             needed = int(num / (self.tsize * 2))
             rem = num % (self.tsize * 2)
@@ -2030,6 +2030,8 @@
         for d in draw:
             dat = [d[0], d[1]]
             for t in d[2:]:
+                t[1] = t[1].replace("VAN DER", "V D")
+                t[1] = t[1].replace("JANSE VAN", "J V")
                 if not t[0]:
                     dat.append("%3s %-20s" % ("", ""))
                 else:

=== modified file 'bwl/bc2040.py'
--- bwl/bc2040.py	2017-08-24 07:49:34 +0000
+++ bwl/bc2040.py	2018-01-30 10:36:47 +0000
@@ -66,7 +66,7 @@
             "tables": ("bwlent", "bwltab"),
             "cols": (
                 ("btb_tab", "", 0, "Cod"),
-                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_surname", "", 0, "Surname", "Y"),
                 ("btb_names", "", 0, "Names"),
                 ("bce_tcod", "", 0, "T"),
                 ("bce_paid", "", 0, "P")),

=== modified file 'bwl/bc2050.py'
--- bwl/bc2050.py	2017-08-24 07:49:34 +0000
+++ bwl/bc2050.py	2018-01-31 19:12:16 +0000
@@ -1869,7 +1869,7 @@
                 else:
                     nam = "Unknown"
                 c = CCD(nam, "NA", 30)
-                self.printLine(a.disp, " %s " % b.disp, c.disp)
+                self.printLine(a.disp, " %s " % b.disp, c.disp, 4.7)
                 self.pglin += 1
         pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
             "report", ext="pdf")
@@ -1932,16 +1932,16 @@
         self.fpdf.setFont()
         self.pglin += 4
 
-    def printLine(self, a, b, c, fill=0):
+    def printLine(self, a, b, c, h=0, fill=0):
         x = 10
         w = self.fpdf.get_string_width("X" * len(a)) + 1
-        self.fpdf.drawText(a, x=x, w=w, border="TLB", fill=fill, ln=0)
+        self.fpdf.drawText(a, x=x, h=h, w=w, border="TLB", fill=fill, ln=0)
         x += w + 1
         w = self.fpdf.get_string_width("X" * len(b)) + 1
-        self.fpdf.drawText(b, x=x, w=w, border="TLB", fill=fill, ln=0)
+        self.fpdf.drawText(b, x=x, h=h, w=w, border="TLB", fill=fill, ln=0)
         x += w + 1
         w = self.fpdf.get_string_width("X" * len(c)) + 1
-        self.fpdf.drawText(c, x=x, w=w, border="TLRB", fill=fill)
+        self.fpdf.drawText(c, x=x, h=h, w=w, border="TLRB", fill=fill)
 
     def printCards(self):
         recs = []

=== modified file 'bwl/bc2060.py'
--- bwl/bc2060.py	2017-08-24 07:49:34 +0000
+++ bwl/bc2060.py	2018-01-30 10:36:55 +0000
@@ -47,7 +47,7 @@
             "tables": ("bwltab", "bwlgme"),
             "cols": (
                 ("btb_tab", "", 0, "Cod"),
-                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_surname", "", 0, "Surname", "Y"),
                 ("btb_names", "", 0, "Names"),
                 ("bcg_rink", "", 0, "RK"),
                 ("bcg_ocod", "", 0, "Opp")),

=== modified file 'bwl/bc2070.py'
--- bwl/bc2070.py	2017-08-24 07:49:34 +0000
+++ bwl/bc2070.py	2018-01-30 10:36:17 +0000
@@ -54,7 +54,7 @@
             "tables": ("bwlent", "bwltab", "bwlgme"),
             "cols": (
                 ("btb_tab", "", 0, "Cod"),
-                ("btb_surname", "", 0, "Surame", "Y"),
+                ("btb_surname", "", 0, "Surname", "Y"),
                 ("btb_names", "", 0, "Names"),
                 ("bcg_rink", "", 0, "RK")),
             "where": [

=== modified file 'bwl/bc6010.py'
--- bwl/bc6010.py	2017-08-24 07:49:34 +0000
+++ bwl/bc6010.py	2018-01-12 14:05:22 +0000
@@ -86,8 +86,11 @@
             return "Invalid Tab Number, Does Not exist"
         self.oldtab = w
         self.gender = acc[self.sql.bwltab_col.index("btb_gender")]
-        self.df.loadEntry(frt, pag, p+1, data="%s, %s" % (acc[3],
-            acc[4].split()[0]))
+        if acc[4]:
+            self.df.loadEntry(frt, pag, p+1, data="%s, %s" % (acc[3],
+                acc[4].split()[0]))
+        else:
+            self.df.loadEntry(frt, pag, p+1, data=acc[3])
 
     def doNewTab(self, frt, pag, r, c, p, i, w):
         if self.oldtab < self.nstart:

=== modified file 'crs/cr3380_rne.py'
--- crs/cr3380_rne.py	2017-08-24 07:49:34 +0000
+++ crs/cr3380_rne.py	2017-09-21 07:28:52 +0000
@@ -46,6 +46,7 @@
             "stype": "C",
             "titl": "Valid Types",
             "data": []}
+        r1s = (("Financial", "F"), ("Capture", "C"))
         fld = (
             (("T",0,0,0),"IUI",3,"Group Code","",
                 "","Y",self.doGrpCod,grp,None,("efld",)),
@@ -53,9 +54,15 @@
             (("T",0,1,0),"IUI",3,"Branch Code","",
                 "","N",self.doBranch,bch,None,("efld",)),
             (("T",0,1,0),"ONA",30,""),
-            (("T",0,2,0),"ID2",7,"From Period","",
-                0,"N",self.doFrom,None,None,("efld",)),
-            (("T",0,3,0),"ID2",7,"To   Period","",
+            (("T",0,2,0),("IRB",r1s),0,"Period Type","",
+                "F","N",self.doPType,None,None,None),
+            (("T",0,3,0),"ID2",7,"From Period","",
+                0,"N",self.doFrom,None,None,("efld",)),
+            (("T",0,4,0),"ID2",7,"To   Period","",
+                0,"N",self.doTo,None,None,("efld",)),
+            (("T",0,5,0),"ID1",10,"From Date","",
+                0,"N",self.doFrom,None,None,("efld",)),
+            (("T",0,6,0),"ID1",10,"To   Date","",
                 0,"N",self.doTo,None,None,("efld",)))
         tnd = ((self.doEnd,"y"), )
         txt = (self.doExit, )
@@ -95,6 +102,11 @@
         self.grpdes = chk[0]
         self.df.loadEntry(frt, pag, p+1, data=self.grpdes)
 
+    def doPType(self, frt, pag, r, c, p, i, w):
+        self.ptype = w
+        if self.ptype == "C":
+            return "sk2"
+
     def doFrom(self, frt, pag, r, c, p, i, w):
         self.start = w
         self.startd = self.df.t_disp[pag][r][p]
@@ -105,20 +117,27 @@
             return "Invalid Date, Earlier than From Date"
         self.end = w
         self.endd = self.df.t_disp[pag][r][p]
+        if self.ptype == "F":
+            return "sk2"
 
     def doEnd(self):
         self.df.closeProcess()
-        hds = [
-            "Creditors' Ledger Transactions for %s" % self.grpdes,
-            "From Period %s to Period %s" % (self.startd, self.endd)]
+        hds = ["Creditors' Ledger Transactions for %s" % self.grpdes]
+        if self.ptype == "F":
+            hds.append("From Period %s to Period %s" % (self.startd, self.endd))
+        else:
+            hds.append("From Date %s to Date %s" % (self.startd, self.endd))
         tab = ["crsmst", "crstrn", "crsrtf"]
         col = ["crt_acno", "crm_name", "crt_ref1", "crt_type", "crt_trdt",
             "crt_tramt", "rtf_depno", "rtf_pjno", "crt_taxamt"]
         whr = [
             ("crt_cono", "=", 1),
-            ("crt_type", "in", (1, 2, 3, 4, 6)),
-            ("crt_curdt", "between", self.start, self.end),
-            ("rtf_depno", "in", self.grpcoy)]
+            ("crt_type", "in", (1, 2, 3, 4, 6))]
+        if self.ptype == "F":
+            whr.append(("crt_curdt", "between", self.start, self.end))
+        else:
+            whr.append(("crt_capdt", "between", self.start, self.end))
+        whr.append(("rtf_depno", "in", self.grpcoy))
         grp = "crt_acno, crm_name, crt_ref1, crt_type, crt_trdt, "\
                 "crt_tramt, rtf_acno, rtf_depno, rtf_pjno, crt_taxamt"
         odr = "rtf_depno, rtf_acno, crt_trdt"

=== modified file 'csv/ctlgrp_fld.csv'
--- csv/ctlgrp_fld.csv	2016-09-03 14:07:52 +0000
+++ csv/ctlgrp_fld.csv	2018-02-12 09:01:10 +0000
@@ -24,3 +24,5 @@
 23,"ctg_hed11","NA","12.0","Heading 11","H11"
 24,"ctg_num12","UI","3.0","Number 12","N12"
 25,"ctg_hed12","NA","12.0","Heading 12","H12"
+26,"ctg_num13","UI","3.0","Number 13","N13"
+27,"ctg_hed13","NA","12.0","Heading 13","H13"

=== modified file 'doc/BKS.rst'
--- doc/BKS.rst	2017-09-10 14:30:43 +0000
+++ doc/BKS.rst	2018-02-17 07:36:26 +0000
@@ -2,7 +2,7 @@
  TARTAN SYSTEMS - Book Clubs
 =============================
 
-:Version:   5.3.2
+:Version:   5.3.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/BWL.rst'
--- doc/BWL.rst	2017-09-10 14:30:43 +0000
+++ doc/BWL.rst	2017-12-18 04:26:03 +0000
@@ -311,7 +311,7 @@
 + **Code** - The relevant competition number or zero for the next available number.
 + **Name** - The name of the competition.
 + **Date** - The starting date of the competition.
-+ **Type** - The competition type as created in `Competition Types (BC)`_.
++ **Type** - The competition type as created in `Competition Types (BC)`_. To create a new type enter 0 and hit Enter.
 
 In the event of drawn games enter all player's codes else enter only the skip's codes.
 

=== modified file 'doc/BWM.rst'
--- doc/BWM.rst	2017-09-10 14:30:43 +0000
+++ doc/BWM.rst	2018-02-17 07:36:26 +0000
@@ -2,7 +2,7 @@
  TARTAN SYSTEMS - Bowling Clubs
 ================================
 
-:Version:   5.3.2
+:Version:   5.3.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/Downloads.rst'
--- doc/Downloads.rst	2017-09-10 14:30:43 +0000
+++ doc/Downloads.rst	2018-02-17 07:36:26 +0000
@@ -11,23 +11,23 @@
 
 |tartan| Version
 ================
-The latest version of Tartan is 5.3.2 and was released on the 10th September, 2017.
+The latest version of Tartan is 5.3.3 and was released on the 17th February, 2018.
 
 Backup and restore functions must only be done with the  same version of Tartan i.e. the version used to restore a backup must be the same as the one used to make the backup.
 
 .. _Documentation: http://www.tartan.co.za/cgi-bin/simple_web.py/Documentation
-.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.3.2.tgz
+.. _Tartan-5-lnx: ftp://tartan.co.za/Tartan_5.3.3.tgz
 .. _Tartan-4-lnx: ftp://tartan.co.za/Tartan_4.1.14.tgz
 .. _Tartan-3-lnx: ftp://tartan.co.za/Tartan_3.4.51.tgz
 .. _Tartan-2-lnx: ftp://tartan.co.za/Tartan_2.5.29.tgz
-.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.3.2.exe
+.. _Tartan-5-win: ftp://tartan.co.za/Tartan_5.3.3.exe
 .. _Tartan-4-win: ftp://tartan.co.za/Tartan_4.1.14.exe
 .. _Tartan-3-win: ftp://tartan.co.za/Tartan_3.4.51.exe
 .. _Tartan-2-win: ftp://tartan.co.za/Tartan_2.5.29.exe
-.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.3.2.tgz
-.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.3.2.exe
-.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.3.2.tgz
-.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.3.2.exe
+.. _Bwlclb-5-lnx: ftp://tartan.co.za/Bwlclb_5.3.3.tgz
+.. _Bwlclb-5-win: ftp://tartan.co.za/Bwlclb_5.3.3.exe
+.. _Seccmp-5-lnx: ftp://tartan.co.za/Seccmp_5.3.3.tgz
+.. _Seccmp-5-win: ftp://tartan.co.za/Seccmp_5.3.3.exe
 
 |linux| Linux
 =============

=== modified file 'doc/GEN_rne.rst'
--- doc/GEN_rne.rst	2016-12-30 14:10:51 +0000
+++ doc/GEN_rne.rst	2018-02-16 06:55:28 +0000
@@ -605,6 +605,15 @@
     + **Ending Period** - The last period to include in the report.
 + **Exit** - Use this button to exit.
 
+Consolidated Financials (GL)
+++++++++++++++++++++++++++++
+Use this routine to produce consolidated financial reports.
+
++ **Financial Period** - The relevant financial period.
++ **Ending Period** - The last period, in the financial year, to take into account.
++ **Report Number** - The relevant report number as created using `Report Generator (GL)`_.
++ **All Branches** - Select whether report are to be generated for all branches or only selected ones.
+
 Toolbox (GL)
 ............
 Change Account Numbers (GL)

=== modified file 'doc/MST.rst'
--- doc/MST.rst	2017-09-10 14:30:43 +0000
+++ doc/MST.rst	2018-02-17 07:36:26 +0000
@@ -2,7 +2,7 @@
  Tartan Systems - User Manual
 ==============================
 
-:Version:   5.3.2
+:Version:   5.3.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/SEC.rst'
--- doc/SEC.rst	2017-09-10 14:30:43 +0000
+++ doc/SEC.rst	2018-02-17 07:36:26 +0000
@@ -2,7 +2,7 @@
  TARTAN SYSTEMS - Sectional Competitions
 ========================================
 
-:Version:   5.3.2
+:Version:   5.3.3
 :Author:    Paul Malherbe
 :Contact:   paul@tartan.co.za
 :Home:      http://www.tartan.co.za

=== modified file 'doc/STR.rst'
--- doc/STR.rst	2017-08-24 07:49:34 +0000
+++ doc/STR.rst	2018-02-16 06:59:09 +0000
@@ -350,6 +350,10 @@
 +++++++++++++++++++++++++++
 Use this routine to delete outstanding purchases orders.
 
+Stock Redundancy (ST)
++++++++++++++++++++++
+Use this routine to flag store's items as redundant, depending on the period of inactivity, or to restore redundant items back to normal.
+
 Interrogation (ST)
 ..................
 This routine is for querying individual Store's Ledger Accounts.

=== added file 'doc/gmailsmtp.txt'
--- doc/gmailsmtp.txt	1970-01-01 00:00:00 +0000
+++ doc/gmailsmtp.txt	2017-07-05 09:04:37 +0000
@@ -0,0 +1,14 @@
+To set the mail server to use smtp.gmail.comm as the smtp server do:
+
+1) Create a gmail account
+2) Edit gmail account:
+    a) Go to Settings
+    b) Go to Accounts and Import
+    c) Add another email address
+    d) Enter your name and email address
+    e) Untick "Treat as Alias"
+    f) Enter "smtp.gmail.com" as SMTP Server
+    g) Enter gmail username and password
+    h) Click on Add Account
+3) Set the new account as default
+4) Select which address replys must come from

=== modified file 'drs/dr1010.py'
--- drs/dr1010.py	2017-08-24 07:49:34 +0000
+++ drs/dr1010.py	2017-10-12 14:30:34 +0000
@@ -497,10 +497,10 @@
                 break
             if not line[15]:
                 line[15] = self.sysdtw
-            if not line[29]:
-                line[29] = "N"
-            if not line[32]:
-                line[32] = "N"
+            if not line[28]:
+                line[28] = "N"
+            if not line[31]:
+                line[31] = "N"
             line.insert(0, self.opts["conum"])
             self.sql.insRec("drsmst", data=line)
         sp.closeProgress()

=== modified file 'gen/gl2030.py'
--- gen/gl2030.py	2017-09-10 14:30:43 +0000
+++ gen/gl2030.py	2017-10-23 20:18:32 +0000
@@ -1045,7 +1045,6 @@
                             self.bh.batno, date, "", amt, 0, 0, self.curdt,
                             0, "", 0, self.trndet, "", "", self.opts["capnm"],
                             self.sysdtw, 0]
-                        print data
                         self.sql.insRec("crstrn", data=data, unique="crt_ref1")
                     elif adrs:
                         AgeAll(self.opts["mf"], system="drs", agetyp=aage,

=== modified file 'gen/gl2040.py'
--- gen/gl2040.py	2017-09-10 14:30:43 +0000
+++ gen/gl2040.py	2017-09-11 09:57:07 +0000
@@ -1565,6 +1565,11 @@
     def doRtlDet(self, frt, pag, r, c, p, i, w):
         self.alldet = w
 
+    def doNewRtl(self, widget=None):
+        callModule(self.opts["mf"], self.df, "rt1010", coy=(self.allcoy,
+            self.allnam), period=None, user=self.opts["capnm"],
+            args=(self.rtlprm, self.othacno))
+
     def endRtl(self):
         self.othtot = float(ASD(self.othtot) + ASD(self.othamt))
         # Rental Ledger Transaction

=== added file 'gen/gl3030_rne.py'
--- gen/gl3030_rne.py	1970-01-01 00:00:00 +0000
+++ gen/gl3030_rne.py	2018-02-17 07:22:11 +0000
@@ -0,0 +1,374 @@
+"""
+SYNOPSIS
+    General Ledger Account Statements.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2017 Paul Malherbe.
+"""
+import time
+from TartanClasses import ASD, CCD, MyFpdf, ProgressBar, Sql, TartanDialog
+from tartanFunctions import doPrinter, doWriteExport, getModName
+from tartanFunctions import getSingleRecords, showError
+from tartanWork import gltrtp
+
+class gl3030:
+    def __init__(self, **opts):
+        self.opts = opts
+        if "auto" not in opts:
+            self.auto = None
+        if self.setVariables():
+            if self.auto:
+                self.whole = "Y"
+                self.sacno = 0
+                self.eacno = 0
+                self.sdate = CCD(self.s_per, "D2", 7)
+                self.edate = CCD(self.e_per, "D2", 7)
+                self.pages = "N"
+                self.doEnd()
+            else:
+                self.mainProcess()
+                self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, ["genbal", "genmst", "gentrn"],
+            prog=__name__)
+        if self.sql.error:
+            return
+        t = time.localtime()
+        self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i) %6s" % (t[0],
+            t[1], t[2], t[3], t[4], __name__)
+        self.head = ("%03u %-30s %s" % (self.opts["conum"], self.opts["conam"],
+            "%s"))
+        self.colsh = ["Coy", "Acc-Num", "Description", "Date", "Reference",
+            "Typ", "Batch", "Remarks", "Debit", "Credit", "Balance"]
+        self.forms = [("UI", 3), ("UI", 7), ("NA", 30), ("D1", 10),
+            ("Na", 9), ("NA", 3), ("Na", 7), ("NA", 30), ("SD", 13.2),
+            ("SD", 13.2), ("SD", 13.2)]
+        self.s_per = int(self.opts["period"][1][0] / 100)
+        self.e_per = int(self.opts["period"][2][0] / 100)
+        return True
+
+    def mainProcess(self):
+        self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "General Ledger Account Statements (%s)" % __name__)
+        glm = {
+            "stype": "R",
+            "tables": ("genmst",),
+            "cols": (
+                ("glm_acno", "", 0, "Acc-Num"),
+                ("glm_desc", "", 0, "Description", "Y")),
+            "where": [("glm_cono", "=", self.opts["conum"])],
+            "order": "glm_acno"}
+        r1s = (("Yes","Y"),("Range","R"),("Singles", "S"), ("Type", "T"))
+        r2s = (("Profit & Loss","P"), ("Balance Sheet","B"))
+        r3s = (("Yes","Y"), ("No","N"))
+        fld = (
+            (("T",0,0,0),("IRB",r1s),0,"Whole File","",
+                "S","Y",self.doWhole,None,None,None),
+            (("T",0,1,0),("IRB",r2s),0,"Whole File","",
+                "P","Y",self.doType,None,None,None),
+            (("T",0,2,0),"IUI",7,"From Account","",
+                "","Y",self.doStartAcc,glm,None,("efld",)),
+            (("T",0,3,0),"IUI",7,"To Account","",
+                0,"Y",self.doEndAcc,glm,None,("efld",)),
+            (("T",0,4,0),"Id2",7,"Starting Period","",
+                self.s_per,"Y",self.doStartPer,None,None,("efld",)),
+            (("T",0,5,0),"Id2",7,"Ending Period","",
+                self.e_per,"Y",self.doEndPer,None,None,("efld",)),
+            (("T",0,6,0),("IRB",r3s),7,"Separate Pages","",
+                "N","Y",self.doPages,None,None,None))
+        tnd = ((self.doEnd,"y"), )
+        txt = (self.doExit, )
+        self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
+            tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
+
+    def doWhole(self, frt, pag, r, c, p, i, w):
+        self.whole = w
+        if self.whole in ("Y", "S"):
+            self.sacno = 0
+            self.eacno = 0
+            self.df.loadEntry("T", 0, 1, data=self.sacno)
+            self.df.loadEntry("T", 0, 2, data=self.eacno)
+            return "sk2"
+
+    def doType(self, frt, pag, r, c, p, i, w):
+        self.type = w
+        return "sk2"
+
+    def doStartAcc(self, frt, pag, r, c, p, i, w):
+        if w == 0:
+            ok = "yes"
+        else:
+            ok = self.readAcno(w)
+        if ok != "yes":
+            return "Invalid Account Number"
+        self.sacno = w
+
+    def doEndAcc(self, frt, pag, r, c, p, i, w):
+        if w == 0:
+            self.eacno = 9999999
+            ok = "yes"
+        else:
+            self.eacno = w
+            ok = self.readAcno(w)
+        if ok != "yes":
+            return "Invalid Account Number"
+
+    def readAcno(self, acno):
+        nam = self.sql.getRec(tables="genmst", cols=["glm_desc"],
+            where=[("glm_cono", "=", self.opts["conum"]),
+            ("glm_acno", "=", acno)], limit=1)
+        if not nam:
+            return "no"
+        else:
+            return "yes"
+
+    def doStartPer(self, frt, pag, r, c, p, i, w):
+        if w < self.s_per or w > self.e_per:
+            return "Invalid Period, Outside Financial Period"
+        self.sdate = CCD(w, "D2", 7)
+
+    def doEndPer(self, frt, pag, r, c, p, i, w):
+        if w < self.sdate.work:
+            return "Invalid Period, Before Start Period"
+        if w > self.e_per:
+            return "Invalid Period, Outside Financial Period"
+        self.edate = CCD(w, "D2", 7)
+
+    def doPages(self, frt, pag, r, c, p, i, w):
+        self.pages = w
+
+    def doEnd(self):
+        if not self.auto:
+            self.df.closeProcess()
+        if self.whole == "S":
+            recs = getSingleRecords(self.opts["mf"], "genmst",
+                ("glm_acno", "glm_desc"), where=[("glm_cono", "=",
+                self.opts["conum"])])
+        elif self.whole == "R":
+            recs = self.sql.getRec(tables="genmst", where=[("glm_cono", "=",
+                self.opts["conum"]), ("glm_acno", "between", self.sacno,
+                self.eacno)], order="glm_acno")
+        elif self.whole == "T":
+            recs = self.sql.getRec(tables="genmst", where=[("glm_cono", "=",
+                self.opts["conum"]), ("glm_type", "=", self.type)],
+                order="glm_acno")
+        else:
+            recs = self.sql.getRec(tables="genmst", where=[("glm_cono", "=",
+                self.opts["conum"])], order="glm_acno")
+        if not recs:
+            showError(self.opts["mf"].body, "Error", "No Accounts Selected")
+        elif not self.auto and self.df.repprt[2] == "export":
+            self.exportReport(recs)
+        else:
+            self.printReport(recs)
+        self.doExit()
+
+    def exportReport(self, recs):
+        p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        expnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+            self.opts["conum"])
+        self.expheads = [self.head % self.sysdttm]
+        self.expheads.append("General Ledger Account Statements for Period "\
+            "%s to %s" % (self.sdate.disp, self.edate.disp))
+        self.expcolsh = [self.colsh]
+        self.expforms = self.forms
+        self.expdatas = []
+        for num, dat in enumerate(recs):
+            p.displayProgress(num)
+            if p.quit:
+                p.closeProgress()
+                return
+            self.acno, self.desc, acctot = self.getAccValues(dat)
+            trn = self.sql.getRec(tables="gentrn", where=[("glt_cono", "=",
+                dat[0]), ("glt_acno", "=", dat[1]), ("glt_curdt", ">=",
+                self.sdate.work), ("glt_curdt", "<=", self.edate.work)],
+                order="glt_acno, glt_curdt, glt_trdt, glt_type, glt_refno, "\
+                "glt_batch")
+            prt = False
+            if acctot:
+                prt = True
+                self.expdatas.append(["BODY", [self.opts["conum"],
+                    self.acno.work, self.desc.work,
+                    ((self.sdate.work * 100) + 1), "", "",
+                    "", "Opening Balance", "", "", acctot]])
+            for acc in trn:
+                prt = True
+                trdt, refno, trtp, batch, amt, dbt, crt, detail, curdt, \
+                    curmth = self.getTrnValues(acc)
+                acctot = float(ASD(acctot) + ASD(amt.work))
+                self.expdatas.append(["BODY", [self.opts["conum"],
+                    self.acno.work, self.desc.work, trdt.work, refno.work,
+                    gltrtp[(trtp.work - 1)][0], batch.work, detail.work,
+                    dbt.work, crt.work, acctot]])
+            if prt:
+                self.expdatas.append(["BLANK"])
+        p.closeProgress()
+        doWriteExport(xtype=self.df.repprt[1], name=expnam,
+            heads=self.expheads, colsh=self.expcolsh, forms=self.expforms,
+            datas=self.expdatas, rcdic=self.opts["mf"].rcdic)
+
+    def printReport(self, recs):
+        self.pgnum = 0
+        self.pglin = 999
+        if not self.auto:
+            p = ProgressBar(self.opts["mf"].body, mxs=len(recs), esc=True)
+        self.head = ("%03u %-30s %59s %10s" % (self.opts["conum"],
+            self.opts["conam"], self.sysdttm, __name__))
+        self.fpdf = MyFpdf(name=__name__, head=self.head)
+        for seq, dat in enumerate(recs):
+            if not self.auto:
+                p.displayProgress(seq)
+                if p.quit:
+                    break
+            self.acno, self.desc, acctot = self.getAccValues(dat)
+            trn = self.sql.getRec(tables="gentrn", where=[("glt_cono", "=",
+                dat[0]), ("glt_acno", "=", dat[1]), ("glt_curdt", ">=",
+                self.sdate.work), ("glt_curdt", "<=", self.edate.work)],
+                order="glt_acno, glt_curdt, glt_trdt, glt_type, glt_refno, "\
+                "glt_batch")
+            if acctot or trn:
+                if not self.pgnum or self.pages == "Y":
+                    self.pageHeading()
+                else:
+                    self.newAccount()
+            if acctot:
+                w1 = CCD(acctot, "SD", 13.2)
+                self.fpdf.drawText("%-10s %-9s %-3s %-7s %-30s %-13s %-13s "\
+                    "%-13s" % (self.sdate.disp + "-01", "", "", "",
+                    "Opening Balance", "", "", w1.disp))
+                self.pglin += 1
+            for acc in trn:
+                trdt, refno, trtp, batch, amt, dbt, crt, detail, curdt, \
+                    curmth = self.getTrnValues(acc)
+                if self.pglin > self.fpdf.lpp:
+                    self.pageHeading()
+                    bf = CCD(acctot, "SD", 13.2)
+                    if bf.work:
+                        self.fpdf.drawText("%32s %-30s %27s %13s" % ("",
+                            "Brought Forward", "", bf.disp))
+                        self.pglin += 1
+                acctot = float(ASD(acctot) + ASD(amt.work))
+                w1 = CCD(acctot, "SD", 13.2)
+                self.fpdf.drawText("%-10s %-9s %-3s %-7s %-30s %13s %13s %13s"\
+                    % (trdt.disp, refno.disp, gltrtp[(trtp.work - 1)][0],
+                    batch.disp, detail.disp, dbt.disp, crt.disp, w1.disp))
+                self.pglin += 1
+            if self.pages == "Y" and (acctot or trn):
+                self.pglin = 999
+        if not self.auto:
+            p.closeProgress()
+            if p.quit:
+                return
+        if self.fpdf.page:
+            pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"], __name__,
+                self.opts["conum"], ext="pdf")
+            self.fpdf.output(pdfnam, "F")
+            if not self.auto:
+                doPrinter(mf=self.opts["mf"], conum=self.opts["conum"],
+                    pdfnam=pdfnam, header=self.tit, repprt=self.df.repprt,
+                    repeml=self.df.repeml)
+
+    def getAccValues(self, data):
+        dic = self.sql.genmst_dic
+        acno = CCD(data[dic["glm_acno"][1]], "UI", 7)
+        desc = CCD(str(data[dic["glm_desc"][1]]), "NA", 30)
+        o = self.sql.getRec(tables="genbal", cols=["glo_cyr"],
+            where=[("glo_cono", "=", self.opts["conum"]), ("glo_acno", "=",
+            acno.work), ("glo_trdt", "=", self.opts["period"][1][0])], limit=1)
+        if o:
+            b = CCD(o[0], "SD", 13.2)
+        else:
+            b = CCD(0, "SD", 13.2)
+        ob = b.work
+        o = self.sql.getRec(tables="gentrn", cols=["round(sum(glt_tramt), 2)"],
+            where=[("glt_cono", "=", self.opts["conum"]), ("glt_acno", "=",
+            acno.work), ("glt_curdt", ">=", self.s_per), ("glt_curdt",
+            "<", self.sdate.work)], limit=1)
+        if o and o[0]:
+            b = CCD(o[0], "SD", 13.2)
+        else:
+            b = CCD(0, "SD", 13.2)
+        acctot = float(ASD(ob) + ASD(b.work))
+        return (acno, desc, acctot)
+
+    def getTrnValues(self, data):
+        tic = self.sql.gentrn_dic
+        trdt = CCD(data[tic["glt_trdt"][1]], "D1", 10)
+        refno = CCD(data[tic["glt_refno"][1]], "Na", 9)
+        trtp = CCD(data[tic["glt_type"][1]], "UI", 1)
+        batch = CCD(data[tic["glt_batch"][1]], "Na", 7)
+        amt = CCD(data[tic["glt_tramt"][1]], "SD", 13.2)
+        if amt.work < 0:
+            dbt = CCD(0, "SD", 13.2)
+            crt = CCD(amt.work, "SD", 13.2)
+        else:
+            dbt = CCD(amt.work, "SD", 13.2)
+            crt = CCD(0, "SD", 13.2)
+        detail = CCD(data[tic["glt_desc"][1]], "NA", 30)
+        curdt = CCD(data[tic["glt_curdt"][1]], "UI", 6)
+        curmth = int(curdt.disp[4:6])
+        return (trdt, refno, trtp, batch, amt, dbt, crt, detail, curdt, curmth)
+
+    def pageHeading(self):
+        self.fpdf.add_page()
+        self.fpdf.setFont(style="B")
+        self.pgnum += 1
+        self.fpdf.drawText(self.head)
+        self.fpdf.drawText()
+        if self.whole == "T":
+            if self.type == "P":
+                txt = "%-54s %-10s %7s %2s %7s %14s %5s" % \
+                ("General Ledger Statements for Profit and Loss Accounts",
+                "for Period", self.sdate.disp, "to", self.edate.disp, "Page",
+                self.pgnum)
+            else:
+                txt = "%-52s %-10s %7s %2s %7s %16s %5s" % \
+                ("General Ledger Statements for Balance Sheet Accounts",
+                "for Period", self.sdate.disp, "to", self.edate.disp, "Page",
+                self.pgnum)
+        else:
+            if self.sacno == 0:
+                sacc = "  First"
+            else:
+                sacc = self.df.t_disp[0][0][1]
+            if self.eacno == 0:
+                eacc = "Last"
+            else:
+                eacc = self.df.t_disp[0][0][2]
+            txt = "%-38s %-7s %2s %-7s %-10s %7s %2s %7s %11s %5s" % \
+                ("General Ledger Statements for Accounts", sacc, "to", eacc,
+                "for Period", self.sdate.disp, "to", self.edate.disp, "Page",
+                self.pgnum)
+        self.fpdf.drawText(txt)
+        self.fpdf.setFont()
+        self.pglin = 3
+        self.newAccount()
+
+    def newAccount(self):
+        if self.fpdf.lpp - self.pglin < 5:
+            self.pageHeading()
+        else:
+            self.fpdf.setFont(style="B")
+            self.fpdf.drawText()
+            self.fpdf.drawText("%-7s %-7s %-30s" % ("Account", self.acno.disp,
+                self.desc.disp))
+            self.fpdf.drawText()
+            self.fpdf.drawText("%-10s %-9s %-3s %-7s %-30s %-13s %-13s %-13s" \
+                % ("   Date", "Reference", "Typ", "Batch", "Remarks",
+                "       Debit", "      Credit", "     Balance"))
+            self.fpdf.underLine(self.head)
+            self.fpdf.setFont()
+            self.pglin += 5
+
+    def doExit(self):
+        if not self.auto:
+            self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'gen/gl3100_rne.py'
--- gen/gl3100_rne.py	2017-08-24 07:49:34 +0000
+++ gen/gl3100_rne.py	2018-02-12 09:05:42 +0000
@@ -79,7 +79,7 @@
         cnd = ((self.doEnd,"n"),)
         cxt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            rows=[12], eflds=fld, butt=but, tend=tnd, txit=txt, cend=cnd,
+            rows=[13], eflds=fld, butt=but, tend=tnd, txit=txt, cend=cnd,
             cxit=cxt, view=("Y","V"), mail=("Y","N"))
 
     def doFP(self, frt, pag, r, c, p, i, w):
@@ -108,7 +108,7 @@
 
     def doTBG(self, frt, pag, r, c, p, i, w):
         self.seqdic = {}
-        for x in xrange(1, 13):
+        for x in xrange(1, 14):
             self.seqdic[x] = [0, "", ""]
         if w:
             acc = self.sql.getRec(tables="ctlgrp",
@@ -123,7 +123,7 @@
                 self.newgrp = False
                 self.df.loadEntry(frt, pag, p+1, data=acc[1])
                 seq = 1
-                for x in xrange(0, 24, 2):
+                for x in xrange(0, 26, 2):
                     coy = acc[x + 2]
                     hed = acc[x + 3]
                     if not coy:
@@ -143,7 +143,7 @@
         self.tbh = w
 
     def doSeq(self, frt, pag, r, c, p, i, w):
-        if not w or w > 12:
+        if not w or w > 13:
             return "Invalid Sequence Number"
         self.seq = w
 
@@ -168,12 +168,12 @@
         olddic = copy.deepcopy(self.seqdic)
         self.seqdic = {}
         seq = 1
-        for x in xrange(1, 13):
+        for x in xrange(1, 14):
             if x == self.seq:
                 continue
             self.seqdic[seq] = olddic[x]
             seq += 1
-        for x in xrange(seq, 13):
+        for x in xrange(seq, 14):
             self.seqdic[x] = [0, "", ""]
         self.df.focusField("C", 0, self.doReload() + 1)
 
@@ -199,7 +199,7 @@
     def doReload(self):
         self.df.clearFrame("C", 0)
         idx = 0
-        for x in xrange(1, 13):
+        for x in xrange(1, 14):
             if not self.seqdic[x][0]:
                 continue
             self.df.loadEntry("C", 0, idx, data=x)
@@ -207,7 +207,7 @@
             self.df.loadEntry("C", 0, idx+2, data=self.seqdic[x][1])
             self.df.loadEntry("C", 0, idx+3, data=self.seqdic[x][2])
             idx += 4
-        if idx == 48:
+        if idx == 52:
             idx -= 4
         return idx
 
@@ -221,7 +221,7 @@
                 data = [self.grp, self.tbh]
             coys = []
             coyd = ""
-            for x in xrange(1, 13):
+            for x in xrange(1, 14):
                 if self.grp:
                     data.extend([self.seqdic[x][0], self.seqdic[x][2]])
                 if not self.seqdic[x][0]:
@@ -274,7 +274,7 @@
                     trn = 0
                 else:
                     trn = trn[0]
-                amt = CCD(float(ASD(bal) + ASD(trn)), "SD", 14.2)
+                amt = CCD(float(ASD(bal) + ASD(trn)), "SI", 13)
                 tot = float(ASD(tot) + ASD(amt.work))
                 if amt.work:
                     zero = False
@@ -297,7 +297,7 @@
                         trn = 0
                     else:
                         trn = trn[0]
-                    amt = CCD(float(ASD(bal) + ASD(trn)), "SD", 14.2)
+                    amt = CCD(float(ASD(bal) + ASD(trn)), "SI", 13)
                     lyr = float(ASD(lyr) + ASD(amt.work))
                     if amt.work:
                         zero = False
@@ -307,8 +307,7 @@
                 if not tot or not lyr:
                     lyv = 0
                 else:
-                    lyv = float(ASD(lyr) - ASD(tot))
-                    lyv = round(lyv * 100.0 / float(ASD(0) - ASD(tot)), 2)
+                    lyv = round(float(ASD(tot) - ASD(lyr)) * 100.0 / lyr, 2)
                     if lyv > 0 and lyv > 999.99:
                         lyv = 999.99
                     elif lyv < 0 and lyv < -999.99:
@@ -321,10 +320,10 @@
             ("desc", "NA", 30, "Description", "y")]
         gtot = []
         for coy in coys:
-            cols.append(("c%s" % coy[0], "SD", 14.2, "%12s" % coy[2], "y"))
+            cols.append(("c%s" % coy[0], "SI", 13, "%12s" % coy[2], "y"))
             gtot.append("c%s" % coy[0])
-        cols.append(("total", "SD", 14.2, "Tot-Balance", "y"))
-        cols.append(("lyear", "SD", 14.2, "LYR-Balance", "y"))
+        cols.append(("total", "SI", 13, "Tot-Balance", "y"))
+        cols.append(("lyear", "SI", 13, "LYR-Balance", "y"))
         cols.append(("lyvar", "SD", 7.2, "LY-VAR", "y"))
         gtot.append("total")
         gtot.append("lyear")

=== modified file 'gen/gl3110_rne.py'
--- gen/gl3110_rne.py	2017-08-24 07:49:34 +0000
+++ gen/gl3110_rne.py	2018-02-08 12:25:14 +0000
@@ -84,7 +84,7 @@
         tnd = ((self.doEnd,"y"),)
         txt = (self.doExit,)
         self.df = TartanDialog(self.opts["mf"], tops=False, title=tit,
-            rows=[10], eflds=fld, tend=tnd, txit=txt, view=("N","V"),
+            rows=[10], eflds=fld, tend=tnd, txit=txt, view=("Y","V"),
             mail=("Y","N"))
 
     def doFP(self, frt, pag, r, c, p, i, w):

=== modified file 'gen/gl3130_rne.py'
--- gen/gl3130_rne.py	2017-08-24 07:49:34 +0000
+++ gen/gl3130_rne.py	2017-12-15 08:27:57 +0000
@@ -788,9 +788,12 @@
                 coy = q[2]
                 nam = self.sql.getRec(tables="ctlmst", cols=["ctm_name"],
                     where=[("ctm_cono", "=", coy)], limit=1)[0]
-                # Get group values
+                # Get Current Year Values
                 ost,pur,sls,inc,adv,cst,wag,stt,npr = self.getVals(
                     coy, (self.sper, self.rper))
+                # Get Last Year Values
+                a,b,c,d,e,f,g,h,i = self.getVals(
+                    coy, (self.sper - 100, self.rper - 100))
                 # Calculate estimated closing stock
                 avg = self.sql.getRec(tables="genqrp", cols=["gqp_rate",
                     "gqp_allow"], where=[("gqp_bcod", "=", bcd),
@@ -807,21 +810,28 @@
                 self.dat1.append([bcd, bnm, coy, nam, ost, pur, sls, slc, inc,
                     adv, stk, cst, stt, alw, dif, wag, per])
                 if sls and cst and dep in deps:
+                    # Gross Profit
                     prf = sls + cst + inc + adv - ost - pur
                     if prf <= sls:
+                        lgp = c + f + d + e - a - b
+                        if lgp > c:
+                            lgp = 0
                         if dep not in self.dat2[bnm][1]:
-                            self.dat2[bnm][1][dep] = [prf, sls]
+                            self.dat2[bnm][1][dep] = [prf, sls, lgp]
                         else:
                             self.dat2[bnm][1][dep][0] += prf
                             self.dat2[bnm][1][dep][1] += sls
+                            self.dat2[bnm][1][dep][2] += lgp
                 # Net Profit
                 if not cst:
                     npr = float(ASD(npr) + ASD(stk))
+                lnp = i
                 if dep not in self.dat3[bnm][1]:
-                    self.dat3[bnm][1][dep] = [npr, sls]
+                    self.dat3[bnm][1][dep] = [npr, sls, lnp]
                 else:
                     self.dat3[bnm][1][dep][0] += npr
                     self.dat3[bnm][1][dep][1] += sls
+                    self.dat3[bnm][1][dep][2] += lnp
         pb.closeProgress()
 
     def getVals(self, coy, per):
@@ -842,7 +852,7 @@
                 whr.append(("glt_acno", "=", acc[0]))
             else:
                 whr.append(("glt_acno", "in", acc))
-            if grp[0] == 8:
+            if grp[0] == 6:
                 # Closing Stock
                 w = whr[:]
                 w.append(("glt_curdt", "=", self.rper))
@@ -945,31 +955,30 @@
                     dpss.append(dep)
         if not dpss:
             return
-        dpss.sort()
-        tab = ["genqrp", "genqrc"]
-        col = ["gqp_dcod", "gqc_name", "gqp_rate"]
+        tab = ["genqrc"]
+        col = ["gqc_dcod", "gqc_name"]
         whr = [
-            ("gqp_bcod", "=", 1),
-            ("gqp_dcod", "in", dpss),
-            ("gqp_rate", "<>", 0),
-            ("gqc_dcod=gqp_dcod",)]
+            ("gqc_dcod", "in", dpss),
+            ("gqc_gprp", "=", "Y")]
         odr = "gqc_name"
         deps = self.sql.getRec(tables=tab, cols=col, where=whr, order=odr)
         self.col4 = {
             "D": [["NA", 13, "Branch"]],
             "E": [["NA", 13, "Branch\nTarget%"]]}
         self.dat4 = {}
-        size = 12
         for dep in deps:
-            self.col4["D"].append(["NA",12,"%s" % dep[1]])
-            dsc = CCD(dep[2], "SD", 6.2).disp
-            self.col4["E"].append(["NA",12,"%s\n%s%s" % (dep[1], dsc, "%")])
-            self.dat4[dep[0]] = [dep[1], dep[2], {}]
-            size += 12
-        self.col4["D"].append(["NA",12,"%s" % "Totals"])
-        size += 12
+            nam = dep[1].split()[0]
+            self.col4["D"].append(["NA",13,"%s" % nam])
+            dsc = self.sql.getRec(tables="genqrp", cols=["max(gqp_rate)"],
+                where=[("gqp_dcod", "=", dep[0])], limit=1)
+            dsp = CCD(dsc[0], "SD", 6.2).disp
+            self.col4["E"].append(["NA",13,"%s\n%s%s" % (nam, dsp, "%")])
+            self.dat4[dep[0]] = [dep[1], dsc[0], {}]
+        self.col4["D"].append(["NA",13,"%s" % "Totals"])
+        self.col4["D"].append(["NA",13,"%s" % "L-Year"])
         for self.rtyp in ("D", "E"):
             self.fpdf.def_orientation = "L"
+            size = len(self.col4[self.rtyp]) * 13
             self.fpdf.setValues("gl3130", size, font="courier")
             self.fpdf.add_page()
             tots = {}
@@ -986,13 +995,13 @@
                         prt = True
                 if not prt:
                     continue
-                b = CCD(bch, "NA", 12).disp
+                b = CCD(bch, "NA", 13).disp
                 w = 13 * self.fpdf.cwth
                 self.fpdf.drawText(b, w=w, h=4, border="TLRB", ln=0)
                 if self.rtyp == "D":
                     btot = 0
+                    blyr = 0
                 for dep in deps:
-                    w = 12 * self.fpdf.cwth
                     if self.rtyp == "E" and dep == deps[-1]:
                         l = 1
                     else:
@@ -1000,8 +1009,9 @@
                     if dep[0] in self.dat2[bch][1]:
                         val = self.dat2[bch][1][dep[0]]
                         if self.rtyp == "D":
-                            t = CCD(val[0], "SI", 12).disp
+                            t = CCD(val[0], "SI", 13).disp
                             btot = float(ASD(btot) + ASD(val[0]))
+                            blyr = float(ASD(blyr) + ASD(val[2]))
                         else:
                             if val[1]:
                                 gp = round(val[0] * 100.0 / val[1], 2)
@@ -1014,15 +1024,19 @@
                                 t = t.disp + "%"
                             self.dat4[dep[0]][2][b.strip()] = gp
                         if dep[1] not in tots:
-                            tots[dep[1]] = [0, 0]
+                            tots[dep[1]] = [0, 0, 0]
                         tots[dep[1]][0] += val[0]
                         tots[dep[1]][1] += val[1]
+                        tots[dep[1]][2] += val[2]
                     else:
                         t = ""
                     self.fpdf.drawText(t, w=w, h=4, align="C",
                         border="TLRB", ln=l)
                 if self.rtyp == "D":
-                    t = CCD(btot, "SI", 12).disp
+                    t = CCD(btot, "SI", 13).disp
+                    self.fpdf.drawText(t, w=w, h=4, align="C",
+                        border="TLRB", ln=0)
+                    t = CCD(blyr, "SI", 13).disp
                     self.fpdf.drawText(t, w=w, h=4, align="C",
                         border="TLRB", ln=1)
             pb.closeProgress()
@@ -1057,6 +1071,8 @@
             for dep in self.dat3[bch][1]:
                 if dep not in dpss:
                     dpss.append(dep)
+        if not dpss:
+            return
         tab = ["genqrc"]
         col = ["gqc_dcod", "gqc_name"]
         whr = [("gqc_dcod", "in", dpss)]
@@ -1066,15 +1082,14 @@
             "G": [["NA", 13, "Branch"]],
             "H": [["NA", 13, "Branch"]]}
         self.dat5 = {}
-        size = 12
         for dep in deps:
-            self.col5["G"].append(["NA",12,"%s" % dep[1]])
-            self.col5["H"].append(["NA",12,"%s" % dep[1]])
+            self.col5["G"].append(["NA",13,"%s" % dep[1]])
+            self.col5["H"].append(["NA",13,"%s" % dep[1]])
             self.dat5[dep[0]] = [dep[1], {}]
-            size += 12
-        self.col5["G"].append(["NA",12,"%s" % "Totals"])
-        size += 12
+        self.col5["G"].append(["NA",13,"%s" % "Totals"])
+        self.col5["G"].append(["NA",13,"%s" % "L-Year"])
         for self.rtyp in ("G", "H"):
+            size = len(self.col5[self.rtyp]) * 13
             self.fpdf.def_orientation = "L"
             self.fpdf.setValues("gl3130", size, font="courier")
             self.fpdf.add_page()
@@ -1092,13 +1107,13 @@
                         prt = True
                 if not prt:
                     continue
-                b = CCD(bch, "NA", 12).disp
+                b = CCD(bch, "NA", 13).disp
                 w = 13 * self.fpdf.cwth
                 self.fpdf.drawText(b, w=w, h=4, border="TLRB", ln=0)
                 if self.rtyp == "G":
                     btot = 0
+                    blyr = 0
                 for dep in deps:
-                    w = 12 * self.fpdf.cwth
                     if self.rtyp == "H" and dep == deps[-1]:
                         l = 1
                     else:
@@ -1106,13 +1121,14 @@
                     if dep[0] in self.dat3[bch][1]:
                         val = self.dat3[bch][1][dep[0]]
                         if self.rtyp == "G":
-                            t = CCD(val[0], "SI", 12).disp
+                            t = CCD(val[0], "SI", 13).disp
                             btot = float(ASD(btot) + ASD(val[0]))
+                            blyr = float(ASD(blyr) + ASD(val[2]))
                         else:
-                            if val[1]:
+                            if not val[1]:
+                                gp = 0
+                            else:
                                 gp = round(val[0] * 100.0 / val[1], 2)
-                            else:
-                                gp = 0
                             t = CCD(gp, "SD", 6.2)
                             if t.err:
                                 t = ""
@@ -1120,15 +1136,19 @@
                                 t = t.disp + "%"
                             self.dat5[dep[0]][1][b.strip()] = gp
                         if dep[1] not in tots:
-                            tots[dep[1]] = [0, 0]
+                            tots[dep[1]] = [0, 0, 0]
                         tots[dep[1]][0] += val[0]
                         tots[dep[1]][1] += val[1]
+                        tots[dep[1]][2] += val[2]
                     else:
                         t = ""
                     self.fpdf.drawText(t, w=w, h=4, align="C",
                         border="TLRB", ln=l)
                 if self.rtyp == "G":
-                    t = CCD(btot, "SI", 12).disp
+                    t = CCD(btot, "SI", 13).disp
+                    self.fpdf.drawText(t, w=w, h=4, align="C",
+                        border="TLRB", ln=0)
+                    t = CCD(blyr, "SI", 13).disp
                     self.fpdf.drawText(t, w=w, h=4, align="C",
                         border="TLRB", ln=1)
             pb.closeProgress()
@@ -1285,6 +1305,7 @@
             self.fpdf.setFont(font[0], "B", font[1])
             if self.rtyp == "D":
                 gtot = 0
+                ltot = 0
                 txt = "Total GP "
             else:
                 txt = "Average GP%"
@@ -1292,24 +1313,32 @@
             keys = list(data.keys())
             keys.sort()
             for dep in keys:
-                w = 12 * self.fpdf.cwth
+                w = 13 * self.fpdf.cwth
                 if self.rtyp == "D":
                     l = 0
-                    txt = CCD(data[dep][0], "SI", 12).disp
+                    txt = CCD(data[dep][0], "SI", 13).disp
                     gtot = float(ASD(gtot) + ASD(data[dep][0]))
+                    ltot = float(ASD(ltot) + ASD(data[dep][2]))
                 else:
                     if dep == keys[-1]:
                         l = 1
                     else:
                         l = 0
-                    gp = CCD(round(data[dep][0] * 100.0 / data[dep][1], 2),
-                        "SD", 6.2).disp
-                    txt = "%s%s" % (gp, "%")
+                    if not data[dep][1]:
+                        gp = 0
+                    else:
+                        gp = round(data[dep][0] * 100.0 / data[dep][1], 2)
+                    t = CCD(gp, "SD", 6.2).disp
+                    txt = "%s%s" % (t, "%")
                 self.fpdf.drawText(txt, w=w, h=5, align="C", border=b,
                     fill=f, ln=l)
             if self.rtyp == "D":
-                txt = CCD(gtot, "SI", 12).disp
-                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b, fill=f)
+                txt = CCD(gtot, "SI", 13).disp
+                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b,
+                    fill=f, ln=0)
+                txt = CCD(ltot, "SI", 13).disp
+                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b,
+                    fill=f, ln=1)
         elif self.rtyp in ("G", "H"):
             w = 13 * self.fpdf.cwth
             b = "TLRB"
@@ -1317,6 +1346,7 @@
             self.fpdf.setFont(font[0], "B", font[1])
             if self.rtyp == "G":
                 gtot = 0
+                ltot = 0
                 txt = "Total NP"
             else:
                 txt = "Average NP%"
@@ -1324,24 +1354,32 @@
             keys = list(data.keys())
             keys.sort()
             for dep in keys:
-                w = 12 * self.fpdf.cwth
+                w = 13 * self.fpdf.cwth
                 if self.rtyp == "G":
                     l = 0
-                    txt = CCD(data[dep][0], "SI", 12).disp
+                    txt = CCD(data[dep][0], "SI", 13).disp
                     gtot = float(ASD(gtot) + ASD(data[dep][0]))
+                    ltot = float(ASD(ltot) + ASD(data[dep][2]))
                 else:
                     if dep == keys[-1]:
                         l = 1
                     else:
                         l = 0
-                    gp = CCD(round(data[dep][0] * 100.0 / data[dep][1], 2),
-                        "SD", 6.2).disp
-                    txt = "%s%s" % (gp, "%")
+                    if not data[dep][1]:
+                        gp = 0
+                    else:
+                        gp = round(data[dep][0] * 100.0 / data[dep][1], 2)
+                    t = CCD(gp, "SD", 6.2).disp
+                    txt = "%s%s" % (t, "%")
                 self.fpdf.drawText(txt, w=w, h=5, align="C", border=b, fill=f,
                     ln=l)
             if self.rtyp == "G":
-                txt = CCD(gtot, "SI", 12).disp
-                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b, fill=f)
+                txt = CCD(gtot, "SI", 13).disp
+                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b,
+                    fill=f, ln=0)
+                txt = CCD(ltot, "SI", 13).disp
+                self.fpdf.drawText(txt, w=w, h=5, align="C", border=b,
+                    fill=f, ln=1)
         self.fpdf.setFont(font[0], "", font[1])
 
     def doBarChart(self, xcol=[], vals=[], tgt=0, fill=False):

=== added file 'gen/gl3140_rne.py'
--- gen/gl3140_rne.py	1970-01-01 00:00:00 +0000
+++ gen/gl3140_rne.py	2018-02-12 14:01:33 +0000
@@ -0,0 +1,861 @@
+"""
+SYNOPSIS
+    General Ledger Consolidated Financial Statements.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2017 Paul Malherbe.
+"""
+
+import copy, time
+from TartanClasses import ASD, CCD, GetCtl, MyFpdf, ProgressBar, Sql
+from TartanClasses import TartanDialog
+from tartanFunctions import copyList, doPrinter, doWriteExport, getModName
+from tartanFunctions import getPeriods, getSingleRecords, makeArray
+from tartanFunctions import mthendDate
+from tartanWork import mthnam
+
+class gl3140:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.mainProcess()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        gc = GetCtl(self.opts["mf"])
+        ctlsys = gc.getCtl("ctlsys")
+        if not ctlsys:
+            return
+        self.gldep = ctlsys["sys_gl_dep"]
+        self.gldig = ctlsys["sys_gl_dig"]
+        self.sql = Sql(self.opts["mf"].dbm, ["ctlmst", "genbud", "genrpt",
+            "genqrb", "genqrc", "genqrd"], prog=__name__)
+        if self.sql.error:
+            return
+        t = time.localtime()
+        self.sysdttm = "(Printed on: %i/%02i/%02i at %02i:%02i) %s" % \
+            (t[0], t[1], t[2], t[3], t[4], __name__)
+        p = self.sql.getRec(tables="ctlynd", cols=["max(cye_period)"],
+            where=[("cye_cono", "=", 1)])
+        self.cfin = int(p[0][0])
+        self.ulc = "X"                          # Temporary Underline Character
+        return True
+
+    def mainProcess(self):
+        self.tit = "General Ledger Financial Statements (%s)" % __name__
+        fin = {
+            "stype": "R",
+            "tables": ("ctlynd",),
+            "cols": (
+                ("cye_period", "", 0, "Prd"),
+                ("cye_start", "", 0, "Start"),
+                ("cye_end", "", 0, "End")),
+            "where": [("cye_cono=1",)]}
+        rpt = {
+            "stype": "R",
+            "tables": ("genrpt",),
+            "cols": (
+                ("glr_repno", "", 0, "Num"),
+                ("glr_type", "", 0, "T"),
+                ("glr_desc", "", 0, "Description", "Y")),
+            "where": [
+                ("glr_cono", "=", 0),
+                ("glr_seq", "=", 0),
+                ("glr_type", "in", ("P", "B", "O"))],
+            "group": "glr_repno, glr_type, glr_desc"}
+        r1s = (("Yes", "Y"), ("No", "N"))
+        fld = (
+            (("T",0,0,0),"IUI",3,"Financial Period","",
+                self.cfin,"Y",self.doFPer,fin,None,("efld",)),
+            (("T",0,1,0),"ID2",7,"Ending Period","Ending Period (YYYY/MM)",
+                0,"N",self.doRepPer,None,None,None),
+            (("T",0,2,0),"IUI",3,"Report Number","",
+                2,"N",self.doRepNum,rpt,None,("notzero",)),
+            (("T",0,3,0),("IRB",r1s),0,"All Branches","",
+                "Y","N",self.doAllBch,None,None,None))
+        tnd = ((self.doMainEnd,"y"), )
+        txt = (self.doMainExit, )
+        self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,
+            tend=tnd, txit=txt, view=("Y","V"), mail=("Y","N"))
+
+    def doFPer(self, frt, pag, r, c, p, i, w):
+        f = getPeriods(self.opts["mf"], 1, w, check=True)
+        if f == (None, None, None):
+            return "Invalid Financial Period"
+        self.period = (w, (f[0].work, f[0].disp), (f[1].work, f[1].disp))
+        self.s_per = self.period[1][0] / 100
+        self.e_per = self.period[2][0] / 100
+        self.df.loadEntry(frt, pag, p+1, data=self.e_per)
+
+    def doRepPer(self, frt, pag, r, c, p, i, w):
+        if w < self.s_per or w > self.e_per:
+            return "Invalid Period"
+        self.end = w
+        yed = CCD(mthendDate((self.end * 100) + 1), "D1", 10)
+        self.yed = "%s %s %s" % ((yed.work % 100),
+            mthnam[int((yed.work % 10000) / 100)][1], int(yed.work / 10000))
+        self.cyr = "  %4s" % int(self.end / 100)
+        self.pyr = "  %4s" % (int(self.end / 100) - 1)
+
+    def doRepNum(self, frt, pag, r, c, p, i, w):
+        self.rep = w
+        err = self.getRepDetails()
+        if err:
+            return err
+
+    def doAllBch(self, frt, pag, r, c, p, i, w):
+        self.bchs = []
+        if w == "Y":
+            self.bchs = self.sql.getRec(tables="genqrb",
+                where=[("gqb_bcod", "<", 999)],
+                order="gqb_bcod")
+            if not self.bchs:
+                return "No Branches Available"
+        else:
+            self.bchs = getSingleRecords(self.opts["mf"],
+                "genqrb", ("gqb_bcod", "gqb_name"),
+                where=[("gqb_bcod", "<", 999)],
+                order="gqb_bcod")
+            if not self.bchs:
+                return "No Branches Selected"
+
+    def doMainEnd(self):
+        self.df.closeProcess()
+        if self.df.repprt[2] == "export":
+            self.pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
+                __name__, "all")
+        else:
+            self.pdfnam = getModName(self.opts["mf"].rcdic["wrkdir"],
+                __name__, "all", ext="pdf")
+        self.doCreateReport()
+        self.opts["mf"].closeLoop()
+
+    def getRepDetails(self):
+        chk = self.sql.getRec(tables="genrpt", cols=["glr_type", "glr_desc"],
+            where=[("glr_cono", "=", 0), ("glr_repno", "=", self.rep),
+            ("glr_seq", "=", 0)], limit=1)
+        if not chk:
+            return "Invalid Report Number or Type"
+        self.rptyp, self.rpdes = chk
+
+    def doHeader(self, frt, pag, r, c, p, i, w):
+        if self.rptyp in ("B", "P"):
+            self.heds[p-1] = w
+        else:
+            self.heds[3] = w
+
+    def doCreateReport(self):
+        if self.df.repprt[2] == "export":
+            self.expdatas = []
+        else:
+            self.fpdf = MyFpdf(name=__name__)
+        p = ProgressBar(self.opts["mf"].body, mxs=len(self.bchs), esc=True)
+        for num, self.bch in enumerate(self.bchs):
+            p.displayProgress(num)
+            self.allfields = []
+            self.deps = self.sql.getRec(tables=["genqrd", "genqrc"],
+                cols=["gqc_dcod", "gqc_name"], where=[("gqd_bcod",
+                "=", self.bch[0]), ("gqc_dcod=gqd_dcod",)],
+                order="gqd_dcod")
+            deps = copyList(self.deps)
+            for num, dep in enumerate(deps):
+                coys = []
+                chk = self.sql.getRec(tables="genqrd", cols=["gqd_cono"],
+                    where=[("gqd_bcod", "=", self.bch[0]),
+                    ("gqd_dcod", "=", dep[0])],
+                    order="gqd_cono")
+                for c in chk:
+                    coys.append(c[0])
+                self.deps[num].append(coys)
+            fin = FinReport(self.opts["mf"], self.period, self.deps,
+                self.rep, self.end)
+            if not fin.allFields:
+                return
+            for fld in fin.allFields:
+                if fld[0] in ("C", "P"):
+                    continue
+                self.allfields.append(fld)
+            if self.df.repprt[2] == "export":
+                self.doExportReport()
+            else:
+                self.doPrintReport()
+        p.closeProgress()
+        if self.df.repprt[2] == "export":
+            doWriteExport(xtype=self.df.repprt[1], name=self.pdfnam,
+                heads=self.expheads, colsh=self.expcolsh, forms=self.expforms,
+                datas=self.expdatas, rcdic=self.opts["mf"].rcdic, view=True)
+        else:
+            self.fpdf.output(self.pdfnam, "F")
+            doPrinter(mf=self.opts["mf"], pdfnam=self.pdfnam,
+                header=self.emlhead, repprt=self.df.repprt,
+                repeml=self.df.repeml)
+
+    def doExportReport(self):
+        self.titls = {1: ["Description", "NA", 30]}
+        self.colss = [1]
+        for num, dep in enumerate(self.deps):
+            self.titls[num + 2] = [dep[1], "SI", 14]
+            self.colss.append(num + 2)
+        self.titls[num + 3] = ["Total", "SI", 14]
+        self.titls[num + 4] = ["LYear", "SI", 14]
+        self.titls[num + 5] = ["Var-%", "SD", 7.2]
+        self.colss.extend([num + 3, num + 4, num + 5])
+        self.expheads = [self.bch[1]]
+        self.expheads.append("TYPE")
+        self.expcolsh = [[]]
+        self.expforms = []
+        for h in self.colss:
+            self.expcolsh[0].append(self.titls[h][0])
+            self.expforms.append(self.titls[h][1:])
+        self.counter = 0
+        for num, dat in enumerate(self.allfields):
+            if dat[6] < self.counter:
+                dat[3] = "Y"
+            if not num:
+                self.pageHeading(dat)
+            if dat[0] == "H":
+                self.doHeading(dat)
+            elif dat[0] in ("C","G","L","P","S","T"):
+                self.doValues(dat)
+            elif dat[0] == "U":
+                self.doUnderline(dat)
+            self.counter = dat[6]
+
+    def doPrintReport(self):
+        self.head = []
+        self.linu = ""
+        self.last = False
+        self.head.append("%s" % self.bch[1])
+        self.head.append("")
+        self.width = 30
+        txt = "%-30s" % "Description"
+        self.linu = "%30s" % ""
+        for dep in self.deps:
+            self.width += 15
+            txt = "%s %13s " % (txt, dep[1])
+            self.linu = "%s %13s " % (self.linu, self.ulc * 13)
+        self.width += 38
+        txt = "%s %13s  %13s  %6s" % (txt, "Total", "LYear", "Var-%")
+        self.linu = "%s %13s  %13s  %6s" % (
+            self.linu, self.ulc * 13, self.ulc * 13, self.ulc * 6)
+        self.head.append(txt)
+        self.fpdf.setValues("gl3130", self.width, font="courier")
+        self.pgnum = 0
+        self.pglin = 999
+        self.counter = 0
+        for num, dat in enumerate(self.allfields):
+            if dat[6] < self.counter:
+                dat[3] = "Y"
+            if self.pglin > self.fpdf.lpp:
+                dat[3] = "N"
+                self.pageHeading(dat)
+            if dat[0] == "H":
+                self.doHeading(dat)
+            elif dat[0] in ("C","G","L","P","S","T"):
+                self.doValues(dat)
+            elif dat[0] == "U":
+                self.doUnderline(dat)
+            self.counter = dat[6]
+
+    def doHeading(self, line):
+        if line[3] == "Y":
+            if self.df.repprt[2] == "export":
+                if self.oldtyp != self.bch[0]:
+                    self.pageHeading(line)
+            else:
+                self.pageHeading(line)
+        if self.df.repprt[2] == "export":
+            data = []
+            for num, dat in enumerate(self.expforms):
+                if int(self.expforms[num][1]) < 30:
+                    data.append("")
+                    continue
+                data.append(line[5])
+                break
+            if self.expdatas[-1][0] not in ("PAGE", "BLANK"):
+                self.expdatas.append(["BLANK"])
+            self.expdatas.append(["HEAD", data])
+            self.expdatas.append(["BLANK"])
+        else:
+            if line[2] == "Y":
+                self.fpdf.setFont(style="B")
+            self.fpdf.drawText(line[5])
+            self.fpdf.setFont()
+            self.fpdf.drawText()
+            self.pglin += 2
+
+    def doValues(self, line):
+        typ = line[0]
+        acc = CCD(line[4], "UI", 7)
+        if acc.work == 0:
+            acc.disp = "       "
+        des = CCD(line[5], "NA", 30)
+        exp = [des.disp]
+        prt = []
+        for val in line[8]:
+            exp.append(CCD(val, "SI", 14).work)
+            prt.append(CCD(val, "SI", 14).disp)
+        if val:
+            var = round(((line[8][-2] - val) * 100.0) / val, 2)
+            if var > 0 and var > 999.99:
+                var = 999.99
+            elif var < 0 and var < -999.99:
+                var = -999.99
+        else:
+            var = 0
+        exp.append(CCD(var, "SD", 7.2).work)
+        prt.append(CCD(var, "SD", 7.2).disp)
+        if self.df.repprt[2] != "export" and line[2] == "Y":
+            self.fpdf.setFont(style="B")
+        if not exp[-1] and not exp[-2]:
+            pass
+        elif self.df.repprt[2] == "export":
+            if typ == "T":
+                txt = "TOTAL"
+            else:
+                txt = "BODY"
+            self.expdatas.append([txt, exp])
+        else:
+            txt = des.disp
+            for fld in prt:
+                txt = "%s %s" % (txt, fld)
+            self.fpdf.drawText(txt)
+            self.pglin += 1
+            self.last = True
+        if self.df.repprt[2] != "export":
+            self.fpdf.setFont()
+
+    def doUnderline(self, line):
+        if self.df.repprt[2] == "export":
+            if line[5] == "Blank":
+                self.expdatas.append(["BLANK"])
+            elif line[5] == "Double":
+                self.expdatas.append(["ULINED"])
+            else:
+                self.expdatas.append(["ULINES"])
+            return
+        if not self.last:
+            return
+        if line[5] == "Blank":
+            self.fpdf.drawText()
+        else:
+            if line[5] == "Double":
+                st = "D"
+            else:
+                st = "S"
+            txt = self.linu.replace(self.ulc, self.fpdf.suc)
+            self.fpdf.underLine(t=st, txt=txt)
+        self.pglin += 1
+        self.last = False
+
+    def pageHeading(self, line):
+        if self.df.repprt[2] == "export":
+            expheads = copy.deepcopy(self.expheads)
+            expcolsh = copy.deepcopy(self.expcolsh)
+            expforms = copy.deepcopy(self.expforms)
+            edate = CCD(self.end, "D2", 7).disp
+            head = "%s for period %s to %s" % (line[11],
+                self.period[1][1][:-3], edate)
+            expheads[1] = head
+            self.expdatas.append(["PAGE",
+                [expheads, expcolsh, expforms, self.bch[1]]])
+            self.oldtyp = self.bch[0]
+            return
+        self.fpdf.add_page()
+        self.pgnum += 1
+        self.pglin = 0
+        self.fpdf.setFont(style="B")
+        for num, data in enumerate(self.head):
+            if num == 2:
+                edate = CCD(self.end, "D2", 7).disp
+                pad = self.width - 11
+                txt = "%s for period %s to %s" % (line[11],
+                    self.period[1][1][:-3], edate)
+                head = "%s%s%s" % ("%-", pad, "s")
+                self.fpdf.drawText("%s %4s %5s" % (head % txt,
+                    "Page", self.pgnum))
+                self.pglin += 1
+                self.emlhead = head
+                self.fpdf.drawText()
+                self.pglin += 1
+            self.fpdf.drawText(data)
+            self.pglin += 1
+        self.fpdf.drawText("%s" % (self.fpdf.suc * self.width))
+        self.pglin += 1
+        self.fpdf.setFont()
+
+    def doMainExit(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+class FinReport:
+    """
+    This class generates a list comprising:
+
+        Type of line i.e. H, L, G, T, S, U, C, P etc.
+        Account Type (B,P,O)
+        Print Highlighted (y or n)
+        Formfeed (y/n)
+        Account Number in the case of 'L'
+        Description i.e. Description or Single/Double/Blank for underlines
+        Line count
+        Number of lines to skip
+        List of Amounts (N/A,Lyr,Cyr,Bud,Ytd,Btd) for type "N"
+        Page Heading i.e. Balance Sheet, Profit and Loss or Other
+        Normal sign (+/-)
+
+    Using the report file as follows:
+
+    Num  Field       FF  Size  Description                     Heading
+    ---  ----------  --  ----  ------------------------------  -----------
+      0  glr_cono    UI   3.0  Company Number                  Coy
+      1  glr_repno   UI   3.0  Report Number                   No
+      2  glr_seq     UI   5.0  Sequence                        Seq
+      3  glr_type    UA   1.0  Type                            T
+      4  glr_desc    NA  30.0  Description                     Description
+      5  glr_high    UA   1.0  Highlight (y/n)                 H
+      6  glr_ffeed   UA   1.0  Form Feed (y/n)                 F
+      7  glr_ignore  UA   1.0  Ignore Account Type (y/n)       I
+      8  glr_from    UI   7.0  From Account                    From-Ac
+      9  glr_to      UI   7.0  To Account                      To-Ac
+     10  glr_obal    UA   1.0  Include Opening Balance (y/n)   B
+     11  glr_accum   UA   1.0  Accumulate Month Values (y/n)   A
+     12  glr_print   UA   1.0  Print Values (y/n/+/-)          P
+     13  glr_norm    UA   1.0  Normal Sign (+/-)               S
+     14  glr_acbal   UA   1.0  Add/Sub/Ignore Balance (a/s/i)  A
+     15  glr_store   UA   1.0  Store Balances (y/n)            S
+     16  glr_snum1   UI   2.0  Storage Number 1                N1
+     17  glr_snum2   UI   2.0  Storage Number 2                N2
+     18  glr_snum3   UI   2.0  Storage Number 3                N3
+     19  glr_acstr   UA   1.0  Add/Sub/Ignore Storage (a/s/i)  A
+     20  glr_group   UI   3.0  Group Number                    Grp
+     21  glr_total   UI   1.0  Total Level                     T
+     22  glr_clear   UA   1.0  Clear Total/Storage Level(s)    C
+     23  glr_strper  UD   6.2  Percentage of Stored Amount     %-tage
+     24  glr_uline   UA   1.0  Underline (b/d/s)               U
+     25  glr_cbase   UA   1.0  Calculation Base (p/a/s)        B
+     26  glr_ctype   UA   1.0  Calculation Type (+ - * /)      C
+     27  glr_camnt   SD  13.2  Percent or Amount               Amount
+     28  glr_label   NA  10.0  Chart Label, Space = None       Label
+
+    as well as the following parameters:
+
+    period   = The Financial Period to be used
+    deps     = A list of departments [[Num, Name, Flag, [Companies]], ...]
+    curdt    = The current financial period of the report e.g. 200302
+    """
+    def __init__(self, mf, period, deps, repno, curdt):
+        self.mf = mf
+        self.period = period
+        self.deps = deps
+        self.repno = repno
+        self.curdt = curdt
+        if self.setVariables():
+            self.mainProcess()
+
+    def setVariables(self):
+        self.sql = Sql(self.mf.dbm, ["ctlmst", "genmst", "genrpt", "genbal",
+            "gentrn"], prog=__name__)
+        if self.sql.error:
+            return
+        self.i_per = int(self.period[1][0] / 100)
+        self.e_per = int(self.period[2][0] / 100)
+        df = self.e_per - self.i_per - 87
+        if df > 12:
+            self.d_per = df - 12
+            yr = int(self.i_per / 100)
+            mt = self.i_per % 100
+            for _ in xrange(self.d_per):
+                mt += 1
+                if mt > 12:
+                    mt -= 12
+                    yr += 1
+            self.s_per = (yr * 100) + mt
+        else:
+            self.d_per = 0
+            self.s_per = self.i_per
+        if self.period[0]:
+            self.s_lyr, e_lyr, fin = getPeriods(self.mf, 1,
+                (self.period[0] - 1))
+            self.i_pyr = int(self.s_lyr.work / 100)
+            self.e_pyr = int(e_lyr.work / 100)
+            df = self.e_pyr - self.i_pyr - 87
+            if df > 12:
+                self.d_pyr = df - 12
+                yr = int(self.i_pyr / 100)
+                mt = self.i_pyr % 100
+                for _ in xrange(self.d_pyr):
+                    mt += 1
+                    if mt > 12:
+                        mt -= 12
+                        yr += 1
+                self.s_pyr = (yr * 100) + mt
+            else:
+                self.d_pyr = 0
+                self.s_pyr = self.i_pyr
+        else:
+            self.d_pyr = 0
+            self.s_pyr = 0
+        self.cmth = self.curdt % 100
+        self.lines = 1
+        self.count = 0
+        self.grpind = False
+        self.xits = False
+        self.clearData()
+        self.allFields = []
+        self.val_tot = makeArray(len(self.deps) + 2, 10, 1)
+        self.val_str = makeArray(len(self.deps) + 2, 100, 1)
+        self.dname = None
+        return True
+
+    def mainProcess(self):
+        self.rpt_lst = self.sql.getRec(tables="genrpt", where=[("glr_cono",
+            "=", 0), ("glr_repno", "=", self.repno)], order="glr_seq")
+        self.rep_num = 0
+        if self.rpt_lst and self.rpt_lst[self.rep_num][3] in ("P","B","O"):
+            self.s_type = self.rpt_lst[0][3]
+            self.atype = self.s_type
+            if self.s_type == "P":
+                self.stanam = "Profit and Loss"
+            elif self.s_type == "B":
+                self.stanam = "Balance Sheet"
+            elif self.s_type == "O":
+                self.stanam = self.rpt_lst[self.rep_num][4]
+            if self.dname:
+                self.stanam = "%s - %s" % (self.dname, self.stanam)
+            while not self.xits:
+                self.processRecords()
+
+    def processRecords(self):
+        if self.grpind:
+            self.grpind = False
+        else:
+            self.nextRepRecord()
+            self.storeRepRecord()
+            if self.rpt_dic == {}:
+                self.xits = True
+        if not self.xits:
+            if self.s_type == "H":
+                self.doHead()
+            elif self.s_type == "L":
+                self.doLedger()
+            elif self.s_type == "G":
+                self.doGroup()
+            elif self.s_type == "T":
+                self.doTotal()
+            elif self.s_type == "S":
+                self.doStore()
+            elif self.s_type == "U":
+                self.doUnderline()
+            elif self.s_type == "P":
+                self.doPercent()
+            elif self.s_type == "C":
+                self.doCalc()
+
+    def doHead(self):
+        if self.rpt_dic["glr_ignore"] == "Y":
+            if self.atype == "P":
+                self.checkAccountType("B")
+            else:
+                self.checkAccountType("P")
+        self.printLine()
+        self.clearData()
+
+    def doLedger(self):
+        accs = self.readGenmst()
+        for acc in accs:
+            for num, dep in enumerate(self.deps):
+                self.lstdicGenmst(acc)
+                self.s_cono = dep[2]
+                self.s_acno = self.gen_dic["glm_acno"]
+                self.s_desc = self.gen_dic["glm_desc"]
+                self.accumData(num)
+            if self.s_print == "+" and self.val[-2] < 0:
+                self.clearData()
+                continue
+            elif self.s_print == "-" and self.val[-2] >= 0:
+                self.clearData()
+                continue
+            elif self.s_print == "N":
+                pass
+            else:
+                self.printLine()
+            self.accumTotals(self.s_acbal)
+            if self.s_store == "Y":
+                self.storeBalances()
+            self.clearData()
+
+    def doGroup(self):
+        self.grpind = True
+        while self.rpt_dic and self.rpt_dic["glr_type"] == "G" and \
+                        self.rpt_dic["glr_group"] == self.s_group:
+            accs = self.readGenmst()
+            for acc in accs:
+                for num, dep in enumerate(self.deps):
+                    self.lstdicGenmst(acc)
+                    self.s_cono = dep[2]
+                    self.s_acno = self.gen_dic["glm_acno"]
+                    self.accumData(num)
+            self.nextRepRecord()
+        if self.s_print == "+" and self.val[-2] < 0:
+            pass
+        elif self.s_print == "-" and self.val[-2] >= 0:
+            pass
+        else:
+            if self.s_print == "Y":
+                self.printLine()
+            self.accumTotals(self.s_acbal)
+            if self.s_store == "Y":
+                self.storeBalances()
+        self.clearData()
+        self.storeRepRecord()
+
+    def doTotal(self):
+        for x in xrange(0, len(self.deps) + 2):
+            self.val[x] = self.val_tot[self.s_total][x]
+        amt = self.val[-2]
+        if self.s_print == "+" and amt < 0:
+            self.clearData()
+            return
+        elif self.s_print == "-" and amt >= 0:
+            self.clearData()
+            return
+        elif self.s_print == "N":
+            pass
+        else:
+            self.printLine()
+        if self.s_store == "Y":
+            self.storeBalances()
+        self.clearData()
+        if self.s_clear == "Y":
+            for x in xrange(0, self.s_total+1):
+                for y in xrange(0, len(self.deps) + 2):
+                    self.val_tot[x][y] = 0
+
+    def doStore(self):
+        for x in xrange(0, len(self.deps) + 2):
+            if self.val_str[self.s_snum1][x] == 0:
+                self.val[x] = 0
+            else:
+                self.val[x] = round((self.val_str[self.s_snum1][x] *
+                    self.s_strper / 100.0), 2)
+        amt = self.val[-2]
+        if self.s_print == "+" and amt < 0:
+            self.clearData()
+            return
+        elif self.s_print == "-" and amt >= 0:
+            self.clearData()
+            return
+        elif self.s_print == "N":
+            pass
+        else:
+            self.printLine()
+        self.accumTotals(self.s_acbal)
+        self.clearData()
+        if self.s_clear == "Y":
+            for x in xrange(0, len(self.deps) + 2):
+                self.val_str[self.s_snum1][x] = 0
+
+    def doUnderline(self):
+        if self.rpt_dic["glr_uline"] == "B":
+            self.s_desc = "Blank"
+        elif self.rpt_dic["glr_uline"] == "S":
+            self.s_desc = "Single"
+        else:
+            self.s_desc = "Double"
+        self.printLine()
+        self.clearData()
+
+    def doPercent(self):
+        for x in xrange(0, len(self.deps) + 2):
+            if self.val_str[self.s_snum1][x] == 0 or \
+                    self.val_str[self.s_snum2][x] == 0:
+                self.val[x] = 0
+            else:
+                self.val[x] = round((self.val_str[self.s_snum1][x] /
+                    self.val_str[self.s_snum2][x]) * 100.0, 2)
+        self.printLine()
+        self.clearData()
+
+    def doCalc(self):
+        for x in xrange(0, len(self.deps) + 2):
+            amt1 = self.val_str[self.s_snum2][x]
+            if self.s_cbase == "S":
+                amt2 = self.val_str[self.s_snum3][x]
+            else:
+                amt2 = self.s_camnt
+            if self.s_ctype == "+":
+                self.val[x] = float(ASD(amt1) + ASD(amt2))
+            elif self.s_ctype == "-":
+                self.val[x] = float(ASD(amt1) - ASD(amt2))
+            elif self.s_ctype == "*":
+                if self.s_cbase == "P":
+                    self.val[x] = round(amt1 * amt2 / 100.0, 2)
+                else:
+                    self.val[x] = round(amt1 * amt2, 2)
+            elif self.s_ctype == "/":
+                self.val[x] = round(amt1 / amt2, 2)
+        self.printLine()
+        self.clearData()
+
+    def readGenmst(self):
+        accs = []
+        glfrom = self.rpt_dic["glr_from"]
+        glto = self.rpt_dic["glr_to"]
+        if not glto:
+            recs = self.sql.getRec(tables="genmst",
+                where=[("glm_acno", "=", glfrom)],
+                limit=1)
+            if recs:
+                accs = [recs]
+        else:
+            chks = []
+            recs = self.sql.getRec(tables="genmst",
+                where=[("glm_acno", ">=", glfrom),
+                ("glm_acno", "<=", glto)], order="glm_acno")
+            for rec in recs:
+                if not rec[1] in chks:
+                    accs.append(rec)
+                    chks.append(rec[1])
+        if not accs:
+            accs = []
+        return accs
+
+    def lstdicGenmst(self, acc):
+        self.gen_lst = acc
+        self.gen_dic = {}
+        for num, fld in enumerate(self.sql.genmst_col):
+            self.gen_dic[fld] = acc[num]
+        if self.rpt_dic["glr_ignore"] == "N":
+            self.checkAccountType(self.gen_dic["glm_type"])
+
+    def clearData(self):
+        self.val = [0] * (len(self.deps) + 2)
+
+    def accumData(self, dp):
+        t1 = len(self.deps)
+        t2 = t1 + 1
+        if self.rpt_dic["glr_obal"] == "Y":
+            o_lyr, o_cyr = self.getObal()
+            self.val[dp] = float(ASD(self.val[dp]) + ASD(o_cyr))
+            self.val[t1] = float(ASD(self.val[t1]) + ASD(o_cyr))
+            self.val[t2] = float(ASD(self.val[t2]) + ASD(o_lyr))
+        lyr, cyr = self.getCbal()
+        self.val[dp] = float(ASD(self.val[dp]) + ASD(cyr))
+        self.val[t1] = float(ASD(self.val[t1]) + ASD(cyr))
+        self.val[t2] = float(ASD(self.val[t2]) + ASD(lyr))
+
+    def getObal(self):
+        if not self.period[0]:
+            lyr = None
+        else:
+            lyr = self.sql.getRec(tables="genbal",
+                cols=["round(sum(glo_cyr), 0)"], where=[("glo_cono",
+                "in", self.s_cono), ("glo_acno", "=", self.s_acno),
+                ("glo_trdt", "=", self.s_lyr.work)], limit=1)[0]
+        cyr = self.sql.getRec(tables="genbal",
+            cols=["round(sum(glo_cyr), 0)"], where=[("glo_cono", "in",
+            self.s_cono), ("glo_acno", "=", self.s_acno), ("glo_trdt",
+            "=", self.period[1][0])], limit=1)[0]
+        if not lyr:
+            lyr = 0
+        if not cyr:
+            cyr = 0
+        return (lyr, cyr)
+
+    def getCbal(self):
+        lyr = self.sql.getRec(tables="gentrn",
+            cols=["round(sum(glt_tramt), 0)"], where=[("glt_cono",
+            "in", self.s_cono), ("glt_acno", "=", self.s_acno),
+            ("glt_curdt", "between", self.i_pyr, self.curdt - 100)],
+            limit=1)[0]
+        cyr = self.sql.getRec(tables="gentrn",
+            cols=["round(sum(glt_tramt), 0)"], where=[("glt_cono",
+            "in", self.s_cono), ("glt_acno", "=", self.s_acno),
+            ("glt_curdt", "between", self.i_per, self.curdt)],
+            limit=1)[0]
+        if not lyr:
+            lyr = 0
+        if not cyr:
+            cyr = 0
+        return (lyr, cyr)
+
+    def printLine(self):
+        self.signChkChg()
+        val = copyList(self.val)
+        if self.s_type != "L":
+            self.s_acno = 0
+        self.allFields.append([self.s_type, self.atype, self.s_high,
+            self.s_ffeed, self.s_acno, self.s_desc, self.count, self.lines,
+            val, [], self.s_label, self.stanam, self.s_norm])
+        self.signChkChg()
+        self.count += 1
+        self.lines = 1
+
+    def signChkChg(self):
+        if self.s_type in ("C","G","L","S","T") and self.s_norm == "N":
+            for x in xrange(0, len(self.deps) + 2):
+                self.val[x] = float(ASD(0) - ASD(self.val[x]))
+
+    def accumTotals(self, acbal):
+        for x in xrange(1, 10):
+            if acbal == "A":
+                for y in xrange(0, len(self.deps) + 2):
+                    self.val_tot[x][y] = \
+                        float(ASD(self.val_tot[x][y]) + ASD(self.val[y]))
+            elif acbal == "S":
+                for y in xrange(0, len(self.deps) + 2):
+                    self.val_tot[x][y] = \
+                        float(ASD(self.val_tot[x][y]) - ASD(self.val[y]))
+
+    def storeBalances(self):
+        if self.s_acstr == "A":
+            for x in xrange(0, len(self.deps) + 2):
+                self.val_str[self.s_snum1][x] = \
+                    float(ASD(self.val_str[self.s_snum1][x]) + ASD(self.val[x]))
+        elif self.s_acstr == "S":
+            for x in xrange(0, len(self.deps) + 2):
+                self.val_str[self.s_snum1][x] = \
+                    float(ASD(self.val_str[self.s_snum1][x]) - ASD(self.val[x]))
+
+    def nextRepRecord(self):
+        self.rpt_dic = {}
+        if self.rep_num == len(self.rpt_lst) - 1:
+            self.xits = True
+        else:
+            self.rep_num += 1
+            num = 0
+            for fld in self.sql.genrpt_col:
+                self.rpt_dic[fld] = self.rpt_lst[self.rep_num][num]
+                num += 1
+
+    def storeRepRecord(self):
+        self.s_acno = 0
+        for key in self.rpt_dic:
+            k = key.split("_")
+            setattr(self, "s_%s" % k[1], self.rpt_dic[key])
+
+    def checkAccountType(self, glm_type):
+        if glm_type == self.atype or self.atype == "O":
+            pass
+        else:
+            if glm_type == "P" and self.atype == "P":
+                pass
+            elif glm_type == "B" and self.atype == "B":
+                pass
+            else:
+                self.count = 66
+            self.atype = glm_type
+            if self.atype == "P":
+                self.stanam = "Profit and Loss"
+            else:
+                self.stanam = "Balance Sheet"
+            if self.dname:
+                self.stanam = "%s - %s" % (self.dname, self.stanam)
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'lon/ln1010.py'
--- lon/ln1010.py	2017-08-24 07:49:34 +0000
+++ lon/ln1010.py	2018-01-30 10:39:42 +0000
@@ -42,7 +42,7 @@
             "tables": ("lonmf1",),
             "cols": (
                 ("lm1_acno", "", 0, "Code"),
-                ("lm1_name", "", 0, "Surame", "Y"),
+                ("lm1_name", "", 0, "Surname", "Y"),
                 ("lm1_email", "", 0, "Email Address"))}
         if "args" in self.opts:
             fld = [

=== modified file 'mem/ml3100.py'
--- mem/ml3100.py	2017-08-24 07:49:34 +0000
+++ mem/ml3100.py	2018-01-30 10:39:53 +0000
@@ -138,7 +138,7 @@
         head = ["Members Birthday Report"]
         cols = [
             ["a", "NA",  7, "Mem-No", "y"],
-            ["b", "NA", 50, "Surame", "y"],
+            ["b", "NA", 50, "Surname", "y"],
             ["c", "NA", 50, "Names",  "y"],
             ["d", "DM", 5, "Birthday", "y"]]
         RepPrt(self.opts["mf"], conum=self.opts["conum"],

=== modified file 'men/rnemen.py'
--- men/rnemen.py	2017-03-25 15:17:51 +0000
+++ men/rnemen.py	2018-02-04 16:47:06 +0000
@@ -126,6 +126,7 @@
     ["PNNN","gl_rp","gl3110",1,"Multi-Company Reports"],
     ["PNNN","gl_rp","gl3120",1,"Quick Trading Results"],
     ["PNNN","gl_rp","gl3130",1,"Preliminary Results"],
+    ["PNNN","gl_rp","gl3140",1,"Consolidated Financials"],
     ["PYNN","gl_tb","gl6010",5,"Change Account Numbers"],
     ["PYNY","gl_tb","gl6020",5,"Copy Masterfile Records"],
     ["PYYN","gl_tb","gl6030",1,"Integrated Controls Report"],

=== modified file 'men/stdmen.py'
--- men/stdmen.py	2017-08-24 07:49:34 +0000
+++ men/stdmen.py	2018-02-14 14:37:55 +0000
@@ -251,6 +251,7 @@
     ["PYNN","st_tb","st6010",5,"Change Product Codes"],
     ["PYYY","st_tb","st6020",5,"Revalue Stock Records",0],
     ["PYYY","st_tb","st6030",5,"Delete Purchase Orders",0],
+    ["PYNN","st_tb","st6040",5,"Stock Redundancy",0],
     ["PYYY","mm_st","st4010",0,"Interrogation"]]
 
 # Sales Invoicing Routines

=== modified file 'mst/ms0000.py'
--- mst/ms0000.py	2017-09-10 14:30:43 +0000
+++ mst/ms0000.py	2018-02-17 07:36:26 +0000
@@ -38,7 +38,7 @@
     temp = tuple(os.environ["TARVER"].split("."))
     VERSION = (int(temp[0]), int(temp[1]), int(temp[2]))
 else:
-    VERSION = (5, 3, 2)
+    VERSION = (5, 3, 3)
 if __name__ == "__main__":
     # Run Tartan
     try:

=== modified file 'mst/msc000.py'
--- mst/msc000.py	2017-08-24 07:49:34 +0000
+++ mst/msc000.py	2017-12-13 09:53:21 +0000
@@ -1434,7 +1434,7 @@
             nam = "Unknown"
             eml = coy[1]
         mes = "%s - %s - %s" % (coy[0], nam, eml)
-        svr = ["smtp.gmail.com", 587, 1, 1, "tartansys@gmail.com", "tarpwd01"]
+        svr = ["smtp.gmail.com", 587, 1, 1, "tartansys@gmail.com", "pakati10"]
         ok = sendMail(svr, eml, "register@tartan.co.za", mes)
         if ok or self.newreg == "X":
             sql = Sql(self.db, "ctlsys", prog="msc000")

=== added file 'mst/msc000_rne.py'
--- mst/msc000_rne.py	1970-01-01 00:00:00 +0000
+++ mst/msc000_rne.py	2017-12-13 09:57:23 +0000
@@ -0,0 +1,1713 @@
+"""
+SYNOPSIS
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2017 Paul Malherbe.
+"""
+
+import cStringIO, fpdf, getpass, gc, glob, os, platform, sys, time
+from TartanClasses import AboutTartan, CCD, Dbase, DBCreate, FileDialog
+from TartanClasses import GetCtl, GUI, MainFrame, MkWindow, PwdConfirm
+from TartanClasses import ScrollText, SelectChoice, Sql, TarBckRes
+from TartanClasses import TartanConfig, TartanDialog, TartanMenu, TartanUser
+from tartanFunctions import askQuestion, b64Convert, copyList, dateDiff
+from tartanFunctions import ftpDownload, getPeriods, getPrgPath
+from tartanFunctions import internetConnect, loadRcFile, parsePrg, projectDate
+from tartanFunctions import runModule, showError, showException
+
+class msc000:
+    def __init__(self, version, opts, args):
+        self.current = [version, "%s.%s.%s" % version]
+        default = [
+            ("bpwd", ""),
+            ("conum", None),
+            ("debug", False),
+            ("exclude", []),
+            ("finper", None),
+            ("help", False),
+            ("itoggle", False),
+            ("loader", False),
+            ("menu", "stdmen"),
+            ("nocheck", False),
+            ("program", None),
+            ("query", None),
+            ("rcfdir", None),
+            ("rcfile", None),
+            ("script", None),
+            ("sysmod", "stdsys"),
+            ("tcode", 0),
+            ("user", {}),
+            ("version", False),
+            ("xdisplay", True),
+            ("zerobar", False)]
+        if sys.platform == "win32":
+            default.append(("output", True))
+        else:
+            default.append(("output", False))
+        for arg, val in default:
+            setattr(self, arg, val)
+        for o, v in opts:
+            if o in ("-b", "--bpwd"):
+                self.bpwd = v
+            elif o in ("-c", "--conum"):
+                self.conum = int(v)
+            elif o in ("-d", "--debug"):
+                self.debug = True
+            elif o in ("-e", "--exclude"):
+                self.exclude = v.split(",")
+            elif o in ("-f", "--finper"):
+                self.finper = int(v)
+            elif o in ("-h", "--help"):
+                self.help = True
+            elif o in ("-i", "--image"):
+                self.itoggle = True
+            elif o in ("-l", "--loader"):
+                self.loader = True
+            elif o in ("-m", "--menu"):
+                self.menu = v
+            elif o in ("-n", "--nocheck"):
+                self.nocheck = True
+            elif o in ("-o", "--output"):
+                if sys.platform == "win32":
+                    self.output = False
+                else:
+                    self.output = True
+            elif o in ("-p", "--program"):
+                self.program = v
+            elif o in ("-q", "--query"):
+                if not args:
+                    if len(v.split()) == 1:
+                        self.query = v  # Execute sql commands in a file
+                    else:
+                        self.query = [v.replace("\\", "")]
+                else:
+                    self.query = []
+                    for a in args:
+                        if a == ";":
+                            self.query.append(v)
+                            v = ""
+                            continue
+                        if not v:
+                            v = a
+                        else:
+                            v = "%s %s" % (v, a.replace("\\", ""))
+                    self.query.append(v)
+            elif o in ("-R", "--rcfdir"):
+                self.rcfdir = v
+            elif o in ("-r", "--rcfile"):
+                self.rcfile = v
+            elif o == "--script":
+                self.script = v
+            elif o in ("-s", "--sysmod"):
+                self.sysmod = v
+            elif o in ("-t", "--tcode"):
+                self.tcode = int(v)
+            elif o in ("-u", "--user"):
+                user = v.split(":")
+                self.user["name"] = user[0]
+                if len(user) == 2:
+                    self.user["pwd"] = user[1]
+                else:
+                    self.user["pwd"] = ""
+            elif o in ("-v", "--version"):
+                self.version = True
+            elif o in ("-x", "--xdisplay"):
+                self.xdisplay = False
+            elif o in ("-z", "--zerobar"):
+                self.zerobar = True
+        if self.output:
+            # Redirect stdout
+            for pid in xrange(1000):
+                if self.debug:
+                    name = "tracer_%s.txt" % pid
+                else:
+                    name = "stdout_%s.txt" % pid
+                self.stdout = os.path.join(getPrgPath(), name)
+                try:
+                    if not os.path.exists(self.stdout):
+                        sys.stdout = open(self.stdout, "w")
+                        os.chmod(self.stdout, 0777)
+                        break
+                except:
+                    pass
+        if self.script:
+            if os.sep in self.script or self.script.count(".py"):
+                import imp
+                imp.load_source(os.path.basename(self.script), self.script)
+            else:
+                __import__(self.script)
+            self.doExit(dbm=False)
+        if self.help:
+            print("""
+Usage:      python ms0000.py [options]
+
+Options:
+            -b, --bpwd=             The backup password
+            -c, --conum=            The company number
+            -d, --debug             Enter debug/trace mode
+            -e, --exclude=          Modules to ignore in debug/trace mode
+            -f, --finper=           The financial period
+            -h, --help              This Help Message
+            -i, --image             Toggle the Tartan image option.
+            -l, --loader            Try and remove module before importing
+            -m, --menu=             The menu to use, defaults to stdmen
+            -n, --nocheck           Do not check for system records
+            -o, --output            Toggle stdout redirection to stdout.txt
+                                        Linux   defaults to False
+                                        Windows defaults to True
+            -p, --program=          Execute program directly bypassing the menu
+            -q, --query=            Execute a sql query
+            -R, --rcfdir=           Directory of Available Tartan RC Files
+            -r, --rcfile=           Path of Tartan RC File to use
+            -s, --sysmod=           Name of the system module to use
+            -t, --tcode=            Transaction code
+            -u, --user=             User name and password e.g. name:password
+            -v, --version           Display Version Details
+            -x, --xdisplay          Do not have a mainframe with -ptarBck
+            -z, --zerobar           Do not have a progressbar with -ptarBck
+""")
+            self.doExit(dbm=False)
+        if not self.version and not self.xdisplay:
+            nodisp = ("tarBck", "tarUpd", "ml6030")
+            if not self.query and self.program not in nodisp:
+                print("xdisplay False but program not in %s" % str(nodisp))
+                self.doExit(dbm=False)
+            elif not self.user:
+                print("xdisplay False but No User Name")
+                self.doExit(dbm=False)
+        if not self.version and self.xdisplay and not GUI:
+            print("Tkinter/ttk not Available or Installed")
+            self.doExit(dbm=False)
+        if self.version:
+            nm = platform.uname()
+            print("%-16s: %s, %s, %s" % ("O/System", nm[0], nm[2], nm[4]))
+            print("%-16s: %s" % ("Tartan", self.current[1]))
+            print("%-16s: %s" % ("Python", sys.version.split()[0]))
+            if self.xdisplay:
+                from TartanClasses import tk
+                from PIL import VERSION
+                print("%-16s: %s" % ("Tcl/Tk",
+                        tk.Tcl().eval("info patchlevel")))
+                print("%-16s: %s" % ("PIL", VERSION))
+            try:
+                import fdb
+                print("%-16s: %s" % ("FDB", fdb.__version__))
+            except:
+                pass
+            try:
+                import MySQLdb
+                print("%-16s: %s" % ("MySQLdb", MySQLdb.__version__))
+            except:
+                try:
+                    import pymysql
+                    print("%-16s: %s" % ("Pymysql", pymysql.__version__))
+                except:
+                    pass
+            try:
+                import psycopg2
+                print("%-16s: %s" % ("Psycopg2",
+                        psycopg2.__version__.split()[0]))
+            except:
+                pass
+            try:
+                import pychart.version
+                print("%-16s: %s" % ("Pychart", pychart.version.version))
+            except:
+                pass
+            try:
+                import sqlite3
+                print("%-16s: %s" % ("Pysqlite", sqlite3.version))
+                print("%-16s: %s" % ("Sqlite3", sqlite3.sqlite_version))
+            except:
+                pass
+            try:
+                print("%-16s: %s" % ("Fpdf", fpdf.__version__))
+            except:
+                pass
+            try:
+                import xlrd
+                print("%-16s: %s" % ("Xlrd", xlrd.info.__VERSION__))
+            except:
+                pass
+            try:
+                import xlwt
+                print("%-16s: %s" % ("Xlwt", xlwt.__VERSION__))
+            except:
+                pass
+            self.doExit(dbm=False)
+        if self.debug:
+            # Set trace mode
+            import trace
+            igm = ["__init__"]
+            if self.exclude:
+                igm.extend(self.exclude)
+            if sys.platform == "win32" and \
+                    os.path.basename(sys.path[0]) == "library.zip":
+                igd = []
+                for mod in sys.modules:
+                    igm.append(mod)
+            else:
+                igd = [sys.prefix, sys.exec_prefix]
+            os.environ["TARTANDB"] = "1"
+            self.tracer = trace.Trace(ignoredirs=igd, ignoremods=igm,
+                trace=1, count=0)
+        self.setVariables()
+        if self.rcfdir:
+            if not os.path.isdir(self.rcfdir):
+                showError(None, "Directory Error",
+                    "Invalid -R Directory: %s" % self.rcfdir)
+                self.doExit(dbm=False)
+            icon = os.path.join(getPrgPath(), "img", "tartan.png")
+            scrn = MkWindow(tk=True, icon=icon).newwin
+            dialog = FileDialog(**{"parent": scrn, "initd": self.rcfdir})
+            self.rcfile = dialog.askopenfilename()
+            scrn.destroy()
+            if not self.rcfile:
+                self.doExit(dbm=False)
+        self.mf = None
+        self.rcdic = None
+        main = "Tartan Systems - Copyright %s 2004-2017 P Malherbe" % u"\u00A9"
+        while not self.rcdic:
+            self.rcdic = loadRcFile(self.rcfile, default=True)
+            if self.rcdic == "error":
+                self.doExit(dbm=False)
+            elif not os.path.isfile(self.rcdic["name"]):
+                self.mf = MainFrame(title=main, rcdic=self.rcdic)
+                if self.mf.rcdic == "error":
+                    self.doExit(dbm=False)
+                self.mf.window.deiconify()
+                self.mf.dbm = None
+                cfg = TartanConfig(self.mf, rcfile=self.rcfile,
+                    rcdic=self.rcdic, level=9)
+                if not cfg.rcfile:
+                    self.doExit(dbm=False)
+                self.rcfile = self.mf.rcfile = cfg.rcfile
+                self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
+        titl = "%s - (%s - %s@%s)" % (main, self.rcdic["dbase"],
+            self.rcdic["dbname"], self.rcdic["dbhost"])
+        if not self.mf:
+            # Create MainFrame if not already existing
+            self.mf = MainFrame(title=titl, rcdic=self.rcdic,
+                xdisplay=self.xdisplay)
+            if self.mf.rcdic == "error":
+                self.doExit(dbm=False)
+        else:
+            self.mf.window.title(titl)
+        # Try connecting to the database and create if missing
+        if self.mf.children:
+            screen = self.mf.body
+        else:
+            screen = self.mf.window
+        self.db = Dbase(rcdic=self.rcdic, screen=screen)
+        if self.db.err:
+            self.doExit(dbm=False)
+        self.mf.dbm = self.db
+        err = self.db.checkDbase()
+        if err not in (True, False):
+            self.doExit()
+        elif err is False:
+            ok = askQuestion(self.mf.window, "Database",
+                "Create the Database Now?")
+            if ok == "no":
+                self.doExit()
+            else:
+                opts = [
+                    ("-c", "i"),
+                    ("-d", "%s" % os.path.join(self.rcdic["prgdir"], "csv")),
+                    ("-l", self.mf.body),
+                    ("-u", self.rcdic["dbuser"]),
+                    ("-p", self.rcdic["dbpwd"]),
+                    ("-s", self.sysmod),
+                    ("-v", self.current[1]),
+                    ("-x", True)]
+                DBCreate(dbm=self.db, opts=opts)
+                self.tarUpd(True)
+        if not self.nocheck:
+            # Open the database
+            self.db.openDbase()
+            # Check for ctlsys and ctlmst
+            err = self.doCheckSys()
+            # Check for ctlmst and if missing call ms1010 or scc110
+            if not err:
+                err = self.doCheckMst()
+            # Close the database
+            if err:
+                self.doExit()
+            self.db.closeDbase()
+        if not self.user:
+            # Login user
+            self.userLogin()
+        else:
+            # Check if user details supplied are valid
+            self.userReadCheck(user=self.user["name"], pwd=self.user["pwd"])
+        if not self.user:
+            self.doExit()
+        if not self.program or self.program != "tarUpd":
+            # Check tartan version
+            self.db.openDbase()
+            self.doVersionCheck()
+            self.db.closeDbase()
+        if self.query:
+            if self.user["lvl"] == 9:
+                err = self.doSqlCmd()
+            else:
+                err = "Invalid Security Level"
+            if err:
+                if self.xdisplay:
+                    showError(self.mf.body, "Data Base Error",
+                        "\nDbCommand Error: %s\n" % err)
+                else:
+                    print("Data Base Error", "DbCommand Error: %s\n" % err)
+            self.doExit()
+        if self.program:
+            mods = copyList(self.usrmod)
+            mods.append(["PNNN", "mm_sy", "tb1010", 9, "Amend Tables"])
+            mods.append(["PNNN", "mm_sy", "tb1030", 9, "Edit Tables"])
+            mods.append(["PNNN", "mm_sy", "tb3010", 9, "Print Tables"])
+            found = False
+            for mod in mods:
+                if mod[2] == self.program:
+                    if len(mod) == 5:
+                        found = True
+                        break
+                    elif len(mod) == 6 and mod[5] == self.tcode:
+                        found = True
+                        break
+            if found:
+                if self.xdisplay:
+                    self.mf.window.deiconify()
+                self.execCommand(mod[0], self.program, mod[4], rtn=self.tcode,
+                    menu=False)
+            self.doExit()
+        if self.itoggle:
+            if self.mf.rcdic["img"].lower() == "y":
+                self.image = False
+            else:
+                self.image = True
+        elif self.mf.rcdic["img"].lower() == "y":
+            self.image = True
+        else:
+            self.image = False
+        if self.image:
+            image = os.path.join(self.rcdic["prgdir"], "img", "tartan.png")
+        else:
+            image = None
+        self.tarmen = TartanMenu(mf=self.mf, usr=self.user["name"],
+            men=self.usrmen, mod=self.usrmod, lvl=self.user["lvl"],
+            cmd=self.execCommand, img=image)
+        if not self.doVersionCheck():
+            self.checkNotes()
+        self.tarmen.drawMenu()
+
+    def setVariables(self):
+        stdmen = __import__(self.menu)
+        self.vop = []
+        self.sss = {}
+        self.men = []
+        self.mod = []
+        self.cono = []
+        for s in stdmen.systems:
+            self.sss[s[0]] = s[1]
+            try:
+                self.men.extend(getattr(stdmen, "%2smen" % s[0]))
+                self.mod.extend(getattr(stdmen, "%2smod" % s[0]))
+            except:
+                pass
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        self.direct = False
+        self.tarmen = None
+        self.email = None
+
+    def userLogin(self):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        if not self.user:
+            self.userReadCheck()
+            if self.user and not self.user["pwd"]:
+                return
+        if self.user:
+            login = self.user["name"]
+        else:
+            try:
+                login = getpass.getuser()
+                if not self.userReadCheck(login, userchk=True):
+                    raise Exception
+            except:
+                login = ""
+        self.mf.head.configure(text="TARTAN User Login and Validation")
+        tit = ("User Validation",)
+        fld = (
+            (("T",0,0,0),"INA",30,"Name","Your User Name",
+                login,"N",self.usrNam,None,None,None,None,
+                "Your log-in Name"),
+            (("T",0,1,0),"IHA",30,"Password","Your Password",
+                "","N",self.usrPwd,None,None,None,None,
+                "Your password. You are allowed a Maximum of 3 attempts."))
+        but = (("Quit", None, self.noUser, 1, None, None),)
+        self.li = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.endUser, "n"),), txit=(self.noUser,))
+        self.mf.startLoop()
+        if dbopend:
+            self.db.closeDbase()
+
+    def usrNam(self, frt, pag, r, c, p, i, w):
+        self.userReadCheck(w)
+        if not self.user:
+            return "Invalid User"
+        if not self.user["pwd"]:
+            return "sk1"
+        self.times = 0
+
+    def usrPwd(self, frt, pag, r, c, p, i, w):
+        err = self.userCheckPwd(w)
+        if not err:
+            return "nc"
+        elif err == "Expired Password" or self.times == 2:
+            return "xt"
+        else:
+            self.times += 1
+            return "Invalid Password"
+
+    def noUser(self, widget=None):
+        self.user = {}
+        self.endUser()
+
+    def endUser(self):
+        self.li.closeProcess()
+        self.mf.closeLoop()
+
+    def userReadCheck(self, user=None, userchk=False, pwd=None, pwdchk=False):
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        sql = Sql(self.db, ["ctlmst", "ctlpwu", "ctlpwm"], prog="msc000")
+        if not user:
+            chk = sql.getRec(tables="ctlpwu")
+            if len(chk) == 1:
+                user = chk[0][sql.ctlpwu_col.index("usr_name")]
+        usr = sql.getRec(tables="ctlpwu", where=[("usr_name", "=", user)],
+            limit=1)
+        if userchk:
+            if dbopend:
+                self.db.closeDbase()
+            return usr
+        if not usr:
+            self.user = {}
+        else:
+            self.user = {
+                "name": user,
+                "pwd":  usr[sql.ctlpwu_col.index("usr_pwd")]}
+            if "usr_last" in sql.ctlpwu_col:
+                self.user["last"] = usr[sql.ctlpwu_col.index("usr_last")]
+            else:
+                self.user["last"] = 0
+            self.user["coy"] = usr[sql.ctlpwu_col.index("usr_coy")]
+            self.user["lvl"] = usr[sql.ctlpwu_col.index("usr_lvl")]
+            if pwdchk and self.user["pwd"] and self.userCheckPwd(pwd):
+                self.user = {}
+            if self.user:
+                self.cono = []
+                self.usrnam = self.user["name"]
+                self.pwd = self.user["pwd"]
+                coy = self.user["coy"]
+                self.lvl = self.user["lvl"]
+                if coy:
+                    coy = coy.split(",")
+                else:
+                    coy = []
+                for co in coy:
+                    if int(co):
+                        self.cono.append(int(co))
+                nos = []
+                # All systems not in the company modules
+                for sss in self.sss:
+                    if sss not in ("bm", "bs", "ca", "ms", "rp", "td"):
+                        nos.append(sss)
+                ctm = sql.getRec(tables="ctlmst", cols=["ctm_modules"])
+                for m in ctm:
+                    for x in xrange(0, len(m[0]), 2):
+                        if m[0][x:x+2].lower() in nos:
+                            nos.remove(m[0][x:x+2].lower())
+                # All systems excluded for the user - nos
+                tmp = sql.getRec(tables="ctlpwm", cols=["mpw_sys"],
+                    where=[("mpw_usr", "=", self.user["name"]),
+                    ("mpw_prg", "=", "")])
+                if tmp:
+                    for s in tmp:
+                        if s not in nos:
+                            nos.append(s[0])
+                # All modules excluded for the user - nop
+                nop = sql.getRec(tables="ctlpwm", cols=["mpw_sys", "mpw_prg"],
+                    where=[("mpw_usr", "=", self.user["name"]), ("mpw_prg",
+                    "<>", ""), ("mpw_pwd", "=", "")])
+                # All modules enabled for the user - self.vop
+                self.vop = sql.getRec(tables="ctlpwm", cols=["mpw_sys",
+                    "mpw_prg", "mpw_coy", "mpw_pwd"], where=[("mpw_usr",
+                    "=", self.user["name"]), ("mpw_prg", "<>", ""),
+                    ("mpw_pwd", "<>", "")])
+                if self.vop:
+                    for sss, mod, coy, pwd in self.vop:
+                        if sss in nos:
+                            # System in nos, remove system from nos
+                            nos.remove(sss)
+                            for prg in self.mod:
+                                # Add all modules in sss to nop
+                                if prg[2][:2] == sss:
+                                    nop.append([prg[2][:2], prg[2][2:]])
+                    for sss, mod, coy, pwd in self.vop:
+                        # Remove all enabled modules from nop
+                        if [sss, mod] in nop:
+                            nop.remove([sss, mod])
+                self.usrmen = []
+                self.usrmod = []
+                for men in self.men:
+                    add = True
+                    for sss in nos:
+                        if men[1] == "mm_%s" % sss:
+                            add = False
+                    if add:
+                        self.usrmen.append(men)
+                mods = copyList(self.mod)
+                for mod in mods:
+                    add = True
+                    for sss in nos:
+                        if mod[2][:2] == sss:
+                            add = False
+                    for sss, prg in nop:
+                        if mod[2] == "%s%s" % (sss, prg):
+                            add = False
+                    if add:
+                        self.usrmod.append(mod)
+        if dbopend:
+            self.db.closeDbase()
+
+    def userCheckPwd(self, pwd):
+        try:
+            crypt = b64Convert("decode", self.user["pwd"])
+        except:
+            crypt = self.user["pwd"]
+        if pwd == self.mf.override:
+            return
+        elif pwd in (self.user["pwd"], crypt):
+            pwlife = self.getCtlSys(["sys_pwlife"])
+            if not pwlife or not self.user["last"]:
+                return
+            t = time.localtime()
+            dte = (t[0] * 10000) + (t[1] * 100) + t[2]
+            chk = projectDate(self.user["last"], pwlife)
+            dif = dateDiff(dte, chk, ptype="days")
+            if not dif:
+                chg = askQuestion(self.mf.window, "Password Expired",
+                    "Your Password Has Expired.\n\nDo You Want to Renew It?")
+                tx = "Expired Password"
+            elif dif < 8:
+                chg = askQuestion(self.mf.window, "Password Expiring",
+                    "Your Password Expires in %s Day(s)!!!\n\nDo You Want "\
+                    "to Renew It Now?" % dif)
+                tx = None
+            else:
+                chg = "no"
+                tx = None
+            if chg == "yes":
+                self.chgPwd()
+                if self.new:
+                    return self.userCheckPwd(self.new)
+                else:
+                    return self.userCheckPwd(self.user["pwd"])
+            else:
+                return tx
+        else:
+            return "Invalid Password"
+
+    def userLogout(self):
+        self.user = {}
+
+    def execCommand(self, typ, prg, tit="", rtn=None, menu=True, password=True):
+        if menu:
+            self.tarmen.closeMenu()
+        if prg not in ("sysUpd", "sysEnd"):
+            if prg == "tarUpd":
+                vtype = "upd"
+            else:
+                vtype = "chk"
+            if self.doVersionCheck(vtype):
+                if menu:
+                    self.tarmen.drawMenu()
+                return
+        try:
+            rtn = int(rtn)
+        except:
+            rtn = None
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        if password and self.getCtlSys(["sys_pwmust"]) == "Y" and not \
+                self.user["pwd"] and prg not in ("chgPwd", "chgUsr", "sysEnd"):
+            showError(self.mf.window, "Missing Password",
+                """Passwords are Enforced.
+
+Please Create a Password by going to:
+
+System --> Change Password""")
+        elif typ[0] == "F":
+            if self.xdisplay:
+                self.mf.head.configure(text="%s (%s)" % (tit, prg))
+                self.mf.updateStatus("")
+            try:
+                getattr(self, prg)()
+            except:
+                if self.xdisplay:
+                    showException(self.mf.body, self.rcdic["wrkdir"],
+                        "Function %s Error" % prg, dbm=self.db)
+                else:
+                    showException(None, self.rcdic["wrkdir"],
+                        "Function %s Error" % prg, dbm=self.db)
+                if dbopend:
+                    self.db.closeDbase()
+                sys.exit()
+        elif typ[0] == "P":
+            self.mf.updateStatus("")
+            mcoy = None
+            error = False
+            if self.vop:
+                sss = prg[:2]
+                mmm = prg[2:]
+                if rtn:
+                    mmm = mmm[:3] + str(rtn)
+                for vvv in self.vop:
+                    if vvv[0] == sss and vvv[1] == mmm:
+                        mcoy, self.mpwd = vvv[2:]
+                        error = self.pwdCheck()
+            if not error:
+                popt = {"mf": self.mf}
+                text = tit
+                if typ[1] == "Y":
+                    if typ[2] in ("L", "Y"):
+                        if self.program and self.conum:
+                            error = self.conoCheck(self.conum, prg=prg)
+                            if not error and typ[2] == "L":
+                                self.getLastPeriod()
+                        else:
+                            self.getCompany(prg=prg, period=typ[2])
+                        if not self.conum:
+                            error = True
+                        else:
+                            if prg in ("gl3030", "gl3040", "gl3050", "gl3080",
+                                    "gl4010", "gl4020", "gl6030", "gl6040"):
+                                check = True
+                            else:
+                                check = False
+                            per = getPeriods(self.mf, self.conum, self.finper,
+                                check=check)
+                            if per == (None, None, None):
+                                error = True
+                            elif rtn and per[2] == "Y":
+                                showError(self.mf.body, "Period Error",
+                                    "This Period Has Already Been Finalised")
+                                error = True
+                            else:
+                                popt["period"] = (self.finper, (per[0].work,
+                                    per[0].disp), (per[1].work, per[1].disp))
+                    else:
+                        if self.program and self.conum:
+                            error = self.conoCheck(self.conum, prg=prg)
+                        else:
+                            self.getCompany(prg=prg, period=False)
+                        if not self.conum:
+                            error = True
+                    if mcoy and self.conum != mcoy:
+                        showError(self.mf.body, "Company Error",
+                            "This Company, Module Combination "\
+                            "is Not Allowed for This User")
+                        error = True
+                    if not error:
+                        popt["conum"] = self.conum
+                        popt["conam"] = self.conam
+                        text = "%-s for %s (%s)" % (text, self.conam, prg)
+                else:
+                    text = "%-s for All Companies (%s)" % (text, prg)
+            if not error:
+                if typ[3] == "Y":
+                    popt["capnm"] = self.user["name"]
+                if prg == "ml1010":
+                    popt["level"] = self.user["lvl"]
+                if rtn:
+                    popt["rtn"] = int(rtn)
+                if self.xdisplay:
+                    self.mf.head.configure(text=text)
+                    self.mf.updateStatus("")
+                if self.debug:
+                    self.tracer.runfunc(self.doRunModule, prg, **popt)
+                else:
+                    self.doRunModule(prg, **popt)
+        if dbopend:
+            try:
+                # Rollback any uncommitted transactions
+                self.db.rollbackDbase()
+            except:
+                pass
+            # Close the database
+            self.db.closeDbase()
+        if menu:
+            # Display the menu
+            if prg == "ms1010":
+                self.userReadCheck(user=self.user["name"])
+                self.tarmen.lvl = self.user["lvl"]
+                self.tarmen.men = self.usrmen
+                self.tarmen.mod = self.usrmod
+                self.tarmen.setVariables()
+            if not self.doVersionCheck():
+                self.checkNotes()
+            self.tarmen.drawMenu()
+
+    def pwdCheck(self):
+        tit = ("Password Validation",)
+        fld = ((("T",0,0,0),"IHA",30,"Password","Password","","N",
+                self.doPGet,None,None,None,None),)
+        but = (("Cancel", None, self.doPCancel, 1, None, None),)
+        self.df = TartanDialog(self.mf, tops=True, title=tit, eflds=fld,
+            butt=but, tend=((self.doPEnd, "n"),), txit=(self.doPCancel,))
+        self.mf.startLoop()
+        return self.pwderr
+
+    def doPGet(self, frt, pag, r, c, p, i, w):
+        if w != b64Convert("decode", self.mpwd):
+            return "Invalid Password"
+        self.pwderr = False
+
+    def doPCancel(self, widget=None):
+        self.pwderr = True
+        self.doPEnd()
+
+    def doPEnd(self):
+        self.df.closeProcess()
+        self.mf.closeLoop()
+
+    def conoCheck(self, coy, prg=None, ctl=False):
+        if self.cono and not self.cono.count(coy):
+            self.conum = None
+            return "Unavailable Company Number"
+        gcl = GetCtl(self.mf)
+        chk = gcl.getCtl("ctlmst", coy, error=False)
+        if not chk:
+            self.conum = None
+            return "Invalid Company"
+        if ctl:
+            return
+        self.conum = coy
+        self.conum = chk["ctm_cono"]
+        self.conam = chk["ctm_name"]
+        self.email = chk["ctm_email"]
+        self.modul = chk["ctm_modules"]
+        if not prg:
+            return
+        # Check Module
+        mod = prg[:2].upper()
+        if mod in ("BM", "CA", "MS", "RP", "TD"):
+            return
+        for x in xrange(0, len(self.modul), 2):
+            if self.modul[x:x + 2] == mod:
+                return
+        return "System (%s) Not Enabled for Company %s" % (mod, self.conum)
+
+    def getCompany(self, prg=None, period=None):
+        self.prg = prg
+        self.pertyp = period
+        sql = Sql(self.db, "ctlmst", prog="msc000")
+        if self.cono:
+            whr = [("ctm_cono", "in", tuple(self.cono))]
+        else:
+            whr = None
+        coy = sql.getRec(tables="ctlmst", where=whr, order="ctm_cono")
+        if not coy:
+            showError(self.mf.window, "Error", "No Valid Company Records.")
+            return
+        self.coys = len(coy)
+        if self.coys == 1:
+            # Single Company
+            self.conum = coy[0][sql.ctlmst_col.index("ctm_cono")]
+            self.conam = coy[0][sql.ctlmst_col.index("ctm_name")].rstrip()
+            self.email = coy[0][sql.ctlmst_col.index("ctm_email")].rstrip()
+            self.modul = coy[0][sql.ctlmst_col.index("ctm_modules")].rstrip()
+            if not self.pertyp:
+                self.finper = None
+                return
+        if not self.conum:
+            if self.cono:
+                self.conum = self.cono[0]
+            else:
+                self.conum = 1
+        csel = {
+            "stype": "R",
+            "tables": ("ctlmst",),
+            "cols": (
+                ("ctm_cono", "", 0, "Com"),
+                ("ctm_name", "", 0, "Name", "Y")),
+            "order": "ctm_cono"}
+        if self.cono:
+            csel["where"] = [("ctm_cono", "in", tuple(self.cono))]
+        if self.coys == 1:
+            # Single Company
+            tit = (self.conam,)
+            fld = []
+        else:
+            tit = ("Company Details",)
+            fld = [
+                [("T",0,0,0),"IUI",3,"Company Number","",
+                    self.conum,"N",self.coNum,csel,None,("notzero",)],
+                [("T",0,1,0),"ONA",30,"Company Name","",
+                    "","N",None,None,None,None]]
+        if self.pertyp == "Y":
+            self.psel = {
+                "stype": "R",
+                "tables": ("ctlynd",),
+                "cols": (
+                    ("cye_period", "", 0, "Prd"),
+                    ("cye_start", "", 0, "Start"),
+                    ("cye_end", "", 0, "End"),
+                    ("cye_final", "", 0, "F")),
+                "where": []}
+            fld.append(
+                [["T",0,2,0],"IUI",3,"Financial Period","",
+                    0,"N",self.finPeriod,self.psel,None,None])
+            if self.coys == 1:
+                self.psel["where"] = [("cye_cono", "=", self.conum)]
+                fld[0][0][2] = 0
+                self.getLastPeriod()
+                fld[0][5] = self.finper
+        elif self.pertyp == "L":
+            self.getLastPeriod()
+            if self.coys == 1:
+                return
+        else:
+            self.finper = None
+            if self.coys == 1:
+                return
+        but = (("Cancel", None, self.coExit, 1, ("T",0,1), ("T",0,0)),)
+        self.cp = TartanDialog(self.mf, title=tit, tops=True, eflds=fld,
+            butt=but, tend=((self.coEnd, "y"),), txit=(self.coExit,))
+        if self.conum:
+            try:
+                self.cp.loadEntry("T", 0, 0, data=self.conum)
+                self.cp.loadEntry("T", 0, 1, data=self.conam)
+                if self.pertyp == "Y" and self.finper is not None:
+                    self.cp.topf[0][2][5] = self.finper
+                    self.cp.loadEntry("T", 0, 2, data=self.finper)
+            except:
+                pass
+        self.cp.focusField("T", 0, 1)
+        self.mf.startLoop()
+
+    def coNum(self, frt, pag, r, c, p, i, w):
+        err = self.conoCheck(w, prg=self.prg)
+        if err:
+            return err
+        self.cp.loadEntry("T", pag, p+1, data=self.conam)
+        if not self.pertyp or self.pertyp == "L":
+            return "ok"
+        self.psel["where"] = [("cye_cono", "=", self.conum)]
+        if self.finper is None:
+            self.getLastPeriod()
+        self.cp.topf[0][2][5] = self.finper
+
+    def getLastPeriod(self):
+        sql = Sql(self.db, "ctlynd", prog="msc000")
+        p = sql.getRec(tables="ctlynd", cols=["max(cye_period)"],
+            where=[("cye_cono", "=", self.conum)])
+        self.finper = int(p[0][0])
+
+    def finPeriod(self, frt, pag, r, c, p, i, w):
+        sql = Sql(self.db, "ctlynd", prog="msc000")
+        r = sql.getRec(tables="ctlynd", cols=["cye_period"],
+            where=[("cye_cono", "=", self.conum), ("cye_period", "=", w)],
+            limit=1)
+        if not r:
+            return "Invalid Financial Period"
+        self.finper = w
+
+    def coExit(self, widget=None):
+        self.conum = None
+        self.coEnd()
+
+    def coEnd(self):
+        self.cp.closeProcess()
+        self.mf.closeLoop()
+
+    def doRunModule(self, *prg, **popt):
+        if self.loader and prg[0] in sys.modules:
+            del(sys.modules[prg[0]])
+            gc.collect()
+        try:
+            if "rtn" in popt:
+                rtn = popt["rtn"]
+            else:
+                rtn = 0
+            sql = Sql(self.mf.dbm, ["ffield", "ctllog"], prog="msc000")
+            if not sql.error:
+                chk = sql.getRec(tables="ffield",
+                    where=[("ff_tabl", "=", "ctllog")])
+            if not sql.error and len(chk) == 7:
+                if not self.user:
+                    name = "admin"
+                else:
+                    name = self.user["name"]
+                logd = [getpass.getuser(), name, prg[0], rtn]
+                if "conum" in popt:
+                    logd.append(popt["conum"])
+                else:
+                    logd.append(0)
+                if "period" in popt:
+                    logd.append(popt["period"][0])
+                else:
+                    logd.append(0)
+                logd.append(long(
+                    "%04i%02i%02i%02i%02i%02i" % time.localtime()[:-3]))
+                sql.insRec("ctllog", data=logd)
+                self.mf.dbm.commitDbase()
+            runModule(prg[0], **popt)
+        except:
+            if self.xdisplay:
+                for wgt in self.mf.window.winfo_children():
+                    if wgt not in (self.mf.head, self.mf.body, self.mf.status):
+                        wgt.destroy()
+                showException(self.mf.body, self.rcdic["wrkdir"],
+                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+            else:
+                showException(None, self.rcdic["wrkdir"],
+                    "Mod: %s or Arg: %s Error" % (prg, popt), dbm=self.db)
+
+    def checkNotes(self):
+        self.db.openDbase()
+        t = time.localtime()
+        self.cdate = ((t[0] * 10000) + (t[1] * 100) + t[2])
+        self.sql = Sql(self.db, ["ctlnot", "ctlpwu"], prog="msc000")
+        chk = self.sql.getRec(tables="ctlnot", where=[("(", "not_user", "=",
+            self.user["name"], "or", "not_auser", "=", self.user["name"],
+            ")"), ("not_adate", ">", 0), ("not_adate", "<=", self.cdate),
+            ("not_aflag", "<>", "C")])
+        if chk:
+            ok = askQuestion(self.mf.window, "Notes", "There are Notes "\
+                "Flagged for Action Still Outstanding, do You want to "\
+                "View them?")
+            if ok == "yes":
+                self.showNotes(chk)
+        self.db.closeDbase()
+
+    def showNotes(self, notes):
+        data = []
+        for note in notes:
+            nte = note[:4]
+            nte.append(note[6])
+            nte.append(note[7])
+            nte.append(note[8])
+            nte.append(note[5])
+            nte.append(note[9])
+            data.append(nte)
+        tits = "Today's Notes"
+        cols = [
+            ("not_cono", "Coy", 3, "UI", "N"),
+            ("not_sys", "Sys", 3, "UA", "N"),
+            ("not_key", "Key", 30, "NA", "N"),
+            ("not_date", "Entry-Date", 10, "D1", "N"),
+            ("not_aflag", "F", 1, "UA", "N"),
+            ("not_adate", "Action-Dte", 10, "d1", "N"),
+            ("not_auser", "Action-User", 20, "NA", "N"),
+            ("not_desc", "Description", 50, "TX", "N"),
+            ("not_seq", "Sequence", 10, "US", "N")]
+        sr = SelectChoice(self.mf.body, tits, cols, data)
+        if sr.selection:
+            self.selectNote(sr.selection)
+            self.checkNotes()
+
+    def selectNote(self, note):
+        self.chgflag = note[5]
+        self.chgdate = note[6]
+        self.chguser = note[7]
+        self.nseq = note[-1:][0]
+        tit = ("Notes Editing",)
+        r1s = (("Normal","N"),("Urgent","U"),("Completed","C"))
+        fld = (
+            (("T",0,0,0),"O@not_date",0,""),
+            (("T",0,1,0),"O@not_user",0,""),
+            (("T",0,2,0),"OTV",(50,10),"Details"),
+            (("T",0,3,0),("IRB",r1s),0,"Action Flag (C/N/U)","Action Flag",
+                "N","N",self.doChgFlag,None,None,None),
+            (("T",0,4,0),"I@not_adate",0,"","",
+                "","N",self.doChgDate,None,None,("efld",)),
+            (("T",0,5,0),"I@not_auser",0,"","",
+                "","N",self.doChgUser,None,None,("efld",)))
+        but = (
+            ("Accept",None,self.doNEnd,1,None,None),
+            ("Cancel",None,self.doNExit,1,None, None))
+        tnd = ((self.doNEnd, "n"), )
+        txt = (self.doNExit, )
+        self.nf = TartanDialog(self.mf, title=tit, eflds=fld, butt=but,
+            tend=tnd, txit=txt, focus=False)
+        self.nf.loadEntry("T", 0, 0, data=note[4])
+        self.nf.loadEntry("T", 0, 1, data=self.user["name"])
+        mess = note[8]
+        #if len(note) > 7:
+        #    for x in xrange(6, len(note) - 1):
+        #        mess = "%s\n%s" % (mess, note[x])
+        self.nf.loadEntry("T", 0, 2, data=mess)
+        self.nf.loadEntry("T", 0, 3, data=note[5])
+        self.nf.loadEntry("T", 0, 4, data=note[6])
+        self.nf.loadEntry("T", 0, 5, data=note[7])
+        if self.chgflag == "C":
+            self.nf.setWidget(self.nf.B0, "normal")
+            self.nf.setWidget(self.nf.B1, "normal")
+        else:
+            self.nf.focusField("T", 0, 4)
+        self.mf.startLoop()
+
+    def doChgFlag(self, frt, pag, r, c, p, i, w):
+        self.chgflag = w
+        if self.chgflag == "C":
+            return "nd"
+
+    def doChgDate(self, frt, pag, r, c, p, i, w):
+        self.chgdate = w
+
+    def doChgUser(self, frt, pag, r, c, p, i, w):
+        usr = self.sql.getRec(tables="ctlpwu", where=[("usr_name", "=", w)],
+            limit=1)
+        if not usr:
+            return "Invalid User Name"
+        self.chguser = w
+        return "nd"
+
+    def doNEnd(self, widget=None):
+        self.sql.updRec("ctlnot", cols=["not_aflag", "not_adate", "not_auser"],
+            data=[self.chgflag, self.chgdate, self.chguser], where=[("not_seq",
+            "=", self.nseq)])
+        self.db.commitDbase()
+        self.doNExit()
+
+    def doNExit(self, widget=None):
+        self.nf.closeProcess()
+        self.mf.closeLoop()
+
+    def chgUsr(self):
+        self.userLogout()
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        self.userLogin()
+        if dbopend:
+            self.db.closeDbase()
+        if not self.user:
+            self.doExit()
+        self.tarmen.usr = self.user["name"]
+        self.tarmen.lvl = self.user["lvl"]
+        self.tarmen.men = self.usrmen
+        self.tarmen.mod = self.usrmod
+        self.tarmen.setVariables()
+
+    def chgPwd(self):
+        tit = ("Change Password",)
+        fld = (
+            (("T",0,0,0),"IHA",30,"Old Password","",
+                "","N",self.doOldPwd,None,None,None,None),
+            (("T",0,1,0),"IHA",30,"New Password","",
+                "","N",self.doNewP1,None,None,None,None),
+            (("T",0,2,0),"IHA",30,"New Password","New Password Again",
+                "","N",self.doNewP2,None,None,None,None))
+        but = (("Cancel", None, self.doPwdExit, 1, None, None),)
+        self.np = TartanDialog(self.mf, title=tit, eflds=fld, butt=but,
+            tend=((self.doPwdEnd, "n"),), txit=(self.doPwdExit,))
+        if not self.pwd:
+            self.np.skip[self.np.pag].append(1)
+            self.np.focusField(self.np.frt, self.np.pag, col=2)
+        self.mf.startLoop()
+
+    def doOldPwd(self, frt, pag, r, c, p, i, w):
+        if w == self.pwd or w == b64Convert("decode", self.pwd):
+            pass
+        else:
+            return "Invalid Old Password"
+
+    def doNewP1(self, frt, pag, r, c, p, i, w):
+        if w == self.pwd or w == b64Convert("decode", self.pwd):
+            return "Same Password"
+        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
+        if not w and pwmust == "Y":
+            return "You Must Have a Password"
+        if pwsize and len(w) < pwsize:
+            return "Minimum of %s Characters Required" % pwsize
+        self.new = w
+
+    def doNewP2(self, frt, pag, r, c, p, i, w):
+        if w != self.new:
+            return "Invalid New Password"
+        self.pwd = b64Convert("encode", w)
+
+    def doPwdEnd(self, widget=None):
+        pwmust, pwsize = self.getCtlSys(["sys_pwmust", "sys_pwsize"])
+        if not self.pwd and pwmust == "Y":
+            if not self.pwd:
+                self.np.skip[self.np.pag].append(1)
+                self.np.focusField(self.np.frt, self.np.pag, col=2)
+            else:
+                self.np.focusField(self.np.frt, self.np.pag, col=1)
+            self.mf.updateStatus("You Must Have a Password",
+                bg="white", fg="red")
+            return
+        t = time.localtime()
+        dte = (t[0] * 10000) + (t[1] * 100) + t[2]
+        sql = Sql(self.db, "ctlpwu", prog="msc000")
+        sql.updRec("ctlpwu", cols=["usr_pwd", "usr_last"], data=[self.pwd,
+            dte], where=[("usr_name", "=", self.user["name"])])
+        self.db.commitDbase()
+        self.user["pwd"] = self.pwd
+        self.user["last"] = dte
+        self.np.closeProcess()
+        self.mf.closeLoop()
+
+    def doPwdExit(self, widget=None):
+        self.new = None
+        self.np.closeProcess()
+        self.mf.closeLoop()
+
+    def tarUsr(self):
+        sss = []
+        prg = {}
+        keys = list(self.sss.keys())
+        keys.sort()
+        for s in keys:
+            sm = []
+            sss.append((self.sss[s], s))
+            for mod in self.mod:
+                if mod[0][0] == "P" and mod[2][:2] == s:
+                    if len(mod) == 6:
+                        mod[2] = "%s%s" % (mod[2][:5], mod[5])
+                    sm.append((mod[3], mod[2][2:], mod[4]))
+            prg[s] = sm
+        TartanUser(self.mf, sss, prg)
+
+    def sysUpd(self):
+        tit = ("System Upgrade",)
+        typ = (("Internet", "I"), ("Local", "L"))
+        fld = (
+            (("T",0,0,0),("IRB",typ),0,"Upgrade Type","",
+                "I","N",self.doSysLoc,None,None,None,None),
+            (("T",0,1,0),"ONA",9,"Current Version","",
+                "","N",None,None,None,None,None),
+            (("T",0,2,0),"ONA",9,"Upgrade Version","",
+                "","N",None,None,None,None,None))
+        but = (
+            ("Upgrade", None, self.doSysUpgrade, 0, ("T",0,0), ("T",0,1)),
+            ("Cancel", None, self.doSysUpdXit, 1, None, None))
+        self.su = TartanDialog(self.mf, title=tit, eflds=fld, butt=but,
+            tend=None, txit=(self.doSysUpdXit,))
+        self.mf.startLoop()
+
+    def doSysLoc(self, frt, pag, r, c, p, i, w):
+        self.updtyp = w
+        sql = Sql(self.db, "ctlmst", prog="msc000")
+        chk = sql.getRec(tables="ctlmst", cols=["ctm_modules"],
+            group="ctm_modules")
+        self.upgsys = ""
+        for mod in chk:
+            if mod == ["BC"] and self.upgsys is not "Tartan":
+                self.upgsys = "Bwlclb"
+            elif mod == ["SC"] and self.upgsys is not "Tartan":
+                self.upgsys = "Seccmp"
+            else:
+                self.upgsys = "Tartan"
+        if self.updtyp == "I":
+            err = self.doSysChkUpgrade()
+            if err:
+                showError(self.mf.window, err[0], err[1])
+                return "Upgrade Error"
+            else:
+                self.su.loadEntry("T", 0, 1, data=self.current[1])
+                self.su.loadEntry("T", 0, 2, data=self.nvtxt)
+                return
+        self.su.setWidget(self.su.mstFrame, "hide")
+        if sys.platform == "win32":
+            ftype = [("Upgrade Files", "%s_5.*.exe" % self.upgsys)]
+        else:
+            ftype = [("Upgrade Files", "%s_5.*.tgz" % self.upgsys)]
+        dialog = FileDialog(**{
+            "parent": self.mf.body,
+            "title": "Select Upgrade File",
+            "initd": self.rcdic["upgdir"],
+            "ftype": ftype})
+        self.updfle = dialog.askopenfilename()
+        self.su.setWidget(self.su.mstFrame, "show")
+        if not self.updfle:
+            return "Invalid File"
+        self.su.loadEntry("T", 0, 1, data=self.current[1])
+        nv = os.path.basename(self.updfle).split("_")[1].split(".")
+        self.newver = (int(nv[0]), int(nv[1]), int(nv[2]))
+        self.nvtxt = "%s.%s.%s" % self.newver
+        self.su.loadEntry("T", 0, 2, data=self.nvtxt)
+        self.su.setWidget(self.su.B0, "focus")
+        if int(nv[0]) > self.current[0][0]:
+            return
+        if int(nv[0]) == self.current[0][0]:
+            if int(nv[1]) > self.current[0][1]:
+                return
+            if int(nv[1]) == self.current[0][1]:
+                if int(nv[2]) > self.current[0][2]:
+                    return
+        self.updfle = None
+        showError(self.mf.window, "Invalid Version",
+            "Not Later Than Current Version.")
+        return "Version Error"
+
+    def doSysChkUpgrade(self):
+        try:
+            err = self.conoCheck(1)
+            if err or not self.email:
+                self.email = "info@tartan.co.za"
+            flenam = cStringIO.StringIO()
+            err = ftpDownload("tartan.co.za", "current",
+                word=self.email, dest=flenam)
+            if err:
+                raise Exception
+            v = flenam.getvalue()
+            flenam.close()
+            # Read and create Tartan file
+            v = v.rstrip().split(".")
+            self.newver = (int(v[0]), int(v[1]), int(v[2]))
+            self.nvtxt = "%s.%s.%s" % self.newver
+            if self.newver[0] > self.current[0][0]:
+                return
+            elif self.newver[0] == self.current[0][0]:
+                if self.newver[1] > self.current[0][1]:
+                    return
+                elif self.newver[1] == self.current[0][1]:
+                    if self.newver[2] > self.current[0][2]:
+                        return
+            return ("Upgrade Error", "No Upgrade Available")
+        except:
+            return ("Connection Error", """Please Ensure that You Are Connected to the Internet.
+
+
+"If Not, Please Connect and then Try Again!""")
+
+    def doSysUpgrade(self, widget=None):
+        self.su.closeProcess()
+        self.mf.updateStatus("")
+        self.mf.closeLoop()
+        ScrollText(scrn=self.mf.body, mess="""
+                        Performing the Upgrade
+
+  After the update has completed you must perform the following:
+
+  1) If you are running Linux the downloaded file will be in your
+     '~/upg' directory. The file's name will be something like
+     '%s_5.x.x.tgz'.
+
+                                 or
+
+  1) If you are running Windows the downloaded file will be in your
+     'C:\\Tartan\\upg' directory. The file's name will be something like
+     '%s_5.x.x.exe'.
+  2) Restart Tartan.
+  3) Execute the 'Update File Formats' routine on the 'System' menu.
+  4) If Tartan is installed on other workstations, copy the downloaded
+     file to those other workstations and either, in the case of linux,
+     extract the file into the ~/prg directory or, in the case of
+     Windows, execute the file.""" % (self.upgsys, self.upgsys))
+        try:
+            if self.updtyp == "I":
+                if sys.platform == "win32":
+                    nam = self.upgsys + "_%s.%s.%s_upd" % self.newver + ".exe"
+                    if not ftpDownload("tartan.co.za", nam, check=True):
+                        nam = self.upgsys + "_%s.%s.%s" % self.newver + ".exe"
+                else:
+                    nam = self.upgsys + "_%s.%s.%s" % self.newver + ".tgz"
+                fle = os.path.join(self.mf.rcdic["upgdir"], nam)
+                err = ftpDownload("tartan.co.za", nam, word=self.email,
+                    dest=fle, close=True)
+                if err:
+                    raise Exception
+            else:
+                fle = self.updfle
+            if sys.platform == "win32":
+                os.spawnv(os.P_NOWAIT, fle, (fle,))
+            else:
+                os.spawnv(os.P_NOWAIT, "/bin/tar",
+                    ("tar", "-xzf", fle, "-C", self.mf.rcdic["prgdir"]))
+            os._exit(0)
+        except:
+            showError(self.mf.window, "Get Error",
+                "Upgrade File Could Not be Retrieved.\n\n"\
+                "Your System Has Not Been Upgraded.\n\n"\
+                "Please Contact Your IT Manager.")
+            self.doSysUpdXit()
+
+    def doSysUpdXit(self, widget=None):
+        self.su.closeProcess()
+        self.mf.closeLoop()
+
+    def tarUpd(self, dbcreate=False):
+        if not dbcreate:
+            # Check on status of Database
+            if self.mf.window:
+                ok = askQuestion(self.mf.window, "Backup",
+                    "Have You Backed Up the Database?", default="no")
+            else:
+                ok = raw_input("Have You Backed Up the Database? (yes/no) ")
+            if ok != "yes":
+                return
+        else:
+            if self.xdisplay:
+                self.mf.head.configure(text="Update File Formats (tarUpd)")
+                self.mf.updateStatus("")
+        dbopen = self.db.dbopen
+        if not dbopen:
+            self.db.openDbase()
+        popt = {
+            "mf": self.mf,
+            "bar": True,
+            "cln": True,
+            "pth": os.path.join(self.mf.rcdic["prgdir"], "csv"),
+            "pwd": self.mf.rcdic["dbpwd"],
+            "rcf": self.rcfile,
+            "sss": self.sysmod,
+            "upd": False,
+            "usr": self.mf.rcdic["dbuser"],
+            "ver": self.current[1]}
+        self.doRunModule("tb1020", **popt)
+        if not dbopen:
+            self.db.closeDbase()
+
+    def doVersionCheck(self, vtype="chk"):
+        error = None
+        self.oldver = (0, 0, 0)
+        self.ovtxt = "%s.%s.%s" % self.oldver
+        upddate = CCD(0, "d1", 10)
+        if self.xdisplay:
+            scrn = self.mf.window
+        else:
+            scrn = "text"
+        if not self.db.dbopen:
+            self.db.openDbase()
+            dbopend = True
+        else:
+            dbopend = False
+        sql = Sql(self.db, "verupd", prog="msc000")
+        if sql.error:
+            if vtype == "chk":
+                return "missing"
+            else:
+                return
+        ver = sql.getRec(tables="verupd", limit=1)
+        if ver:
+            v = ver[0].split(".")
+            self.oldver = (int(v[0]), int(v[1]), int(v[2]))
+            self.ovtxt = "%s.%s.%s" % self.oldver
+            upd = sql.getRec(tables="verupd", cols=["ver_upddate"],
+                where=[("ver_version", "=", ver[0])], limit=1)
+            if upd:
+                upddate = CCD(upd[0], "d1", 10)
+        if dbopend:
+            self.db.closeDbase()
+        if vtype == "chk" and not self.nocheck:
+            if self.oldver == (0, 0, 0):
+                error = "not"
+            elif self.oldver < (4, 1, 10):
+                error = "tooold"
+            elif self.oldver < self.current[0]:
+                error = "newer"
+            elif self.oldver > self.current[0]:
+                error = "older"
+        elif vtype == "upd":
+            if self.oldver == (0, 0, 0):
+                pass
+            elif self.oldver == self.current[0]:
+                error = "updated"
+            elif self.oldver > self.current[0]:
+                error = "older"
+        if error == "tooold":
+            showError(scrn, "Version Error",
+                """The Version of the Data, %s.%s.%s, is too Old.
+
+Please follow the upgrade instructions at http//www.tartan.co.za
+
+or
+
+Email info@tartan.co.za, with your current version number, for assistance.""" % self.oldver)
+            self.doExit()
+        elif error == "not":
+            showError(scrn, "Version Error", """'Update File Formats'
+Not Yet Done for this Version of TARTAN.""")
+        elif error == "newer":
+            if self.lvl < 8:
+                showError(scrn, "Version Error", """Your Version of TARTAN (%s) Is Newer than the File Formats!
+
+Please ask your Administrator to Update the File Formats.""" % self.current[1])
+                self.doExit()
+            else:
+                ok = askQuestion(scrn, "Version Error", """Your Version of TARTAN (%s) Is Newer than the File Formats!
+
+Do You Want to Update Your File Formats Now?""" % self.current[1],
+                default="yes")
+                if ok == "yes":
+                    self.tarUpd(True)
+                else:
+                    self.doExit()
+        elif error == "older":
+            showError(scrn, "Version Error", """Your Version of TARTAN (%s) Is Older than the File Formats!
+
+Please Upgrade Your Version of TARTAN.""" % self.current[1])
+        elif error == "updated":
+            ok = askQuestion(scrn, "Version Error", """Your File Formats for TARTAN (%s) were Already Updated on %s.
+
+Do You Want to Run the Update Again?""" % (self.current[1], upddate.disp))
+            if ok == "yes":
+                error = None
+        return error
+
+    def tarBck(self):
+        self.db.openDbase()
+        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarBck",
+            passwd=self.bpwd)
+        if cf.flag == "ok":
+            try:
+                sql = Sql(self.db, ["ctlmst", "ctlsys"], prog="msc000")
+                if sql.error:
+                    raise Exception
+                csys = sql.getRec(tables="ctlsys", cols=["sys_budays",
+                    "sys_msvr", "sys_mprt", "sys_msec", "sys_maut",
+                    "sys_mnam", "sys_mpwd"], limit=1)
+                if not csys:
+                    raise Exception
+            except:
+                csys = None
+            if self.zerobar:
+                TarBckRes(self.mf, mode="B", csys=csys, bar=False)
+            else:
+                TarBckRes(self.mf, mode="B", csys=csys)
+
+    def tarRes(self):
+        cf = PwdConfirm(self.mf, conum=0, system="MST", code="TarRes",
+            passwd=self.bpwd)
+        if cf.flag == "ok":
+            TarBckRes(self.mf, mode="R", ver=self.current[1])
+
+    def tarCfg(self):
+        cfg = TartanConfig(self.mf, rcdic=self.rcdic, level=self.lvl)
+        if cfg.rcfile:
+            self.rcfile = cfg.rcfile
+        self.rcdic = self.mf.rcdic = loadRcFile(self.rcfile)
+        geo = self.rcdic["geo"].split("x")
+        self.mf.geo = [int(geo[0]), int(geo[1])]
+        self.mf.resizeChildren()
+
+    def sysEnd(self):
+        self.userLogout()
+        self.doHousekeeping()
+        self.doExit()
+
+    def doAbout(self, event=None):
+        self.mf.destroyChildren()
+        self.about = AboutTartan(self.mf, self.current[1])
+
+    def doManual(self):
+        self.doBrowser("Manual")
+
+    def doQuick(self):
+        self.doBrowser("QuickStart")
+
+    def doBrowser(self, doc):
+        pdf = os.path.join(self.rcdic["prgdir"], "doc", "%s.pdf" % doc)
+        if os.path.exists(pdf):
+            exe, cmd = parsePrg(self.rcdic["vwr"])
+            cmd.append(pdf)
+            os.spawnv(os.P_NOWAIT, exe, tuple(cmd))
+        elif internetConnect():
+            try:
+                import webbrowser
+                web = "http://tartan.co.za/cgi-bin/simple_web.py/%s" % doc
+                webbrowser.open(web)
+            except:
+                showError(self.mf.window, "Error", "Browser Not Found.")
+        else:
+            showError(self.mf.window, "Error", "No Internet Connection.")
+
+    def doHousekeeping(self):
+        fles = []
+        for tp in ("csv", "gif", "jpg", "odt", "pdf", "png", "ps", "xls"):
+            fles.extend(glob.glob(os.path.join(self.rcdic["wrkdir"],
+                "*.%s" % tp)))
+        if fles:
+            ask = askQuestion(self.mf.body, "Temporary Files",
+                "Do you wish to Keep the Temporary Report Files "\
+                "in the wrk Directory?", default="no")
+            if ask == "no":
+                for fle in fles:
+                    try:
+                        os.remove(fle)
+                    except:
+                        pass
+
+    def doExit(self, dbm=True, sysexit=True):
+        if dbm and self.db.dbopen:
+            self.db.closeDbase()
+        if self.debug:
+            sys.settrace(None)
+        if self.output:
+            # Close and display stdout -- Windows Problem
+            try:
+                sys.stdout.close()
+                sys.stdout = sys.__stdout__
+                if os.path.getsize(self.stdout) and not self.debug:
+                    text = open(self.stdout, "r")
+                    lines = text.readlines()
+                    text.close()
+                    if self.debug and len(lines) > 50:
+                        maxi = 50
+                    else:
+                        maxi = len(lines)
+                    mess = ""
+                    for x in xrange(maxi):
+                        mess = "%s%s" % (mess, lines[x - maxi])
+                    if self.debug:
+                        if self.xdisplay:
+                            ScrollText(title="Trace Output", mess=mess)
+                        else:
+                            print("Trace Output: ", mess)
+                    else:
+                        if self.xdisplay:
+                            ScrollText(title="Standard Output", mess=mess)
+                        else:
+                            print("Standard Output: ", mess)
+                # Housekeeping
+                for pid in xrange(1000):
+                    try:
+                        os.remove(os.path.join(getPrgPath(),
+                            "stdout_%s.txt" % pid))
+                    except:
+                        pass
+            except:
+                pass
+        if sysexit:
+            os._exit(1)
+
+    def doCheckSys(self):
+        sql = Sql(self.db, "ctlsys", prog=__name__)
+        if sql.error:
+            return "error"
+        rec = sql.getRec(tables="ctlsys", limit=1)
+        if not rec:
+            self.user = {"name": "admin", "pwd": "", "lvl": 9}
+            self.execCommand("PNNY", "msc110", tit="System Record Maintenance",
+                menu=False, password=False)
+            rec = sql.getRec(tables="ctlsys", limit=1)
+        if not rec:
+            return "error"
+
+    def doCheckMst(self):
+        chk = self.conoCheck(1, ctl=True)
+        if not chk:
+            return
+        if "sc" in self.sss:
+            for mod in self.mod:
+                if mod[2] in ("ms1010", "scc110"):
+                    module = mod[2]
+                    break
+        else:
+            module = "ms1010"
+        self.user = {"name": "admin", "pwd": "", "lvl": 9}
+        self.execCommand("PNNY", module, tit="Company Records Maintenance",
+            menu=False, password=False)
+        chk = self.conoCheck(1, ctl=True)
+        if chk:
+            return "error"
+
+    def getCtlSys(self, cols):
+        try:
+            sql = Sql(self.db, "ctlsys", prog="msc000")
+            if sql.error:
+                raise Exception
+            sss = sql.getRec(tables="ctlsys", cols=cols, limit=1)
+            if not sss:
+                raise Exception
+            if len(cols) == 1:
+                return sss[0]
+            else:
+                return sss
+        except:
+            sss = []
+            for col in cols:
+                sss.append(None)
+            return sss
+
+    def doSqlCmd(self):
+        if type(self.query) is list:
+            flenam = self.query
+        else:
+            name = os.path.abspath(self.query)
+            if os.path.isfile(name):
+                flenam = open(name, "r")
+            else:
+                return "Invalid Query File (%s)" % name
+        self.db.openDbase()
+        for line in flenam:
+            line = line.rstrip()
+            if not line or line[0] == "#":
+                continue
+            comm = line.split()
+            sel = False
+            qty = None
+            if comm and comm[0].lower() == "select":
+                sel = True
+                if comm[1][:3].lower() in ("avg", "max", "min", "sum"):
+                    qty = 1
+                elif comm[1].lower() == "count(*)":
+                    qty = 1
+                for num, cmd in enumerate(comm):
+                    if num < 2:
+                        continue
+                    if cmd == "limit":
+                        qty = int(comm[num + 1])
+                        break
+            try:
+                if comm[0] == "commit":
+                    self.db.commitDbase()
+                else:
+                    sq = Sql(self.db)
+                    if sel:
+                        ret = sq.sqlRec(line, limit=qty)
+                        mess = ""
+                        for r in ret:
+                            if type(r) is list:
+                                r = str(r)[1:-1]
+                            else:
+                                r = str(r)
+                            if not mess:
+                                mess = r
+                            else:
+                                mess = mess + "\n" + r
+                        if self.xdisplay and self.output:
+                            self.mf.window.deiconify()
+                            self.mf.head.configure(text="SQL Query")
+                            ScrollText(scrn=self.mf.body, mess=mess)
+                        else:
+                            print(mess)
+                    else:
+                        sq.sqlRec(line)
+            except:
+                self.db.closeDbase()
+                return "Error in SQL Statement\n\n%s" % line
+        self.db.closeDbase()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'mst/msy010.py'
--- mst/msy010.py	2017-08-24 07:49:34 +0000
+++ mst/msy010.py	2018-02-15 15:13:56 +0000
@@ -14,7 +14,8 @@
 import time
 from TartanClasses import ASD, CCD, GetCtl, ProgressBar, PwdConfirm, Sql
 from TartanClasses import TartanDialog
-from tartanFunctions import getPeriods, copyList, mthendDate, showError
+from tartanFunctions import getPeriods, copyList, getTrn, mthendDate
+from tartanFunctions import showError
 
 class msy010:
     def __init__(self, **opts):
@@ -48,6 +49,10 @@
             self.mod.append(ctlmst["ctm_modules"][x:x+2])
         if "AR" in self.mod:
             tab.append("assctl")
+        if "CR" in self.mod:
+            tab.append("crsage")
+        if "DR" in self.mod:
+            tab.append("drsage")
         if "GL" in self.mod:
             ctlctl = self.gc.getCtl("ctlctl", self.opts["conum"])
             if not ctlctl:
@@ -59,6 +64,7 @@
         if "LN" in self.mod:
             tab.append("lonctl")
         if "ML" in self.mod:
+            tab.append("memage")
             tab.append("memctl")
         if "RC" in self.mod:
             tab.append("rcactl")
@@ -511,8 +517,6 @@
                         group=grp, order=grp, limit=lim)
                     if not bals:
                         continue
-                    if tab[0] in ("crstrn", "drstrn", "memtrn"):
-                        trns = sql.getRec(tables=tab[0], where=whr)
                     sql.delRec(tab[0], where=whr)
                     if tab[0] == "asstrn":
                         from tartanWork import armvtp
@@ -533,73 +537,175 @@
                             self.opts["capnm"], self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
                     elif tab[0] == "crstrn" and bals[0]:
-                        for num, trn in enumerate(trns):
-                            # Delete Ageing
-                            if "args" not in self.opts and not num % 10:
-                                pb.displayProgress()
-                            typ = trn[sql.crstrn_col.index("crt_type")]
-                            ref = trn[sql.crstrn_col.index("crt_ref1")]
-                            sql.delRec("crsage", where=[("cra_cono", "=",
-                                rec[0]), ("cra_acno", "=", rec[1]),
-                                ("cra_type", "=", typ), ("cra_ref1", "=",
-                                ref)])
-                            sql.delRec("crsage", where=[("cra_cono", "=",
-                                rec[0]), ("cra_acno", "=", rec[1]),
-                                ("cra_atyp", "=", typ), ("cra_aref", "=",
-                                ref)])
-                            if "crsrtf" in ourtab:
-                                sql.delRec("crsrtf", where=[("rtf_cono",
-                                "=", rec[0]), ("rtf_acno", "=", rec[1]),
-                                ("rtf_type", "=", typ), ("rtf_ref1", "=",
-                                ref)])
                         data = rec[:2]
                         data.extend([3, "Bal-Fwd", "Bal-Fwd", edate, "",
                             bals[0], 0, 0, ecurdt, self.sysdtw, "Y", bals[0],
                             "Brought Forward", "", "", self.opts["capnm"],
                             self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
+                        # Re-Age Transactions
+                        self.sql.delRec("crsage", where=[("cra_cono", "=",
+                            rec[0]), ("cra_acno", "=", rec[1])])
+                        crc, cr = getTrn(self.opts["mf"].dbm, "crs",
+                            whr=[("crt_cono", "=", rec[0]), ("crt_acno", "=",
+                                rec[1]), ("crt_tramt", "<", 0)], zer="N")
+                        if cr:
+                            drc, dr = getTrn(self.opts["mf"].dbm, "crs",
+                                whr=[("crt_cono", "=", rec[0]), ("crt_acno",
+                                "=", rec[1]), ("crt_tramt", ">", 0)],
+                                neg=False, zer="N")
+                            if dr:
+                                for cno, ctr in enumerate(cr):
+                                    ccdt = ctr[crc.index("crt_curdt")]
+                                    cbal = ctr[crc.index("balance")]
+                                    camt = cbal
+                                    for dno, dtr in enumerate(dr):
+                                        dbal = dtr[drc.index("balance")]
+                                        if not dbal:
+                                            continue
+                                        damt = float(ASD(dbal) + ASD(camt))
+                                        if damt < 0:
+                                            camt = damt
+                                            damt = 0.00
+                                        else:
+                                            camt = 0.00
+                                        diff = float(ASD(dbal) - ASD(damt))
+                                        dr[dno][drc.index("balance")] = damt
+                                        if diff:
+                                            self.sql.insRec("crsage",
+                                                data=[rec[0], rec[1],
+                                                dtr[drc.index("crt_type")],
+                                                dtr[drc.index("crt_ref1")],
+                                                ccdt,
+                                                ctr[drc.index("crt_type")],
+                                                ctr[drc.index("crt_ref1")],
+                                                diff, 0])
+                                        if not camt:
+                                            break
+                                    diff = float(ASD(cbal) - ASD(camt))
+                                    if diff:
+                                        self.sql.insRec("crsage",
+                                            data=[rec[0], rec[1],
+                                            ctr[drc.index("crt_type")],
+                                            ctr[drc.index("crt_ref1")],
+                                            ccdt,
+                                            ctr[drc.index("crt_type")],
+                                            ctr[drc.index("crt_ref1")],
+                                            diff, 0])
                     elif tab[0] == "drstrn" and bals[0]:
-                        for num, trn in enumerate(trns):
-                            # Delete Ageing
-                            if "args" not in self.opts and not num % 10:
-                                pb.displayProgress()
-                            typ = trn[sql.drstrn_col.index("drt_type")]
-                            ref = trn[sql.drstrn_col.index("drt_ref1")]
-                            sql.delRec("drsage", where=[("dra_cono", "=",
-                            rec[0]), ("dra_chain", "=", rec[1]), ("dra_acno",
-                            "=", rec[2]), ("dra_type", "=", typ), ("dra_ref1",
-                            "=", ref)])
-                            sql.delRec("drsage", where=[("dra_cono", "=",
-                                rec[0]), ("dra_chain", "=", rec[1]),
-                                ("dra_acno", "=", rec[2]), ("dra_atyp", "=",
-                                typ), ("dra_aref", "=", ref)])
                         data = rec[:3]
                         data.extend([3, "Bal-Fwd", "Bal-Fwd", edate, "",
                             bals[0], 0, ecurdt, "Brought Forward", "", "",
                             self.opts["capnm"], self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
+                        # Re-Age Transactions
+                        self.sql.delRec("drsage", where=[("dra_cono",
+                            "=", rec[0]), ("dra_chain", "=", rec[1]),
+                            ("dra_acno", "=", rec[2])])
+                        crc, cr = getTrn(self.opts["mf"].dbm, "drs",
+                            whr=[("drt_cono", "=", rec[0]), ("drt_chain",
+                            "=", rec[1]), ("drt_acno", "=", rec[2]),
+                            ("drt_tramt", "<", 0)], zer="N")
+                        if cr:
+                            drc, dr = getTrn(self.opts["mf"].dbm, "drs",
+                                whr=[("drt_cono", "=", rec[0]), ("drt_chain",
+                                "=", rec[1]), ("drt_acno", "=", rec[2]),
+                                ("drt_tramt", ">", 0)], neg=False, zer="N")
+                            if dr:
+                                for cno, ctr in enumerate(cr):
+                                    ccdt = ctr[crc.index("drt_curdt")]
+                                    cbal = CCD(ctr[crc.index("balance")],
+                                        "SD", 13.2).work
+                                    camt = cbal
+                                    for dno, dtr in enumerate(dr):
+                                        dbal = dtr[drc.index("balance")]
+                                        if not dbal:
+                                            continue
+                                        damt = float(ASD(dbal) + ASD(camt))
+                                        if damt < 0:
+                                            camt = damt
+                                            damt = 0.00
+                                        else:
+                                            camt = 0.00
+                                        diff = float(ASD(dbal) - ASD(damt))
+                                        dr[dno][drc.index("balance")] = damt
+                                        if diff:
+                                            self.sql.insRec("drsage",
+                                                data=[rec[0], rec[1], rec[2],
+                                                dtr[drc.index("drt_type")],
+                                                dtr[drc.index("drt_ref1")],
+                                                ccdt,
+                                                ctr[drc.index("drt_type")],
+                                                ctr[drc.index("drt_ref1")],
+                                                diff, 0])
+                                        if not camt:
+                                            break
+                                    diff = float(ASD(cbal) - ASD(camt))
+                                    if diff:
+                                        self.sql.insRec("drsage", data=[rec[0],
+                                            rec[1], rec[2],
+                                            ctr[drc.index("drt_type")],
+                                            ctr[drc.index("drt_ref1")],
+                                            ccdt,
+                                            ctr[drc.index("drt_type")],
+                                            ctr[drc.index("drt_ref1")],
+                                            diff, 0])
                     elif tab[0] == "gentrn" and bals[0]:
                         continue
                     elif tab[0] == "memtrn" and bals[0]:
-                        for num, trn in enumerate(trns):
-                            # Delete Ageing
-                            if "args" not in self.opts and not num % 10:
-                                pb.displayProgress()
-                            typ = trn[sql.memtrn_col.index("mlt_type")]
-                            ref = trn[sql.memtrn_col.index("mlt_refno")]
-                            sql.delRec("memage", where=[("mta_cono", "=",
-                                rec[0]), ("mta_memno", "=", rec[1]),
-                                ("mta_type", "=", typ), ("mta_refno", "=",
-                                ref)])
-                            sql.delRec("memage", where=[("mta_cono", "=",
-                                rec[0]), ("mta_memno", "=", rec[1]),
-                                ("mta_atyp", "=", typ), ("mta_aref", "=",
-                                ref)])
                         data = rec[:2]
                         data.extend([3, "Bal-Fwd", "Bal-Fwd", edate, bals[0],
                             0, ecurdt, "", 0, "Brought Forward", "", "",
                             self.opts["capnm"], self.sysdtw, 0])
                         sql.insRec(tab[0], data=data)
+                        # Re-Age Transactions
+                        self.sql.delRec("memage", where=[("mta_cono",
+                            "=", rec[0]), ("mta_acno", "=", rec[1])])
+                        crc, cr = getTrn(self.opts["mf"].dbm, "mem",
+                            whr=[("mlt_cono", "=", rec[0]), ("mlt_memno",
+                            "=", rec[1]), ("mlt_tramt", "<", 0)], zer="N")
+                        if cr:
+                            drc, dr = getTrn(self.opts["mf"].dbm, "mem",
+                                whr=[("mlt_cono", "=", rec[0]), ("mlt_memno",
+                                "=", rec[1]), ("mlt_tramt", ">", 0)],
+                                neg=False, zer="N")
+                            if dr:
+                                for cno, ctr in enumerate(cr):
+                                    ccdt = ctr[crc.index("mlt_curdt")]
+                                    cbal = CCD(ctr[crc.index("balance")],
+                                        "SD", 13.2).work
+                                    camt = cbal
+                                    for dno, dtr in enumerate(dr):
+                                        dbal = dtr[drc.index("balance")]
+                                        if not dbal:
+                                            continue
+                                        damt = float(ASD(dbal) + ASD(camt))
+                                        if damt < 0:
+                                            camt = damt
+                                            damt = 0.00
+                                        else:
+                                            camt = 0.00
+                                        diff = float(ASD(dbal) - ASD(damt))
+                                        dr[dno][drc.index("balance")] = damt
+                                        if diff:
+                                            self.sql.insRec("memage",
+                                                data=[rec[0], rec[1],
+                                                dtr[drc.index("mlt_type")],
+                                                dtr[drc.index("mlt_refno")],
+                                                ccdt,
+                                                ctr[drc.index("mlt_type")],
+                                                ctr[drc.index("mlt_refno")],
+                                                diff, 0])
+                                        if not camt:
+                                            break
+                                    diff = float(ASD(cbal) - ASD(camt))
+                                    if diff:
+                                        self.sql.insRec("memage", data=[rec[0],
+                                            rec[1], ctr[drc.index("mlt_type")],
+                                            ctr[drc.index("mlt_refno")], ccdt,
+                                            ctr[drc.index("mlt_type")],
+                                            ctr[drc.index("mlt_refno")],
+                                            diff, 0])
                     elif tab[0] == "rcaowt" and bals[0]:
                         data = rec[:2]
                         data.extend([4, "Bal-Fwd", "Bal-Fwd", edate, bals[0],

=== renamed file 'mst/msy030.py' => 'mst/msy030_rne.py'
=== modified file 'scp/sc2010.py'
--- scp/sc2010.py	2017-08-24 07:49:34 +0000
+++ scp/sc2010.py	2018-01-30 10:40:01 +0000
@@ -67,7 +67,7 @@
             "tables": ("scpent", "scpmem"),
             "cols": (
                 ("scm_scod", "", 0, "Cod"),
-                ("scm_surname", "", 0, "Surame", "Y"),
+                ("scm_surname", "", 0, "Surname", "Y"),
                 ("scm_names", "", 0, "Names")),
             "where": [
                 ("scm_cono", "=", self.opts["conum"]),

=== modified file 'sls/si2010.py'
--- sls/si2010.py	2017-08-24 07:49:34 +0000
+++ sls/si2010.py	2018-02-14 07:42:32 +0000
@@ -364,19 +364,19 @@
         doc = {
             "stype": "R",
             "tables": ("slsiv1", "drsmst"),
-        "cols": [
-            ("si1_docno", "", 0, "Doc-Num"),
-            ("si1_chain", "", 0, "Chn"),
-            ("si1_acno", "", 0, "Acc-Num"),
-            ("drm_name", "", 0, "Name", "Y")],
-        "where": [
-            ("si1_cono", "=", self.opts["conum"]),
-            ("si1_rtn", "=", self.typs),
-            ("si1_invno", "=", ""),
-            ("drm_cono=si1_cono",),
-            ("drm_chain=si1_chain",),
-            ("drm_acno=si1_acno",)],
-        "screen": self.df.mstFrame}
+            "cols": [
+                ("si1_docno", "", 0, "Doc-Num"),
+                ("si1_chain", "", 0, "Chn"),
+                ("si1_acno", "", 0, "Acc-Num"),
+                ("drm_name", "", 0, "Name", "Y")],
+            "where": [
+                ("si1_cono", "=", self.opts["conum"]),
+                ("si1_rtn", "=", self.typs),
+                ("si1_invno", "=", ""),
+                ("drm_cono=si1_cono",),
+                ("drm_chain=si1_chain",),
+                ("drm_acno=si1_acno",)],
+            "screen": self.df.mstFrame}
         r1s = [
             ("New", "N"),
             ("Amend", "A")]
@@ -697,7 +697,8 @@
             return "Invalid Group Code"
         self.df.colf[pag][1][8]["where"] = [
             ("st1_cono", "=", self.opts["conum"]),
-            ("st1_group", "=", self.grp)]
+            ("st1_group", "=", self.grp),
+            ("st1_type", "<>", "X")]
         #######################################################################
         # Get Next Line Number
         #######################################################################
@@ -710,9 +711,9 @@
     def doCod(self, frt, pag, r, c, p, i, w):
         strmf1 = self.sql.getRec(tables="strmf1", where=[("st1_cono", "=",
             self.opts["conum"]), ("st1_group", "=", self.grp), ("st1_code",
-            "=", w)], limit=1)
+            "=", w), ("st1_type", "<>", "X")], limit=1)
         if not strmf1:
-            return "Invalid Code"
+            return "Invalid or Redundant Code"
         if self.stgl == "Y":
             gl = self.sql.getRec(tables="genmst", cols=["glm_desc"],
                 where=[("glm_cono", "=", self.opts["conum"]), ("glm_acno", "=",
@@ -952,12 +953,12 @@
         self.rc.topf[pag][1][8]["where"] = [
             ("st1_cono", "=", self.opts["conum"]),
             ("st1_group", "=", self.recgrp),
-            ("st1_type", "not", "in", ("J", "R"))]
+            ("st1_type", "not", "in", ("R", "X"))]
 
     def doRecCod(self, frt, pag, r, c, p, i, w):
         strmf1 = self.sql.getRec(tables="strmf1", where=[("st1_cono", "=",
             self.opts["conum"]), ("st1_group", "=", self.recgrp), ("st1_code",
-            "=", w), ("st1_type", "not", "in", ("J", "R"))], limit=1)
+            "=", w), ("st1_type", "not", "in", ("R", "X"))], limit=1)
         if not strmf1:
             return "Invalid Code"
         self.reccod = w

=== modified file 'sls/sic110.py'
--- sls/sic110.py	2017-08-24 07:49:34 +0000
+++ sls/sic110.py	2018-01-17 09:41:06 +0000
@@ -30,7 +30,7 @@
             self.opts["conum"])], limit=1)
         if not self.acc:
             self.new = True
-            self.acc = [self.opts["conum"], "Y", "Y", "sales_document", ""]
+            self.acc = [self.opts["conum"], "Y", "Y", "N", "sales_document", ""]
         else:
             self.new = False
         return True
@@ -50,15 +50,18 @@
                 ("tpm_system", "=", "INV")],
             "order": "tpm_tname"}
         r1s = (("Yes","Y"),("No","N"))
+        r2s = (("None","N"),("10c","T"),("50c","F"),("Rand","R"))
         self.fld = (
             (("T",0,0,0),("IRB",r1s),0,"Delivery Notes","",
                 self.acc[1],"N",self.doDelNo,None,None,None),
             (("T",0,1,0),("IRB",r1s),0,"Print Values","",
                 self.acc[2],"N",None,None,None,None),
-            (("T",0,2,0),"INA",20,"Invoice Template","",
-                self.acc[3],"N",self.doTplNam,tpl,None,None),
-            (("T",0,3,0),"ITX",50,"Email Address","",
-                self.acc[4],"N",None,None,None,None))
+            (("T",0,2,0),("IRB",r2s),0,"Round Down to Nearest","",
+                self.acc[3],"N",None,None,None,None),
+            (("T",0,3,0),"INA",20,"Invoice Template","",
+                self.acc[4],"N",self.doTplNam,tpl,None,None),
+            (("T",0,4,0),"ITX",50,"Email Address","",
+                self.acc[5],"N",None,None,None,None))
         but = (
             ("Accept",None,self.doAccept,0,("T",0,1),("T",0,0)),
             ("Quit",None,self.doExit,1,None,None))

=== modified file 'std/TartanClasses.py'
--- std/TartanClasses.py	2017-08-24 07:49:34 +0000
+++ std/TartanClasses.py	2018-02-05 05:30:02 +0000
@@ -7509,7 +7509,7 @@
         elif self.altkey:
             self.altkey = False
         elif event.char == " " or event.char.isalnum():
-            self.entry.place(relx=1, anchor="ne")
+            self.entry.place(anchor="ne", relx=1)
             self.entry.insert("end", event.char)
             self.entry.focus_set()
 
@@ -15424,7 +15424,7 @@
         if self.mf.window:
             p1.closeProgress()
             p2.closeProgress()
-        elif self.bar:
+        elif self.bar and TBAR:
             p2.finish()
             print
 
@@ -16352,7 +16352,7 @@
                         if self.impign != "Y":
                             showError(self.mf.body, "Column Error",
                                 "Row %s Column %s, %s is Invalid" %
-                                (num, col[0], dat))
+                                (num, col[0], dat[col[1]]))
                             raise Exception
             except:
                 imperr = True
@@ -17189,7 +17189,6 @@
 Paul Malherbe
 
 Phone:    27-28-3140092
-Fax:      27-86-2621838
 Email:    info@tartan.co.za
 
 %s 2004-%s Paul Malherbe

=== modified file 'std/tartanFunctions.py'
--- std/tartanFunctions.py	2017-08-24 07:49:34 +0000
+++ std/tartanFunctions.py	2018-02-07 07:49:58 +0000
@@ -1565,14 +1565,17 @@
                 styles[idx] = ezxf(fmt)
         return styles[idx]
 
-    def createSheet(fmt, page, heads=args["heads"], colsh=args["colsh"]):
-        sheet = book.add_sheet("Page %s" % page)
+    def createSheet(fmt, page):
+        if type(page) == str:
+            sheet = book.add_sheet(page)
+        else:
+            sheet = book.add_sheet("Page %s" % page)
         # Main headings
         rowx = 0
         blank = False
-        for num, valx in enumerate(heads):
+        for num, valx in enumerate(args["heads"]):
             if type(valx) in (list, tuple):
-                cols = len(colsh[-1]) - 1
+                cols = len(args["colsh"][-1]) - 1
                 hgt, siz = valx[1:]
                 hxf = "font: name arial, height %s, bold on" % siz
                 hxf = getStyle(hxf + "; align: horz centre, vert centre")
@@ -1600,7 +1603,7 @@
         if blank:
             rowx += 1
         # Column headings
-        for colx, valx in enumerate(colsh):
+        for colx, valx in enumerate(args["colsh"]):
             nc = 0
             for cx, vx in enumerate(valx):
                 #hxf = fmt + ", bold on; pattern: pattern solid"
@@ -1676,7 +1679,15 @@
         # Generate the body
         for num, row in enumerate(args["datas"]):
             if row[0] == "PAGE":
-                sheet, rowx = createSheet(fmt, page, row[1][0], row[1][1])
+                args["heads"] = row[1][0]
+                args["colsh"] = row[1][1]
+                if len(row[1]) > 2:
+                    args["forms"] = row[1][2]
+                if len(row[1]) == 4:
+                    pg = row[1][3]
+                else:
+                    pg = page
+                sheet, rowx = createSheet(fmt, pg)
                 page += 1
                 continue
             if row[0] in ("ULINES", "ULINED"):
@@ -2039,19 +2050,19 @@
             endrks.append("%s%s" % (g, 7))
         elif 6 in greens[g]:
             endrks.append("%s%s" % (g, 6))
-    # Remove end rinks if not needed
+    # Remove rinks not needed starting with end rinks
     rem = rinks - needed
-    if rem > endrks:
-        rem = endrks
-    chk = [0, 6, 0, 0, 0, 0, 0, 1]
+    chk = [0, 6, 5, 4, 0, 3, 2, 1]
     num = 7
     keys = list(greens.keys())
     keys.sort()
     while rem:
         for g in keys:
-            if num in greens[g] and "%s%s" % (g, num) not in keep:
+            rnk = "%s%s" % (g, num)
+            if num in greens[g] and rnk not in keep:
                 greens[g].remove(num)
-                endrks.remove("%s%s" % (g, num))
+                if rnk in endrks:
+                    endrks.remove("%s%s" % (g, num))
                 rem -= 1
             if not rem:
                 break

=== modified file 'str/st1010.py'
--- str/st1010.py	2017-08-24 07:49:34 +0000
+++ str/st1010.py	2018-02-15 12:13:07 +0000
@@ -60,7 +60,9 @@
                 ("st1_code", "", 0, "Product Code"),
                 ("st1_type", "", 0, "T"),
                 ("st1_desc", "", 0, "Description", "Y")),
-            "where": [("st1_cono", "=", self.opts["conum"])],
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "<>", "X")],
             "whera": [],
             "index": 1}
         loc = {
@@ -212,6 +214,8 @@
         if not self.old1:
             self.newcode = True
             self.gtype = None
+        elif self.old1[3] == "X":
+            return "Redundant Code"
         else:
             self.newcode = False
             d = 3

=== modified file 'str/st1020.py'
--- str/st1020.py	2017-08-24 07:49:34 +0000
+++ str/st1020.py	2018-02-14 07:51:56 +0000
@@ -50,7 +50,9 @@
                 ("st1_group", "", 0, "Grp"),
                 ("st1_code", "", 0, "Product Code"),
                 ("st1_desc", "", 0, "Description", "Y")),
-            "where": [("st1_cono", "=", self.opts["conum"])],
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "<>", "X")],
             "whera": [["T", "st1_group", 0]],
             "index": 1}
         stl = {
@@ -95,9 +97,10 @@
     def doCode(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="strmf1", cols=["st1_desc"],
             where=[("st1_cono", "=", self.opts["conum"]), ("st1_group", "=",
-            self.group), ("st1_code", "=", w)], limit=1)
+            self.group), ("st1_code", "=", w), ("st1_type", "<>", "X")],
+            limit=1)
         if not acc:
-            return "Invalid Code"
+            return "Invalid or Redundant Code"
         self.code = w
         self.df.loadEntry("T", pag, p+1, data=acc[0])
         if self.locs == "N":

=== modified file 'str/st2010.py'
--- str/st2010.py	2017-08-24 07:49:34 +0000
+++ str/st2010.py	2018-02-14 07:55:03 +0000
@@ -171,7 +171,7 @@
                 ("st1_desc", "", 0, "Description","Y")),
             "where": [
                 ("st1_cono", "=", self.opts["conum"]),
-                ("st1_type", "not", "in", ("J", "R")),
+                ("st1_type", "not", "in", ("R", "X")),
                 ("st1_value_ind", "<>", "N")],
             "whera": [("C", "st1_group", 0)],
             "order": "st1_group, st1_code"}
@@ -446,8 +446,10 @@
             "=", w)], limit=1)
         if not strmf1:
             return "Invalid Code"
-        if strmf1[self.sql.strmf1_col.index("st1_type")] in ("J", "R"):
-            return "Invalid Code (Group Item)"
+        if strmf1[self.sql.strmf1_col.index("st1_type")] == "R":
+            return "Invalid Code (Recipe)"
+        if strmf1[self.sql.strmf1_col.index("st1_type")] == "X":
+            return "Invalid Code (Redundant)"
         if strmf1[self.sql.strmf1_col.index("st1_value_ind")] == "N":
             return "Invalid Code (Value Indicator)"
         strmf2 = self.sql.getRec(tables="strmf2", where=[("st2_cono", "=",

=== modified file 'str/st2020.py'
--- str/st2020.py	2017-08-24 07:49:34 +0000
+++ str/st2020.py	2018-02-14 07:58:20 +0000
@@ -98,7 +98,7 @@
                 ("st1_desc", "", 0, "Description", "Y")),
             "where": [
                 ("st1_cono", "=", self.opts["conum"]),
-                ("st1_type", "not", "in", ("J", "R")),
+                ("st1_type", "not", "in", ("R", "X")),
                 ("st1_value_ind", "<>", "N")],
             "whera": [["C", "st1_group", 0, 0]],
             "order": "st1_group, st1_code",
@@ -220,7 +220,8 @@
                 break
             self.code = code.work
             chk = self.sql.getRec(tables="strmf1", where=[("st1_group", "=",
-                self.group), ("st1_code", "=", self.code)], limit=1)
+                self.group), ("st1_code", "=", self.code), ("st1_type", "<>",
+                "X")], limit=1)
             if not chk:
                 err = "Line %s: Invalid Group %s or Code %s" % ((num + 1),
                     self.group, self.code)
@@ -283,8 +284,10 @@
             "=", w)], limit=1)
         if not acc:
             return "Invalid Code"
-        if acc[0] in ("J", "R"):
-            return "Invalid Code (Job/Recipe Item)"
+        if acc[0] == "R":
+            return "Invalid Code (Recipe Item)"
+        if acc[0] == "X":
+            return "Invalid Code (Redundant"
         if acc[4] == "N":
             return "Invalid Code (Value Indicator)"
         self.desc = acc[1]

=== modified file 'str/st2030.py'
--- str/st2030.py	2017-08-24 07:49:34 +0000
+++ str/st2030.py	2018-02-14 08:00:27 +0000
@@ -89,7 +89,9 @@
                 ("st1_code", "", 0, "Product Code"),
                 ("st1_type", "", 0, "T"),
                 ("st1_desc", "", 0, "Description", "Y")),
-            "where": [("st1_cono", "=", self.opts["conum"])],
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "<>", "X")],
             "whera": [["C", "st1_group", 0, 0]],
             "order": "st1_group, st1_code",
             "index": 1}
@@ -166,9 +168,10 @@
     def doCode(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="strmf1", cols=["st1_desc", "st1_type",
             "st1_uoi"], where=[("st1_cono", "=", self.opts["conum"]),
-            ("st1_group", "=", self.group), ("st1_code", "=", w)], limit=1)
+            ("st1_group", "=", self.group), ("st1_code", "=", w),
+            ("st1_type", "<>", "X")], limit=1)
         if not acc:
-            return "Invalid Code"
+            return "Invalid or Redundant Code"
         self.code = w
         self.desc = acc[0]
         self.gtype = acc[1]

=== modified file 'str/st2040.py'
--- str/st2040.py	2017-08-24 07:49:34 +0000
+++ str/st2040.py	2018-02-14 08:01:26 +0000
@@ -59,7 +59,7 @@
                 ("st1_desc", "", 0, "Description", "Y")),
             "where": [
                 ("st1_cono", "=", self.opts["conum"]),
-                ("st1_type", "not", "in", ("J", "R"))],
+                ("st1_type", "not", "in", ("R", "X"))],
             "whera": [["C", "st1_group", 0, 0]],
             "order": "st1_group, st1_code",
             "index": 1}
@@ -130,8 +130,10 @@
             ("st1_group", "=", self.group), ("st1_code", "=", w)], limit=1)
         if not acc:
             return "Invalid Code"
-        if acc[0] in ("J", "R"):
-            return "Invalid Code (Group Item)"
+        if acc[0] == "R":
+            return "Invalid Code (Recipe Item)"
+        if acc[0] == "X":
+            return "Invalid Code (Redundant)"
         self.df.loadEntry("C", pag, p+1, data=acc[1])
         self.df.loadEntry("C", pag, p+2, data=acc[2])
 

=== modified file 'str/st3030.py'
--- str/st3030.py	2017-08-24 07:49:34 +0000
+++ str/st3030.py	2018-02-14 08:03:22 +0000
@@ -150,6 +150,7 @@
         whr = [("st2_cono", "=", self.opts["conum"])]
         if self.group:
             whr.append(("st2_group", "=", self.group))
+        whr.append(("st1_type", "<>", "X"))
         whr.append(("st2_loc", "=", self.loc))
         whr.extend([("st1_cono=st2_cono",), ("st1_group=st2_group",),
             ("st1_code=st2_code",)])

=== modified file 'str/st3040.py'
--- str/st3040.py	2017-08-24 07:49:34 +0000
+++ str/st3040.py	2018-02-14 08:04:52 +0000
@@ -46,7 +46,11 @@
     def mainProcess(self):
         self.tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
             "Stores Master Code List (%s)" % __name__)
-        r1s = (("All", "A"), ("Normal", "N"), ("Recipe", "R"))
+        r1s = (
+            ("All", "A"),
+            ("Normal", "N"),
+            ("Recipe", "R"),
+            ("Redundant", "X"))
         grp = {
             "stype": "R",
             "tables": ("strgrp",),
@@ -58,7 +62,7 @@
             (("T",0,0,0),"IUA",3,"Product Group","",
                 "","Y",self.doGroup,grp,None,("efld",)),
             (("T",0,1,0),("IRB",r1s),0,"Product Type","",
-                "A","Y",self.doType,None,None,None))
+                "N","Y",self.doType,None,None,None))
         tnd = ((self.doEnd,"Y"), )
         txt = (self.doExit, )
         self.df = TartanDialog(self.opts["mf"], title=self.tit, eflds=fld,

=== modified file 'str/st3110.py'
--- str/st3110.py	2017-08-24 07:49:34 +0000
+++ str/st3110.py	2018-02-14 08:12:31 +0000
@@ -64,14 +64,16 @@
                 ("st1_group", "", 0, "Grp"),
                 ("st1_code", "", 0, "Product Code"),
                 ("st1_desc", "", 0, "Description", "Y")),
-            "where": [("st1_cono", "=", self.opts["conum"])],
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "<>", "X")],
             "whera": [["T", "st1_group", 2, 0]],
             "index": 1}
         lab = {
             "stype": "C",
             "head": ("Codes",),
             "data": list(labels.keys())}
-        r1s = (("Normal", "N"), ("Recipes", "R"), ("All", "A"))
+        r1s = (("Normal", "N"), ("Recipes", "R"))
         r2s = (("Yes", "A"), ("No", "N"), ("All", "B"))
         r3s = (("No", "N"), ("Yes", "Y"))
         fld = [
@@ -134,9 +136,10 @@
         if self.code:
             acc = self.sql.getRec(tables="strmf1", cols=["st1_desc"],
                 where=[("st1_cono", "=", self.opts["conum"]), ("st1_group",
-                "=", self.grp), ("st1_code", "=", w)], limit=1)
+                "=", self.grp), ("st1_code", "=", w), ("st1_type", "<>", "X")],
+                limit=1)
             if not acc:
-                return "Invalid Code"
+                return "Invalid or Redundant Code"
 
     def doTypes(self, frt, pag, r, c, p, i, w):
         self.types = w
@@ -175,8 +178,7 @@
             whr.append(("st1_group", "=", self.grp))
         if self.code:
             whr.append(("st1_code", "=", self.code))
-        if self.types in ("N", "R"):
-            whr.append(("st1_type", "=", self.types))
+        whr.append(("st1_type", "=", self.types))
         if self.valind in ("A", "N"):
             whr.append(("st1_value_ind", "=", self.valind))
         if self.loc:

=== modified file 'str/st3120.py'
--- str/st3120.py	2017-08-24 07:49:34 +0000
+++ str/st3120.py	2018-02-14 08:16:27 +0000
@@ -116,6 +116,7 @@
         whr = [("st1_cono", "=", self.opts["conum"])]
         if self.group:
             whr.append(("st1_group", "=", self.group))
+        whr.append(("st1_type", "<>", "X"))
         whr.append(("st1_value_ind", "=", "A"))
         recs = self.sql.getRec(tables="strmf1", cols=["st1_group", "st1_code",
             "st1_desc", "st1_uoi"], where=whr, order="st1_group, st1_code")

=== modified file 'str/st4010.py'
--- str/st4010.py	2017-08-24 07:49:34 +0000
+++ str/st4010.py	2018-02-14 08:18:23 +0000
@@ -62,7 +62,9 @@
                 ("st1_code", "", 0, "Product Code"),
                 ("st1_type", "", 0, "T"),
                 ("st1_desc", "", 0, "Description", "Y")),
-            "where": [("st1_cono", "=", self.opts["conum"])],
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "<>", "X")],
             "whera": [["T", "st1_group", 0, 0]],
             "index": 1}
         stl = {
@@ -174,9 +176,9 @@
     def doCode(self, frt, pag, r, c, p, i, w):
         acc = self.sql.getRec(tables="strmf1", where=[("st1_cono", "=",
             self.opts["conum"]), ("st1_group", "=", self.group), ("st1_code",
-            "=", w)], limit=1)
+            "=", w), ("st1_type", "<>", "X")], limit=1)
         if not acc:
-            return "Invalid Code"
+            return "Invalid or Redundant Code"
         self.code = w
         self.desc = acc[self.sql.strmf1_col.index("st1_desc")]
         self.df.loadEntry("T", 0, 2, data=self.desc)

=== modified file 'str/st5010.py'
--- str/st5010.py	2017-08-24 07:49:34 +0000
+++ str/st5010.py	2018-02-14 08:19:03 +0000
@@ -158,7 +158,7 @@
         recs = self.sql.getRec(tables=["strmf1", "strmf2"], cols=["st2_group",
             "st2_code", "st2_loc", "st2_bin", "st1_desc", "st1_uoi"],
             where=[("st1_cono=st2_cono",), ("st1_group=st2_group",),
-            ("st1_code=st2_code",), ("st1_type", "not", "in", ("J", "R")),
+            ("st1_code=st2_code",), ("st1_type", "not", "in", ("R", "X")),
             ("st2_cono", "=", self.opts["conum"]), ("st2_group", ">=",
             self.sgrp), ("st2_group", "<=", self.egrp), ("st2_loc", ">=",
             self.sloc), ("st2_loc", "<=", self.eloc), ("st2_bin", ">=",

=== modified file 'str/st5020.py'
--- str/st5020.py	2017-08-24 07:49:34 +0000
+++ str/st5020.py	2018-02-14 08:20:59 +0000
@@ -64,7 +64,7 @@
                 ("st1_desc", "", 0, "Description", "Y")),
             "where": [
                 ("st1_cono", "=", self.opts["conum"]),
-                ("st1_type", "not", "in", ("J", "R"))],
+                ("st1_type", "not", "in", ("R", "X"))],
             "whera": [["T", "st1_group", 4, 0]],
             "order": "st1_group, st1_code",
             "index": 1}
@@ -140,8 +140,10 @@
                 "=", self.fgrp), ("st1_code", "=", w)], limit=1)
             if not acc:
                 return "Invalid Code"
-            if acc[0] in ("J", "R"):
-                return "Invalid Code (Group Item)"
+            if acc[0] == "R":
+                return "Invalid Code (Recipe Item)"
+            if acc[0] == "X":
+                return "Invalid Code (Redundant Item)"
         self.fcode = w
 
     def doSell(self, frt, pag, r, c, p, i, w):
@@ -163,7 +165,7 @@
                 whr.append(("st1_group", ">=", self.fgrp))
             if self.fcode:
                 whr.append(("st1_code", ">=", self.fcode))
-            whr.extend([("st1_type", "not", "in", ("J","R")),
+            whr.extend([("st1_type", "not", "in", ("R","X")),
                 ("st2_cono=st1_cono",), ("st2_group=st1_group",),
                 ("st2_code=st1_code",), ("st2_loc", "=", self.loc)])
             self.codes = self.sql.getRec(tables=["strmf1", "strmf2"],
@@ -197,7 +199,7 @@
                 ("st1_desc", "", 0, "Description", "Y")),
             "where": [
                 ("st1_cono", "=", self.opts["conum"]),
-                ("st1_type", "not", "in", ("J", "R"))],
+                ("st1_type", "not", "in", ("R", "X"))],
             "whera": [["C", "st1_group", 0, 0]],
             "index": 1}
         if self.auto == "Y":
@@ -245,8 +247,10 @@
             self.group2), ("st1_code", "=", w)], limit=1)
         if not ac1:
             return "Invalid Code"
-        if ac1[0] in ("J", "R"):
-            return "Invalid Code (Group Item)"
+        if ac1[0] == "R":
+            return "Invalid Code (Recipe Item)"
+        if ac1[0] == "X":
+            return "Invalid Code (Redundant Item)"
         ac2 = self.sql.getRec(tables="strmf2", where=[("st2_cono", "=",
             self.opts["conum"]), ("st2_group", "=", self.group2), ("st2_code",
             "=", w), ("st2_loc", "=", self.loc)], limit=1)

=== modified file 'str/st6020.py'
--- str/st6020.py	2017-08-24 07:49:34 +0000
+++ str/st6020.py	2018-02-14 08:27:32 +0000
@@ -1,6 +1,7 @@
 """
 SYNOPSIS
-    Stores Revalue at Last Cost and Eradicate All Minus Balances.
+    Stores Revalue at Average or Last Cost and Optionally Eradicate All Minus
+    Balances.
 
     This file is part of Tartan Systems (TARTAN).
 
@@ -76,11 +77,15 @@
 
     def endPage(self):
         self.df.closeProcess()
+        whr = [
+            ("st2_cono", "=", self.opts["conum"]),
+            ("st1_cono=st2_cono",),
+            ("st1_group=st2_group",),
+            ("st1_code=st2_code",),
+            ("st1_type", "<>", "X"),
+            ("st1_value_ind", "<>", "N")]
         recs = self.sql.getRec(tables=["strmf1", "strmf2"], cols=["st2_group",
-            "st2_code", "st2_loc"], where=[("st2_cono", "=",
-            self.opts["conum"]), ("st1_cono=st2_cono",),
-            ("st1_group=st2_group",), ("st1_code=st2_code",), ("st1_value_ind",
-            "<>", "N")], order="st2_group, st2_code")
+            "st2_code", "st2_loc"], where=whr, order="st2_group, st2_code")
         if not recs:
             showError(self.opts["mf"].body, "Processing Error",
             "No Stock Records")

=== added file 'str/st6040.py'
--- str/st6040.py	1970-01-01 00:00:00 +0000
+++ str/st6040.py	2018-02-14 15:25:20 +0000
@@ -0,0 +1,171 @@
+"""
+SYNOPSIS
+    Stores Ledger Change Type to Redundant for all Items having had No
+    Movement for a Period of Time and with a Zero Quantity.
+
+    This file is part of Tartan Systems (TARTAN).
+
+AUTHOR
+    Written by Paul Malherbe, <paul@tartan.co.za>
+
+COPYING
+    Copyright (C) 2004-2017 Paul Malherbe.
+"""
+
+import time
+from TartanClasses import GetCtl, ProgressBar, Sql, TartanDialog
+from tartanFunctions import showError
+
+class st6040:
+    def __init__(self, **opts):
+        self.opts = opts
+        if self.setVariables():
+            self.dataHeader()
+            self.opts["mf"].startLoop()
+
+    def setVariables(self):
+        self.sql = Sql(self.opts["mf"].dbm, ["strmf1", "strtrn"], prog=__name__)
+        if self.sql.error:
+            return
+        gc = GetCtl(self.opts["mf"])
+        strctl = gc.getCtl("strctl", self.opts["conum"])
+        if not strctl:
+            return
+        t = time.localtime()
+        self.sysdtw = (t[0] * 10000) + (t[1] * 100) + t[2]
+        self.curdt = self.sysdtw / 100
+        return True
+
+    def dataHeader(self):
+        tit = ("%03i %s" % (self.opts["conum"], self.opts["conam"]),
+            "Stores Ledger Redundant Items (%s)" % __name__)
+        grp = {
+            "stype": "R",
+            "tables": ("strgrp",),
+            "cols": (
+                ("gpm_group", "", 0, "Grp"),
+                ("gpm_desc", "", 0, "Description", "Y")),
+            "where": [("gpm_cono", "=", self.opts["conum"])]}
+        stm = {
+            "stype": "R",
+            "tables": ("strmf1",),
+            "cols": (
+                ("st1_code", "", 0, "Product Code"),
+                ("st1_desc", "", 0, "Description", "Y")),
+            "where": [
+                ("st1_cono", "=", self.opts["conum"]),
+                ("st1_type", "=", "X")],
+            "whera": [["T", "st1_group", 0, 0]],
+            "index": 0}
+        fld = [
+            (("T",0,0,0),"INA",3,"Group","Product Group",
+                "","Y",self.doGroup,grp,None,("notblank",)),
+            (("T",0,1,0),"INA",20,"Code","Product Code",
+                "","N",self.doCode,stm,None,("notblank",)),
+            (("T",0,2,0),"ONA",30,"Description")]
+        but = (
+            ("Generate",None,self.doGenerate,1,None,None),
+            ("Restore",None,self.doRestore,1,None,None),
+            ("Exit",None,self.exitPage,1,None,None))
+        tnd = ((self.endPage, "y"),)
+        txt = (self.exitPage,)
+        self.df = TartanDialog(self.opts["mf"], title=tit, eflds=fld,
+            butt=but, tend=tnd, txit=txt, focus=False)
+        self.df.setWidget(self.df.B0, state="normal")
+        self.df.setWidget(self.df.B1, state="normal")
+        self.df.setWidget(self.df.B2, state="normal")
+
+    def doGenerate(self):
+        tit = "Generate Redundant Items"
+        fld = (
+            (("T",0,0,0),"IUI",3,"Months","Inactive Months",
+                24,"Y",self.doMonths,None,None,("efld",)),)
+        state = self.df.disableButtonsTags()
+        self.df.setWidget(self.df.mstFrame, state="hide")
+        self.mt = TartanDialog(self.opts["mf"], title=tit, tops=True,
+            eflds=fld, tend=((self.doMthEnd, "y"),), txit=(self.doMthExit,))
+        self.opts["mf"].startLoop()
+        self.df.setWidget(self.df.mstFrame, state="show")
+        self.df.enableButtonsTags(state=state)
+
+    def doMonths(self, frt, pag, r, c, p, i, w):
+        months = w
+        yr = self.curdt / 100
+        mt = self.curdt % 100
+        for mth in range(months):
+            mt -= 1
+            if not mt:
+                mt = 12
+                yr -= 1
+        self.startp = (yr * 100) + mt
+
+    def doMthEnd(self):
+        self.mt.closeProcess()
+        whr = [
+            ("st1_cono", "=", self.opts["conum"]),
+            ("st1_type", "=", "N"),
+            ("stt_cono=st1_cono",),
+            ("stt_group=st1_group",),
+            ("stt_code=st1_code",)]
+        accs = self.sql.getRec(tables=["strmf1", "strtrn"], cols=["st1_group",
+            "st1_code", "max(stt_curdt)", "sum(stt_qty)", "sum(stt_cost)"],
+            where=whr, order="st1_group, st1_code")
+        chgs = []
+        for acc in accs:
+            if acc[2] < self.startp and not acc[3] and not acc[4]:
+                chgs.append(acc[:2])
+        if not chgs:
+            showError(self.opts["mf"].body, "Processing Error",
+                "No Redundant Records")
+        else:
+            self.cnt = 0
+            p = ProgressBar(self.opts["mf"].body, mxs=len(chgs),
+                typ="Redundant Items")
+            for num, rec in enumerate(chgs):
+                p.displayProgress(num)
+                self.sql.updRec("strmf1", cols=["st1_type"], data=["X"],
+                    where=[("st1_cono", "=", self.opts["conum"]),
+                    ("st1_group", "=", rec[0]), ("st1_code", "=", rec[1])])
+            p.closeProgress()
+            mess = """%s Items Will be Marked as Redundant.
+
+Would you like to COMMIT these Changes?""" % len(chgs)
+            self.opts["mf"].dbm.commitDbase(ask=True, mess=mess)
+        self.opts["mf"].closeLoop()
+
+    def doMthExit(self):
+        self.mt.closeProcess()
+        self.opts["mf"].closeLoop()
+
+    def doRestore(self):
+        self.df.focusField("T", 0, 1)
+
+    def doGroup(self, frt, pag, r, c, p, i, w):
+        chk = self.sql.getRec(tables="strmf1", where=[("st1_cono",
+            "=", self.opts["conum"]), ("st1_group", "=", w),
+            ("st1_type", "=", "X")], limit=1)
+        if not chk:
+            return "Invalid Group"
+        self.grp = w
+
+    def doCode(self, frt, pag, r, c, p, i, w):
+        chk = self.sql.getRec(tables="strmf1", where=[("st1_cono",
+            "=", self.opts["conum"]), ("st1_group", "=", self.grp),
+            ("st1_code", "=", w), ("st1_type", "=", "X")], limit=1)
+        if not chk:
+            return "Invalid Code"
+        self.cod = w
+        self.df.loadEntry(frt, pag, p+1, data=chk[4])
+
+    def endPage(self):
+        self.sql.updRec("strmf1", cols=["st1_type"], data=["N"],
+            where=[("st1_cono", "=", self.opts["conum"]),
+            ("st1_group", "=", self.grp), ("st1_code", "=", self.cod)])
+        self.opts["mf"].dbm.commitDbase()
+        self.df.focusField("T", 0, 1)
+
+    def exitPage(self):
+        self.df.closeProcess()
+        self.opts["mf"].closeLoop()
+
+# vim:set ts=4 sw=4 sts=4 expandtab:

=== modified file 'uty/pkgprg.py'
--- uty/pkgprg.py	2017-08-24 07:49:34 +0000
+++ uty/pkgprg.py	2018-02-16 13:58:35 +0000
@@ -133,8 +133,9 @@
     custom = ["rne", ["ar6020", "ar6030", "cr1010", "cr2010", "cr2020",
               "cr2030", "cr3030", "cr3070", "cr3310", "cr3320", "cr3330",
               "cr3340", "cr3350", "cr3360", "cr3370", "cr3380", "cr4010",
-              "cr6010", "gl3100", "gl3110", "gl3120", "gl3130", "glc310",
-              "glc410", "glc510", "ln2020", "ms1010", "tartanWork"]]
+              "cr6010", "gl3030", "gl3100", "gl3110", "gl3120", "gl3130",
+              "gl3140", "glc310", "glc410", "glc510", "ln2020", "msc000",
+              "ms1010", "msy030", "tartanWork"]]
     exclude = ["cr3080", "dr1020", "dr2030", "dr6030", "drc210", "drc220",
                "drc310", "drc320", "drc510", "drc520", "drc610", "drc620",
                "drc710", "drc810", "msy020", "si2020", "si3010", "si3070",
@@ -142,8 +143,8 @@
                "st3010", "st3020", "st3030", "st3040", "st3050", "st3060",
                "st3070", "st3080", "st3090", "st3100", "st3110", "st3120",
                "st4010", "st5010", "st5020", "st5030", "st5040", "st6010",
-               "st6020", "stc220", "stc320", "stc410", "stc420", "tb1010",
-               "tb1040", "tb3010", "pw1010"]
+               "st6020", "st6030", "st6040", "stc220", "stc320", "stc410",
+               "stc420", "tb1010", "tb1040", "tb3010", "pw1010"]
 elif system == "s":
     if publish or verinc:
         exeCmd("mv %s/TartanExe/Seccmp_%s.* %s/TartanOld/" % (bd, vv, bd))

